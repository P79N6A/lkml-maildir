Date: Wed, 4 Sep 2002 11:35:26 -0700
From: "Libershteyn, Vladimir" <>
Subject: RE: Problem on a kernel driver(SuSE, SMP)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2002/9/4/159

> -----Original Message-----
> From: Richard B. Johnson [mailto:root@chaos.analogic.com]
> Sent: Wednesday, September 04, 2002 11:25 AM
> To: Libershteyn, Vladimir
> Cc: linux-kernel@vger.kernel.org
> Subject: RE: Problem on a kernel driver(SuSE, SMP)
> 
> 
> On Wed, 4 Sep 2002, Libershteyn, Vladimir wrote:
> 
> > > 
> > > You are not too specific, which makes it hard to 
> understand what may
> > > be going wrong so I'll assume that you probably did a bad thing.
> > 
> > I think I gave all the specific information
> > 
> > > 
> > > (1)  You cannot sleep in an interrupt, which means you can't use
> > > down_*() and friends inside an ISR.
> > 
> > I DO NOT sleep in ISR, the up*() routine is inside the ISR, 
> dut not down*()
> > This is a standard use of the mechanism
> > 
> > > 
> > > (2)  Wait queues should work fine from the 'user-side' of 
> a driver,
> > > but again, you cannot ever sleep in an interrupt service routine.
> > > Look in ../linux/drivers/* for examples of code that works.
> > > 
> > 
> > Again there is NO sleep in ISR, and I know that queues 
> should work fine, 
> > but they don't, that why I have a problem, but problem only on
> > SMP machine.
> > 
> > > (3)  You can't use any wait-queue or sleep on a semaphore while
> > > holding a spin-lock or while the interrupts are disabled. You can
> > > manage your own lock against re-entry in your procedure, but you
> > > can't allow two tasks to try the same semaphore at (nearly) the
> > > same time or you can dead-lock.
> > 
> > I DO NOT hold any spinlocks, while use down_interruptible
> > 
> > > 
> > > 
> > > (4)	The fact that 'down' hangs means that there is nothing
> > > that the CPU can do. This is direct evidence that you have the
> > > interrupts disabled when down executes.
> > 
> > To be more specific, here is a code:
> > ----------------------------------------------------
> > function when thread go to sleep, if data not ready 
> > ---------------------------------------------------
> 
> Snipped code.
> 
> How do you know that 
>  	up(&a->sem[enumerator]);
> in the ISR and...
>  	down_interruptible(&a->sem[enumerator]);
> In axl_get_response...
> 	... have the same value of 'enumerator', therefore the same
> semaphore?
> 
> One comes from a modulus and another from indirection off from 'board
> address'?
> 
> I think there is a bug there.
> 
First of all it does not even come to the ISR routine. 
The hang appears at down_interruptible. the interrupt don't even occur yet.
I know that.
To prove it I did limited possible resources to one card (card 0) and to only
one logical device (enumerator 0). The probelm is the same.
Regards,
Vlad
P.S. This product has been shiped for 3 years with RH and SuSE, There was no problems 
with any but SuSE SMP machines.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/