Date: Tue, 27 Mar 2007 21:14:20 +0200
From: Ingo Molnar <>
Subject: Re: [BUG] scheduler: strange behavor with massive interactive processes
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/3/27/225

* Satoru Takeuchi <takeuchi_satoru@jp.fujitsu.com> wrote:
> Hi Ingo and all,
> 
> When I was executing massive interactive processes, I found that some 
> of them occupy CPU time and the others hardly run.
yeah.
> I also attach the test program which easily recreates this problem.
thanks, this is really helpful - does the patch below improve the 
situation?
	Ingo
---------------------->
Subject: [patch] sched: improve starvation prevention
From: Ingo Molnar <mingo@elte.hu>
improve starvation prevention by guaranteeing STARVATION_LIMIT. This 
also simplifies the code a bit.
Signed-off-by: Ingo Molnar <mingo@elte.hu>
---
 kernel/sched.c |   12 +++++-------
 1 file changed, 5 insertions(+), 7 deletions(-)
Index: linux/kernel/sched.c
===================================================================
--- linux.orig/kernel/sched.c
+++ linux/kernel/sched.c
@@ -235,7 +235,7 @@ struct rq {
 	 */
 	unsigned long nr_uninterruptible;
 
-	unsigned long expired_timestamp;
+	unsigned long switch_timestamp;
 	/* Cached timestamp set by update_cpu_clock() */
 	unsigned long long most_recent_timestamp;
 	struct task_struct *curr, *idle;
@@ -3103,9 +3103,9 @@ static inline int expired_starving(struc
 {
 	if (rq->curr->static_prio > rq->best_expired_prio)
 		return 1;
-	if (!STARVATION_LIMIT || !rq->expired_timestamp)
+	if (!STARVATION_LIMIT)
 		return 0;
-	if (jiffies - rq->expired_timestamp > STARVATION_LIMIT * rq->nr_running)
+	if (jiffies - rq->switch_timestamp > STARVATION_LIMIT)
 		return 1;
 	return 0;
 }
@@ -3218,8 +3218,6 @@ static void task_running_tick(struct rq 
 		p->time_slice = task_timeslice(p);
 		p->first_time_slice = 0;
 
-		if (!rq->expired_timestamp)
-			rq->expired_timestamp = jiffies;
 		if (!TASK_INTERACTIVE(p) || expired_starving(rq)) {
 			enqueue_task(p, rq->expired);
 			if (p->static_prio < rq->best_expired_prio)
@@ -3406,7 +3404,7 @@ need_resched_nonpreemptible:
 		idle_balance(cpu, rq);
 		if (!rq->nr_running) {
 			next = rq->idle;
-			rq->expired_timestamp = 0;
+			rq->switch_timestamp = jiffies;
 			goto switch_tasks;
 		}
 	}
@@ -3420,7 +3418,7 @@ need_resched_nonpreemptible:
 		rq->active = rq->expired;
 		rq->expired = array;
 		array = rq->active;
-		rq->expired_timestamp = 0;
+		rq->switch_timestamp = jiffies;
 		rq->best_expired_prio = MAX_PRIO;
 	}
 
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/