Date: Mon, 8 Oct 2001 21:53:13 +0200
From: Radovan Garabik <>
Subject: [PATCH] dead keys in unicode console mode
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2001/10/8/246

FWIW, this little patch makes it possible to
use dead keys in unicode console mode.
It is against 2.4.10, but should apply cleanly in
broader range of kernel versions.
-- 
 -----------------------------------------------------------
| Radovan Garabik 
http://melkor.dnp.fmph.uniba.sk/~garabik/
 |
| __..--^^^--..__    garabik @ melkor.dnp.fmph.uniba.sk     |
 -----------------------------------------------------------
Antivirus alert: file .signature infected by signature virus.
Hi! I'm a signature virus! Copy me into your signature file to help me spread!
diff -Nurd linux.orig/drivers/char/keyboard.c linux/drivers/char/keyboard.c
--- linux.orig/drivers/char/keyboard.c	Tue Sep 18 22:39:51 2001
+++ linux/drivers/char/keyboard.c	Mon Oct  8 21:39:02 2001
@@ -151,7 +151,7 @@
 
 /* N.B. drivers/macintosh/mac_keyb.c needs to call put_queue */
 void put_queue(int);
-static unsigned char handle_diacr(unsigned char);
+static ushort handle_diacr(unsigned char);
 
 /* kbd_pt_regs - set by keyboard_interrupt(), used by show_ptregs() */
 struct pt_regs * kbd_pt_regs;
@@ -541,12 +541,24 @@
 
 static void do_self(unsigned char value, char up_flag)
 {
+        ushort v;
 	if (up_flag)
 		return;		/* no action, if this is a key release */
 
-	if (diacr)
-		value = handle_diacr(value);
-
+	if (diacr) {
+                v = handle_diacr(value);
+                if (kbd->kbdmode == VC_UNICODE) {
+                        to_utf8(v & 0xFFFF);
+                        return;
+                }
+            
+                /* 
+                 * this makes at least latin-1 compose chars work 
+                 * even when using unicode keymap in non-unicode mode
+		 */
+		value = v & 0xFF; 
+        
+        }
 	if (dead_key_next) {
 		dead_key_next = 0;
 		diacr = value;
@@ -582,18 +594,18 @@
 	if (up_flag)
 		return;
 
-	diacr = (diacr ? handle_diacr(value) : value);
+	diacr = (diacr ? (handle_diacr(value) & 0xFF) : value);
 }
 
 
 /*
  * We have a combining character DIACR here, followed by the character CH.
- * If the combination occurs in the table, return the corresponding value.
+ * If the combination occurs in the table, return the corresponding UCS2 value.
  * Otherwise, if CH is a space or equals DIACR, return DIACR.
  * Otherwise, conclude that DIACR was not combining after all,
  * queue it and return CH.
  */
-unsigned char handle_diacr(unsigned char ch)
+ushort handle_diacr(unsigned char ch)
 {
 	int d = diacr;
 	int i;
diff -Nurd linux.orig/include/linux/kd.h linux/include/linux/kd.h
--- linux.orig/include/linux/kd.h	Sun Sep 23 19:31:01 2001
+++ linux/include/linux/kd.h	Mon Oct  8 21:39:02 2001
@@ -115,7 +115,8 @@
 #define KDSKBSENT	0x4B49	/* sets one function key string entry */
 
 struct kbdiacr {
-        unsigned char diacr, base, result;
+        unsigned char diacr, base;
+        unsigned short int result; /* holds UCS2 value */
 };
 struct kbdiacrs {
         unsigned int kb_cnt;    /* number of entries in following array */