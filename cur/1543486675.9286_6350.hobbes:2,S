Date: 21 Feb 1999 02:52:52 +0000
From: David Wragg <>
Subject: Re: Asynchrony (was Re: Locking a process or thread onto a specific CPU)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/2/20/88

Jamie Lokier <lkd@tantalophile.demon.co.uk> writes:
> David Wragg wrote:
> [snip]
> > I'd like to see a nice implementation of user-on-kernel-threads on
> > Linux, but I'm really not sure it would be a win for typical pthreads
> > C programs. When you say LinuxThreads loses against FreeBSD threads,
> > is that for micro-benchmarks or real programs?
> 
> I don't know about typical pthreads programs.  The "fast, really I mean
> fast" threads that I'm talking about is indeed user-on-kernel-threads.
Alexander was talking about FreeBSD's user-level threads, though.
> Kernel threads isn't even an option for the >50,000 threads I have in
> mind.  I'm not talking about being silly with threads here for the sake
> of it.  I'm talking about having >50,000 objects in a simulation, which
> most of the time don't need a locally allocated stack or kernel context.
> However, occasionally they do need one (when they block, or page to
> disk).
Fine, but if you are talking about threads (of any kind) that don't
have individual stacks, then it doesn't have much bearing on
pthreads. Such threads are very interesting in their own right, though.
> The intention is (1) that a typical fast "schedule calling 50,000
> objects' `think()' methods" list+heap scheduler runs most of the objects
> efficiently (without individual stack frames); (2) some processing
> continues even while paging;
Your sleeping-process-signals-another-process idea gives this, and is
easy to implement. (And possibly could be used for a nice
implementation of POSIX aio).
> (3) a few objects can use operating system
> services and get their own stack frame (on demand), while being able to
> use the same mutex/semaphore/message services as the 50,000 simulated
> objects.
I can see why you would want this. But why should a pthreads
implementation provide mutex, etc. facilities that can be used by
programs well outside the scope of pthreads? If you can do it in
LinuxThreads with no significant cost to other LinuxThreads progams,
go ahead. But if you can't, then it's not going to be attractive to
people doing things that don't resemble heavily-threaded simulations.
Dave Wragg
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/