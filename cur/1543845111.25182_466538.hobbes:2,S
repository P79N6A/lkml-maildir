Date: Mon, 25 Sep 2006 18:02:06 -0700
From: Jeremy Fitzhardinge <>
Subject: Re: [PATCH] Linux Kernel Markers 0.13 for 2.6.17
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/9/25/313

Mathieu Desnoyers wrote:
> To protect code from being preempted, the macros preempt_disable and
> preempt_enable must normally be used. Logically, this macro must make sure gcc
> doesn't interleave preemptible code and non-preemptible code.
> 
No, it only needs to prevent globally visible side-effects from being 
moved into/out of preemptable blocks.  In practice that means memory 
updates (including the implicit ones that calls to external functions 
are assumed to make).
> Which makes me think that if I put barriers around my asm, call, asm trio, no
> other code will be interleaved. Is it right ?
> 
No global side effects, but code with local side effects could be moved 
around without changing the meaning of preempt.
For example:
	int foo;
	extern int global;
	foo = some_function();
	foo += 42;
	preempt_disable();
	// stuff
	preempt_enable();
	global = foo;
	foo += other_thing();
Assume here that some_function and other_function are extern, and so gcc 
has no insight into their behaviour and therefore conservatively assumes 
they have global side-effects.
The memory barriers in preempt_disable/enable will prevent gcc from 
moving any of the function calls into the non-preemptable region. But 
because "foo" is local and isn't visible to any other code, there's no 
reason why the "foo += 42" couldn't move into the preempt region.  
Likewise, the assignment to "global" can't move out of the range between 
the preempt_enable and the call to other_thing().
So in your case, if your equivalent of the non-preemptable block is the 
call to the marker function, then there's a good chance that the 
compiler might decide to move some other code in there.
Now it might be possible to take the addresses of labels to inhibit code 
motion into a particular range:
	{
		__label__ before, after;
		asm volatile("" : : "m" (*&&before), "m" (*&&after));	// gcc can't know what we're doing with the labels
	before:	;
		// stuff
	after:	;
	}
but that might be risky for several reasons: I don't know of any 
particular promises gcc makes in this circumstance; I suspect taking the 
address of a label will have a pretty severe inhibition on what 
optimisations gcc's is willing to use (it may prevent inlining 
altogether); and this looks pretty unusual, so there could be bugs.
    J
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/