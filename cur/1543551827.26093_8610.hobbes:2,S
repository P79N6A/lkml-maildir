Date: Tue, 17 Oct 2000 17:56:19 +0400
From: Andrey Panin <>
Subject: [PATCH] NIC drivers: check_region() removal continues
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/10/17/40

Hi all,
check_region() removal continues ...
Affected drivers: hp.c, hp-plus.c, es3210.c, e2100.c, 3c505.c
Best regards,
	    Andrey
-- 
Andrey Panin 		| Embedded systems software engineer
pazke@orbita1.ru	| PGP key: 
http://www.orbita1.ru/~pazke/AndreyPanin.asc
diff -urN /mnt/disk/linux/drivers/net/hp.c /linux/drivers/net/hp.c
--- /mnt/disk/linux/drivers/net/hp.c	Fri Oct 13 21:40:06 2000
+++ /linux/drivers/net/hp.c	Mon Oct 16 19:23:08 2000
@@ -94,13 +94,9 @@
 	else if (base_addr != 0)	/* Don't probe at all. */
 		return -ENXIO;
 
-	for (i = 0; hppclan_portlist[i]; i++) {
-		int ioaddr = hppclan_portlist[i];
-		if (check_region(ioaddr, HP_IO_EXTENT))
-			continue;
-		if (hp_probe1(dev, ioaddr) == 0)
+	for (i = 0; hppclan_portlist[i]; i++)
+		if (hp_probe1(dev, hppclan_portlist[i]) == 0)
 			return 0;
-	}
 
 	return -ENODEV;
 }
@@ -108,18 +104,23 @@
 
 int __init hp_probe1(struct net_device *dev, int ioaddr)
 {
-	int i, board_id, wordmode;
+	int i, retval, board_id, wordmode;
 	const char *name;
 	static unsigned version_printed = 0;
 
+	if (!request_region(ioaddr, HP_IO_EXTENT, "hp"))
+		return -ENODEV;
+
 	/* Check for the HP physical address, 08 00 09 xx xx xx. */
 	/* This really isn't good enough: we may pick up HP LANCE boards
 	   also!  Avoid the lance 0x5757 signature. */
 	if (inb(ioaddr) != 0x08
 		|| inb(ioaddr+1) != 0x00
 		|| inb(ioaddr+2) != 0x09
-		|| inb(ioaddr+14) == 0x57)
-		return -ENODEV;
+		|| inb(ioaddr+14) == 0x57) {
+		retval = -ENODEV;
+		goto out;
+	}
 
 	/* Set up the parameters based on the board ID.
 	   If you have additional mappings, please mail them to me -djb. */
@@ -134,7 +135,7 @@
 	/* We should have a "dev" from Space.c or the static module table. */
 	if (dev == NULL) {
 		printk("hp.c: Passed a NULL device.\n");
-		dev = init_etherdev(0, 0);
+		BUG();
 	}
 
 	if (ei_debug  &&  version_printed++ == 0)
@@ -143,7 +144,8 @@
 	/* Allocate dev->priv and fill in 8390 specific dev fields. */
 	if (ethdev_init(dev)) {
 		printk (" unable to get memory for dev->priv.\n");
-		return -ENOMEM;
+		retval = -ENOMEM;
+		goto out;
 	}
 
 	printk("%s: %s (ID %02x) at %#3x,", dev->name, name, board_id, ioaddr);
@@ -173,24 +175,19 @@
 		} while (*++irqp);
 		if (*irqp == 0) {
 			printk(" no free IRQ lines.\n");
-			kfree(dev->priv);
-			dev->priv = NULL;
-			return -EBUSY;
+			retval = -EBUSY;
+			goto out1;
 		}
 	} else {
 		if (dev->irq == 2)
 			dev->irq = 9;
 		if (request_irq(dev->irq, ei_interrupt, 0, "hp", dev)) {
 			printk (" unable to get IRQ %d.\n", dev->irq);
-			kfree(dev->priv);
-			dev->priv = NULL;
-			return -EBUSY;
+			retval = -EBUSY;
+			goto out1;
 		}
 	}
 
-	/* Grab the region so we can find another board if something fails. */
-	request_region(ioaddr, HP_IO_EXTENT,"hp");
-
 	/* Set the base address to point to the NIC, not the "real" base! */
 	dev->base_addr = ioaddr + NIC_OFFSET;
 	dev->open = &hp_open;
@@ -209,6 +206,12 @@
 	hp_init_card(dev);
 
 	return 0;
+out1:
+	kfree(dev->priv);
+	dev->priv = NULL;
+out:
+	release_region(ioaddr, HP_IO_EXTENT);
+	return retval;
 }
 
 static intdiff -urN /mnt/disk/linux/drivers/net/hp-plus.c /linux/drivers/net/hp-plus.c
--- /mnt/disk/linux/drivers/net/hp-plus.c	Fri Oct 13 21:40:06 2000
+++ /linux/drivers/net/hp-plus.c	Mon Oct 16 19:16:49 2000
@@ -133,13 +133,9 @@
 	else if (base_addr != 0)	/* Don't probe at all. */
 		return -ENXIO;
 
-	for (i = 0; hpplus_portlist[i]; i++) {
-		int ioaddr = hpplus_portlist[i];
-		if (check_region(ioaddr, HP_IO_EXTENT))
-			continue;
-		if (hpp_probe1(dev, ioaddr) == 0)
+	for (i = 0; hpplus_portlist[i]; i++)
+		if (hpp_probe1(dev, hpplus_portlist[i]) == 0)
 			return 0;
-	}
 
 	return -ENODEV;
 }
@@ -148,21 +144,26 @@
 /* Do the interesting part of the probe at a single address. */
 int __init hpp_probe1(struct net_device *dev, int ioaddr)
 {
-	int i;
+	int i, retval;
 	unsigned char checksum = 0;
 	const char *name = "HP-PC-LAN+";
 	int mem_start;
 	static unsigned version_printed = 0;
 
+	if (!request_region(ioaddr, HP_IO_EXTENT, "hp-plus"))
+		return -ENODEV;
+
 	/* Check for the HP+ signature, 50 48 0x 53. */
 	if (inw(ioaddr + HP_ID) != 0x4850
-		|| (inw(ioaddr + HP_PAGING) & 0xfff0) != 0x5300)
-		return -ENODEV;
+		|| (inw(ioaddr + HP_PAGING) & 0xfff0) != 0x5300) {
+		retval = -ENODEV;
+		goto out;
+	}
 
 	/* We should have a "dev" from Space.c or the static module table. */
 	if (dev == NULL) {
 		printk("hp-plus.c: Passed a NULL device.\n");
-		dev = init_etherdev(0, 0);
+		BUG();
 	}
 
 	if (ei_debug  &&  version_printed++ == 0)
@@ -183,7 +184,8 @@
 
 	if (checksum != 0xff) {
 		printk(" bad checksum %2.2x.\n", checksum);
-		return -ENODEV;
+		retval = -ENODEV;
+		goto out;
 	} else {
 		/* Point at the Software Configuration Flags. */
 		outw(ID_Page, ioaddr + HP_PAGING);
@@ -193,12 +195,10 @@
 	/* Allocate dev->priv and fill in 8390 specific dev fields. */
 	if (ethdev_init(dev)) {
 		printk ("hp-plus.c: unable to allocate memory for dev->priv.\n");
-		return -ENOMEM;
+		retval = -ENOMEM;
+		goto out;
 	 }
 
-	/* Grab the region so we can find another board if something fails. */
-	request_region(ioaddr, HP_IO_EXTENT,"hp-plus");
-
 	/* Read the IRQ line. */
 	outw(HW_Page, ioaddr + HP_PAGING);
 	{
@@ -252,6 +252,9 @@
 	outw(inw(ioaddr + HPP_OPTION) & ~EnableIRQ, ioaddr + HPP_OPTION);
 
 	return 0;
+out:
+	release_region(ioaddr, HP_IO_EXTENT);
+	return retval;
 }
 
 static intdiff -urN /mnt/disk/linux/drivers/net/es3210.c /linux/drivers/net/es3210.c
--- /mnt/disk/linux/drivers/net/es3210.c	Fri Oct 13 21:40:06 2000
+++ /linux/drivers/net/es3210.c	Mon Oct 16 19:37:27 2000
@@ -131,31 +131,31 @@
 	if (ioaddr > 0x1ff)		/* Check a single specified location. */
 		return es_probe1(dev, ioaddr);
 	else if (ioaddr > 0)		/* Don't probe at all. */
-		return ENXIO;
+		return -ENXIO;
 
 	if (!EISA_bus) {
 #if ES_DEBUG & ES_D_PROBE
 		printk("es3210.c: Not EISA bus. Not probing high ports.\n");
 #endif
-		return ENXIO;
+		return -ENXIO;
 	}
 
 	/* EISA spec allows for up to 16 slots, but 8 is typical. */
-	for (ioaddr = 0x1000; ioaddr < 0x9000; ioaddr += 0x1000) {
-		if (check_region(ioaddr + ES_SA_PROM, ES_IO_EXTENT))
-			continue;
+	for (ioaddr = 0x1000; ioaddr < 0x9000; ioaddr += 0x1000)
 		if (es_probe1(dev, ioaddr) == 0)
 			return 0;
-	}
 
-	return ENODEV;
+	return -ENODEV;
 }
 
 int __init es_probe1(struct net_device *dev, int ioaddr)
 {
-	int i;
+	int i, retval;
 	unsigned long eisa_id;
 
+	if (!request_region(ioaddr + ES_SA_PROM, ES_IO_EXTENT, "es3210"))
+		return -ENODEV;
+
 #if ES_DEBUG & ES_D_PROBE
 	printk("es3210.c: probe at %#x, ID %#8x\n", ioaddr, inl(ioaddr + ES_ID_PORT));
 	printk("es3210.c: config regs: %#x %#x %#x %#x %#x %#x\n",
@@ -167,7 +167,8 @@
 /*	Check the EISA ID of the card. */
 	eisa_id = inl(ioaddr + ES_ID_PORT);
 	if ((eisa_id != ES_EISA_ID1) && (eisa_id != ES_EISA_ID2)) {
-		return ENODEV;
+		retval = -ENODEV;
+		goto out;
 	}
 
 /*	Check the Racal vendor ID as well. */
@@ -178,13 +179,14 @@
 		for(i = 0; i < ETHER_ADDR_LEN; i++)
 			printk(" %02x", inb(ioaddr + ES_SA_PROM + i));
 		printk(" (invalid prefix).\n");
-		return ENODEV;
+		retval = -ENODEV;
+		goto out;
 	}
 
 	/* We should have a "dev" from Space.c or the static module table. */
 	if (dev == NULL) {
 		printk("es3210.c: Passed a NULL device.\n");
-		dev = init_etherdev(0, 0);
+		BUG();
 	}
 
 	printk("es3210.c: ES3210 rev. %ld at %#x, node", eisa_id>>24, ioaddr);
@@ -216,7 +218,8 @@
 
 	if (request_irq(dev->irq, ei_interrupt, 0, "es3210", dev)) {
 		printk (" unable to get IRQ %d.\n", dev->irq);
-		return EAGAIN;
+		retval = -EAGAIN;
+		goto out;
 	}
 
 	if (dev->mem_start == 0) {
@@ -225,8 +228,8 @@
 
 		if (mem_enabled != 0x80) {
 			printk(" shared mem disabled - giving up\n");
-			free_irq(dev->irq, dev);
-			return -ENXIO;
+			retval = -ENXIO;
+			goto out1;
 		}
 		dev->mem_start = 0xC0000 + mem_bits*0x4000;
 		printk(" using ");
@@ -243,8 +246,8 @@
 	/* Allocate dev->priv and fill in 8390 specific dev fields. */
 	if (ethdev_init(dev)) {
 		printk (" unable to allocate memory for dev->priv.\n");
-		free_irq(dev->irq, dev);
-		return -ENOMEM;
+		retval = -ENOMEM;
+		goto out1;
 	}
 
 #if ES_DEBUG & ES_D_PROBE
@@ -253,8 +256,6 @@
 #endif
 	/* Note, point at the 8390, and not the card... */
 	dev->base_addr = ioaddr + ES_NIC_OFFSET;
-	request_region(ioaddr + ES_SA_PROM, ES_IO_EXTENT, "es3210");
-
 
 	ei_status.name = "ES3210";
 	ei_status.tx_start_page = ES_START_PG;
@@ -274,6 +275,11 @@
 	dev->stop = &es_close;
 	NS8390_init(dev, 0);
 	return 0;
+out1:
+	free_irq(dev->irq, dev);
+out:
+	release_region(ioaddr + ES_SA_PROM, ES_IO_EXTENT);
+	return retval;
 }
 
 /*diff -urN /mnt/disk/linux/drivers/net/e2100.c /linux/drivers/net/e2100.c
--- /mnt/disk/linux/drivers/net/e2100.c	Fri Oct 13 21:40:06 2000
+++ /linux/drivers/net/e2100.c	Mon Oct 16 20:29:23 2000
@@ -127,34 +127,38 @@
 	else if (base_addr != 0)	/* Don't probe at all. */
 		return -ENXIO;
 
-	for (port = e21_probe_list; *port; port++) {
-		if (check_region(*port, E21_IO_EXTENT))
-			continue;
+	for (port = e21_probe_list; *port; port++)
 		if (e21_probe1(dev, *port) == 0)
 			return 0;
-	}
 
 	return -ENODEV;
 }
 
 int __init e21_probe1(struct net_device *dev, int ioaddr)
 {
-	int i, status;
+	int i, status, retval;
 	unsigned char *station_addr = dev->dev_addr;
 	static unsigned version_printed = 0;
 
+	if (!request_region(ioaddr, E21_IO_EXTENT, "e2100"))
+		return -ENODEV;
+
 	/* First check the station address for the Ctron prefix. */
 	if (inb(ioaddr + E21_SAPROM + 0) != 0x00
 		|| inb(ioaddr + E21_SAPROM + 1) != 0x00
-		|| inb(ioaddr + E21_SAPROM + 2) != 0x1d)
-		return -ENODEV;
+		|| inb(ioaddr + E21_SAPROM + 2) != 0x1d) {
+		retval = -ENODEV;
+		goto out;
+	}
 
 	/* Verify by making certain that there is a 8390 at there. */
 	outb(E8390_NODMA + E8390_STOP, ioaddr);
 	udelay(1);	/* we want to delay one I/O cycle - which is 2MHz */
 	status = inb(ioaddr);
-	if (status != 0x21 && status != 0x23)
-		return -ENODEV;
+	if (status != 0x21 && status != 0x23) {
+		retval = -ENODEV;
+		goto out;
+	}
 
 	/* Read the station address PROM.  */
 	for (i = 0; i < 6; i++)
@@ -169,17 +173,17 @@
 	/* We should have a "dev" from Space.c or the static module table. */
 	if (dev == NULL) {
 		printk("e2100.c: Passed a NULL device.\n");
-		dev = init_etherdev(0, 0);
+		BUG();
 	}
 
-	printk("%s: E21** at %#3x,", dev->name, ioaddr);
 	for (i = 0; i < 6; i++)
 		printk(" %02X", station_addr[i]);
 
 	/* Allocate dev->priv and fill in 8390 specific dev fields. */
 	if (ethdev_init(dev)) {
 		printk (" unable to get memory for dev->priv.\n");
-		return -ENOMEM;
+		retval = -ENOMEM;
+		goto out;
 	}
 
 	if (dev->irq < 2) {
@@ -191,14 +195,14 @@
 			}
 		if (i >= 8) {
 			printk(" unable to get IRQ %d.\n", dev->irq);
-			return -EAGAIN;
+			kfree(dev->priv);
+			dev->priv = NULL;
+			retval = -EAGAIN;
+			goto out;
 		}
 	} else if (dev->irq == 2)	/* Fixup luser bogosity: IRQ2 is really IRQ9 */
 		dev->irq = 9;
 
-	/* Grab the region so we can find a different board if IRQ select fails. */
-	request_region(ioaddr, E21_IO_EXTENT, "e2100");
-
 	/* The 8390 is at the base address. */
 	dev->base_addr = ioaddr;
 
@@ -248,6 +252,9 @@
 	NS8390_init(dev, 0);
 
 	return 0;
+out:
+	release_region(ioaddr, E21_IO_EXTENT);
+	return retval;
 }
 
 static intdiff -urN /mnt/disk/linux/drivers/net/3c505.c /linux/drivers/net/3c505.c
--- /mnt/disk/linux/drivers/net/3c505.c	Fri Oct 13 21:40:04 2000
+++ /linux/drivers/net/3c505.c	Sat Oct 14 00:53:51 2000
@@ -1302,8 +1302,8 @@
 	long flags;
 	byte orig_HSR;
 
-	if (check_region(addr, 0xf))
-		return -1;
+	if (!request_region(addr, ELP_IO_EXTENT, "3c505"))
+		return -ENODEV;
 
 	orig_HSR = inb_status(addr);
 
@@ -1313,7 +1313,7 @@
 	if (orig_HSR == 0xff) {
 		if (elp_debug > 0)
 			printk(notfound_msg, 1);
-		return -1;
+		goto out;
 	}
 	/* Enable interrupts - we need timers! */
 	save_flags(flags);
@@ -1332,7 +1332,7 @@
 		if (inb_status(addr) & DIR) {
 			if (elp_debug > 0)
 				printk(notfound_msg, 2);
-			return -1;
+			goto out;
 		}
 	} else {
 		/* If HCR.DIR is down, we pull it up. HSR.DIR should follow. */
@@ -1343,7 +1343,7 @@
 		if (!(inb_status(addr) & DIR)) {
 			if (elp_debug > 0)
 				printk(notfound_msg, 3);
-			return -1;
+			goto out;
 		}
 	}
 	/*
@@ -1353,6 +1353,9 @@
 		printk(found_msg);
 
 	return 0;
+out:
+	release_region(addr, ELP_IO_EXTENT);
+	return -ENODEV;
 }
 
 /*************************************************************
@@ -1503,6 +1506,7 @@
 		outb_control(adapter->hcr_val & ~(FLSH | ATTN), dev);
 	}
 	printk("%s: failed to initialise 3c505\n", dev->name);
+	release_region(dev->base_addr, ELP_IO_EXTENT);
 	return -ENODEV;
 
       okay:
@@ -1593,10 +1597,6 @@
 	if (adapter->rx_pcb.data.configure) {
 		printk("%s: adapter configuration failed\n", dev->name);
 	}
-	/*
-	 * and reserve the address region
-	 */
-	request_region(dev->base_addr, ELP_IO_EXTENT, "3c505");
 
 	/*
 	 * initialise the device