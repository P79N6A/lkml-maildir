Date: Tue, 28 Aug 2007 11:05:07 +0100
From: "Jan Beulich" <>
Subject: [PATCH] handle recursive calls to bust_spinlocks()
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/8/28/64

Various architectures may call bust_spinlocks() recursively; the
function itself, however, doesn't appear to be meant to be called in
this manner. Nevertheless, this doesn't appear to be a problem as long
as bust_spinlocks(0) doesn't get called twice in a row (otherwise,
unblank_screen() may enter the scheduler). However, at least on i386
die() has been capable of returning (and on other architectures this
should really be that way, too) when notify_die() returns NOTIFY_STOP.
Short of getting a reply to a respective query, this patch makes
bust_spinlocks() increment/decrement oops_in_progress, and wake klogd
only when the count drops back to zero.
Signed-off-by: Jan Beulich <jbeulich@novell.com>
 lib/bust_spinlocks.c |    6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)
--- linux-2.6.23-rc4/lib/bust_spinlocks.c	2007-04-26 05:08:32.000000000 +0200
+++ 2.6.23-rc4-recursive-bust-spinlocks/lib/bust_spinlocks.c	2007-08-17 15:07:14.000000000 +0200
@@ -17,13 +17,13 @@
 void __attribute__((weak)) bust_spinlocks(int yes)
 {
 	if (yes) {
-		oops_in_progress = 1;
+		++oops_in_progress;
 	} else {
 #ifdef CONFIG_VT
 		unblank_screen();
 #endif
-		oops_in_progress = 0;
-		wake_up_klogd();
+		if (--oops_in_progress == 0)
+			wake_up_klogd();
 	}
 }
 
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/