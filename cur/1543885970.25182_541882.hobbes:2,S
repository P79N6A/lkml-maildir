Date: Tue, 8 May 2007 21:56:35 -0500
From: Matt Mackall <>
Subject: Re: + fix-spellings-of-slab-allocator-section-in-init-kconfig.patch added to -mm tree
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/5/8/664

On Wed, May 09, 2007 at 12:02:29PM +1000, Nick Piggin wrote:
> BTW, we _really_ should be doing RCU properly in slob, because you
> technically can't noop RCU on UP (even though the current users may be
> safe...).
Thanks. Hugh was pretty convinced it was unneeded:
http://marc.info/?l=linux-mm&m=116413907023393&w=2
And since I didn't care much about the SMP case, I didn't pursue it.
This almost looks reasonable. I think HW_ALIGN | RCU is going to make
it break though:
> +	if (unlikely(c->flags & SLAB_DESTROY_BY_RCU))
> +		b += sizeof(struct slob_rcu);
> +
That could be dealt with by putting the slob_rcu at the end of the
object and having the RCU helper function use ->size to work backward
to the actual pointer.
>  void kmem_cache_free(struct kmem_cache *c, void *b)
>  {
>  	if (c->dtor)
>  		c->dtor(b, c, 0);
I think if we want RCU to actually work, we want to run ->dtor in
__kmem_cache_free?
> -	if (c->size < PAGE_SIZE)
> -		slob_free(b, c->size);
> -	else
> -		free_pages((unsigned long)b, find_order(c->size));
> +	if (unlikely(c->flags & SLAB_DESTROY_BY_RCU)) {
> +		struct slob_rcu *slob_rcu;
> +		b -= sizeof(struct slob_rcu);
> +		slob_rcu = b;
> +		slob_rcu->size = c->size;
Which means just store c in the header^Wfooter, then we can retrieve the size
and the dtor in the RCU helper.
We might as well add slab_is_available and make the damn thing work on
sparsemem again too.
-- 
Mathematics is the supreme nostalgia of our time.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/