Date: Mon, 21 Mar 2005 00:12:29 -0500
From: Dmitry Torokhov <>
Subject: Re: [PATCH 0/5] I8K driver facelift
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/3/21/2

Hi,
On Thursday 17 March 2005 04:46, Frank Sorenson wrote:
> Dmitry Torokhov wrote:
> | Hrm, can we be a little more explicit and not poke in the sysfs guts right
> | in the driver? What do you think about the patch below athat implements
> | "attribute arrays"? And I am attaching cumulative i8k patch using these
> | arrays so they can be tested.
> 
> Also, with power_status being a module parameter defaulting to 0/off, we
> can leave out the device_create_file for the i8k_power_status_attr.  No
> need to expose it in sysfs if it will always return -EIO.
>
Since root can toggle power_status through sysfs at runtime (see
/sys/modules/i8k/parameters/power_status) I think it is simplier to have
the file always created. 
I have implemented arrays of groups of attributes:
[dtor@core ~]$ ls -R /sys/bus/platform/devices/i8k/fan/
/sys/bus/platform/devices/i8k/fan/:
0  1
/sys/bus/platform/devices/i8k/fan/0:
speed  state
/sys/bus/platform/devices/i8k/fan/1:
speed  state
Please give it a try when you have time. Thanks!
-- 
Dmitry
===================================================================
sysfs: add support for attribute arrays so it is possible to create
       a number of similar attributes all sharing the same show and
       store handlers:
          ../<attr_name>/0
          ../<attr_name>/1
               ...
          ../<attr_name>/<n>
       Number of attributes can be specified at run-time.
Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
 fs/sysfs/Makefile     |    2 
 fs/sysfs/array.c      |  162 ++++++++++++++++++++++++++++++++++++++++++++++++++
 include/linux/sysfs.h |   20 +++++-
 3 files changed, 182 insertions(+), 2 deletions(-)
Index: dtor/fs/sysfs/array.c
===================================================================
--- /dev/null
+++ dtor/fs/sysfs/array.c
@@ -0,0 +1,162 @@
+/*
+ * fs/sysfs/array.c - Operations for adding/removing arrays of attributes.
+ *
+ * Copyright (c) 2005 Dmitry Torokhov <dtor@mail.ru>
+ *
+ * This file is released under the GPL v2.
+ *
+ */
+
+#include <linux/kobject.h>
+#include <linux/module.h>
+#include <linux/dcache.h>
+#include "sysfs.h"
+
+struct attr_element {
+	struct attribute attr;
+	unsigned int idx;
+	char name[4];
+};
+#define to_attr_element(e)	container_of(e, struct attr_element, attr)
+
+struct attr_array {
+	const struct enumerated_attr *base_attr;
+	unsigned int n_elements;
+	struct kobject kobj;
+	struct attr_element elements[0];
+};
+#define to_attr_array(obj)	container_of(obj, struct attr_array, kobj)
+
+static ssize_t
+attr_array_show(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	struct attr_element *element = to_attr_element(attr);
+	struct attr_array *array = to_attr_array(kobj);
+	ssize_t ret = 0;
+
+	if (array->base_attr->show)
+		ret = array->base_attr->show(kobj->parent, element->idx, buf);
+
+	return ret;
+}
+
+static ssize_t
+attr_array_store(struct kobject *kobj, struct attribute *attr,
+		 const char *buf, size_t count)
+{
+	struct attr_element *element = to_attr_element(attr);
+	struct attr_array *array = to_attr_array(kobj);
+	ssize_t ret = 0;
+
+	if (array->base_attr->store)
+		ret = array->base_attr->store(kobj->parent, element->idx, buf, count);
+
+	return ret;
+}
+
+static struct sysfs_ops attr_array_sysfs_ops = {
+	.show	= attr_array_show,
+	.store	= attr_array_store,
+};
+
+static void attr_array_release(struct kobject *kobj)
+{
+	kfree(to_attr_array(kobj));
+}
+
+static struct kobj_type ktype_attr_array = {
+	.release	= attr_array_release,
+	.sysfs_ops	= &attr_array_sysfs_ops,
+};
+
+
+static int create_array_element(struct attr_array *array,
+				unsigned int idx)
+{
+	struct attr_element *element = &array->elements[idx];
+
+	snprintf(element->name, sizeof(element->name), "%d", idx);
+	element->idx = idx;
+	element->attr = array->base_attr->attr;
+	element->attr.name = element->name;
+
+	return sysfs_create_file(&array->kobj, &element->attr);
+}
+
+static inline void remove_array_element(struct attr_array *array,
+					unsigned int idx)
+{
+	sysfs_remove_file(&array->kobj, &array->elements[idx].attr);
+}
+
+int sysfs_create_array(struct kobject *kobj,
+		       const struct enumerated_attr *attr,
+		       unsigned int n_elements)
+{
+	struct attr_array *array;
+	size_t size;
+	unsigned int i;
+	int error;
+
+	BUG_ON(!kobj || !kobj->dentry);
+	BUG_ON(!attr_name(*attr));
+
+	if (n_elements > 999)
+		return -EINVAL;
+
+	size = sizeof(struct attr_array) +
+	       sizeof(struct attr_element) * n_elements;
+
+	array = kmalloc(size, GFP_KERNEL);
+	if (!array)
+		return -ENOMEM;
+
+	memset(array, 0, size);
+	array->base_attr = attr;
+	array->n_elements = n_elements;
+
+	array->kobj.ktype = &ktype_attr_array;
+	array->kobj.parent = kobj;
+	kobject_set_name(&array->kobj, attr_name(*attr));
+
+	error = kobject_register(&array->kobj);
+	if (error)
+		goto fail;
+
+	for (i = 0; i < n_elements; i++) {
+		error = create_array_element(array, i);
+		if (error) {
+			while (--i)
+				remove_array_element(array, i);
+			goto fail;
+		}
+	}
+
+	return 0;
+
+ fail:
+	kfree(array);
+	return error;
+}
+
+void sysfs_remove_array(struct kobject *kobj,
+			const struct enumerated_attr *attr)
+{
+	struct attr_array *array;
+	struct dentry *dir;
+	unsigned int i;
+
+	dir = sysfs_get_dentry(kobj->dentry, attr_name(*attr));
+
+	if (dir) {
+		array = to_attr_array(to_kobj(dir));
+		for (i = 0; i < array->n_elements; i++)
+			remove_array_element(array, i);
+		kobject_unregister(&array->kobj);
+	}
+
+	dput(dir);
+}
+
+EXPORT_SYMBOL_GPL(sysfs_create_array);
+EXPORT_SYMBOL_GPL(sysfs_remove_array);
Index: dtor/include/linux/sysfs.h
===================================================================
--- dtor.orig/include/linux/sysfs.h
+++ dtor/include/linux/sysfs.h
@@ -26,7 +26,12 @@ struct attribute_group {
 	struct attribute	** attrs;
 };
 
+struct enumerated_attr {
+	struct attribute	attr;
 
+	ssize_t	(*show)(struct kobject *, unsigned int index, char *);
+	ssize_t	(*store)(struct kobject *, unsigned int index, const char *, size_t);
+};
 
 /**
  * Use these macros to make defining attributes easier. See include/linux/device.h
@@ -102,7 +107,7 @@ sysfs_update_file(struct kobject *, cons
 extern void
 sysfs_remove_file(struct kobject *, const struct attribute *);
 
-extern int 
+extern int
 sysfs_create_link(struct kobject * kobj, struct kobject * target, char * name);
 
 extern void
@@ -114,6 +119,9 @@ int sysfs_remove_bin_file(struct kobject
 int sysfs_create_group(struct kobject *, const struct attribute_group *);
 void sysfs_remove_group(struct kobject *, const struct attribute_group *);
 
+int sysfs_create_array(struct kobject *, const struct enumerated_attr *, unsigned int);
+void sysfs_remove_array(struct kobject *, const struct enumerated_attr *);
+
 #else /* CONFIG_SYSFS */
 
 static inline int sysfs_create_dir(struct kobject * k)
@@ -177,6 +185,16 @@ static inline void sysfs_remove_group(st
 	;
 }
 
+static inline int sysfs_create_array(struct kobject * k, const struct enumerated_attr * a, unsigned int n)
+{
+	return 0;
+}
+
+static inline void sysfs_remove_array(struct kobject * k, const struct enumerated_attr * a)
+{
+	;
+}
+
 #endif /* CONFIG_SYSFS */
 
 #endif /* _SYSFS_H_ */
Index: dtor/fs/sysfs/Makefile
===================================================================
--- dtor.orig/fs/sysfs/Makefile
+++ dtor/fs/sysfs/Makefile
@@ -3,4 +3,4 @@
 #
 
 obj-y		:= inode.o file.o dir.o symlink.o mount.o bin.o \
-		   group.o
+		   group.o array.o===================================================================
sysfs: add support for arrays of groups of attributes:
          ../<group_name>/0/<attr_a>
          ../<group_name>/0/<attr_b>
          ../<group_name>/1/<attr_a>
          ../<group_name>/1/<attr_b>
                 ...
          ../<group_name>/<n>/<attr_a>
          ../<group_name>/<n>/<attr_b>
Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
 fs/sysfs/Makefile      |    2 
 fs/sysfs/group-array.c |  206 +++++++++++++++++++++++++++++++++++++++++++++++++
 include/linux/sysfs.h  |   18 ++++
 3 files changed, 225 insertions(+), 1 deletion(-)
Index: dtor/fs/sysfs/Makefile
===================================================================
--- dtor.orig/fs/sysfs/Makefile
+++ dtor/fs/sysfs/Makefile
@@ -3,4 +3,4 @@
 #
 
 obj-y		:= inode.o file.o dir.o symlink.o mount.o bin.o \
-		   group.o array.o
+		   group.o array.o group-array.o
Index: dtor/include/linux/sysfs.h
===================================================================
--- dtor.orig/include/linux/sysfs.h
+++ dtor/include/linux/sysfs.h
@@ -33,6 +33,11 @@ struct enumerated_attr {
 	ssize_t	(*store)(struct kobject *, unsigned int index, const char *, size_t);
 };
 
+struct attribute_group_array {
+	char			* name;
+	struct enumerated_attr	* attrs;
+};
+
 /**
  * Use these macros to make defining attributes easier. See include/linux/device.h
  * for examples..
@@ -122,6 +127,9 @@ void sysfs_remove_group(struct kobject *
 int sysfs_create_array(struct kobject *, const struct enumerated_attr *, unsigned int);
 void sysfs_remove_array(struct kobject *, const struct enumerated_attr *);
 
+int sysfs_create_group_array(struct kobject *, const struct attribute_group_array *, unsigned int);
+void sysfs_remove_group_array(struct kobject *, const struct attribute_group_array *);
+
 #else /* CONFIG_SYSFS */
 
 static inline int sysfs_create_dir(struct kobject * k)
@@ -195,6 +203,16 @@ static inline void sysfs_remove_array(st
 	;
 }
 
+static inline int sysfs_create_group_array(struct kobject * k, const struct attribute_group_array * a, unsigned int n)
+{
+	return 0;
+}
+
+static inline void sysfs_remove_group_array(struct kobject * k, const struct attribute_group_array * a)
+{
+	;
+}
+
 #endif /* CONFIG_SYSFS */
 
 #endif /* _SYSFS_H_ */
Index: dtor/fs/sysfs/group-array.c
===================================================================
--- /dev/null
+++ dtor/fs/sysfs/group-array.c
@@ -0,0 +1,206 @@
+/*
+ * fs/sysfs/group-array.c - Operations for adding/removing arrays of groups
+ *			    of attributes.
+ *
+ * Copyright (c) 2005 Dmitry Torokhov <dtor@mail.ru>
+ *
+ * This file is released under the GPL v2.
+ *
+ */
+
+#include <linux/kobject.h>
+#include <linux/module.h>
+#include <linux/dcache.h>
+#include "sysfs.h"
+
+#define to_enumerated_attr(obj)	container_of(obj, struct enumerated_attr, attr)
+
+struct attr_group {
+	struct kobject kobj;
+	struct kobject *attr_owner;
+	unsigned int idx;
+};
+#define to_attr_group(obj)	container_of(obj, struct attr_group, kobj)
+
+struct attr_array {
+	struct kobject kobj;
+	unsigned int n_elements;
+	struct enumerated_attr *attrs;
+};
+#define to_attr_array(obj)	container_of(obj, struct attr_array, kobj)
+
+static ssize_t
+attr_group_show(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	struct enumerated_attr *eattr = to_enumerated_attr(attr);
+	struct attr_group *group = to_attr_group(kobj);
+	ssize_t ret = 0;
+
+	if (eattr->show)
+		ret = eattr->show(group->attr_owner, group->idx, buf);
+
+	return ret;
+}
+
+static ssize_t
+attr_group_store(struct kobject *kobj, struct attribute *attr,
+		 const char *buf, size_t count)
+{
+	struct enumerated_attr *eattr = to_enumerated_attr(attr);
+	struct attr_group *group = to_attr_group(kobj);
+	ssize_t ret = 0;
+
+	if (eattr->store)
+		ret = eattr->store(group->attr_owner, group->idx, buf, count);
+
+	return ret;
+}
+
+static struct sysfs_ops attr_group_sysfs_ops = {
+	.show	= attr_group_show,
+	.store	= attr_group_store,
+};
+
+static void attr_group_release(struct kobject *kobj)
+{
+	struct attr_group *group = to_attr_group(kobj);
+
+	kobject_put(group->attr_owner);
+	kfree(group);
+}
+
+static struct kobj_type ktype_attr_group = {
+	.release	= attr_group_release,
+	.sysfs_ops	= &attr_group_sysfs_ops,
+};
+
+static void attr_array_release(struct kobject *kobj)
+{
+	kfree(to_attr_array(kobj));
+}
+
+static struct kobj_type ktype_attr_array = {
+	.release	= attr_array_release,
+};
+
+static int create_group(struct attr_array *array, unsigned int idx)
+{
+	struct attr_group *group;
+	struct enumerated_attr *eattr, *eattr2;
+	int err;
+
+	group = kmalloc(sizeof(struct attr_group), GFP_KERNEL);
+	if (!group)
+		return -ENOMEM;
+
+	memset(group, 0, sizeof(struct attr_group));
+	kobject_set_name(&group->kobj, "%d", idx);
+	group->kobj.ktype = &ktype_attr_group;
+	group->kobj.parent = &array->kobj;
+	group->attr_owner = kobject_get(array->kobj.parent);
+	group->idx = idx;
+
+	err = kobject_register(&group->kobj);
+	if (err)
+		goto fail1;
+
+	for (eattr = array->attrs; attr_name(*eattr); eattr++) {
+		err = sysfs_create_file(&group->kobj, &eattr->attr);
+		if (err)
+			goto fail2;
+	}
+
+	return 0;
+
+ fail2:	for (eattr2 = array->attrs; eattr2 != eattr; eattr2++)
+		sysfs_remove_file(&group->kobj, &eattr2->attr);
+ fail1:	kfree(group);
+	return err;
+}
+
+static void remove_group(struct attr_array *array, unsigned int idx)
+{
+	struct attr_group *group;
+	struct enumerated_attr *eattr;
+	struct dentry *dir;
+	char name[4];
+
+	snprintf(name, sizeof(name), "%d", idx);
+	dir = sysfs_get_dentry(array->kobj.dentry, name);
+	if (dir) {
+		group = to_attr_group(to_kobj(dir));
+		for (eattr = array->attrs; attr_name(*eattr); eattr++)
+			sysfs_remove_file(&group->kobj, &eattr->attr);
+		kobject_unregister(&group->kobj);
+	}
+
+	dput(dir);
+}
+
+int sysfs_create_group_array(struct kobject *kobj,
+			     const struct attribute_group_array *a,
+			     unsigned int n_elements)
+{
+	struct attr_array *array;
+	unsigned int i;
+	int error;
+
+	BUG_ON(!kobj || !kobj->dentry);
+	BUG_ON(!a->name);
+
+	if (n_elements > 999)
+		return -EINVAL;
+
+	array = kmalloc(sizeof(struct attr_array), GFP_KERNEL);
+	if (!array)
+		return -ENOMEM;
+
+	memset(array, 0, sizeof(struct attr_array));
+	array->attrs = a->attrs;
+	array->n_elements = n_elements;
+
+	array->kobj.ktype = &ktype_attr_array;
+	array->kobj.parent = kobj;
+	kobject_set_name(&array->kobj, a->name);
+
+	error = kobject_register(&array->kobj);
+	if (error)
+		goto fail;
+
+	for (i = 0; i < n_elements; i++) {
+		error = create_group(array, i);
+		if (error) {
+			while (--i)
+				remove_group(array, i);
+			goto fail;
+		}
+	}
+
+	return 0;
+
+ fail:
+	kfree(array);
+	return error;
+}
+
+void sysfs_remove_group_array(struct kobject *kobj,
+			      const struct attribute_group_array *a)
+{
+	struct attr_array *array;
+	struct dentry *dir;
+	unsigned int i;
+
+	dir = sysfs_get_dentry(kobj->dentry, a->name);
+
+	if (dir) {
+		array = to_attr_array(to_kobj(dir));
+		for (i = 0; i < array->n_elements; i++)
+			remove_group(array, i);
+		kobject_unregister(&array->kobj);
+	}
+
+	dput(dir);
+}
+
+EXPORT_SYMBOL_GPL(sysfs_create_group_array);
+EXPORT_SYMBOL_GPL(sysfs_remove_group_array);