Date: 30 Jan 2002 06:06:50 +0200
From: Jarno Paananen <>
Subject: How to avoid zombie kernel threads?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2002/1/29/278

Hi,
I'm coding a driver (can be found from
http://hardsid.sourceforge.net/
 is someone is actually interested)
that uses a kernel thread to do the actual work asynchronously from
rest of the world. The thread is created when opening a character
device and exits when the device is closed.
This works fine otherwise but if the user mode process opens and
closes the device multiple times during its lifetime I get N-1
zombie kernel threads where N is the number of opens.
The code goes like this:
in device open:
        DECLARE_MUTEX_LOCKED(sem);
        int rmmod = 0; 
        rmmod = 0;
        notify = &sem;
        kernel_thread(hsid_thread, (void *)sid_data, 0);
        down(&sem);
        notify = NULL;
 
in device close:
        notify = &sem;
        rmmod = 1;
        up(&todoSem); // just to wake the thread to do something
        down(&sem);
        notify = NULL;
        rmmod = 0;
and the thread itself does:
[daemonize() etc.]
    /* Notify the parent */
    if(notify != NULL)
        up(notify);
    for(;;)
    {
        if (rmmod || signal_pending(current))
            break;
        /* We sit here waiting for something to do */
        down_interruptible(&todoSem);
        if (rmmod || signal_pending(current))
            break;
        [actual work]
    }
    if(notify != NULL)
        up(notify);
    return 0;
I think this worked fine in earlier 2.4 versions (not sure though),
but I'm now seeing this in both 2.4.18-pre7 and 2.5.2-dj6, UP and SMP.
Thanks,
// Jarno
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/