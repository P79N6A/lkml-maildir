Date: Mon, 29 Nov 1999 15:28:18 +0000
From: Dmitry Veprintsev <>
Subject: Synaptics - pc_keyb.c
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/11/29/54

Hi, in order to get the Synaptecs config utility to work, i had to apply
the 
following path (not mine - see original post). 
http://www.uwsg.indiana.edu/hypermail/linux/kernel/9904.3/0887.html
the same patch against 2.2.13 is attached (sorry for stripping down
original comments - had to apply it by hand). 
Cheers, Dmitry
----
Dr. Dmitry Veprintsev; mailto:dbv@mrc-lmb.cam.ac.uk
MRC Centre for Protein Eng., Hills Rd., Cambridge CB2 2QH, UK
ph:  44(1223)402027 fax: 44(1223)402140
http://macx48.mrc-lmb.cam.ac.uk
--- /usr/src/linux/drivers/char/pc_keyb.c.orig	Mon Aug  9 20:04:39 1999
+++ /usr/src/linux/drivers/char/pc_keyb.c	Mon Nov 29 14:17:56 1999
@@ -77,6 +77,8 @@
 static int aux_count = 0;
 /* used when we send commands to the mouse that expect an ACK. */
 static unsigned char mouse_reply_expected = 0;
+static unsigned char mouse_ack_pending = 0;
+#define MOUSE_ACK_TIMEOUT 5 /* actually, 1 seems to be enough usually */
 
 #define AUX_INTS_OFF (KBD_MODE_KCC | KBD_MODE_DISABLE_MOUSE | KBD_MODE_SYS | KBD_MODE_KBD_INT)
 #define AUX_INTS_ON  (KBD_MODE_KCC | KBD_MODE_SYS | KBD_MODE_MOUSE_INT | KBD_MODE_KBD_INT)
@@ -386,6 +388,8 @@
 static inline void handle_mouse_event(unsigned char scancode)
 {
 #ifdef CONFIG_PSMOUSE
+        if (mouse_ack_pending)
+	mouse_ack_pending = 0; 
 	if (mouse_reply_expected) {
 		if (scancode == AUX_ACK) {
 			mouse_reply_expected--;
@@ -771,11 +775,24 @@
 {
 	unsigned long flags;
 
+        int loop = 0;
+
 	spin_lock_irqsave(&kbd_controller_lock, flags);
 	kb_wait();
+
+        while (mouse_ack_pending && loop++ < MOUSE_ACK_TIMEOUT ) { 
+        mdelay(1);
+        handle_kbd_event();
+        }
+        if ( mouse_ack_pending )
+        printk(KERN_WARNING "mouse ack timeout\n") ;
+
 	kbd_write_command(KBD_CCMD_WRITE_MOUSE);
 	kb_wait();
 	kbd_write_output(val);
+        
+	mouse_ack_pending = 1;
+	
 	spin_unlock_irqrestore(&kbd_controller_lock, flags);
 }
 
@@ -785,13 +802,27 @@
 static void aux_write_ack(int val)
 {
 	unsigned long flags;
-
+        
+	int loop = 0;
+	 
 	spin_lock_irqsave(&kbd_controller_lock, flags);
 	kb_wait();
+	
+        while (mouse_ack_pending && loop++ < MOUSE_ACK_TIMEOUT ) { 
+        mdelay(1);
+        handle_kbd_event();
+        }
+        if ( mouse_ack_pending )
+        printk(KERN_WARNING "mouse ack timeout\n") ;
+	
+	
 	kbd_write_command(KBD_CCMD_WRITE_MOUSE);
 	kb_wait();
 	kbd_write_output(val);
 	/* we expect an ACK in response. */
+
+	mouse_ack_pending = 1;
+
 	mouse_reply_expected++;
 	kb_wait();
 	spin_unlock_irqrestore(&kbd_controller_lock, flags);