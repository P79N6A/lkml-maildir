Date: Wed, 25 Oct 2000 19:42:44 -0400 (EDT)
From: "Albert D. Cahalan" <>
Subject: Re: large memory support for x86
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/10/25/180

Petr Vandrovec writes:
> Sure it does not. Selectors point to linear addresses, before passing them
> through pagetables. You have 32+14 bits of virtual address (32 = offset,
> 14 = valid bits in selector), which are translated, together with
> offset, to 32 bit linear address. This 32bit linear address is passed
> through pagetables to 36 bit physical address. So it must go through
> 32bit linear address, and there is no easy way to overcome this limit.
...
> make complete segment non present, and on pagefault
> unmap all pages belonging to some selector + invalidate selector, and
> map something else in. You must create at least four such areas,
> as you must have mapped at least CS, SS, ES and one of DS/FS/GS to
> successfully execute MOVSB... So each area should be < 256MB.
This does it...
You sort of page (segment?) the virtual space with segment faults.
Um, you want 3-level software page tables with that?
> Are you really sure that it is worth of effort? Also do not forget
> that 'sizeof(void*) > sizeof(long)' in such environment, so tons of
> code broke... And someone must translate pointers from 48bits to 32
> for kernel use...
No, you don't need that. Nobody could tolerate it anyway.
You need to hack gcc to use a 64-bit long, and a 64-bit pointer.
The pointer has 16 dead bits, 16 segment bits, and 32 offset bits.
Hey, look, LP64 on ia32!
You might want a separate personality for this, so that programs
compiled with this feature would get their own system calls.
Otherwise, there will surely be serious monkey business in libc
trying to get a pointer the kernel will use correctly.
If you select a good segment size and cache hardware page tables
that aren't active, performance might not be... abysmal. The worst
part might be that the CPU becomes less parallel when it encounters
operations that access different segments. Of course 64-bit pointer
math doesn't come free either. I once had a 486DX-75 and I liked it,
so you're doing fine if you can beat that. At least you can use this
to test software for LP64.
Hey, threads are extra cool. They don't really need to share the
hardware page tables. If you only share the software page tables,
then you don't thrash so bad.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
Please read the FAQ at 
http://www.tux.org/lkml/