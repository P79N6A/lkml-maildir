Date: Sun, 24 Sep 2000 14:28:07 -0500 (CDT)
From: Peter Samuelson <>
Subject: Re: how interesting are data->bss patches?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/9/24/101

[Tigran Aivazian <tigran@veritas.com>]
> The question you ask can be answered trivially - yes, it is
> definitely a good idea, please make such a patch.
OK, I'll look at it.
> But what is far from being trivial is the magic reg. expression that
> is capable of catching all "globals initialized to 0 or NULL".
Well, I'm not actually parsing C here, obviously.  For a first
iteration, I did:
  sed -e '/^[A-Za-z].*=[ 	]*NULL;/s/[ 	]*=[ 	]*NULL;/;/'
(where those blank areas are 'space tab') and likewise for 0.  This
catches assignment lines with no leading whitespace.  I wrapped it up
in a 'find|while read x;do' loop that generated a patchfile in-place (I
was low on disk space, couldn't just fork the tree) using diff -U4 to
give me extra context.  The idea is to page through the resulting diff
and delete bogus hunks (and re-align comments that get moved too far
left, etc.), of which I expect there won't be too many.
A more advanced version will filter out __initdata assignments
automatically.  I haven't got that far yet.
> I seriously thought of "simply" reading entire 2279844 lines of C
> code to catch all "data->bss" cases but if you can have grep(1) do
> that for me then that may save quite a lot of time :)
My expression doesn't catch *all* offenders, by any means.  For
example, things like
  char *foo[MAX_BLURFL] = { NULL, };
would be much harder to pick up.
Peter
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
Please read the FAQ at 
http://www.tux.org/lkml/