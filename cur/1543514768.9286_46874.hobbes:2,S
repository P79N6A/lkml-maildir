Date: Tue, 02 Nov 1999 00:28:27 +0100
From: Manfred Spraul <>
Subject: problem in md?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/11/1/130

Hi Ingo,
IIRC I suspected a possible problem in md_thread() a few weeks ago, and
I proved wrong. But now I'm sure that there could be a problem!
md_thread calls
cli()
for(;;) {
	interruptible_sleep_on()
	cli();
	do_something().
}
are you aware that do_something() is called WITHOUT the global interrupt
lock held?
Let me explain it:
* the initial cli() disables the local interrupts, and acquires the
global lock.
* interruptible_sleep_on() calls spin_lock_irqsave(), and this saves the
_local_ interrupt flag on the stack.
* schedule() releases the global interrupt lock.
* schedule() eventually returns, and interruptible_sleep_on() restores
the _local_ interrupt flag. (hidden in wq_write_unlock_irqrestore().)
* __global_cli() notices that the local interrupts are disabled, and
downgrades the global lock to a local lock.
I think you should add an sti() just before the cli(). You cannot call
the sti() before interruptible_sleep_on(), this could cause a race.
Please correct me if I'm wrong, 
	Manfred
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/