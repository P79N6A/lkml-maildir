Date: Mon, 5 Nov 2001 08:18:36 +0100
From: Jens Axboe <>
Subject: Re: [Ext2-devel] disk throughput
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2001/11/5/261

On Mon, Nov 05 2001, Jens Axboe wrote:
> Interesting, the 2.5 design prevents this since it doesn't account
> merges as a penalty (like a seek). I can do something like that for 2.4
> too, I'll do a patch for you to test.
Ok here it is. It's not as efficient as the 2.5 version since it
proceeds to scan the entire queue for a merge, but it should suffice for
your testing.
-- 
Jens Axboe
--- drivers/block/ll_rw_blk.c~	Mon Nov  5 08:15:25 2001
+++ drivers/block/ll_rw_blk.c	Mon Nov  5 08:15:51 2001
@@ -696,7 +696,9 @@
 		case ELEVATOR_BACK_MERGE:
 			if (!q->back_merge_fn(q, req, bh, max_segments))
 				break;
+#if 0
 			elevator->elevator_merge_cleanup_fn(q, req, count);
+#endif
 			req->bhtail->b_reqnext = bh;
 			req->bhtail = bh;
 			req->nr_sectors = req->hard_nr_sectors += count;
@@ -708,7 +710,9 @@
 		case ELEVATOR_FRONT_MERGE:
 			if (!q->front_merge_fn(q, req, bh, max_segments))
 				break;
+#if 0
 			elevator->elevator_merge_cleanup_fn(q, req, count);
+#endif
 			bh->b_reqnext = req->bh;
 			req->bh = bh;
 			req->buffer = bh->b_data;
--- drivers/block/elevator.c~	Mon Nov  5 08:13:19 2001
+++ drivers/block/elevator.c	Mon Nov  5 08:18:04 2001
@@ -81,8 +81,9 @@
 			 int max_sectors)
 {
 	struct list_head *entry = &q->queue_head;
-	unsigned int count = bh->b_size >> 9, ret = ELEVATOR_NO_MERGE;
+	unsigned int count = bh->b_size >> 9, ret = ELEVATOR_NO_MERGE, queue;
 
+	queue = 1;
 	while ((entry = entry->prev) != head) {
 		struct request *__rq = blkdev_entry_to_request(entry);
 
@@ -90,13 +91,13 @@
 		 * simply "aging" of requests in queue
 		 */
 		if (__rq->elevator_sequence-- <= 0)
-			break;
+			queue = 0;
 
 		if (__rq->waiting)
 			continue;
 		if (__rq->rq_dev != bh->b_rdev)
 			continue;
-		if (!*req && bh_rq_in_between(bh, __rq, &q->queue_head))
+		if (queue && !*req && bh_rq_in_between(bh, __rq,&q->queue_head))
 			*req = __rq;
 		if (__rq->cmd != rw)
 			continue;
@@ -110,7 +111,6 @@
 			break;
 		} else if (__rq->sector - count == bh->b_rsector) {
 			ret = ELEVATOR_FRONT_MERGE;
-			__rq->elevator_sequence -= count;
 			*req = __rq;
 			break;
 		}