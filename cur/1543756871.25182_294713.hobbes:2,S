Date: Mon, 14 Feb 2005 08:56:45 +1100
From: Herbert Xu <>
Subject: Re: linux-2.6.11-rc3 and isdn mppp
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/2/13/70

On Sat, Feb 12, 2005 at 04:50:23PM +0000, Christian Heim wrote:
> Well, i have to setup ISDN here at home, and wanted to use both channels.
> I am able to add the second channel, but then the kernel (at least i think) 
> starts to complain.
> 
> >17:36:22 kraftwerk Badness in local_bh_enable at kernel/softirq.c:140
> >17:36:22 kraftwerk [<c011b201>] local_bh_enable+0x71/0x80
> >17:36:22 kraftwerk [<c030c1a7>] isdn_ppp_xmit+0xe7/0x7d0
isdn_net_get_locked_lp is doing a local_bh_enable with hard IRQs
disabled.  This is not allowed.
The following patch fixes the problem by removing the unnecessary
local_bh_enable while the hard IRQs are disabled.
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
Cheers,
-- 
Visit Openswan at 
http://www.openswan.org/
Email: Herbert Xu 许志壬 <herbert@gondor.apana.org.au>
Home Page: 
http://gondor.apana.org.au/herbert/
PGP Key: 
http://gondor.apana.org.au/herbert/pubkey.txt
===== drivers/isdn/i4l/isdn_net.h 1.48 vs edited =====
--- 1.48/drivers/isdn/i4l/isdn_net.h	2004-06-23 00:44:03 +10:00
+++ edited/drivers/isdn/i4l/isdn_net.h	2005-02-14 08:52:19 +11:00
@@ -78,18 +78,19 @@
 
 	spin_lock_irqsave(&nd->queue_lock, flags);
 	lp = nd->queue;         /* get lp on top of queue */
-	spin_lock_bh(&nd->queue->xmit_lock);
+	spin_lock(&nd->queue->xmit_lock);
 	while (isdn_net_lp_busy(nd->queue)) {
-		spin_unlock_bh(&nd->queue->xmit_lock);
+		spin_unlock(&nd->queue->xmit_lock);
 		nd->queue = nd->queue->next;
 		if (nd->queue == lp) { /* not found -- should never happen */
 			lp = NULL;
 			goto errout;
 		}
-		spin_lock_bh(&nd->queue->xmit_lock);
+		spin_lock(&nd->queue->xmit_lock);
 	}
 	lp = nd->queue;
 	nd->queue = nd->queue->next;
+	local_bh_disable();
 errout:
 	spin_unlock_irqrestore(&nd->queue_lock, flags);
 	return lp;