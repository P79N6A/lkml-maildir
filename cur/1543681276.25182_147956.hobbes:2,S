Date: Mon, 14 Jul 2003 16:17:28 +0100
From: John Levon <>
Subject: [PATCH] OProfile: dynamically allocate MSR struct
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2003/7/14/187

Andi pointed out to me that cpu_msrs was a source of bloat. Dynamically
allocate it instead. Tested on my SMP box.
Note that we could eventually use per cpu stuff here, but I'd like to
wait on that for now.
regards
john
diff -Naur -X dontdiff linux-cvs/arch/i386/oprofile/nmi_int.c linux-fixes/arch/i386/oprofile/nmi_int.c
--- linux-cvs/arch/i386/oprofile/nmi_int.c	2003-06-18 15:06:05.000000000 +0100
+++ linux-fixes/arch/i386/oprofile/nmi_int.c	2003-07-14 15:34:29.000000000 +0100
@@ -12,6 +12,7 @@
 #include <linux/smp.h>
 #include <linux/oprofile.h>
 #include <linux/sysdev.h>
+#include <linux/slab.h>
 #include <asm/nmi.h>
 #include <asm/msr.h>
 #include <asm/apic.h>
@@ -20,7 +21,7 @@
 #include "op_x86_model.h"
  
 static struct op_x86_model_spec const * model;
-static struct op_msrs cpu_msrs[NR_CPUS];
+static struct op_msrs * cpu_msrs;
 static unsigned long saved_lvtpc[NR_CPUS];
  
 static int nmi_start(void);
@@ -125,6 +126,10 @@
 
 static int nmi_setup(void)
 {
+	cpu_msrs = kmalloc(sizeof(struct op_msrs) * NR_CPUS, GFP_KERNEL);
+	if (!cpu_msrs)
+		return -ENOMEM;
+
 	/* We walk a thin line between law and rape here.
 	 * We need to be careful to install our NMI handler
 	 * without actually triggering any NMIs as this will
@@ -185,6 +190,7 @@
 	on_each_cpu(nmi_cpu_shutdown, NULL, 0, 1);
 	unset_nmi_callback();
 	enable_lapic_nmi_watchdog();
+	kfree(cpu_msrs);
 }
 
  
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/