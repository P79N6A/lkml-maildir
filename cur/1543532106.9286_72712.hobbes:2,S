Date: Tue, 28 Mar 2000 18:13:26 +0100
From: "Stephen C. Tweedie" <>
Subject: Re: Bad FS behavior w/ testcase
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/3/28/89

Hi,
On Mon, Mar 27, 2000 at 06:47:29PM -0500, James Lewis Nance wrote:
>     I have found an annoying problem with the way linux handles dirty pages
> of unlinked files.  The attached testcase makes a file, unlinks it, and
> dirties 64M of its pages.  The program then prints a message and calls
> _exit().  You will notice a long delay between this message appearing and
> when you get your shell prompt back.  AFAICT, this delay is due to the
> process writting the dirty pages back to the file.  Now since the file has
> been unlinked there is no need to write these pages back, but it looks like
> linux does not know this.  Any comments?
This is correct behaviour.  The kernel makes sure that the writes are 
propagated to a file before a mmap shared write region is closed.  In
general, the kernel cannot just assume that the file is dead, even if
it is unlinked, because there may be other processes with the file 
descriptor still open.  
Yes, there's a very special case where the inode is both unlinked and
unshared, but it's not really worth adding lots of complexity to the 
memory management code just for such a case.  The memory manager is
_required_ to flush such data to the file before a process exits.  If
this special case concerns you a lot, just use the new madvise() code
in the 2.3 kernel to madvise(MADV_DONTNEED) the region before you exit.
That will discard all of the dirty data rather than flush it.
--Stephen
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/