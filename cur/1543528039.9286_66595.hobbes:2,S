Date: Tue, 29 Feb 2000 20:28:27 +0100 (CET)
From: Mike Galbraith <>
Subject: Re: string-486.h?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/2/29/189

On Tue, 29 Feb 2000, Ben Kosse wrote:
> > Well the problem is bad 'C' code. It's not the compiler's fault. It's
> > just doing what it's told to do.
> > 
> >         char str[12]="mystring";
> > 
> >    declares a string on the stack with room for 12 bytes. However it is
> > initialized with only 9 (8 characters + the implied \0). So the rest
> > of the area has to be zeroed, which the compiler does.
> No it doesn't. For all C is required to care about, it could be stored as:
> "mystring\0bla" The definition is 12 bytes on the stack, the first nine being
> "mystring\0".
The compiler decided to not inline memset.  The same thing happens with
devel tree egcs snapshots for memcpy.  The only question is this (imho)
is the compiler obligated to inline imlied memory range modifications
(memset memcpy whatever) just because it used to?.. or should kernel
code state explicitly what it means given that there is no lib backing?
	-Mike
raw data from the thing I looked at in aic7xxx.c
egcs-20000221----------------------------------------------------------
    p->sc = *sc;
   11991:	6a 40                	push   $0x40
   11993:	8b 95 e0 fe ff ff    	mov    0xfffffee0(%ebp),%edx
   11999:	52                   	push   %edx
   1199a:	8d 86 1e 03 00 00    	lea    0x31e(%esi),%eax
   119a0:	50                   	push   %eax
   119a1:	e8 fc ff ff ff       	call   119a2 <aic7xxx_load_seeprom+0x3d2>
                                           ^^^^^ awol memcpy
  }
   119a6:	83 c4 0c             	add    $0xc,%esp
  p->discenable = 0;
    
  /*
   * Limit to 16 targets just in case.  The 2842 for one is known to
   * blow the max_targets setting, future cards might also.
   */
gcc-2.95.2-------------------------------------------------------------
    p->sc = *sc;
   112b6:	8b 7d 08             	mov    0x8(%ebp),%edi
   112b9:	8b 85 e8 fe ff ff    	mov    0xfffffee8(%ebp),%eax
   112bf:	81 c7 1e 03 00 00    	add    $0x31e,%edi
   112c5:	89 c6                	mov    %eax,%esi
   112c7:	fc                   	cld    
   112c8:	b9 10 00 00 00       	mov    $0x10,%ecx
   112cd:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
                                    == inlined memcpy
  }
  p->discenable = 0;
   112cf:	8b 45 08             	mov    0x8(%ebp),%eax
   112d2:	66 c7 40 38 00 00    	movw   $0x0,0x38(%eax)
    
  /*
   * Limit to 16 targets just in case.  The 2842 for one is known to
   * blow the max_targets setting, future cards might also.
   */
egcs-20000221----------------------------------------------------------
{
	int d0, d1, d2;
	switch (n % 4) {
		case 0: COMMON(""); return to;
   11a1e:	b9 10 00 00 00       	mov    $0x10,%ecx
   11a23:	81 c7 1e 03 00 00    	add    $0x31e,%edi
   11a29:	8b b5 e0 fe ff ff    	mov    0xfffffee0(%ebp),%esi
   11a2f:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
      }
    }
#if 0 /*ambiguous?*/
    p->sc = *sc;
#else
    memcpy(&p->sc, sc, sizeof(*sc));
#endif
  }
  p->discenable = 0;
   11a31:	8b 45 08             	mov    0x8(%ebp),%eax
    
  /*
   * Limit to 16 targets just in case.  The 2842 for one is known to
   * blow the max_targets setting, future cards might also.
   */
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/