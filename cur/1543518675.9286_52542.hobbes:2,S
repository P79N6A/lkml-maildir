Date: Fri, 10 Dec 1999 12:03:11 +0200 (EET)
From: Julian Anastasov <>
Subject: Shared memory region > 1.4GB for 2.2.13+ (2GB x86)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/12/10/26

	Hi,
	This is a patch to allow shared memory region > 1.4GB
on 2GB x86 Linux 2.2.13+, i.e. near 1.9GB.
	It can be activated using:
echo 195887104 > /proc/sys/kernel/task_unmapped_base
	By this way the shared libs are mapped before the 192MB
virtual address and the shared memory region can be mapped from
0x0C000000 to 0x80000000.
	The patch allows this address (TASK_UNMAPPED_BASE) to be changed
but it can hurt the other processes. So, it must be used carefully (for DB
servers)
	I know that this patch is for x86 only. May be there are
other platforms that can benefit from this sysctl.
	The applications which use brk()/sbrk() can allocate more memory
using this patch (> 700MB).
	It is dangerous to set task_unmapped_base near the 2/3 TASK_SIZE
where the elf loader is mapped, i.e. don't go after 1.3GB on 2GB support.
May be we can restrict this providing another value for
max_task_unmapped_base?
	I don't expect this patch to be included in the 2.2
kernel, may be it doesn't look very good but it can be very useful :)
Regards,
Julian Anastasov
--- linux/include/linux/sysctl.h.orig	Mon Dec  6 14:39:00 1999
+++ linux/include/linux/sysctl.h	Mon Dec  6 14:56:21 1999
@@ -104,7 +104,8 @@
 	KERN_MSGMNB=36,         /* int: Maximum message queue size */
 	KERN_MSGPOOL=37,         /* int: Maximum system message pool size */
 	KERN_SYSRQ=38,		/* int: Sysreq enable */
-	KERN_SHMALL=41		/* int: maximum size of shared memory */
+	KERN_SHMALL=41,		/* int: maximum size of shared memory */
+	KERN_TASK_UNMAPPED_BASE=42
 };
 
 
--- linux/kernel/sysctl.c.orig	Mon Dec  6 14:39:00 1999
+++ linux/kernel/sysctl.c	Mon Dec  6 14:55:40 1999
@@ -51,6 +51,12 @@
 extern int shmall_max;
 #endif
 
+#if defined(CONFIG_2GB) || defined(CONFIG_3GB)
+extern int min_task_unmapped_base;
+extern int cur_task_unmapped_base;
+extern int max_task_unmapped_base;
+#endif
+
 #ifdef __sparc__
 extern char reboot_command [];
 #endif
@@ -221,6 +227,11 @@
 	{KERN_SHMALL, "shmall", &shmall, sizeof (int),
 	 0644, NULL, &proc_dointvec_minmax, &sysctl_intvec,
 	 NULL, &zero_value, &shmall_max},
+#endif
+#if defined(CONFIG_2GB) || defined(CONFIG_3GB)
+{KERN_TASK_UNMAPPED_BASE, "task_unmapped_base", &cur_task_unmapped_base, sizeof (int),
+	0644, NULL, &proc_dointvec_minmax, &sysctl_intvec,
+	NULL, &min_task_unmapped_base, &max_task_unmapped_base},
 #endif
 #ifdef CONFIG_MAGIC_SYSRQ
 	{KERN_SYSRQ, "sysrq", &sysrq_enabled, sizeof (int),
--- linux/mm/mmap.c.orig	Mon Dec  6 14:39:01 1999
+++ linux/mm/mmap.c	Mon Dec  6 15:02:53 1999
@@ -41,6 +41,12 @@
 
 int sysctl_overcommit_memory;
 
+#if defined(CONFIG_2GB) || defined(CONFIG_3GB)
+int min_task_unmapped_base = 0x04000000;
+int cur_task_unmapped_base = TASK_UNMAPPED_BASE;
+int max_task_unmapped_base = (TASK_SIZE - 0x00400000);
+#endif
+
 /* Check that a process has enough memory to allocate a
  * new virtual mapping.
  */
@@ -362,7 +368,11 @@
 	if (len > TASK_SIZE)
 		return 0;
 	if (!addr)
+#if defined(CONFIG_2GB) || defined(CONFIG_3GB)
+		addr = (unsigned long) cur_task_unmapped_base;
+#else
 		addr = TASK_UNMAPPED_BASE;
+#endif
 	addr = PAGE_ALIGN(addr);
 
 	for (vmm = find_vma(current->mm, addr); ; vmm = vmm->vm_next) {