Date: Tue, 8 Aug 2000 13:15:28 +0200
From: Jakub Jelinek <>
Subject: [PATCH] Patch to build test6-pre8 with gcc 2.96
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/8/8/59

Hi!
gcc 2.96 purposedly does not inline some memcpy/memset calls if it does not
consider it to be a win (usually happens with -march=i686 and large constant
size copies). This patch tries to replace a few implicit memcpy's/memset's
with explicit ones plus adds an export for non-versioned memcpy/memset to
cover the cases where the implicit memcpy cannot be removed (e.g. isdn has
big structure which is passed by value to another function, which generates
an implicit memcpy not inlined on -march=i686) - this is what Richard
Henderson has been proposing for a while. Module writes who do not want to
use the out-of-line memcpy can look at the symbols imported by their modules
and add explicit memcpy's/memset's to get rid of them.
This patch also exports to other symbols, empty_zero_page is needed on
3level pagetable ia32 boxes because pgd_none, which is used by several
modules, references it. vt_cons is needed by some video modules.
--- linux/drivers/net/eth16i.c.jj	Mon Jun 19 22:30:58 2000
+++ linux/drivers/net/eth16i.c	Tue Aug  8 11:38:34 2000
@@ -663,7 +663,7 @@ static int eth16i_probe_port(int ioaddr)
 {
 	int i;
 	int retcode;
-	unsigned char dummy_packet[64] = { 0 };
+	unsigned char dummy_packet[64];
 
 	/* Powerup the chip */
 	outb(0xc0 | POWERUP, ioaddr + CONFIG_REG_1);
@@ -679,6 +679,7 @@ static int eth16i_probe_port(int ioaddr)
 
 	dummy_packet[12] = 0x00;
 	dummy_packet[13] = 0x04;
+	memset(dummy_packet + 14, 0, sizeof(dummy_packet) - 14);
 
 	eth16i_select_regbank(2, ioaddr);
 
--- linux/drivers/char/console.c.jj	Wed Jul 19 00:57:28 2000
+++ linux/drivers/char/console.c	Tue Aug  8 11:38:34 2000
@@ -2940,7 +2940,9 @@ EXPORT_SYMBOL(video_scan_lines);
 EXPORT_SYMBOL(vc_resize);
 EXPORT_SYMBOL(fg_console);
 EXPORT_SYMBOL(console_blank_hook);
-
+#ifdef CONFIG_VT
+EXPORT_SYMBOL(vt_cons);
+#endif
 #ifndef VT_SINGLE_DRIVER
 EXPORT_SYMBOL(take_over_console);
 EXPORT_SYMBOL(give_up_console);
--- linux/drivers/isdn/hisax/callc.c.jj	Tue Aug  8 11:24:10 2000
+++ linux/drivers/isdn/hisax/callc.c	Tue Aug  8 11:38:34 2000
@@ -366,7 +366,7 @@ lli_deliver_call(struct FsmInst *fi, int
 		 * No need to return "unknown" for calls without OAD,
 		 * cause that's handled in linklevel now (replaced by '0')
 		 */
-		ic.parm.setup = chanp->proc->para.setup;
+		memcpy (&ic.parm.setup, &chanp->proc->para.setup, sizeof(ic.parm.setup));
 		ret = chanp->cs->iif.statcallb(&ic);
 		if (chanp->debug & 1)
 			link_debug(chanp, 1, "statcallb ret=%d", ret);
@@ -383,7 +383,7 @@ lli_deliver_call(struct FsmInst *fi, int
 				FsmChangeState(fi, ST_IN_PROCEED_SEND);
 				chanp->d_st->lli.l4l3(chanp->d_st, CC_PROCEED_SEND | REQUEST, chanp->proc);
 				if (ret == 5) {
-					chanp->setup = ic.parm.setup;
+					memcpy (&chanp->setup, &ic.parm.setup, sizeof(chanp->setup));
 					chanp->d_st->lli.l4l3(chanp->d_st, CC_REDIR | REQUEST, chanp->proc);
 				}
 				break;
@@ -1506,7 +1506,7 @@ HiSax_command(isdn_ctrl * ic)
 				link_debug(chanp, 1, "DIAL %s -> %s (%d,%d)",
 					ic->parm.setup.eazmsn, ic->parm.setup.phone,
 					ic->parm.setup.si1, ic->parm.setup.si2);
-			chanp->setup = ic->parm.setup;
+			memcpy (&chanp->setup, &ic->parm.setup, sizeof (chanp->setup));
 			if (!strcmp(chanp->setup.eazmsn, "0"))
 				chanp->setup.eazmsn[0] = '\0';
 			/* this solution is dirty and may be change, if
@@ -1722,7 +1722,7 @@ HiSax_command(isdn_ctrl * ic)
 			chanp = csta->channel + ic->arg;
 			if (chanp->debug & 1)
 				link_debug(chanp, 1, "REDIR");
-			chanp->setup = ic->parm.setup;
+			memcpy (&chanp->setup, &ic->parm.setup, sizeof(chanp->setup));
 			FsmEvent(&chanp->fi, EV_REDIR, NULL);
 			break;
 
--- linux/drivers/isdn/hisax/l3dss1.c.jj	Tue Aug  8 11:24:10 2000
+++ linux/drivers/isdn/hisax/l3dss1.c	Tue Aug  8 11:38:34 2000
@@ -3081,7 +3081,7 @@ dss1down(struct PStack *st, int pr, void
 		if ((proc = dss1_new_l3_process(st, cr))) {
 			proc->chan = chan;
 			chan->proc = proc;
-			proc->para.setup = chan->setup;
+			memcpy (&proc->para.setup, &chan->setup, sizeof (chan->setup));
 			proc->callref = cr;
 		}
 	} else {
--- linux/drivers/isdn/hisax/l3_1tr6.c.jj	Tue Aug  8 11:24:10 2000
+++ linux/drivers/isdn/hisax/l3_1tr6.c	Tue Aug  8 11:38:34 2000
@@ -883,7 +883,7 @@ down1tr6(struct PStack *st, int pr, void
 		} else {
 			proc->chan = chan;
 			chan->proc = proc;
-			proc->para.setup = chan->setup;
+			memcpy (&proc->para.setup, &chan->setup, sizeof (chan->setup));
 			proc->callref = cr;
 		}
 	} else {
--- linux/arch/i386/lib/Makefile.jj	Tue Jul 18 23:55:01 2000
+++ linux/arch/i386/lib/Makefile	Tue Aug  8 11:38:34 2000
@@ -7,7 +7,8 @@
 
 L_TARGET = lib.a
 L_OBJS  = checksum.o old-checksum.o delay.o \
-	usercopy.o getuser.o putuser.o iodebug.o
+	usercopy.o getuser.o putuser.o iodebug.o \
+	memcpy.o
 
 ifdef CONFIG_X86_USE_3DNOW
 L_OBJS += mmx.o
--- linux/arch/i386/lib/memcpy.c.jj	Tue Aug  8 11:38:34 2000
+++ linux/arch/i386/lib/memcpy.c	Tue Aug  8 11:38:34 2000
@@ -0,0 +1,19 @@
+#include <linux/config.h>
+#include <linux/string.h>
+
+#undef memcpy
+#undef memset
+
+void * memcpy(void * to, const void * from, size_t n)
+{
+#ifdef CONFIG_X86_USE_3DNOW
+	return __memcpy3d(to, from, n);
+#else
+	return __memcpy(to, from, n);
+#endif
+}
+
+void * memset(void * s, char c, size_t count)
+{
+	return __memset(s, c, count);
+}
--- linux/arch/i386/kernel/i386_ksyms.c.jj	Tue Aug  8 11:24:08 2000
+++ linux/arch/i386/kernel/i386_ksyms.c	Tue Aug  8 11:38:34 2000
@@ -12,6 +12,7 @@
 #include <linux/pci.h>
 #include <linux/apm_bios.h>
 #include <linux/kernel.h>
+#include <linux/string.h>
 
 #include <asm/semaphore.h>
 #include <asm/processor.h>
@@ -24,6 +25,7 @@
 #include <asm/irq.h>
 #include <asm/mmx.h>
 #include <asm/desc.h>
+#include <asm/pgtable.h>
 
 extern void dump_thread(struct pt_regs *, struct user *);
 extern spinlock_t rtc_lock;
@@ -142,3 +144,14 @@ EXPORT_SYMBOL(screen_info);
 EXPORT_SYMBOL(get_wchan);
 
 EXPORT_SYMBOL(rtc_lock);
+
+#undef memcpy
+#undef memset
+extern void * memcpy(void * to, const void * from, size_t n);
+extern void * memset(void * s, char c, size_t count);
+EXPORT_SYMBOL_NOVERS(memcpy);
+EXPORT_SYMBOL_NOVERS(memset);
+
+#ifdef CONFIG_X86_PAE
+EXPORT_SYMBOL(empty_zero_page);
+#endif
	Jakub
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/