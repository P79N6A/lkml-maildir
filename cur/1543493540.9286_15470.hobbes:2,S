Date: Wed, 21 Apr 1999 20:48:10 -0400
From: Jim Zelenka <>
Subject: Porting questions
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/4/21/122

I'm porting an embedded system into the linux kernel, and I
have a few questions. My apologies if these have been
covered before, but I searched archives of this mailing list
and perused the code and was unable to determine the
correct answers.
1. What is the correct way to do a generic thread yield? I
tried using sched_yield() via the __KERNEL_SYSCALLS__ interface,
but that blew up (kernel accessed a bad address). I tried
calling schedule(), but that similarly died with a kernel NULL
pointer dereference.
2. I need to do block I/O, both synchronously and asynchronously.
I'd like to do so with as little overhead as possible. My reading
of the code suggested that I could assemble a struct buffer_head
that described my request and issue that to ll_rw_block(), but
that failed complaining that my request must be exactly 1k long.
Most of my requests will be 8k, with some 512-byte requests. All
of these requests will be to a disk, and they will be sector-aligned.
3. What is the right way to determine the number of blocks in
a block device? Currently I cheat by issuing a BLKGETSIZE
ioctl via the __KERNEL_SYSCALLS__ interface.
If it matters, I'm developing for currently developing for a
2.2.3 kernel, and I'm not concerned about supporting older
kernels.
Any help or pointers will be greatly appreciated.
-Jim.Zelenka@cs.cmu.edu
Senior Research Programmer
CMU/SCS Parallel Data Lab
http://www.pdl.cs.cmu.edu/PEOPLE/jimz.html
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/