Date: Thu, 10 Feb 2000 21:16:25 -0500
From:  willy@thepuffi ...
Subject: [FIX] rd.c (was Re: Linux Status For 2.3.x: v 2.3.43)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/2/11/11

On Thu, Feb 10, 2000 at 10:05:11PM +0000, Alan Cox wrote:
> initrd is bust
Here's what we're using in linux/parisc.  It seems to work.  I dislike the
way we're constructing a dentry and a file, but at least we're no longer
constructing our own inode.  Credit should also go to Thomas Bogendorfer
who also worked on this fix.
--- linux/drivers/block/rd.c	Tue Jan 18 21:54:21 2000
+++ cvs/linux-2.3/drivers/block/rd.c	Thu Feb 10 11:43:45 2000
@@ -368,6 +368,7 @@
 	if (DEVICE_NR(inode->i_rdev) >= NUM_RAMDISKS)
 		return -ENXIO;
 
+	filp->f_op = &def_blk_fops;
 	MOD_INC_USE_COUNT;
 
 	return 0;
@@ -566,7 +567,7 @@
  */
 static void __init rd_load_image(kdev_t device, int offset, int unit)
 {
- 	struct inode inode, out_inode;
+ 	struct inode *inode, *out_inode;
 	struct file infile, outfile;
 	struct dentry in_dentry, out_dentry;
 	mm_segment_t fs;
@@ -580,25 +581,27 @@
 	ram_device = MKDEV(MAJOR_NR, unit);
 
 	memset(&infile, 0, sizeof(infile));
-	memset(&inode, 0, sizeof(inode));
 	memset(&in_dentry, 0, sizeof(in_dentry));
-	inode.i_rdev = device;
-	init_waitqueue_head(&inode.i_wait);
+	inode = get_empty_inode();
+	inode->i_rdev = device;
+	inode->i_bdev = bdget(kdev_t_to_nr(device));
 	infile.f_mode = 1; /* read only */
 	infile.f_dentry = &in_dentry;
-	in_dentry.d_inode = &inode;
+	in_dentry.d_inode = inode;
 
 	memset(&outfile, 0, sizeof(outfile));
-	memset(&out_inode, 0, sizeof(out_inode));
 	memset(&out_dentry, 0, sizeof(out_dentry));
-	out_inode.i_rdev = ram_device;
-	init_waitqueue_head(&out_inode.i_wait);
+	out_inode = get_empty_inode();
+	out_inode->i_rdev = ram_device;
+	out_inode->i_bdev = bdget(kdev_t_to_nr(ram_device));
 	outfile.f_mode = 3; /* read/write */
 	outfile.f_dentry = &out_dentry;
-	out_dentry.d_inode = &out_inode;
+	out_dentry.d_inode = out_inode;
 
-	if (blkdev_open(&inode, &infile) != 0) return;
-	if (blkdev_open(&out_inode, &outfile) != 0) return;
+	if (blkdev_open(inode, &infile) != 0)
+		goto free_inodes;
+	if (blkdev_open(out_inode, &outfile) != 0)
+		goto free_inodes;
 
 	fs = get_fs();
 	set_fs(KERNEL_DS);
@@ -661,10 +664,10 @@
 			rotate = 0;
 			invalidate_buffers(device);
 			if (infile.f_op->release)
-				infile.f_op->release(&inode, &infile);
+				infile.f_op->release(inode, &infile);
 			printk("Please insert disk #%d and press ENTER\n", i/devblocks+1);
 			wait_for_keypress();
-			if (blkdev_open(&inode, &infile) != 0)  {
+			if (blkdev_open(inode, &infile) != 0)  {
 				printk("Error opening disk.\n");
 				goto done;
 			}
@@ -687,8 +690,11 @@
 
 done:
 	if (infile.f_op->release)
-		infile.f_op->release(&inode, &infile);
+		infile.f_op->release(inode, &infile);
 	set_fs(fs);
+free_inodes:
+	iput(inode);
+	iput(out_inode);
 }
 
 
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/