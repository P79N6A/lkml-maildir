Date: Wed, 29 Aug 2001 11:03:10 +0200
From: Helge Hafting <>
Subject: Re: [IDEA+RFC] Possible solution for min()/max() war
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2001/8/29/26

Brad Chapman wrote:
> 
> Mr. Schwab,
> 
[...]
> > There is no such thing as signed/unsigned comparision in C.  Any
> > comparison is either signed or unsigned, depending on whether the common
> > type of arguments after applying the usual arithmetic conversions is
> > signed or unsigned.
> 
>         Then why, IIRC, are the kernel hackers so upset about how the three-arg
> macros _prevent_ signed/unsigned comparisons? Apparently the ability to compare
> signed/unsigned variables must have _some_ significance....
You are misunderstanding this.
It is possible to write something that _looks like_ a signed to unsigned
comparison, i.e.:
int a;
unsigned int b;
...
x = min(a,b);
Looks like a signed to unsigned comparison - but it isn't!
You see, the compiler always does an _implicit_ cast in cases like this.
So the actual code generated by the compiler might become a signed to
signed
comparison, or a unsigned to unsigned comparison.  
One of the arguments gets changed invisibly, and that is what kernel
developers
are so upset about.  You don't really know which one without thinking
hard
about it, and that is a source of many hard-to-find bugs.
A min function with a single type argument force you to select a type,
instead of blindly let the compiler choose one or the other.
Your two-type min has exactly the same problem as the no-type min:
You can specify two different types, but the compiler will then
force it to be only one anyway.  And you may wonder which of the two
it will choose.  And there will be bugs as people assumed signed
when it turned out to be unsigned.
The single-type min let you specify exactly which type will be used
in the comparison.  You may use the type of one of the arguments,
or something different from both.  The type you select will be
the one used anyway, there is no room for doubt or false assumptions.
> 
> >
> > |>    Thus, I have a humble idea: add another type argument!
> >
> > This does not bye you anything because the there can only be one common
> > type anyway.
> 
>         IDGT. What if you don't want a common type? What if you explicitly
> _want_ to cast signed "up" to unsigned or unsigned "down" to signed?
What you ask for is impossible.  You can write code that looks like
it is comparing different types, but that won't actually happen.
The cpu always compares two quantities of the same type, no matter
what you write.  The compiler will force a single type anyway, so
it is nice to state explicit what that single type will be.
Stating two types buys you nothing, as the compiler will
force a single one again.  I don't even know about a cpu that
will do signed to unigned compares - this is why the compiler
works that way.  Common cpu's only do two
kindes of comparisons - signed to signed, and unigned to
unsigned.  Which one depends on which comparison instruction
the compiler inserts.  
A variable don't really have a type on common cpu's.  
That's just a programming language convention.
The machine instructions are typed though, and the single-typed min()
in the kernel mirrors this.
Helge Hafting
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/