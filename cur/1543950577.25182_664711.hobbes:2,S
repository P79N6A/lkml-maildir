Date: Thu, 6 Mar 2008 15:24:15 -0800
From: Andrew Morton <>
Subject: Re: 2.6.25-rc3-git3: Reported regressions from 2.6.24
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/3/6/440

On Thu, 6 Mar 2008 15:13:31 -0800
Suresh Siddha <suresh.b.siddha@intel.com> wrote:
> > sd 1:0:0:0: [sdb] Stopping disk
> > sd 0:0:0:0: [sda] Synchronizing SCSI cache
> > sd 0:0:0:0: [sda] Stopping disk
> > ACPI: PCI interrupt for device 0000:05:00.1 disabled
> > ACPI: PCI interrupt for device 0000:05:00.0 disabled
> > ACPI: Preparing to enter system sleep state S5
> > Disabling non-boot CPUs ...
> > CPU 1 is now offline
> > SysRq : Show State
> >   task                        PC stack   pid father
> 
> I have been looking into a similar issue, which stops my system going into
> standy.
OK.
> > 
> > So CPU 1 is offline.  But the comatose watchdog thread is pinned to CPU 1. 
> > Could this be related to the problem?  By what means is a task which is
> > pinned to a going-away CPU handled?  How is this guy supposed to ever run
> > again?
> 
> move_task_off_dead_cpu() should move that thread to another online cpu. But
> for some reason it isn't running.
hm.  What guarantees that kernel/sched.c:migration_call(CPU_DEAD) is called
before kernel/softlockup.c:cpu_callback(CPU_DEAD)?  Just the ordering in
do_pre_smp_initcalls(), and notifier-chain behaviour, I guess.