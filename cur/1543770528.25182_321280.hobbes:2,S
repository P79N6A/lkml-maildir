Date: Fri, 27 May 2005 21:38:36 -0400
From: Steven Rostedt <>
Subject: Re: disowning a process
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/5/27/274

On Fri, 2005-05-27 at 18:34 -0500, Davy Durham wrote:
> Well, when I tried using it in a program with some sleeps to test.. I 
> noticed that the intermediate process that daemon creates is not cleaned 
> up with a wait() call (so I see a defunct process in the ps listing).
You didn't use it right. See below.
> 
> If I manually do the double fork() then I can call waitpid() myself for 
> the pid that I know it spawned.   But if I just call wait() after 
> calling daemon, then I don't know if I just cleaned up the pid it 
> spawned (do I?), or some other previously spawned one (for perhaps 
> totally different reasons)..
You still need to fork the first child, and the daemon does the second
fork and exits the parent, and does all the necessary things for the
system to make a proper daemon.
> 
> For my specifics it may not be a problem, but I guess I'm just whining 
> about the fact that daemon() doesn't clean it up itself (or can it?)
Attached is a simple C program that uses daemon the way you want to.
-- Steve
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
int main (int argc, char **argv)
{
	pid_t pid;
	if ((pid = fork()) < 0) {
		perror("fork");
	} else if (!pid) {
		if (daemon(1,1) < 0) {
			perror("daemon");
			exit(-1);
		}
		printf("daemon is %d\n",getpid());
		sleep(100);
		exit(0);
	}
	printf("middle child is %d (and died)\n",pid);
	waitpid(pid,NULL,0);
	printf("parent is %d\n",getpid());
	sleep(100);
	return 0;
}