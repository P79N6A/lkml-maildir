Date: Sat, 7 Dec 2002 14:35:23 +0100
From: Marc-Christian Petersen <>
Subject: [BUG] 2.4.20-BK
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2002/12/7/32

Hi Alan,
using 2.4.20-BK tree gives me:
flushing ide devices: hda hdd
at reboot time in an endless loop drawing over the screen. No reboot will be 
made, I have to do that either by sysrq-b or reset button.
Using:
[*]   PCI IDE chipset support
[*]     Generic PCI bus-master DMA support
[*]       Use PCI DMA by default when available
<*>     Intel PIIXn chipsets support
[*]   IGNORE word93 Validation BITS
root@codeman:[/] # hdparm -i /dev/hda
/dev/hda:
 Model=MAXTOR 6L060J3, FwRev=A93.0500, SerialNo=663219752652
 Config={ HardSect NotMFM HdSw>15uSec Fixed DTR>10Mbs }
 RawCHS=16383/16/63, TrkSize=32256, SectSize=21298, ECCbytes=4
 BuffType=DualPortCache, BuffSize=1819kB, MaxMultSect=16, MultSect=16
 CurCHS=4047/16/255, CurSects=16511760, LBA=yes, LBAsects=117266688
 IORDY=on/off, tPIO={min:120,w/IORDY:120}, tDMA={min:120,rec:120}
 PIO modes:  pio0 pio1 pio2 pio3 pio4 
 DMA modes:  mdma0 mdma1 mdma2 
 UDMA modes: udma0 udma1 udma2 udma3 udma4 *udma5 udma6 
 AdvancedPM=no WriteCache=enabled
 Drive conforms to: ATA/ATAPI-5 T13 1321D revision 1:  1 2 3 4 5
BTW: The attached patch is needed to build the 2.4.20-BK tree successfully
     because "local_irq_*" is missing and ld complains about undefined
     reference at linking time.
Any hints to fix that flushing ide bla foobar thing?
TIA!
ciao, Marcdiff -u --new-file --recursive --exclude-from /usr/src/exclude linux.vanilla/include/asm-i386/system.h linux.20-ac1/include/asm-i386/system.h
--- linux.vanilla/include/asm-i386/system.h	2002-11-29 21:27:23.000000000 +0000
+++ linux.20-ac1/include/asm-i386/system.h	2002-11-11 15:59:38.000000000 +0000
@@ -322,8 +319,18 @@
 /* used in the idle loop; sti takes one instruction cycle to complete */
 #define safe_halt()		__asm__ __volatile__("sti; hlt": : :"memory")
 
+#define __save_and_cli(x)	do { __save_flags(x); __cli(); } while(0);
+#define __save_and_sti(x)	do { __save_flags(x); __sti(); } while(0);
+
 /* For spinlocks etc */
+#if 0
 #define local_irq_save(x)	__asm__ __volatile__("pushfl ; popl %0 ; cli":"=g" (x): /* no input */ :"memory")
+#define local_irq_set(x)	__asm__ __volatile__("pushfl ; popl %0 ; sti":"=g" (x): /* no input */ :"memory")
+#else
+#define local_irq_save(x)	__save_and_cli(x)
+#define local_irq_set(x)	__save_and_sti(x)
+#endif
+
 #define local_irq_restore(x)	__restore_flags(x)
 #define local_irq_disable()	__cli()
 #define local_irq_enable()	__sti()
@@ -338,6 +345,8 @@
 #define sti() __global_sti()
 #define save_flags(x) ((x)=__global_save_flags())
 #define restore_flags(x) __global_restore_flags(x)
+#define save_and_cli(x) do { save_flags(x); cli(); } while(0);
+#define save_and_sti(x) do { save_flags(x); sti(); } while(0);
 
 #else
 
@@ -345,6 +354,8 @@
 #define sti() __sti()
 #define save_flags(x) __save_flags(x)
 #define restore_flags(x) __restore_flags(x)
+#define save_and_cli(x) __save_and_cli(x)
+#define save_and_sti(x) __save_and_sti(x)
 
 #endif
 