Date: Mon, 2 Feb 2009 12:12:31 +0000 (GMT)
From: Hugh Dickins <>
Subject: Re: 2.6.29-rc libata sff 32bit PIO regression
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2009/2/2/86

On Mon, 2 Feb 2009, Sergei Shtylyov wrote:
> Hugh Dickins wrote:
> > But this patch works as well for me as the patch I posted before
> > (though much more verbose: please simplify if you see a better way).
> 
>   How about the following?
> 
> 		unsigned char *tail = buf + buflen - slop;
> 		unsigned char pad[4];
> 
> 		if (rw == READ) {
> 			if (slop <= 2)
> 				ioread16_rep(data_addr, pad, 1);
> 			else
> 				ioread32_rep(data_addr, pad, 1);
> 					memcpy(tail, pad, slop);
Too many tabs on the memcpy.
> 		} else {
> 			memcpy(pad, tail, slop);
> 			memset(pad + slop, 0, 4 - slop);
And we could make that line even more complicated!
But I think unsigned char pad[4] = {0, 0, 0, 0} would be better.
Though Alan didn't have it initialized at all: I don't know if
that was oversight or superior knowledge.  In Alan's case, one
should usually assume the latter.
> 			if (slop <= 2)
> 				iowrite16_rep(data_addr, pad, 1);
> 			else
> 				iowrite32_rep(data_addr, pad, 1);
> 		}
Well, I don't know.  I felt really pleased with using ioread16_rep
and the char array in my original patch, where slop might be 1 or 2
or 3; but once it comes down to always one single PIO op, I felt
it too lazy to be using the _rep form.
I really don't care, whatever works and best satisfies Alan.
> > -	return words << 2;
> > +
> > +	return buflen + (buflen & 1);
> >   
> 
>    return (buflen + 1) & ~1;
> 
>   Well, I guess I could just have posted my own patch... :-)
Yes, do go ahead, I'm not desperate to get my name in there!
Hugh