Date: Fri, 9 Jul 2004 14:53:53 -0400 (EDT)
From: Pavel Roskin <>
Subject: [PATCH] Updated pci-skeleton.c
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2004/7/9/142

On Thu, 8 Jul 2004, Jeff Garzik wrote:
> Pavel Roskin wrote:
>> drivers/net/pci-skeleton.c doesn't have power management code, but the 
>> driver it was based on, 8139too.c, has such code and uses 
>> pci_set_power_state() after pci_(save|restore)_state().  Other well 
>> maintained drivers (e.g. e100.c) use pci_set_power_state() after 
>> pci_save_state() and before pci_restore_state().  I think it's reasonable 
>> to follow this example.  Jeff?
>
>
> Yeah, that's working code.  Feel free to cut-n-paste, and/or even update 
> pci-skeleton.c :)
Here it is.  The patch fixes all compile errors and warnings in 
pci-skeleton.c.  The "debug" parameter lacks corresponding variable, so I 
removed it to avoid a warning on module load.  Obsolete pci_power_on() and 
pci_power_off() have been replaced with the new code using 
pci_set_power_state(), pci_save_state() and pci_restore_state().  The 
driver has been tested by compiling it as module and as part of the 
kernel.
-- 
Regards,
Pavel Roskin--- linux.orig/drivers/net/pci-skeleton.c
+++ linux/drivers/net/pci-skeleton.c
@@ -481,6 +481,7 @@ struct netdrv_private {
 	unsigned int mediasense:1;	/* Media sensing in progress. */
 	spinlock_t lock;
 	chip_t chipset;
+	u32 pci_state[16];	/* Data saved during suspend */
 };
 
 MODULE_AUTHOR ("Jeff Garzik <jgarzik@pobox.com>");
@@ -488,12 +489,10 @@ MODULE_DESCRIPTION ("Skeleton for a PCI 
 MODULE_LICENSE("GPL");
 MODULE_PARM (multicast_filter_limit, "i");
 MODULE_PARM (max_interrupt_work, "i");
-MODULE_PARM (debug, "i");
 MODULE_PARM (media, "1-" __MODULE_STRING(8) "i");
 MODULE_PARM_DESC (multicast_filter_limit, "pci-skeleton maximum number of filtered multicast addresses");
 MODULE_PARM_DESC (max_interrupt_work, "pci-skeleton maximum events handled per interrupt");
 MODULE_PARM_DESC (media, "pci-skeleton: Bits 0-3: media type, bit 17: full duplex");
-MODULE_PARM_DESC (debug, "(unused)");
 
 static int read_eeprom (void *ioaddr, int location, int addr_len);
 static int netdrv_open (struct net_device *dev);
@@ -588,7 +587,6 @@ static int __devinit netdrv_init_board (
 	void *ioaddr = NULL;
 	struct net_device *dev;
 	struct netdrv_private *tp;
-	u8 tmp8;
 	int rc, i;
 	u32 pio_start, pio_end, pio_flags, pio_len;
 	unsigned long mmio_start, mmio_end, mmio_flags, mmio_len;
@@ -744,7 +742,6 @@ static int __devinit netdrv_init_one (st
 	int i, addr_len, option;
 	void *ioaddr = NULL;
 	static int board_idx = -1;
-	u8 tmp;
 
 /* when built into the kernel, we only print version if device is found */
 #ifndef MODULE
@@ -868,7 +865,7 @@ static void __devexit netdrv_remove_one 
 
 	pci_set_drvdata (pdev, NULL);
 
-	pci_power_off (pdev, -1);
+	pci_disable_device (pdev);
 
 	DPRINTK ("EXIT\n");
 }
@@ -1136,7 +1133,6 @@ static void netdrv_hw_start (struct net_
 	struct netdrv_private *tp = dev->priv;
 	void *ioaddr = tp->mmio_addr;
 	u32 i;
-	u8 tmp;
 
 	DPRINTK ("ENTER\n");
 
@@ -1875,9 +1871,11 @@ static void netdrv_set_rx_mode (struct n
 		rx_mode = AcceptBroadcast | AcceptMulticast | AcceptMyPhys;
 		mc_filter[1] = mc_filter[0] = 0;
 		for (i = 0, mclist = dev->mc_list; mclist && i < dev->mc_count;
-		     i++, mclist = mclist->next)
-			set_bit (ether_crc (ETH_ALEN, mclist->dmi_addr) >> 26,
-				 mc_filter);
+		     i++, mclist = mclist->next) {
+			int bit_nr = ether_crc(ETH_ALEN, mclist->dmi_addr) >> 26;
+
+			mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+		}
 	}
 
 	/* if called from irq handler, lock already acquired */
@@ -1908,7 +1906,7 @@ static int netdrv_suspend (struct pci_de
 	unsigned long flags;
 
 	if (!netif_running(dev))
-		return;
+		return 0;
 	netif_device_detach (dev);
 
 	spin_lock_irqsave (&tp->lock, flags);
@@ -1923,7 +1921,8 @@ static int netdrv_suspend (struct pci_de
 
 	spin_unlock_irqrestore (&tp->lock, flags);
 
-	pci_power_off (pdev, -1);
+	pci_save_state (pdev, tp->pci_state);
+	pci_set_power_state (pdev, 3);
 
 	return 0;
 }
@@ -1932,10 +1931,12 @@ static int netdrv_suspend (struct pci_de
 static int netdrv_resume (struct pci_dev *pdev)
 {
 	struct net_device *dev = pci_get_drvdata (pdev);
+	struct netdrv_private *tp = dev->priv;
 
 	if (!netif_running(dev))
-		return;
-	pci_power_on (pdev);
+		return 0;
+	pci_set_power_state (pdev, 0);
+	pci_restore_state (pdev, tp->pci_state);
 	netif_device_attach (dev);
 	netdrv_hw_start (dev);
 