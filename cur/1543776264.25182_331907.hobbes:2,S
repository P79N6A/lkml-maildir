Date: Thu, 7 Jul 2005 10:56:29 -0400 (EDT)
From: Steven Rostedt <>
Subject: Re: Real-Time Preemption, -RT-2.6.12-final-V0.7.50-45
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/7/7/174

Hi Ingo,
I've just downloaded 51-09 and tried running it here on a normal intel
pentium4 box here at my customers site.  It included some hotplug PCI
modules (I don't know why since it's doesn't have hotplug devices) and I
got some init_MUTEX_LOCKED bugs on them.  Below you will find the patch (I
assume that compat_semaphore is still used).
Anyway, I also want to let you know that the e100 does not work.  It's
detected, but it wont bring up DHCP, and when I manually configued it, it
just froze (the process not the machine). But when I did a sysrq-t, the
machine froze up after it completed with some RT yeilding bug. Here's what
was last to spit out:
NETDEV WATCHDOG: eth0: transmit timed out
BUG: events/0:10 RT task yield()-ing!
 [<c01042ef>] dump_stack+0x1f/0x30 (20)
 [<c02e8b1a>] yield+0x5a/0x60 (20)
 [<c029bec5>] dev_deactivate+0x65/0x70 (20)
 [<c0296ae8>] linkwatch_run_queue+0xf8/0x110 (40)
 [<c0296b31>] linkwatch_event+0x31/0x70 (16)
 [<c013081b>] worker_thread+0x17b/0x230 (124)
 [<c01353de>] kthread+0xae/0xc0 (48)
 [<c0101445>] kernel_thread_helper+0x5/0x10 (814882844)
---------------------------
| preempt count: 00000001 ]
| 1-level deep critical section nesting:
----------------------------------------
.. [<c014007a>] .... add_preempt_count+0x1a/0x20
.....[<c0140fcd>] ..   ( <= print_traces+0x1d/0x60)
------------------------------
| showing all locks held by: |  (events/0/10 [cf6ca030,  98]):
------------------------------
#001:             [c0390684] {rtnl_sem.lock}
... acquired at:  linkwatch_event+0x2c/0x70
This was right after the trace and all else froze. Anyway, I'll debug it
tomorrow since I'm about to go home for the day. And here's the patch for
the hotplug stuff (sorry about the -p0).
Index: drivers/pci/hotplug/ibmphp_hpc.c
===================================================================
--- drivers/pci/hotplug/ibmphp_hpc.c	(revision 237)
+++ drivers/pci/hotplug/ibmphp_hpc.c	(working copy)
@@ -104,7 +104,7 @@
 static struct semaphore sem_hpcaccess;	// lock access to HPC
 static struct semaphore semOperations;	// lock all operations and
 					// access to data structures
-static struct semaphore sem_exit;	// make sure polling thread goes away
+static struct compat_semaphore sem_exit;	// make sure polling thread goes away
 //----------------------------------------------------------------------------
 // local function prototypes
 //----------------------------------------------------------------------------
Index: drivers/pci/hotplug/cpqphp_ctrl.c
===================================================================
--- drivers/pci/hotplug/cpqphp_ctrl.c	(revision 237)
+++ drivers/pci/hotplug/cpqphp_ctrl.c	(working copy)
@@ -45,8 +45,8 @@
 			u8 behind_bridge, struct resource_lists *resources);
 static void interrupt_event_handler(struct controller *ctrl);
-static struct semaphore event_semaphore;	/* mutex for process loop (up if something to process) */
-static struct semaphore event_exit;		/* guard ensure thread has exited before calling it quits */
+static struct compat_semaphore event_semaphore;	/* mutex for process loop (up if something to process) */
+static struct compat_semaphore event_exit;		/* guard ensure thread has exited before calling it quits */
 static int event_finished;
 static unsigned long pushbutton_pending;	/* = 0 */
Index: drivers/pci/hotplug/shpchp_ctrl.c
===================================================================
--- drivers/pci/hotplug/shpchp_ctrl.c	(revision 237)
+++ drivers/pci/hotplug/shpchp_ctrl.c	(working copy)
@@ -47,8 +47,8 @@
 	u8 behind_bridge, struct resource_lists *resources, u8 bridge_bus, u8 bridge_dev);
 static void interrupt_event_handler(struct controller *ctrl);
-static struct semaphore event_semaphore;	/* mutex for process loop (up if something to process) */
-static struct semaphore event_exit;		/* guard ensure thread has exited before calling it quits */
+static struct compat_semaphore event_semaphore;	/* mutex for process loop (up if something to process) */
+static struct compat_semaphore event_exit;		/* guard ensure thread has exited before calling it quits */
 static int event_finished;
 static unsigned long pushbutton_pending;	/* = 0 */
Index: drivers/pci/hotplug/cpci_hotplug_core.c
===================================================================
--- drivers/pci/hotplug/cpci_hotplug_core.c	(revision 237)
+++ drivers/pci/hotplug/cpci_hotplug_core.c	(working copy)
@@ -60,8 +60,8 @@
 static atomic_t extracting;
 int cpci_debug;
 static struct cpci_hp_controller *controller;
-static struct semaphore event_semaphore;	/* mutex for process loop (up if something to process) */
-static struct semaphore thread_exit;		/* guard ensure thread has exited before calling it quits */
+static struct compat_semaphore event_semaphore;	/* mutex for process loop (up if something to process) */
+static struct compat_semaphore thread_exit;		/* guard ensure thread has exited before calling it quits */
 static int thread_finished = 1;
 static int enable_slot(struct hotplug_slot *slot);
Index: drivers/pci/hotplug/pciehp_ctrl.c
===================================================================
--- drivers/pci/hotplug/pciehp_ctrl.c	(revision 237)
+++ drivers/pci/hotplug/pciehp_ctrl.c	(working copy)
@@ -48,8 +48,8 @@
 	u8 behind_bridge, struct resource_lists *resources, u8 bridge_bus, u8 bridge_dev);
 static void interrupt_event_handler(struct controller *ctrl);
-static struct semaphore event_semaphore;	/* mutex for process loop (up if something to process) */
-static struct semaphore event_exit;		/* guard ensure thread has exited before calling it quits */
+static struct compat_semaphore event_semaphore;	/* mutex for process loop (up if something to process) */
+static struct compat_semaphore event_exit;		/* guard ensure thread has exited before calling it quits */
 static int event_finished;
 static unsigned long pushbutton_pending;	/* = 0 */
 static unsigned long surprise_rm_pending;	/* = 0 */
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/