Date: Tue, 15 Jan 2008 22:17:30 -0500
From: Mathieu Desnoyers <>
Subject: Re: [RFC PATCH 16/22 -v2] add get_monotonic_cycles
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/1/15/514

* Steven Rostedt (rostedt@goodmis.org) wrote:
> 
> On Tue, 15 Jan 2008, Mathieu Desnoyers wrote:
> >
> > Ok, but what actually insures that the clock->cycle_* reads won't be
> > reordered across the clocksource_read() ?
> 
> <looks at code>
> 
> Hmm, interesting.I didn't notice that clocksource_read() is a static
> inline.  I was thinking that since it was passing a pointer to a function,
> gcc could not assume that it could move that code across it. But now
> looking to see that clocksource_read is simply a static inline that does:
> 
>   cs->read();
> 
> But still, can gcc assume that it can push loads of unknown origin
> variables across function calls? So something like:
> 
> static int *glob;
> 
> void foo(void) {
> 	int x;
> 
> 	x = *glob;
> 
> 	bar();
> 
> 	if (x != *glob)
> 		/* ... */
> }
> 
> I can't see how any compiler could honestly move the loading of the first
> x after the calling of bar(). With glob pointing to some unknown
> variable, that may be perfectly fine for bar to modify.
> 
> 
> > > >
> > > > > +		cycle_raw = clock->cycle_raw;
> > > > > +		cycle_last = clock->cycle_last;
> > > > > +
> > > > > +		/* read clocksource: */
> > > > > +		cycle_now = clocksource_read(clock);
> 
> So the question here is,can cycle_raw and cycle_last be loaded from
> the unknown source that clock points to after the call to
> clocksource_read()?
> 
>  I'm thinking not.
> 
I agree with you that I don't see how the compiler could reorder this.
So we forget about compiler barriers. Also, the clock source used is a
synchronized clock source (get_cycles_sync on x86_64), so it should make
sure the TSC is read at the right moment.
However, what happens if the clock source is, say, the jiffies ?
Is this case, we have :
static cycle_t jiffies_read(void)
{
        return (cycle_t) jiffies;
}
Which is nothing more than a memory read of 
extern unsigned long volatile __jiffy_data jiffies;
I think it is wrong to assume that reads from clock->cycle_raw and from
jiffies will be ordered correctly in SMP. I am tempted to think that
ordering memory writes to clock->cycle_raw vs jiffies is also needed in this
case (where clock->cycle_raw is updated, or where jiffies is updated).
We can fall in the same kind of issue if we read the HPET, which is
memory I/O based. It does not seems correct to assume that MMIO vs
normal memory reads are ordered. (pointing back to this article :
http://lwn.net/Articles/198988/
)
Mathieu
> > > > > +
> > > > > +		/* calculate the delta since the last update_wall_time: */
> > > > > +		cycle_delta = (cycle_now - cycle_last) & clock->mask;
> > > > > +
> > > > > +	} while (cycle_raw != clock->cycle_raw ||
> > > > > +		 cycle_last != clock->cycle_last);
> > > > > +
> > > > > +	return cycle_raw + cycle_delta;
> > > > > +}
> 
> 
> -- Steve
> 
-- 
Mathieu Desnoyers
Computer Engineering Ph.D. Student, Ecole Polytechnique de Montreal
OpenPGP key fingerprint: 8CD5 52C3 8E3C 4140 715F  BA06 3F25 A8FE 3BAE 9A68