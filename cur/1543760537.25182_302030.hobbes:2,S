Date: Fri, 11 Mar 2005 11:01:12 -0500 (EST)
From: Steven Rostedt <>
Subject: Re: [patch] Real-Time Preemption, -RT-2.6.11-rc3-V0.7.38-01
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/3/11/128

On Fri, 11 Mar 2005, Ingo Molnar wrote:
>
> * Steven Rostedt <rostedt@goodmis.org> wrote:
>
> > Here's the patch. It's probably more of an overkill wrt buffer heads,
> > but it seems to be the easiest solution.
>
> isnt there some ext3-private journal structure (journal-bh) linked off
> the bh? If the lock is in that structure then the overhead would only
> affect ext3.
>
Yes, there is, and I was trying to use it before you mentioned trying this
(which works for now).  The locks are called before and after the private
pointer of the bh is set and removed.  The journal_head lock, I was going
to make global, and the state lock would go on this structure. I would
have to do some hack in journal.c to flag the state lock when it was
removing the journal head so that it didn't do the remove there, but did
it after the state lock was released. But this still had a few crashes.
The journal_head lock was used to lock when to add or remove the private
data from the bh, so you can see why this structure can't be used for this
purpose. But the state lock seemed to be ok for this. I need to know more
about the journaling system.
 I'll look into doing this too, but this fix should due for now.
-- Steve
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/