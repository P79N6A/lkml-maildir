Date: Fri, 6 Oct 2000 05:59:11 +0100
From: Philipp Rumpf <>
Subject: Re: is there a limit on bss size?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/10/6/134

On Thu, Oct 05, 2000 at 04:30:35PM +0100, Tigran Aivazian wrote:
> Hi,
> 
> I put a simple construct in kernel/sched.c like this:
> 
> struct runq_log_s {
>         char comm[16];
>         int  pid;
> } runq_log[1024*1024];
> 
> and the kernel didn't boot. Yes, I understand it is 20M of bss - so what?
Look at the code in arch/i386/kernel/entry.S that initializes our temporary
page tables:
/*
 * Initialize page tables
 */
	movl $pg0-__PAGE_OFFSET,%edi /* initialize page tables */
	movl $007,%eax		/* "007" doesn't mean with right to kill, but
				   PRESENT+RW+USER */
2:	stosl
	add $0x1000,%eax
	cmp $empty_zero_page-__PAGE_OFFSET,%edi
	jne 2b
/*
 * The page tables are initialized to only 8MB here - the final page
 * tables are set up later depending on memory size.
 */
.org 0x2000
ENTRY(pg0)
.org 0x3000
ENTRY(pg1)
My guess is we're trying to access higher addresses, and getting another
fault for those.  Could you try modifying head.S in the obvious way to
map more than 8MB during the boot process ?
> I will try with a smaller value and see what is the limit but am curious
> as to the reason. The last thing I see is Uncompressing linux... Maybe the
> code in arch/i386/kernel/head.S which clears BSS is broken at "large
> values"?
That code would indeed be what causes the page faults we cannot handle,
if my theory is correct.
	Philipp Rumpf
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
Please read the FAQ at 
http://www.tux.org/lkml/