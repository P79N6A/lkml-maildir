Date: Fri, 30 Jul 1999 17:54:16 +0900
From: NIIBE Yutaka <>
Subject: Re: sched_yield() on "SCHED_FIFO"
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/7/30/31

Kuniyasu SUZAKI writes:
 > The supposed action of my program depended on the Round Robin
 > scheduling on 1 CPU. The program produced two processes and they would
 > be executed alternately, because it yielded each other on 1 CPU.  The
 > main problem is one process monopolied a CPU even if it executed
 > sched_yield().
Oops, I had not understood the code you provided.  Now, I see your
point.
I think that I've found the cause of the problem.
---------------------------  kernel/sched.c
asmlinkage int sys_sched_yield(void)
{
	spin_lock_irq(&runqueue_lock);
	if (current->policy == SCHED_OTHER)         <---------- This line.
		current->policy |= SCHED_YIELD;
	current->need_resched = 1;
	move_last_runqueue(current);
	spin_unlock_irq(&runqueue_lock);
	return 0;
}
---------------------------
This line was introduced on November 1998 in the patch-2.1.127.
Without this conditional (set SCHED_YIELD flag regardless of policy),
I guess it works fine.
Could someone try?  I don't have single CPU machine at hand.
-- 
Niibe Yutaka
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/