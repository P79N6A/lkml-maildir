Date: Thu, 14 Feb 2008 17:56:45 +0100
From: Andi Kleen <>
Subject: [PATCH] Fix direct mapping alias regressin in ioremap v2
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/2/14/241

Fix direct mapping alias regressin in ioremap v2
[This fixes the general ioremap bug I mentioned earlier. It was
fortunately easier to fix that I thought first.]
set_memory_*/cpa is not currently able to resolve ioremap addresses to
their direct mapping aliases.
However uncached ioremap still needs to fix up the direct mapping
to be uncached when the direct mapping happens to overlap
the remapped area. Otherwise there would be a cached mapping
to the uncached ioremap area and that is not allowed in the x86
architecture.
Do this explicitely in ioremap() by passing the direct mapping
address to cpa and ignoring the error if the address wasn't
in the direct mapping.
I also fixed a minor bug I noticed -- need to pass in size + offset,
not just size.
v2: Improve description
    Fix bug noticed by Ingo of __va() wrapping on 32bit
Signed-off-by: Andi Kleen <ak@suse.de>
Index: linux/arch/x86/mm/ioremap.c
===================================================================
--- linux.orig/arch/x86/mm/ioremap.c
+++ linux/arch/x86/mm/ioremap.c
@@ -104,6 +104,7 @@ static void __iomem *__ioremap(unsigned 
 	unsigned long pfn, offset, last_addr, vaddr;
 	struct vm_struct *area;
 	pgprot_t prot;
+	int err;
 
 	/* Don't allow wraparound or zero size */
 	last_addr = phys_addr + size - 1;
@@ -156,9 +157,16 @@ static void __iomem *__ioremap(unsigned 
 		return NULL;
 	}
 
-	if (ioremap_change_attr(vaddr, size, mode) < 0) {
-		vunmap(area->addr);
-		return NULL;
+	/* Fix up the direct mapping for the new cache attributes */
+	if ((phys_addr + size + offset) >> PAGE_SHIFT <= max_pfn_mapped) {
+		err = ioremap_change_attr((unsigned long)__va(phys_addr),
+				size + offset, mode);
+		if (err == -EINVAL) {
+			/* Original address was partly unmapped. Ignore. */
+		} else if (err < 0) {
+			vunmap(area->addr);
+			return NULL;
+		}
 	}
 
 	return (void __iomem *) (vaddr + offset);