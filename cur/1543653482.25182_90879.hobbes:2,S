Date: 19 Nov 2002 11:29:50 -0800
From: Andy Pfiffer <>
Subject: Re: [ANNOUNCE][CFT] kexec for v2.5.48 && kexec-tools-1.7 -- Success Story!
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2002/11/19/209

On Tue, 2002-11-19 at 09:34, Eric W. Biederman wrote:
> Andy Pfiffer <andyp@osdl.org> writes:
> 
> > On Tue, 2002-11-19 at 02:25, Eric W. Biederman wrote:
> > > > Complete kernel boot-up log attached below.  I'm going to try to find my
> > > > other 576MB of RAM with the right command-line magic... ;^)
> > > 
> > > Or you can write a routine to gather that information dynamically and send
> > > me a patch for /sbin/kexec.  Though it may take another proc file to do
> > > that one properly.
> > > 
> > > Eric
Hmmm...I seem to be having some trouble setting "mem=" (system hangs). 
Maybe multiple "mem=NNNK@0xXXXXXXXX" options won't work.
While I try to figure out what's going on, here's a program ("kargs")
that composes a kernel command line from the contents of
"/proc/cmndline" and "/proc/iomem".  It doesn't do as much error
checking as it should...
Usage (sh quoting): kexec --force "--command-line=`kargs`" bzImage
Andy
/*
 *	andyp@osdl.org
 *	Tue Nov 19 09:26:22 PST 2002
 *
 *	Compose a kernel command line on stdout from the contents
 *	of /proc/iomem and /proc/cmndline.
 */
#include <stdio.h>
#include <stdlib.h>
#include <regex.h>
struct memregion {
	unsigned long		first;
	unsigned long		last;
	struct memregion	*next;
};
int memopt(char *iomem, char *out, int outlen)
{
	FILE	*f;
	struct memregion *list, *tmp;
	char	*pattern;
	regex_t	preg;
	int	cc, kb;
	char	line[256];
	if ((f = fopen(iomem, "r")) == NULL)
		return -1;
	pattern = "^[0-9a-fA-F].*-[0-9a-fA-F].* : System RAM";
	if (regcomp(&preg, pattern, 0)) {
		(void) fclose(f);
		return -1;
	}
	list = (struct memregion *) 0;
	while (fgets(line, sizeof(line), f) != NULL) {
		if (regexec(&preg, line, 0, 0, 0) == REG_NOMATCH)
			continue;
		tmp = (struct memregion *) malloc(sizeof(struct memregion));
		if (tmp == (struct memregion *) 0)
			goto out;
		cc = sscanf(line, "%x-%x", &tmp->first, &tmp->last);
		if (cc != 2) {
			free(tmp);
			goto out;
		}
		tmp->next = list;
		list = tmp;
	}
	out[0] = 0;
	tmp = list;
	while (tmp) {
		strcat(out, "mem=");
		kb = (tmp->last - tmp->first + 1) >> 10;
		sprintf(line, "%dK@0x%08x", kb, tmp->first);
		strcat(out, line);
		if (tmp->next)
			strcat(out, " ");
		tmp = tmp->next;
	}
out:
	while (list) {
		tmp = list->next;
		free(list);
		list = tmp;
	}
	regfree(&preg);
	(void) fclose(f);
	return 0;
}
static int lastcmd(char *cmndline, char *out, int outlen)
{
	FILE	*f;
	char	line[256];
	if ((f = fopen(cmndline, "r")) == NULL)
		return -1;
	memset(out, 0, outlen);
	if (fgets(line, sizeof(line), f) != NULL)
		strncpy(out, line, strlen(line) - 1);
	fclose(f);
	return 0;
}
int main(int argc, char **argv)
{
	int	cc;
	char	*name;
	char	memline[256];
	char	curline[256];
	name = "/proc/iomem";
	cc = memopt(name, memline, sizeof(memline));
	if (cc < 0) {
		perror(name);
		exit(1);
	}
	name = "/proc/cmdline";
	cc = lastcmd(name, curline, sizeof(curline));
	if (cc < 0) {
		perror(name);
		exit(1);
	}
	printf("%s %s\n", curline, memline);
	exit(0);
}