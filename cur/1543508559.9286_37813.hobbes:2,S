Date: Tue, 7 Sep 1999 21:37:05 -0400 (EDT)
From: "Richard B. Johnson" <>
Subject: Re: Serial proxy driver help...
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/9/7/129

On 7 Sep 1999, Junio Hamano wrote:
> >>>>> "RJ" == Richard B Johnson <root@chaos.analogic.com> writes:
> 
> RJ> 	This is a template.
> 
> RJ>     for(;;)
> RJ>     {
> RJ>        select(i+1....)    /* Timeout on select about 2 character times */
> RJ>        {
> RJ>            len = read(i, buf, LEN);
> RJ>            if(len)write(j, buf, len);
> RJ>        }
> RJ>        select(j+1....)
> RJ>        {
> RJ>            len = read(j, buf, LEN);
> RJ>            if(len) write(i, buf, len);
> RJ>       }
> RJ>     }
> 
> Would you care to explain how you would handle breaks and sttys
> (i.e. serial configuration change such as parity, speed, etc.)
> in the above scheme please?
> 
I wouldn't. The original inquiry was to pass through everything
from one tty to another bi-directionally.
Further, the general mechanism was shown. It is, in fact, not necessary
to have any time-out at all, one could pass a NULL pointer to select
instead of the struct timeval (which was not even shown), and use
only one select call (as pointed out by others who would mask the
whole mechanism to one difficult to follow line of code).
A working scheme is:
                sfd = max(fd, master) +1;
                for(;;)
                {
                    FD_ZERO(&mem->rfds);
                    FD_SET(fd, &mem->rfds);
                    FD_SET(master, &mem->rfds);
                    if(select(sfd, &mem->rfds, NULL, NULL, NULL))
                    {
                        if(FD_ISSET(fd, &mem->rfds))
                        {
                            if((i = read(fd, mem->buf, BUF_LEN)) <= 0)
                                break;
                            if((i = write(master, mem->buf, i)) <= 0)
                                break;
                        }
                        if(FD_ISSET(master, &mem->rfds))
                        {
                            if((i = read(master, mem->buf, BUF_LEN)) <= 0)
                                 break;
                            if((i = write(fd, mem->buf, i)) <= 0)
                                 break;
                        }
                    }
                }
                (void)close(master);
                (void)close(fd);
Now, if you wish a protocol, i.e., like telnet, you could use in-band
signaling. After all, you did read the data into a buffer where it
can be inspected. This, however, prevents you from running 8-bit
transparent data because data bytes would be interpreted as protocol
commands.
With RS-232C, you are in luck because there are two modem-control bits
that can be used to signal out-of-band data. You need the exceptfds
for this.
Cheers,
Dick Johnson
                   **** FILE SYSTEM WAS MODIFIED ****
Penguin : Linux version 2.3.13 on an i686 machine (400.59 BogoMips).
Warning : It's hard to remain at the trailing edge of technology.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/