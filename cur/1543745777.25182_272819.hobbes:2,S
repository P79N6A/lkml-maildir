Date: Sat, 20 Nov 2004 00:13:17 GMT
From: Stephen Tweedie <>
Subject: [Patch 3/3]: ext3: handle attempted double-delete of metadata.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2004/11/19/391

This patch improves ext3's ability to deal with corruption on-disk.
If we try to delete a metadata block twice, we confuse ext3's internal
revoke error-checking, resulting in a BUG().  But this can occur in
practice due to a corrupt indirect block, so we should attempt to fail
gracefully.
Downgrade the assert failure to a JH_EXPECT_BH failure, and return EIO
when it occurs.
This is easily reproduced with a sample ext3 fs image containing an
inode which references the same indirect block more than once.
Deleting that inode will BUG() an unfixed kernel with:
Assertion failure in journal_revoke() at fs/jbd/revoke.c:379:
"!buffer_revoked(bh)"
With the fix, ext3 recovers gracefully.
Signed-off-by: Stephen Tweedie <sct@redhat.com>
--- linux-2.6-ext3/fs/jbd/revoke.c.=K0002=.orig
+++ linux-2.6-ext3/fs/jbd/revoke.c
@@ -376,7 +376,12 @@ int journal_revoke(handle_t *handle, uns
            first having the revoke cancelled: it's illegal to free a
            block twice without allocating it in between! */
 	if (bh) {
-		J_ASSERT_BH(bh, !buffer_revoked(bh));
+		if (!J_EXPECT_BH(bh, !buffer_revoked(bh),
+				 "inconsistent data on disk")) {
+			if (!bh_in)
+				brelse(bh);
+			return -EIO;
+		}
 		set_buffer_revoked(bh);
 		set_buffer_revokevalid(bh);
 		if (bh_in) {
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/