Date: Tue, 6 Jul 1999 18:06:37 +0100
From: "Marco Ermini" <>
Subject: Re: linux headers and C++
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/7/6/127

----- Original Message ----- 
From: Dancer <dancer@zeor.simegen.com>
To: Marco Ermini <mail@markoer.org>
Cc: Linux Kernel Mailing List <linux-kernel@vger.rutgers.edu>
Sent: Tuesday, July 06, 1999 3:35 PM
Subject: Re: linux headers and C++
> Marco Ermini wrote:
> > 
> > Looking at the Linux source tree, I don't
> > think Linux is OO. But I personally
> > don't feel it as a limitation per se. WinNT
> > is (maybe?) OO. What's the result? The
> > only things that count, at the end, are the
> > results. Linux could be not OO, but the
> > sources are (quite) always clean and
> > understandable.
> 
> OO doesn't imply inheritance. Yes, having language features that support
> OO is nice, but it's possible to do good, clean OO code in C without
> heaps of tangled, complex code....UNLESS you try to mimic the things
> that a language with..
;-)
>*ahem* Let me try that sentence again: UNLESS you
> try to do the really complicated stuff that the language support of (for
> example) C++ or smalltalk hides the complexity of.
>
> Multiple inheritance, virtual members, templates (ye gods)..each of
> these things has layers of complexity. The fact that a compiler _hides_
> that complexity from you doesn't make the end-code simple, and if you
> try to implement foolishly complicated OO constructs in a non-OO
> language, then you _do_ risk getting badly fuddled.
If I understand, you are saying: this kind
of things could be, depending from the
case, an added layer of confusion *ahem*
complexity, or an useful level of abstraction.
Ok, this is what I meant.
 
> However: Basic object orientation (packages and interfaces and instance
> data) is quite straightforward under C (and only marginally less so in
> ASM) and in plenty of other procedural languages. We've been doing it
> for years, and were probably doing it before someone gave it a name.
> 
> The kernel's full of OO code. So's glibc.
> 
> I _will_ grant that sometimes it is easier and cleaner to do some things
> in a language with support for the whole OO paradigm. And sometimes it
> isn't. It depends on what you're doing. It depends on what you're doing,
> and how you go about it.
We all red Bertrand Meyer's book, ok
(but maybe we don't need Eiffel, for the
reasons you explained, that all the OO
abstraction we need could be realized
well and clearly with just basic, plain C).
> Sometimes C++ will do the whole bloat thing on you. And sometimes it
> won't. It depends on what you're doing, and how you go about it.
> 
> The language is a tool and a description. Not a religion or a dogma. You
> always try to select the best tool for the job...and in a cooperative
> development environment sometimes the best tool is a tool that the other
> people can use with equal facility.
> 
> For reference, I spend most of my time coding in C++. Because it happens
> to be the best tool for the jobs I do. If a job warrants C (and some of
> them do) then C code is what I write. I'm an atheist when it comes to
> compiled languages.
I agree, totally. I had to use almost
everything in my work, from C, C++
to Visual Basic or Delphi (and sometimes,
it's worth of using them, too, if in the
team the other programmers just know
VB or Delphi and we have to use
Windows).
Of course, we became religious when
we come to interpreted languages ;-)
As you could imagine, I prefer
Python over Perl...
Cheers
Marco
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/