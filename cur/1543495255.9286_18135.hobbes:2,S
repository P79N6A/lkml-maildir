Date: Mon, 10 May 1999 17:35:36 +0100
From: Jan-Simon Pendry <>
Subject: Re: [patch] new scheduler
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/5/10/70

Phillip Ezolt wrote:
> Does flock/fcntl wake up all of the processes that are waiting on the lock?
> 
> If so, has the thundering herd problem just been pushed into flock/fcntl
> instead of accept?
> 
> >
> > I'm willing to accept any well founded explanation, and this is where
> > most of the concern has been coming from.
yes, as can be demonstrated by running the attached program, eg:
	slock -s 60
will start 60 contending processes, and the load average will
tend towards 60.  the load should tend to 1 since at most one
process can actually hold the file lock.
at a first glance this would appear tricky to fix.  fixing the accept()
race looks to be trivial if we had a decent semaphore implementation.
who's working on that?
jan-simon.#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/file.h>
#include <string.h>
static int
forkn(int n)
{
	int	i;
	pid_t	pid;
	for (i = 0; i < n; i++) {
		pid = fork();
		switch (pid) {
		case -1:
			fprintf(stderr, "slock: fork: %s\n", strerror(errno));
			break;
		case 0:
			return (i);
		default:
			break;
		}
	}
	return (n);
}
int
main(int c, char *v[])
{
	int	fd = STDIN_FILENO;
	int	ch, id, nservers, nxid;
	char	xid[12];
	nservers = 1;
	while ((ch = getopt(c, v, "s:")) != EOF) {
		switch (ch) {
		case 's':
			nservers = atoi(optarg);
			if (nservers < 1)
				nservers = 1;
			break;
		}
	}
	id = forkn(nservers);
	nxid = sprintf(xid, "%d ", id);
	for (;;) {
		flock(fd, LOCK_EX);
		flock(fd, LOCK_UN);
		/*write(1, xid, nxid);*/
	}
}