Date: Wed, 07 Jan 2009 09:43:02 -0500
From: Chris Mason <>
Subject: Re: [PATCH mmotm] nilfs2: insert checks and hole block allocation in page_mkwrite
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2009/1/7/233

On Wed, 2009-01-07 at 22:06 +0900, Ryusuke Konishi wrote:
> Chris Mason told me that page_mkwrite() has some works to do.
> 
> On Wed, 17 Dec 2008 21:52:55 -0500, Chris Mason wrote:
> > nilfs_page_mkwrite doesn't seem to dirty the page?  block_page_mkwrite
> > does more, including checks against i_size and others.
> 
> This will insert i_size check, and hole block allocation code in the
> nilfs_page_mkwrite.
> 
> Previously, the hole block allocation was delayed until just before
> writing for mmapped pages.  This accompanies removal of the delayed
> allocation code.
> 
> Cc: Chris Mason <chris.mason@oracle.com>
> Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
> ---
>  fs/nilfs2/file.c    |   59 +++++++++++++++++++++++++++++++++++++++++++++++++-
>  fs/nilfs2/segment.c |   42 ++++--------------------------------
>  2 files changed, 62 insertions(+), 39 deletions(-)
> 
> diff --git a/fs/nilfs2/file.c b/fs/nilfs2/file.c
> index 7ddd42e..146dc23 100644
> --- a/fs/nilfs2/file.c
> +++ b/fs/nilfs2/file.c
> @@ -75,11 +75,66 @@ nilfs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
> 
>  static int nilfs_page_mkwrite(struct vm_area_struct *vma, struct page *page)
>  {
> -	if (!(vma->vm_flags & (VM_WRITE | VM_MAYWRITE)))
> -		return -EPERM;
> +	struct inode *inode = vma->vm_file->f_dentry->d_inode;
> +	struct address_space *mapping = inode->i_mapping;
> +	struct nilfs_transaction_info ti;
> +	struct buffer_head *bh, *head;
> +	int fully_mapped = 1;
> +	int ret = -EINVAL;
> +
> +	/*
> +	 * use i_alloc_sem to stop truncate operations on the inode
> +	 */
> +	down_read(&inode->i_alloc_sem);
I'm not 100% sure this is safe.  It seems likely the direct io paths
could trigger a mkwrite with the i_alloc_sem already held?
If I'm reading the code correctly you're:
* grab i_alloc sem to protect against truncate
* check to see if the page is mapped already (no holes)
* if there are holes, lock the page, start transaction and do the full
block_page_mkwrite
* drop i_alloc_sem
Would this work instead?:
* lock the page, check to see if it is mapped
* if there are holes, drop the lock, start transaction and do the full
block_page_mkwrite
-chris