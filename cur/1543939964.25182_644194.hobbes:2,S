Date: Mon, 28 Jan 2008 09:59:07 +0900
From: "Kyungmin Park" <>
Subject: Re: [PATCH] CRAMFS: Uncompressed files support
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/1/27/272

> > This patch enables the uncompressed files support in cramfs.
> >
> > The word 'uncompressed file' is from linear cramfs (aka Application XIP).
> > In linear cramfs, it is used to suport XIP on NOR. However it is also helpful on OneNAND. It makes a filesystem faster by removing compression overhead.
> > In XIP mode it runs XIP, But non-XIP mode. It copies data to ram and runs.
> >
> > In my simple test, copy busybox (compressed or uncompressed).
> > It reduces the about 50% time saving from 0.40s to 0.19s.
> > Yes, it incrases the file system size, but nowadays flash has big capacity.
> > It's trade-off between size and performance.
> >
> > Also this patch uses the page cache directly.
> > In previous implementation, it used the local buffer. why?
> > It's already uncompressed and fits to page size. So It uses the page directly to remove useless memory copy.
> >
> > It's compatible the existing linear cramfs image and original one.
> >
> > Any comments are welcome.
> >
> > diff --git a/fs/cramfs/inode.c b/fs/cramfs/inode.c
> > index 3d194a2..edba28f 100644
> > --- a/fs/cramfs/inode.c
> > +++ b/fs/cramfs/inode.c
>
> I don't know what kernel this is against but it generates a lot of rejects
> against present mainline.
>
Sorry, it used another tree instead of mainline. Following patch will
be against mainline.
>
> Are you sure about the kmap/kunmap handling in this patch?  It looks like
> it might be unbalanced.
>
Yes, It's matching. Because cramfs_read returns virtual address, it
returns the kmap-ped address if it had page, then caller kunmap-ed and
release it. Otherwise pg doesn't have page pointer.
Anyway, here's more simple method using get_block sytle.
With this patch, it can also use multi page read, cramfs_readpages.
However, it has no big improvement in my environment.
The goal is same it uses the requested page directly instead of
useless memory copy.
Any comments are welcome.
Thank you,
Kyungmin Park
Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
diff --git a/fs/cramfs/inode.c b/fs/cramfs/inode.c
index 350680f..2d6736d 100644
--- a/fs/cramfs/inode.c
+++ b/fs/cramfs/inode.c
@@ -23,6 +23,7 @@
 #include <linux/buffer_head.h>
 #include <linux/vfs.h>
 #include <linux/mutex.h>
+#include <linux/mpage.h>
 #include <asm/semaphore.h>
 #include <asm/uaccess.h>
@@ -40,6 +41,7 @@ static DEFINE_MUTEX(read_mutex);
 #define CRAMINO(x)	(((x)->offset && (x)->size)?(x)->offset<<2:1)
 #define OFFSET(x)	((x)->i_ino)
+#define CRAMFS_INODE_IS_XIP(x)	((x)->i_mode & S_ISVTX)
 static int cramfs_iget5_test(struct inode *inode, void *opaque)
 {
@@ -468,16 +470,32 @@ static struct dentry * cramfs_lookup(struct
inode *dir, struct dentry *dentry, s
 	return NULL;
 }
+static int cramfs_get_block(struct inode *inode, sector_t iblock,
+		struct buffer_head *bh_result, int create)
+{
+	/* A write? */
+	BUG_ON(unlikely(create));
+
+	iblock += (PAGE_ALIGN(OFFSET(inode)) >> PAGE_CACHE_SHIFT);
+	map_bh(bh_result, inode->i_sb, iblock);
+
+	return 0;
+}
+
 static int cramfs_readpage(struct file *file, struct page * page)
 {
 	struct inode *inode = page->mapping->host;
+	struct super_block *sb = inode->i_sb;
 	u32 maxblock, bytes_filled;
 	void *pgdata;
 	maxblock = (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
 	bytes_filled = 0;
-	if (page->index < maxblock) {
-		struct super_block *sb = inode->i_sb;
+
+	/* Handle uncompressed files */
+	if (CRAMFS_INODE_IS_XIP(inode) && page->index < maxblock) {
+		return mpage_readpage(page, cramfs_get_block);
+	} else if (page->index < maxblock) {
 		u32 blkptr_offset = OFFSET(inode) + page->index*4;
 		u32 start_offset, compr_len;