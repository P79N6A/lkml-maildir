Date: Sat, 23 Jun 2001 16:30:26 +0100
From: Russell King <>
Subject: Re: sizeof problem in kernel modules
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2001/6/23/39

On Sat, Jun 23, 2001 at 04:54:20PM +0200, Der Herr Hofrat wrote:
> struct { short x; long y; short z; }bad_struct;
> struct { long y; short x; short z; }good_struct;
> 
> I would expect both structs to be 8byte in size , or atleast the same size !
> but good_struct turns out to be 8bytes and bad_struct 12 .
> 
> what am I doing wrong here ?
You're expecting the compiler to lay them out without any spacing between
them.  There is no such requirement in C.
The compiler knows that its more efficient for long words to be accessed
on a long word boundary, so it wastes two bytes after each short in your
bad_struct case.  However, it won't waste them in this case, because there
isn't a long:
struct { short x; short y; short z; }
If you really really really want that layout, then use
__attribute__((packed)) (read the gcc info files to find out what this
does), but don't unless you absolutely must.
Here is another struct layout example:
struct foo {
	short x;
	char y;		/* implicit 1 byte padding after this element */
	short z;
};
Again, the 1 byte padding can be removed by use of the __attribute__
above.
--
Russell King (rmk@arm.linux.org.uk)                The developer of ARM Linux
             
http://www.arm.linux.org.uk/personal/aboutme.html
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/