Date: Wed, 7 Jan 2009 13:35:04 +0100
From: Jens Axboe <>
Subject: Re: Data corruption issue with splice() on 2.6.27.10
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2009/1/7/140

On Wed, Jan 07 2009, Jarek Poplawski wrote:
> On Wed, Jan 07, 2009 at 01:22:05PM +0100, Willy Tarreau wrote:
> > [ CCing Evgeniy and Herbert who also participate to the thread ]
> ...
> > Well, I've just tested it. It did not fix the problem but made it worse.
> ...
> 
> Terrible mistake! Here is take 2.
Not sure what this:
> +static inline struct page *linear_to_page(struct page *page, unsigned int len,
> +					  unsigned int offset)
> +{
> +	struct page *p = alloc_pages(GFP_KERNEL, 0);
> +
> +	if (!p)
> +		return NULL;
> +	memcpy((void *)p + offset, (void *)page + offset, len);
is trying to do. I'm assuming you want to copy the page contents? If so,
you'd want something like
        memcpy(page_address(p) + offset, page_address(page) + offset, len);
with possible kmaps for 'page'.
Irregardless of that particular oddity, I don't think this is the right
path to take at all. We need to delay the pipe buffer consumption until
the appropriate time.
-- 
Jens Axboe