Date: Fri, 26 Feb 1999 16:48:18 +0100 (CET)
From: Andrea Arcangeli <>
Subject: Re: How to read xtime
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/2/26/114

On 26 Feb 1999, H. Peter Anvin wrote:
>However, if you have a reasonable limit on how long you may be
>interrupted (1/2 of the major increment) you can do this without
>loops:
>
>	mov (xtime_sec),%ecx
>	mov (xtime_usec),%eax
>	mov (xtime_sec),%edx
>	cmp %eax,500000			; 1/2 of the major increment
>	jb 1f
>	mov %ecx,%edx
>1:	; Result in %edx:%eax
>
>If the minor counter is less than halfway to rollover, it is safe to
>assume the value read immediately *after* is stable; if it's more than
>halfway, that the value read immediately *before* is stable.  One
>advantage with not having a loop is that you don't bias the output.
Maybe we aren't talking about the same thing, but my point is that if you
don't use any lock and you don't __cli() the other cpu, you could _always_
have %ecx == %edx even if the other CPU has updated only usec (because
it's been interrupted a bit before having the time to increase tv_sec).
Andrea Arcangeli
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/