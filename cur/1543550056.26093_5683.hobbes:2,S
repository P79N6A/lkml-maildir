Date: Fri, 29 Sep 2000 09:53:58 +1100
From: Keith Owens <>
Subject: Re: [patch] enabling APIC and NMI watchdog on UP systems
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/9/28/40

On Thu, 28 Sep 2000 21:19:29 +0200 (CEST), 
Ingo Molnar <mingo@elte.hu> wrote:
>the attached patch (against test9-pre7) is a cleaned up version Keir
>Fraser's APIC-on-UP patch, and adds the enabling code of Keith Owens which
>programs P6 performance counter 0 as an NMI. (i simplified the code alot -
>there is no problem at all with getting NMIs from two sources, and it's
>not necessary to make it configurable.)
Using performance counter 1 for NMI conflicts with using the
performance counters for tuning.  IMHO it is better to default to NMI
off for UP so we do not disturb people who are doing performance
monitoring.  That then requires a mechanism for configuring the UP NMI
and activating it on the fly, which complicates the code.
AFAICT your patch will not generate local APIC NMIs fast enough.  From
kdb v1.5-beta2.
int set_nmi_counter_local(void)
{
	extern unsigned long cpu_khz;
	if (!(boot_cpu_data.x86_capability & X86_FEATURE_APIC))
		return(-EIO);
	if (nmi_watchdog_source && nmi_watchdog_source != 1)
		return(0);      /* Not using local APIC */
	return wrmsr_eio(PERFCTR1, -(cpu_khz/HZ*1000), 0);
}
set_nmi_counter_local() has to be called after every NMI to reset the
counter.  Otherwise the counter is zero (it just overflowed) and will
not generate another NMI until it loops all the way round to 2**40
again.  If you are going to reprogram PERFCTR1 for every NMI then you
do not want to do that unless PERFCTR1 really is the NMI source, again
it will conflict with real use of the performance counters so we need
to track the source and make it configurable.
I am basing this on Intel ia32 arch vol3, 24319202.pdf
15.6.2. Monitoring Counter Overflow
...
When interrupted by a counter overflow, the interrupt handler needs to
perform the following actions:
* Save the instruction pointer (EIP register), code-segment selector,
  TSS segment selector, counter values and other relevant information
  at the time of the interrupt.
* Reset the counter to its initial setting and return from the
  interrupt.
If you tested a UP compile on an SMP box, you probably got NMI via the
IO-APIC which hides the lack of counter reset.  I had to hack
smp_scan_config() to immediately return(0) so it would not pick up the
SMP config and not use the IO-APIC for NMI.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
Please read the FAQ at 
http://www.tux.org/lkml/