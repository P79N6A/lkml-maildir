Date: Tue, 12 Sep 2000 23:23:07 +0200
From: Felix von Leitner <>
Subject: does anyone have a minimal opendir/readdir/closedir implementation?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/9/12/85

For my project "dietlibc" (
http://www.fefe.de/dietlibc/
) I am looking
into implementing directory access now.
The kernel interface seems to be:
  * supply an O_DIRECTORY flag to open()
  * a getdents system call
You don't read on the fd in readdir, you call getdents.
getdents reads n struct dirents.  You can't say how many you want, you
can only limit the bytes it copies.  Oh, and that's a kernel struct
dirent, which is subtly different from the glibc one (it does not
contain the d_type field).
So a "natural" approach would be to have opendir call getdents on a
"big" buffer to get all the records and then have readdir return each
one.  But... how do I know how much space to reserve?  lseek can find
out the file size, but directories under /proc have a size of 0.
glibc seems to handle this by defining an elaborate buffer data structure.
As the name implies, dietlibs seeks to implement functions with minimal
code size.  Speed is also important, but not as much as code size.
Strict POSIX compliance is nice if it doesn't increase the code size
much.
How am I to implement these functions small and efficiently?  There
surely is a better way than having a buffer management and translating
data structures, right?  Since this is not a kernel issue in the strict
sense, please reply directly and not to the mailing list.
Felix
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
Please read the FAQ at 
http://www.tux.org/lkml/