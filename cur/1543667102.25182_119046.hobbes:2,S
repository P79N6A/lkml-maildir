Date: Fri, 21 Mar 2003 04:35:50 -0800
From: David Schwartz <>
Subject: Re: read() & close()
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2003/3/21/79

On Thu, 20 Mar 2003 15:14:52 +0100, Filipau, Ihar wrote:
>I have/had a simple issue with multi-threaded programs:
>
>one thread is doing blocking read(fd) or poll({fd}) on
>file/socket.
>
>another thread is doing close(fd).
>
>I expected first thread will unblock with some kind
>of error - but nope! It is blocked!
>
>Is it expected behaviour?
	It is impossible to make this work reliably, so *please* don't do 
that. For example, how can you possibly assure that the first thread 
is actually in 'poll' when call 'close'? There is no atomic 'release 
mutex and poll' function.
	So what happens if the system pre-empts the thread right before it 
calls 'poll'. Then you call 'close'. Perhaps next a thread started by 
some library function calls 'socket' and gets the file descriptor you 
just 'close'd. Now your call to 'poll' polls on the *wrong* socket!
	You simply must accept the fact that you cannot free a resource in 
one thread while another thread is or might be using it.
	DS
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/