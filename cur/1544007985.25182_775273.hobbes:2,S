Date: Mon, 1 Dec 2008 07:10:36 +0100
From: "stephane eranian" <>
Subject: Re: [patch 20/24] perfmon: system calls interface
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/12/1/15

Thomas,
On Thu, Nov 27, 2008 at 3:01 PM, Thomas Gleixner <tglx@linutronix.de> wrote:
> On Wed, 26 Nov 2008, eranian@googlemail.com wrote:
>
>> +asmlinkage long sys_pfm_write(int fd, int uflags,
>> +                           int type,
>> +                           void __user *ureq,
>> +                           size_t sz)
>
>> +asmlinkage long sys_pfm_read(int fd, int uflags,
>> +                          int type,
>> +                          void __user *ureq,
>> +                          size_t sz)
>
> After looking at both I did a diff of the two functions:
>
> --- r.c 2008-11-27 14:27:54.000000000 +0100
> +++ w.c 2008-11-27 14:27:52.000000000 +0100
> @@ -36,10 +36,12 @@
>        ret = pfm_check_task_state(ctx, PFM_CMD_STOPPED, &flags);
>        if (ret)
>                goto skip;
> -
>        switch(type) {
> +       case PFM_RW_PMC:
> +               ret = __pfm_write_pmcs(ctx, req, count);
> +               break;
>        case PFM_RW_PMD:
> -               ret = __pfm_read_pmds(ctx, req, count);
> +               ret = __pfm_write_pmds(ctx, req, count);
>                break;
>        default:
>                PFM_DBG("invalid type=%d", type);
> @@ -48,12 +50,13 @@
>  skip:
>        spin_unlock_irqrestore(&ctx->lock, flags);
>
> -       if (copy_to_user(ureq, req, sz))
> -               ret = -EFAULT;
> -
> +       /*
> +        * This function may be on the critical path.
> +        * We want to avoid the branch if unecessary.
> +        */
>        if (fptr)
>                kfree(fptr);
>  error:
>        pfm_release_ctx_from_fd(&cookie);
>        return ret;
>  }
>
> Both read and write are multiplexing syscalls already and 90% of the
> code is the same.
>
>        case PFM_RD_PMC:
>        case PFM_RD_PMD:
>        case PFM_WR_PMC:
>        case PFM_WR_PMD:
>
> would make them the same and safe a syscall and duplicated code.
>
I have some issues with this approach because in the API I have tried to follow
the model where the  syscall name describes the action taken (only one
per call):
    - create
    - read
    - write
    - set_state
    - attach/detach I admit this one is not so clean. But Ingo
indicated he would prefer them as separate which I am
      happy to do (it was like this originally)