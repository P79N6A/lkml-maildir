Date: Tue, 27 Jul 1999 04:44:39 +0100 (BST)
From: "Stephen C. Tweedie" <>
Subject: New raw IO patches available for 2.2, 2.3
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/7/26/137

Hi all,
/pub/linux/sct/fs/raw-io/raw-19990727.tar.gz contains the latest raw IO
code for unbuffered, direct disk IO via standard Unix character mode raw
devices.  Note that the character major number used in this release has
moved from 111 to 162 (that major number should be "official" now).
I've included the readme below.  This release should work on most 2.2
kernels (2.2.9 upwards at least), and on 2.3.12-pre5.  Due to the
extensive file locking changes in 2.3 recently, it will not work on
older 2.3 kernels.
--Stephen
----------------------------------------------------------------
Raw device support v0.5, 27 July 1999
Changed since v0.4:	Changed major number from 111 to 162
			Added support for 2.3.  On 2.3, the internals 
			of the brw_kiovec code now use asynchronous 
			completion from the buffer cache layers.
			The 2.2 patch here (against 2.2.11-pre1, but it
			should work on most 2.2 kernels) does not use
			the new internal asynchronous code, because that
			would require a change in the VFS buffer_head
			structure.  We don't want to prevent the use of
			external filesystem modules with raw-enabled
			kernels.
Fixed since v0.3:	IOs larger than 64k should work now, thanks to
			Chris Loveland <cwl@mars.iol.unh.edu>
This archive includes patches against both the 2.2.11-pre1 and
2.3.12-pre5 kernels, but you should have luck using the 2.2 version
against other 2.2 kernels.
The raw devices implemented in this release are genuine Un*x-compatible
character-mode raw devices.  However, unlike most Unixen, the Linux raw
devices are not hard-coded in advance against specific block devices.
Rather, there is a new character major number (currently 162) which
implements a series of unbound raw devices, and it is up to the system
administrator to make sure that these are bound to the appropriate block
devices at runtime.  This means that _any_ block device can have a
character raw device front-end, even if the block device is only loaded
later on at runtime.
The Makefile in this directory will generate a user front-end program
called "raw".  It is used as follows:
You can query the binding of an existing raw device with
	raw -l /dev/rawN
or 
	raw -a
to query them all.  To bind a raw device to an existing block device,
use either
	raw /dev/rawN <major> <minor>
giving the block-device major and minor numbers directly, or
	raw /dev/rawN /dev/<blockdev>
to bind to an existing device in /dev.  Note that the permissions on the
raw device are entirely separate from the block device, and you must set
the mode and ownership of the raw device appropriately.
There are 255 raw devices available for binding, plus a master raw
device (with minor number 0) which is used to control the bindings on
the others.  You can set up a few raw devices to start with via mknod:
	mknod /dev/raw c 162 0
	chmod 600 /dev/raw	# This is important!
	mknod /dev/raw1 c 162 1
	mknod /dev/raw2 c 162 2
	mknod /dev/raw3 c 162 3
	mknod /dev/raw4 c 162 4
and bind them to whatever block devices you want to use:
	raw /dev/raw1 /dev/sda3
	raw /dev/raw2 /dev/fd0
or whatever.  Let me know how it works for you!
Finally, do remember that these are raw devices.  That means:
* All IOs must be 512-byte aligned both in memory and on disk
* There is no cache coherency between the raw device and the buffered
  device.
--Stehen Tweedie <sct@redhat.com>
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/