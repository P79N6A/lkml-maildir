Date: Thu, 25 Mar 1999 08:04:11 -0800 (PST)
From: Y2K <>
Subject: Re: modutils (Re: cipe 1.2.0 & kernel 2.2.x)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/3/25/70

On Thu, 25 Mar 1999, Malcolm Beattie wrote:
> Olaf Titz writes:
> Since Linux is now entering the realms of plenty of file descriptors,
> I wonder if it's worth having a closefdset() syscall used as follows:
>     fd_set most;
>     FD_ZERO(&most);
>     for (i=getdtablesize()-1; i>2; --i)
>  	FD_SET(i, &most);
>     closefdset(&most);
> On the positive side, it reduces all those extra syscalls at a stroke
> and it's simple to write. On the negative side, it's a non-standard
> interface and could easily be considered a unnecessary wart. It also
> can't return any errors beyond "at least one close failed" but that
> doesn't matter for the purposes it would be used for.
It could zero out the ones it closed properly. Then you could use
FD_ISSET; think of select --
From my man page  `man 2 select`:
	On exit,  the  sets  are  modified in place to indicate which
	descriptors actually changed status.
Your new call could be similar. However you couldn't tell what the problem
was exactly if it did not fail on first real failure.
maybe a better solution would be a getopenfdset(fdset *set);
so in bad pseudo c:
long n;
int bad=0;
fdset all;
getopenfdset(&all);
FD_CLR(0,&all); FD_CLR(1,&all); FD_CLR(2,&all);
while ( notempty(&all)&&(!bad) ) bad=close( firstfd(&all) );
If they don't have lots of open files then you won't be calling close as
often.
Anyway any changes should not be taken lightly.
Maybe a combo approach would be better.
Maybe both are very misguided.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/