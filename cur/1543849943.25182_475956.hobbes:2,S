Date: Mon, 23 Oct 2006 14:21:32 -0400
From: "Holden Karau" <>
Subject: [PATCH] wireless-2.6 zd1211rw check against regulatory domain rather than hardcoded value of 11
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/10/23/248

From: Holden Karau <holden@pigscanfly.ca> 
http://www.holdenkarau.com
I have made a small patch for the zd1211rw driver which uses the
boundry channels of the regulatory domain, rather than the hard coded
values of 1 & 11.
Signed-off-by: Holden Karau <holden@pigscanfly.ca> 
http://www.holdenkarau.com
---
I'm not entirely sure how useful this patch is, but it seems like a
good idea. If its totally misguided, let me know :-) In case the patch
gets mangled I've put it up at
http://www.holdenkarau.com/~holden/projects/zd1211rw/zd1211rw-use-geo-for-channels.patch
And now for the patch:
--- a/drivers/net/wireless/zd1211rw/zd_chip.c	2006-10-23
10:07:39.000000000 -0400
+++ b/drivers/net/wireless/zd1211rw/zd_chip.c	2006-10-23
10:41:51.000000000 -0400
@@ -38,6 +38,8 @@ void zd_chip_init(struct zd_chip *chip,
 	mutex_init(&chip->mutex);
 	zd_usb_init(&chip->usb, netdev, intf);
 	zd_rf_init(&chip->rf);
+	/* The chip needs to know which geo it is in */
+	chip->geo = ieee80211_get_geo(zd_mac_to_ieee80211(zd_netdev_mac(netdev)));
 }
 void zd_chip_clear(struct zd_chip *chip)
@@ -606,14 +608,17 @@ static int patch_6m_band_edge(struct zd_
 		{ CR128, 0x14 }, { CR129, 0x12 }, { CR130, 0x10 },
 		{ CR47,  0x1e },
 	};
+	struct ieee80211_geo *geo = chip->geo;
 	if (!chip->patch_6m_band_edge || !chip->rf.patch_6m_band_edge)
 		return 0;
-	/* FIXME: Channel 11 is not the edge for all regulatory domains. */
-	if (channel == 1 || channel == 11)
+	/* Checks the channel boundry of the region */
+	dev_dbg_f("checking boundry == %d || %d\n" , 1 , geo->bg_channels);
+	if (channel == 1 || channel == geo->bg_channels)
 		ioreqs[0].value = 0x12;
+
 	dev_dbg_f(zd_chip_dev(chip), "patching for channel %d\n", channel);
 	return zd_iowrite16a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));
 }
--- a/drivers/net/wireless/zd1211rw/zd_chip.h	2006-10-23
10:07:39.000000000 -0400
+++ b/drivers/net/wireless/zd1211rw/zd_chip.h	2006-10-23
10:39:08.000000000 -0400
@@ -21,6 +21,8 @@
 #include "zd_types.h"
 #include "zd_rf.h"
 #include "zd_usb.h"
+#include "zd_ieee80211.h"
+#include <linux/wireless.h>
 /* Header for the Media Access Controller (MAC) and the Baseband Processor
  * (BBP). It appears that the ZD1211 wraps the old ZD1205 with USB glue and
@@ -669,6 +671,7 @@ struct zd_chip {
 	/* SetPointOFDM in the vendor driver */
 	u8 ofdm_cal_values[3][E2P_CHANNEL_COUNT];
 	u16 link_led;
+  	struct ieee80211_geo* geo;
 	unsigned int pa_type:4,
 		patch_cck_gain:1, patch_cr157:1, patch_6m_band_edge:1,
 		new_phy_layout:1,
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/