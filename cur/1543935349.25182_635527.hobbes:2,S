Date: Tue, 08 Jan 2008 18:42:43 +0900
From: Tejun Heo <>
Subject: Re: [Bluez-devel] Oops involving RFCOMM and sysfs
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/1/8/68

Gabor Gombas wrote:
> On Tue, Jan 08, 2008 at 12:24:05AM +0900, Tejun Heo wrote:
> 
>> Does the attached patch fix the problem?
> 
> No, it still oopses.
Thanks.  Please apply the attached patch and report the oops.
-- 
tejun
diff --git a/drivers/ata/libata-eh.c b/drivers/ata/libata-eh.c
diff --git a/fs/dcache.c b/fs/dcache.c
diff --git a/fs/sysfs/dir.c b/fs/sysfs/dir.c
index 3371629..f5ec27e 100644
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@ -96,7 +96,7 @@ static void sysfs_unlink_sibling(struct sysfs_dirent *sd)
  *	RETURNS:
  *	Pointer to found dentry on success, ERR_PTR() value on error.
  */
-struct dentry *sysfs_get_dentry(struct sysfs_dirent *sd)
+static struct dentry *__sysfs_get_dentry(struct sysfs_dirent *sd, int dbg)
 {
 	struct dentry *dentry = dget(sysfs_sb->s_root);
 
@@ -111,6 +111,8 @@ struct dentry *sysfs_get_dentry(struct sysfs_dirent *sd)
 
 		/* look it up */
 		parent = dentry;
+		printk("XXX: looking up %s (%p) / %s\n",
+		       parent->d_name.name, parent->d_inode, cur->s_name);
 		mutex_lock(&parent->d_inode->i_mutex);
 		dentry = lookup_one_noperm(cur->s_name, parent);
 		mutex_unlock(&parent->d_inode->i_mutex);
@@ -122,6 +124,11 @@ struct dentry *sysfs_get_dentry(struct sysfs_dirent *sd)
 	return dentry;
 }
 
+struct dentry *sysfs_get_dentry(struct sysfs_dirent *sd)
+{
+	return __sysfs_get_dentry(sd, 0);
+}
+
 /**
  *	sysfs_get_active - get an active reference to sysfs_dirent
  *	@sd: sysfs_dirent to get an active reference to
@@ -838,6 +845,14 @@ int sysfs_move_dir(struct kobject *kobj, struct kobject *new_parent_kobj)
 
 	mutex_lock(&sysfs_rename_mutex);
 	BUG_ON(!sd->s_parent);
+	{
+		char *s = kobject_get_path(kobj, GFP_KERNEL);
+		char *p = kobject_get_path(new_parent_kobj, GFP_KERNEL);
+
+		printk("XXX: moving %s under %s\n", s, p);
+		kfree(s);
+		kfree(p);
+	}
 	new_parent_sd = new_parent_kobj->sd ? new_parent_kobj->sd : &sysfs_root;
 
 	error = 0;
@@ -845,14 +860,14 @@ int sysfs_move_dir(struct kobject *kobj, struct kobject *new_parent_kobj)
 		goto out;	/* nothing to move */
 
 	/* get dentries */
-	old_dentry = sysfs_get_dentry(sd);
+	old_dentry = __sysfs_get_dentry(sd, 1);
 	if (IS_ERR(old_dentry)) {
 		error = PTR_ERR(old_dentry);
 		goto out;
 	}
 	old_parent = old_dentry->d_parent;
 
-	new_parent = sysfs_get_dentry(new_parent_sd);
+	new_parent = __sysfs_get_dentry(new_parent_sd, 1);
 	if (IS_ERR(new_parent)) {
 		error = PTR_ERR(new_parent);
 		goto out;
@@ -878,7 +893,6 @@ again:
 	error = 0;
 	d_add(new_dentry, NULL);
 	d_move(old_dentry, new_dentry);
-	dput(new_dentry);
 
 	/* Remove from old parent's list and insert into new parent's list. */
 	sysfs_unlink_sibling(sd);