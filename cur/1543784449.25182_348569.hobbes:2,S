Date: Fri, 09 Sep 2005 11:42:26 +0200
From: "Jan Beulich" <>
Subject: Re: [PATCH] rmmod notifier chain (attempt 2)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/9/9/96

>>> Tom Rini <trini@kernel.crashing.org> 08.09.05 17:33:14 >>>
>On Thu, Sep 08, 2005 at 05:03:58PM +0200, Jan Beulich wrote:
>It's possible to do this a bit differently, if I'm guessing right at
>what NLKD does.  The following is from the KGDB patches (trimmed of
some
>other, unrelated to the notify part code):
I don't think the way you showed kgdb does this is quite useful;
especially calling the notifier chain with MODULE_GONE and a NULL module
seems rather pointless. I therefore used the placement as in the first
patch version, but deleted the extra notifier chain:
(Note: Patch also attached because the inline version is certain to
get
line wrapped.)
Debugging and maintenance support code occasionally needs to know not
only of module insertions, but also modulke removals. This adds a
notifier
chain for this purpose.
Signed-off-by: Jan Beulich <jbeulich@novell.com>
diff -Npru 2.6.13/include/linux/module.h
2.6.13-rmmod-notify/include/linux/module.h
--- 2.6.13/include/linux/module.h	2005-08-29 01:41:01.000000000
+0200
+++ 2.6.13-rmmod-notify/include/linux/module.h	2005-09-09
10:28:29.490342264 +0200
@@ -210,6 +210,7 @@ enum module_state
 	MODULE_STATE_LIVE,
 	MODULE_STATE_COMING,
 	MODULE_STATE_GOING,
+	MODULE_STATE_GONE
 };
 
 /* Similar stuff for section attributes. */
diff -Npru 2.6.13/kernel/module.c 2.6.13-rmmod-notify/kernel/module.c
--- 2.6.13/kernel/module.c	2005-08-29 01:41:01.000000000 +0200
+++ 2.6.13-rmmod-notify/kernel/module.c	2005-09-09
10:29:10.935041712 +0200
@@ -1165,6 +1165,10 @@ static int __unlink_module(void *_mod)
 /* Free a module, remove from lists, etc (must hold module mutex). */
 static void free_module(struct module *mod)
 {
+	down(&notify_mutex);
+	notifier_call_chain(&module_notify_list, MODULE_STATE_GONE,
mod);
+	up(&notify_mutex);
+
 	/* Delete from various lists */
 	stop_machine_run(__unlink_module, mod, NR_CPUS);
 	remove_sect_attrs(mod);
@@ -1910,9 +1914,13 @@ sys_init_module(void __user *umod,
                    buggy refcounters. */
 		mod->state = MODULE_STATE_GOING;
 		synchronize_sched();
-		if (mod->unsafe)
+		if (mod->unsafe) {
 			printk(KERN_ERR "%s: module is now stuck!\n",
 			       mod->name);
+			down(&notify_mutex);
+			notifier_call_chain(&module_notify_list,
MODULE_STATE_GONE, mod);
+			up(&notify_mutex);
+		}
 		else {
 			module_put(mod);
 			down(&module_mutex);
[unhandled content-type:application/octet-stream]