Date: Tue, 30 May 2006 16:40:32 +0800
From: Wu Fengguang <>
Subject: [patch 2/4] readahead: context based method - apply stream_shift size limits to contexta method
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/5/30/51

Apply size limits to the contexta method, so that the possible following
stateful method will not be presented too small stream_shift size.
Signed-off-by: Wu Fengguang <wfg@mail.ustc.edu.cn>
---
--- linux-2.6.17-rc4-mm3.orig/mm/readahead.c
+++ linux-2.6.17-rc4-mm3/mm/readahead.c
@@ -1388,13 +1388,12 @@ out_unlock:
  * Determine the request parameters for context based read-ahead that extends
  * from start of file.
  *
- * The major weakness of stateless method is perhaps the slow grow up speed of
- * ra_size. The logic tries to make up for this in the important case of
- * sequential reads that extend from start of file. In this case, the ra_size
- * is not chosen to make the whole next chunk safe (as in normal ones). Only
- * half of which is safe. The added 'unsafe' half is the look-ahead part. It
- * is expected to be safeguarded by rescue_pages() when the previous chunks are
- * lost.
+ * One major weakness of stateless method is the slow scaling up of ra_size.
+ * The logic tries to make up for this in the important case of sequential
+ * reads that extend from start of file. In this case, the ra_size is not
+ * chosen to make the whole next chunk safe (as in normal ones). Only part of
+ * which is safe: the tailing look-ahead part is 'unsafe'. However it will be
+ * safeguarded by rescue_pages() when the previous chunks are lost.
  */
 static int adjust_rala_aggressive(unsigned long ra_max,
 				unsigned long *ra_size, unsigned long *la_size)
@@ -1406,11 +1405,6 @@ static int adjust_rala_aggressive(unsign
 	*la_size = index * readahead_ratio / 100;
 	*ra_size += *la_size;
 
-	if (*ra_size > ra_max)
-		*ra_size = ra_max;
-	if (*la_size > *ra_size)
-		*la_size = *ra_size;
-
 	return 1;
 }
 
@@ -1474,6 +1468,8 @@ try_context_based_readahead(struct addre
 		ra_set_class(ra, RA_CLASS_CONTEXT);
 	}
 
+	limit_rala(ra_max, ra_index - index, &ra_size, &la_size);
+
 	ra_set_index(ra, index, ra_index);
 	ra_set_size(ra, ra_size, la_size);
 
--
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/