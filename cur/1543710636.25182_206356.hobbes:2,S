Date: Sun, 14 Mar 2004 19:18:59 +0100
From: Manfred Spraul <>
Subject: Re: [PATCH 2.4] sys_select() return error on bad file
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2004/3/14/82

Marcelo wrote:
>> 
>> Anyway, I don't see how your proposal would do better performance?
>> My patch just adds a new variable on the stack, which should not make any
>> difference in performance. And later, it is the same if the new or another
>> variable gets changed or checked.
>
>Curiosity: Does SuS/POSIX define behaviour for "all fds are closed" ? 
> 
>
I'd interpret SuS that a closed fd is ready for reading and writing:
 From the select page:
<<<
A descriptor shall be considered ready for reading when a call to an 
input function with O_NONBLOCK clear would not block, whether or not the 
function would transfer data successfully. (The function might return 
data, an end-of-file indication, or an error other than one indicating 
that it is blocked, and in each of these cases the descriptor shall be 
considered ready for reading.)
<<<
read(fd,,) will return immediately with EBADF, thus the fd is ready.
But that's a grey area, especially if you close the fd during the select 
call. For example HP UX just kills the current process if an fd that is 
polled is closed by overwriting it with dup2. I didn't test select, but 
I'd expect a similar behavior.
Armin: did you compare the Linux behavior with other unices? Are there 
other unices that return EBADF for select() if all fds are closed?
Attached is an untested proposal, against 2.6, but I'm not sure if it's 
really a good idea to change the current code - it might break existing 
apps.
--
    Manfred
--- 2.6/fs/select.c	2004-03-14 14:28:28.000000000 +0100
+++ build-2.6/fs/select.c	2004-03-14 19:08:57.000000000 +0100
@@ -223,25 +223,25 @@
 					break;
 				if (!(bit & all_bits))
 					continue;
+				mask = DEFAULT_POLLMASK;
 				file = fget(i);
 				if (file) {
 					f_op = file->f_op;
-					mask = DEFAULT_POLLMASK;
 					if (f_op && f_op->poll)
 						mask = (*f_op->poll)(file, retval ? NULL : wait);
 					fput(file);
-					if ((mask & POLLIN_SET) && (in & bit)) {
-						res_in |= bit;
-						retval++;
-					}
-					if ((mask & POLLOUT_SET) && (out & bit)) {
-						res_out |= bit;
-						retval++;
-					}
-					if ((mask & POLLEX_SET) && (ex & bit)) {
-						res_ex |= bit;
-						retval++;
-					}
+				}
+				if ((mask & POLLIN_SET) && (in & bit)) {
+					res_in |= bit;
+					retval++;
+				}
+				if ((mask & POLLOUT_SET) && (out & bit)) {
+					res_out |= bit;
+					retval++;
+				}
+				if ((mask & POLLEX_SET) && (ex & bit)) {
+					res_ex |= bit;
+					retval++;
 				}
 			}
 			if (res_in)