Date: Tue, 7 Nov 2006 21:06:05 +0900
From: Akinobu Mita <>
Subject: [PATCH 1/2] input: make serio_register_driver() return error code
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/11/7/88

serio_register_driver() may fail under memory shortage.
When serio_register_driver() called, it queues SERIO_REGISTER_DRIVER
event into global serio_event_list, and then kseriod kernel thread
handles that event and do driver_register().
But event allocation by serio_register_driver() may fail.
Because it is GFP_ATOMIC allocation. It will cause the problem
by serio_unregister_driver() with not being registered driver
at module_exit() time 
This patch makes serio_register_driver() call driver_register()
directly instead of kseriod so that it can check whether
driver_register() is succeeded or not.
Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
 drivers/input/serio/serio.c |   18 ++++--------------
 include/linux/serio.h       |    7 +------
 2 files changed, 5 insertions(+), 20 deletions(-)
Index: work-fault-inject/drivers/input/serio/serio.c
===================================================================
--- work-fault-inject.orig/drivers/input/serio/serio.c
+++ work-fault-inject/drivers/input/serio/serio.c
@@ -46,7 +46,7 @@ EXPORT_SYMBOL(__serio_register_port);
 EXPORT_SYMBOL(serio_unregister_port);
 EXPORT_SYMBOL(serio_unregister_child_port);
 EXPORT_SYMBOL(__serio_unregister_port_delayed);
-EXPORT_SYMBOL(__serio_register_driver);
+EXPORT_SYMBOL(serio_register_driver);
 EXPORT_SYMBOL(serio_unregister_driver);
 EXPORT_SYMBOL(serio_open);
 EXPORT_SYMBOL(serio_close);
@@ -175,7 +175,6 @@ enum serio_event_type {
 	SERIO_RECONNECT,
 	SERIO_REGISTER_PORT,
 	SERIO_UNREGISTER_PORT,
-	SERIO_REGISTER_DRIVER,
 };
 
 struct serio_event {
@@ -322,10 +321,6 @@ static void serio_handle_event(void)
 				serio_find_driver(event->object);
 				break;
 
-			case SERIO_REGISTER_DRIVER:
-				serio_add_driver(event->object);
-				break;
-
 			default:
 				break;
 		}
@@ -791,22 +786,17 @@ static struct bus_type serio_bus = {
 	.remove = serio_driver_remove,
 };
 
-static void serio_add_driver(struct serio_driver *drv)
+int serio_register_driver(struct serio_driver *drv)
 {
 	int error;
 
+	drv->driver.bus = &serio_bus;
 	error = driver_register(&drv->driver);
 	if (error)
 		printk(KERN_ERR
 			"serio: driver_register() failed for %s, error: %d\n",
 			drv->driver.name, error);
-}
-
-void __serio_register_driver(struct serio_driver *drv, struct module *owner)
-{
-	drv->driver.bus = &serio_bus;
-
-	serio_queue_event(drv, owner, SERIO_REGISTER_DRIVER);
+	return error;
 }
 
 void serio_unregister_driver(struct serio_driver *drv)
Index: work-fault-inject/include/linux/serio.h
===================================================================
--- work-fault-inject.orig/include/linux/serio.h
+++ work-fault-inject/include/linux/serio.h
@@ -91,12 +91,7 @@ static inline void serio_unregister_port
 	__serio_unregister_port_delayed(serio, THIS_MODULE);
 }
 
-void __serio_register_driver(struct serio_driver *drv, struct module *owner);
-static inline void serio_register_driver(struct serio_driver *drv)
-{
-	__serio_register_driver(drv, THIS_MODULE);
-}
-
+int serio_register_driver(struct serio_driver *drv);
 void serio_unregister_driver(struct serio_driver *drv);
 
 static inline int serio_write(struct serio *serio, unsigned char data)
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/