Date: Sun, 9 Mar 2008 20:27:45 +0100
From: Ingo Molnar <>
Subject: Re: quicklists confuse meminfo
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/3/9/149

* Ingo Molnar <mingo@elte.hu> wrote:
> > careful with this; the quicklists aren't JUST for speed they are 
> > also there to make sure a page we free that is a pagetable, is not 
> > reused until we have finished flushing the tlbs on all the cpus that 
> > saw it. This is a really hard correctness requirement, and while I 
> > can see that quicklists are probably not the best way to achieve 
> > this, we can't just throw away the behavior ;(
> 
> no, that's not true anymore - and the current quicklists code doesnt 
> do anything like that AFAICS. It used to be a lot more complex, but 
> now it's just a thin wrapper around the page allocator.
i.e. the patch below should do the trick.
(it's still work in progress but it seems to boot just fine)
	Ingo
------------>
Subject: x86: patches/remove-quicklists.patch
From: Ingo Molnar <mingo@elte.hu>
Date: Sun Mar 09 20:04:32 CET 2008
---
 arch/x86/mm/pgtable_32.c |   13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)
Index: linux-x86.q/arch/x86/mm/pgtable_32.c
===================================================================
--- linux-x86.q.orig/arch/x86/mm/pgtable_32.c
+++ linux-x86.q/arch/x86/mm/pgtable_32.c
@@ -10,7 +10,6 @@
 #include <linux/pagemap.h>
 #include <linux/spinlock.h>
 #include <linux/module.h>
-#include <linux/quicklist.h>
 
 #include <asm/system.h>
 #include <asm/pgtable.h>
@@ -338,12 +337,16 @@ static void pgd_mop_up_pmds(struct mm_st
 
 pgd_t *pgd_alloc(struct mm_struct *mm)
 {
-	pgd_t *pgd = quicklist_alloc(0, GFP_KERNEL, pgd_ctor);
+	pgd_t *pgd;
+
+	pgd = (void *)__get_free_page(GFP_KERNEL | __GFP_ZERO);
+	if (pgd)
+		pgd_ctor(pgd);
 
 	mm->pgd = pgd;		/* so that alloc_pd can use it */
 
 	if (pgd && !pgd_prepopulate_pmd(mm, pgd)) {
-		quicklist_free(0, pgd_dtor, pgd);
+		free_page((unsigned long)pgd);
 		pgd = NULL;
 	}
 
@@ -353,12 +356,12 @@ pgd_t *pgd_alloc(struct mm_struct *mm)
 void pgd_free(struct mm_struct *mm, pgd_t *pgd)
 {
 	pgd_mop_up_pmds(mm, pgd);
-	quicklist_free(0, pgd_dtor, pgd);
+	pgd_dtor(pgd);
+	free_page((unsigned long)pgd);
 }
 
 void check_pgt_cache(void)
 {
-	quicklist_trim(0, pgd_dtor, 25, 16);
 }
 
 void __pte_free_tlb(struct mmu_gather *tlb, struct page *pte)