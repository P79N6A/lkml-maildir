Date: Thu, 24 Feb 2005 16:43:33 -0800
From: Darren Hart <>
Subject: [PATCH] vm: mlock superfluous variable
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/2/24/328

The were a couple long standing (since at least 2.4.21) superfluous 
variables and two unnecessary assignments in do_mlock().  The intent of 
the resulting code is also more obvious.
Tested on a 4 way x86 box running a simple mlock test program.  No 
problems detected.
Signed-off-by: Darren Hart <dvhltc@us.ibm.com>n
diff -purN -X /home/dvhart/.diff.exclude /home/linux/views/linux-2.6.11-rc5/mm/mlock.c 2.6.11-rc5-mlock/mm/mlock.c
--- /home/linux/views/linux-2.6.11-rc5/mm/mlock.c	2004-12-24 15:26:12.000000000 -0800
+++ 2.6.11-rc5-mlock/mm/mlock.c	2005-02-24 13:57:38.000000000 -0800
@@ -58,8 +58,8 @@ out:
 
 static int do_mlock(unsigned long start, size_t len, int on)
 {
-	unsigned long nstart, end, tmp;
-	struct vm_area_struct * vma, * next;
+	unsigned long nstart, end;
+	struct vm_area_struct * vma;
 	int error;
 
 	len = PAGE_ALIGN(len);
@@ -86,13 +86,11 @@ static int do_mlock(unsigned long start,
 			break;
 		}
 
-		tmp = vma->vm_end;
-		next = vma->vm_next;
-		error = mlock_fixup(vma, nstart, tmp, newflags);
+		error = mlock_fixup(vma, nstart, vma->vm_end, newflags);
 		if (error)
 			break;
-		nstart = tmp;
-		vma = next;
+		nstart = vma->vm_end;
+		vma = vma->vm_next;
 		if (!vma || vma->vm_start != nstart) {
 			error = -ENOMEM;
 			break;