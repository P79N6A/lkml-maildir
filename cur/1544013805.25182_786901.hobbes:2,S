Date: Mon, 5 Jan 2009 13:42:56 +0100
From: Oleg Nesterov <>
Subject: Re: [PATCH 3/6][v5] Define siginfo_from_ancestor_ns()
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2009/1/5/144

On 12/27, Sukadev Bhattiprolu wrote:
>
> +static inline int siginfo_from_ancestor_ns(struct task_struct *t,
> +                       siginfo_t *info)
> +{
> +	struct pid_namespace *ns;
> +
> +	/*
> +	 * Ensure signal is from user-space before checking pid namespace.
> +	 * (We maybe called from interrupt context and dereferencing
> +	 * pid namespace would be safe).
> +	 */
> +	if (siginfo_from_user(info)) {
> +		/*
> +		 * If we do not have a pid in the receiver's namespace,
> +		 * we must be from an ancestor namespace.
> +		 *
> +		 * Note:
> +		 * 	If receiver is exiting, ns == NULL,
Confused. I thought we alread have the patch which ensures
task_active_pid_ns() is never NULL?
If not, we can get ns from task_pid(t). See also below.
>                       signal will be
> +		 * 	queued but eventually ignored anyway (wants_signal()
> +		 * 	is FALSE).
This is only true for thread-specific signals, please remove
this comment,
> +		ns = task_active_pid_ns(t);
> +		if (!ns || task_pid_nr_ns(current, ns) <= 0)
> +			return 1;
See above. In any case, we shouldn't return 1 if ns == NULL.
But afaics we always can know its namespace.
Oleg.