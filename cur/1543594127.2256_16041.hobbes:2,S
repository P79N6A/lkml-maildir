Date: Thu, 14 Jun 2001 00:42:31 +0400
From: Stas Sergeev <>
Subject: Re: [patch] do proper cleanups before requesting irq
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2001/6/13/120

Pavel Machek wrote:
> > The problem is that there are comparisons of pointers to task_struct when
> > deciding if the task is alive. If one task dies and other one starts, it is
> > possible (is it?) that the task structure of the newly created task resides
> > at the very address where was the dead one's, so comparing pointers is not
> > reliable. This patch changes it to comparisons of task's pids.
> > Can anyone, please, atleast tell me if this patch is correct?
> it might be better but it is not correct. pids are reused, too
Many thanks for reply.
If everything can be reused then it seems that the correct approach is to do a
cleanup when the task terminates, not when other one tries to request an irq.
The following patch does exactly this.
Please, once again, is this correct now?
------------------------------------------------------
--- linux/arch/i386/kernel/irq.h	Fri May 12 21:38:59 2000
+++ linux/arch/i386/kernel/irq.h	Wed Jun 13 18:44:06 2001
@@ -85,6 +85,7 @@
 extern void init_IRQ_SMP(void);
 extern int handle_IRQ_event(unsigned int, struct pt_regs *, struct irqaction *);
 extern int setup_x86_irq(unsigned int, struct irqaction *);
+extern void release_x86_irqs(struct task_struct *);
 
 /*
  * Various low-level irq details needed by irq.c, process.c,
--- linux/arch/i386/kernel/process.c	Mon Dec 11 17:29:12 2000
+++ linux/arch/i386/kernel/process.c	Wed Jun 13 18:58:00 2001
@@ -544,6 +544,7 @@
 
 void release_thread(struct task_struct *dead_task)
 {
+    release_x86_irqs(dead_task);
 }
 
 /*
--- linux/arch/i386/kernel/vm86.c	Sat May  5 06:31:51 2001
+++ linux/arch/i386/kernel/vm86.c	Wed Jun 13 19:01:26 2001
@@ -618,6 +618,14 @@
 	}
 	read_unlock(&tasklist_lock);
 	return ret;
+}
+
+void release_x86_irqs(struct task_struct *task)
+{
+	int i;
+	for (i=3; i<16; i++)
+	    if (vm86_irqs[i].tsk == task)
+		free_vm86_irq(i);
 }
 
 static inline void handle_irq_zombies(void)
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/