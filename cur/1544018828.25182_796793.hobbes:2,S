Date: Sun, 25 Jan 2009 21:04:42 -0800 (PST)
From: David Miller <>
Subject: Re: hardware time stamping with optional structs in data area
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2009/1/26/1

From: Patrick Ohly <patrick.ohly@intel.com>
Date: Wed, 21 Jan 2009 11:07:37 +0100
> I tested them with the modified PTPd with and without hardware support
> on x86. With 64 bit kernel and user space both works. With 32 bit user
> space on a 64 bit kernel software-only time stamping works (thanks to
> the socket's compatibility layer), hardware support doesn't: the ifreq
> is passed to the right device driver, but the data pointer from a 32 bit
> process is not interpreted correctly by a 64 bit driver. If there is a
> way to handle this then please let me know - I didn't see how a device
> driver could distinguish between a 32 and 64 bit user process.
See fs/compat_ioctl.c:dev_ifsioc() for how to handle the
"32-bit process under 64-bit kernel" issue wrt. struct ifreq
Next, I don't like that loop in the SKB allocator to deal with the
variable size.  You're computing what amounts to a constant
calculation.
Just consolidate the array into a direct conversion table.  You only
have 2 bits defined so you only need an array of 4 entries.  Pass the
optional flag bits directly in as the index of that table.