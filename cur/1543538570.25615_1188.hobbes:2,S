Date: Mon, 10 Jul 2000 16:58:20 +0200 (CEST)
From: Roberto Zunino <>
Subject: How to mix kernel_thread and SIGCHLD ?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/7/10/40

I'm modifying the 2.2.16 kernel to spawn a user process on certain
conditions. Do do this, I do
kernel_thread(kmyownd, NULL, CLONE_FS | CLONE_FILES | CLONE_SIGHAND);
at the end of init/main.c:do_basic_setup.
From kmyownd I wait for someone to wake me up and then I do another
kernel_thread(spawn_process, param, 0);
where spawn_process calls, well, kmod.c:exec_usermodehelper in order to
execve() the user process.
This runs nicely but for some reason I don't understand, kmyownd doesn't
get woken up when the child process dies. Therefore kmyownd cannot
waitpid() and a lot of zombies remain pending.
The signal mask should be ok since I siginitsetinv(&current->blocked,
sigmask(SIGCHLD)) in the parent. It seems that send_sig_info is doing
no-op because signal_ignored().
A possible solution (maybe) would be to spawn a process, wait for it to
die, spawn another, wait again for the new one, etc. etc. but I'd like to
have concurrent processes running and to server them when they die.
Could someone give me a hint? What should a kernel thread do to let its
children rest in peace?
Please note that I don't know the linux internals very well -- therefore
expect the most stupid mistakes from me :-)
Thanks,
Zun.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/