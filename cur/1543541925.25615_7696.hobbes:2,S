Date: Sun, 20 Aug 2000 19:38:35 -0700
From: Michael Peddemors <>
Subject: INITRD/RAMDISK/SYSLINUX booting fails with new kernel (vs 2.2 series)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/8/20/108

Haven't got ANY responses from my repeated requests that this may be an 
issue, and it is a fundamental requirement on my distro, and I found your 
Email in the devfs/util.c so I thought you should be able to steer me in the 
right direction.
Gettting a -ENODEV now with the new kernel, and I THINK it is because in 
./fs/super.c I do not get a handle returned.
I looked at devfs_make_root() in devfs/util.c and it seems to return without 
doing anything.  I am passing in the root= option as root=/dev/ram0
But this is initrd so I am not sure it is supposed to return anything other 
than the comments in the util.c file suggest so.
And as I understand it (forgive me if don't re-iterate clearly) with initrd, 
the bootloader (in this case syslinux) moves the compressed filesystem into 
/devram0 and when the initrd aware kernel boots up, it creates the ramdisks 
without disturbing the original ram device.  Then, when it is time for it to 
mount the root device, it will see that an initrd compressed image is in the 
/dev/ram location, uncompress it, and then continue. along it's processes.
So it seems that it doesn't see the original ram device.
Looked at devfs_find_handle and you would ASSUME that a handle would be 
found, however. I don't get one.  Looking at the parameters to the call as 
reported during bootup....
<These are my printk messages during bootup>
devfs_handle parameters in super.c
dir is NULL, ROO_DEVICE_NAME is ram0
MAJOR (ROOT_DEV) is 1
MINOR (ROOT_DEV) is 0
(And DEVFS_SPECIAL_BLOCK is a NULL pointer dereference)
No Handle found/defined in super.c
As from super.c
        handle = devfs_find_handle (NULL, ROOT_DEVICE_NAME,
                                    MAJOR (ROOT_DEV), MINOR (ROOT_DEV),
                                    DEVFS_SPECIAL_BLK, 1);
        printk(KERN_NOTICE "devfs_handle parameters in super.c\n");
        printk(KERN_NOTICE "dir is NULL, ROOT_DEVICE_NAME is 
%s\n",ROOT_DEVICE_NAME);
        printk(KERN_NOTICE "MAJOR (ROOT_DEV) is %d\n",MAJOR (ROOT_DEV));
        printk(KERN_NOTICE "MINOR (ROOT_DEV) is %d\n",MINOR (ROOT_DEV));
        if (handle)  /*  Sigh: bd*() functions only paper over the cracks  */
        {
            unsigned major, minor;
 
            devfs_get_maj_min (handle, &major, &minor);
            ROOT_DEV = MKDEV (major, minor);
        } else printk(KERN_NOTICE "No handle found/defined in super.c\n");
        if (!ROOT_DEV)
                panic("I have no root and I want to scream");
 
        bdev = bdget(kdev_t_to_nr(ROOT_DEV));
        if (!bdev)
                panic(__FUNCTION__ ": unable to allocate root device");
        bdev->bd_op = devfs_get_ops (handle);
        path_start = devfs_generate_path (handle, path + 5, sizeof (path) - 
5);
        mode = FMODE_READ;
        if (!(root_mountflags & MS_RDONLY))
                mode |= FMODE_WRITE;
        retval = blkdev_get(bdev, mode, 0, BDEV_FS);
        if (retval == -EROFS) {
                root_mountflags |= MS_RDONLY;
                retval = blkdev_get(bdev, FMODE_READ, 0, BDEV_FS);
        }
        /* At this point, we get a -ENODEV returned, this is the problem */   
  
What/where should I be looking next??
Am I off base wrrying about no handle?
Or is the problem earlier in the bootup sequence??
-- 
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
Please read the FAQ at 
http://www.tux.org/lkml/