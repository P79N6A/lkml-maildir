Date: Tue, 19 Feb 2008 23:16:18 -0600
From: Kumar Gala <>
Subject: Re: [PATCH] [LMB]: Fix lmb_add_region if region should be added at the head
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/2/20/5

On Feb 19, 2008, at 10:45 PM, David Miller wrote:
> From: Kumar Gala <galak@kernel.crashing.org>
> Date: Tue, 19 Feb 2008 22:27:48 -0600 (CST)
>
>> We introduced a bug in fixing lmb_add_region to handle an initial
>> region being non-zero.  Before that fix it was impossible to insert
>> a region at the head of the list since the first region always  
>> started
>> at zero.
>>
>> Now that its possible for the first region to be non-zero we need to
>> check to see if the new region should be added at the head and if so
>> actually add it.
>>
>> Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
> ...
>> @@ -184,6 +184,11 @@ static long __init lmb_add_region(struct  
>> lmb_region *rgn, u64 base, u64 size)
>> 			break;
>> 		}
>> 	}
>> +
>> +	if (base < rgn->region[0].base) {
>> +		rgn->region[0].base = base;
>> +		rgn->region[0].size = size;
>> +	}
>> 	rgn->cnt++;
>>
>> 	return 0;
>
> Are you sure this is sufficient?
>
> It seems to me, to handle this properly, you'll need to handle
> the case where the lower addressed entry you are inserting is
> not contiguous with the existing entry 0.
>
> Therefore, you need to move all existing entries up a slot,
> then you can set the 0 entry to 'base' and 'size'.
The for loop above the code I added will move all the existing slots  
up one.  Its just the tail cleanup we are missing.
- k