Date: Wed, 28 Jan 2009 14:47:08 +1100
From: Bron Gondwana <>
Subject: [PATCH 2/3] epoll: allow 0 for "unlimited" on epoll limits
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2009/1/27/444

If you set 0 as the limit for max_user_watches or max_user_instances,
then treat them as unlimited.
Note - this doesn't disable the accounting, just the limit test.
Signed-off-by: Bron Gondwana <brong@fastmail.fm>
---
 Documentation/filesystems/proc.txt |    4 ++++
 fs/eventpoll.c                     |    8 ++++----
 2 files changed, 8 insertions(+), 4 deletions(-)
diff --git a/Documentation/filesystems/proc.txt b/Documentation/filesystems/proc.txt
index 4677abf..c4debd3 100644
--- a/Documentation/filesystems/proc.txt
+++ b/Documentation/filesystems/proc.txt
@@ -2244,6 +2244,8 @@ If you are running a heavily loaded Postfix or Apache server, you may need
 to set this higher.  Both these servers run an epoll instance per child 
 process.
 
+Setting max_user_instances to '0' makes it unlimited.
+
 max_user_watches
 ----------------
 
@@ -2256,6 +2258,8 @@ on a 64bit one.
 The current default value for  max_user_watches  is the 1/32 of the available
 low memory, divided for the "watch" cost in bytes.
 
+Setting max_user_watches to '0' makes it unlimited.
+
 
 ------------------------------------------------------------------------------
 
diff --git a/fs/eventpoll.c b/fs/eventpoll.c
index 16eb817..c6d5c1d 100644
--- a/fs/eventpoll.c
+++ b/fs/eventpoll.c
@@ -582,8 +582,8 @@ static int ep_alloc(struct eventpoll **pep)
 
 	user = get_current_user();
 	error = -EMFILE;
-	if (unlikely(atomic_read(&user->epoll_devs) >=
-			max_user_instances))
+	if (unlikely(max_user_instances &&
+	            (max_user_instances < atomic_read(&user->epoll_devs))))
 		goto free_uid;
 	error = -ENOMEM;
 	ep = kzalloc(sizeof(*ep), GFP_KERNEL);
@@ -761,8 +761,8 @@ static int ep_insert(struct eventpoll *ep, struct epoll_event *event,
 	struct epitem *epi;
 	struct ep_pqueue epq;
 
-	if (unlikely(atomic_read(&ep->user->epoll_watches) >=
-		     max_user_watches))
+	if (unlikely(max_user_watches &&
+                    (max_user_watches < atomic_read(&ep->user->epoll_watches))))
 		return -ENOSPC;
 	if (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))
 		return -ENOMEM;
-- 
1.5.6.3