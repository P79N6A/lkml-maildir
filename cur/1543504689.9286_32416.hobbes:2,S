Date: Tue, 03 Aug 1999 17:05:53 +0900
From: Kuniyasu SUZAKI <>
Subject: sched_rr_get_interval() and *REAL* time quantum of SCHED_RR
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/8/3/42

Please tell me the meaning of sched_rr_get_interval() and *REAL* time
quantum of SCHED_RR.
I was thinking sched_rr_get_interval() returns the time quantum of
round robin scheduling at "SCHED_RR".  However the returned value of
sched_rr_get_interval() and the real period of round robin scheduling
were different. I add the check program at the bottom of this mail.
The results as follows.
bash# ./rr_time 
SCHED_RR
priority = 99
sched_rr_get_interval() returns 0.000150 sec
RR processes: 1452 1453
Real time quantum of SCHED_RR
0.092238 sec
0.209990 sec
0.209996 sec
0.209997 sec
0.209995 sec
0.209996 sec
0.209996 sec
0.209998 sec
0.210016 sec
0.209975 sec
sched_rr_get_interval() told me that 0.000150 sec was time quantum of
SCHED_RR but the real time quantum was about 0.2 sec except first
execution.
The period of round robin scheduling was looked to be decided by the
"counter" value of task struct which is used scheduling. The return
value of sched_rr_get_interval() was fixed 150us in "kernel/sched.c".
What does the time 150us mean? Why doesn't sched_rr_get_interval()
return the time calculated by "counter" value?
And I would like to change "counter" value of task struct because I
want to change the time quantum of SCHED_RR from another process. 
The sched_yield() changes the counter value to ZERO but it is allowed
only for the current process.
Is there any techniques to change the the "counter" value?
Please help me. Thank you.
PS
On Solaris sched_rr_get_interval() returned the real period of round
robin.
					Sincerely yours,
					Kuniyasu Suzaki
					Electrotechnical Lab
------- check program "rr_time.c" -------
/*
  Linux
  gcc -o rr_time rr_time.c
  Solaris
  gcc -DSOLARIS -o rr_time rr_time.c -lposix4
*/
#include <unistd.h>
#include <sched.h>
#include <stdio.h>
#include <errno.h>
#include <sys/time.h>
#include <time.h>
#include <signal.h>
#include <sys/types.h>
#include <sched.h>
#define TIMES 10
main()
{
  int max;
  pid_t child;
  int i;
  int policy;
  float ftmp;
  struct sched_param param;
  struct timespec rr_period;
  struct timeval on[TIMES];
  struct timeval off[TIMES];
  struct timezone tz;
  if((max = sched_get_priority_max(SCHED_RR)) == -1) {
    perror("sched_get_priority_max");
    exit(1);
  }
  param.sched_priority = max;
  if(sched_setscheduler(getpid(),SCHED_RR,&param) == -1){
    perror("sched_setscheduler");
    exit(1);
  }
  
  if((policy = sched_getscheduler(getpid())) != -1) {
    switch(policy) {
    case 0:
      printf("SCHED_OTHER\n");
      break;
    case 1:
      printf("SCHED_FIFO\n");
      break;
    case 2:
      printf("SCHED_RR\n");
      break;
#ifdef SOLARIS
    case 3:
      printf("SCHED_SYS\n");
      break;
    case 4:
      printf("SCHED_IA\n");
      break;
    case 5:
      printf("_SCHED_NEXT\n");
      break;
#endif
    default:
      printf("Unknown Scheduling (No.%d)\n",policy);
      break;
    }
  }
  
  if(sched_getparam(getpid(),&param) != 0) {
    perror("sched_getparam");
    exit(1);
  }
  printf("priority = %d\n",param.sched_priority);
  if(sched_rr_get_interval(0,&rr_period) == -1) {
    perror("sched_rr_get_interval");
    exit(1);
  }
  printf("sched_rr_get_interval() returns %f sec\n",((double)rr_period.tv_sec) +  (((double)rr_period.tv_nsec)*0.000000001));
  child = fork();
  if(child == 0) {
    /*** child process ***/
    /*** it inherits SCHED_RR scheduling. ***/
    while(1) {  /*** the loop waste time till the kernel execute context switch ***/
      for(i = 0; i < 100; i++) {
	ftmp = (float)(1) / 1000.0;
      }
    }
    exit(1); /*** never reach ***/
  }
  for(i = 0; i < TIMES; i++) {
    gettimeofday(&(on[i]),&tz);
    if(sched_yield() == -1) {
      perror("sched_yield()");
      exit(1);
    }
    gettimeofday(&(off[i]),&tz);
  }
  printf("RR processes: %d %d\n",getpid(),child);
  printf("Real time quantum of SCHED_RR\n");
  kill(child,SIGINT);
  for(i = 0; i < TIMES; i++) {
    printf("%f sec\n",
	   ((double)(off[i].tv_sec - on[i].tv_sec)) +  (((double)(off[i].tv_usec - on[i].tv_usec))*0.000001));
  }
  exit(1);
}
------- end of check program "rr_time.c" -------
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/