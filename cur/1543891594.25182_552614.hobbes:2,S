Date: Sun, 3 Jun 2007 20:07:08 +0200 (CEST)
From: Jan Kratochvil <>
Subject: Re: [PATCH] Support for controlling leds on xbox 360 pad.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/6/3/136

Hi,
  the previous patch made led support dependent on force feedback. Which 
doesn't make sense from user point of view. So this patch removes this odd 
dependency. I made it in separate patch to make my changes easier to 
review.
Led support of xbox 360 now doesn't depend on force feedback.
Signed-off-by: Jan Kratochvil <honza@jikos.cz>
---
  drivers/input/joystick/Kconfig |    2 +-
  drivers/input/joystick/xpad.c  |   87 ++++++++++++++++++++++------------------
  2 files changed, 49 insertions(+), 40 deletions(-)
diff --git a/drivers/input/joystick/Kconfig b/drivers/input/joystick/Kconfig
index 2098ab6..e6c7560 100644
--- a/drivers/input/joystick/Kconfig
+++ b/drivers/input/joystick/Kconfig
@@ -276,7 +276,7 @@ config JOYSTICK_XPAD_FF
  config JOYSTICK_XPAD_LEDS
  	bool "LED Support for Xbox360 controller 'BigX' LED"
-	depends on LEDS_CLASS && JOYSTICK_XPAD_FF
+	depends on LEDS_CLASS && JOYSTICK_XPAD
  	---help---
  	  This option enables support for the LED which surrounds the Big X on
  	  XBox 360 controller.
diff --git a/drivers/input/joystick/xpad.c b/drivers/input/joystick/xpad.c
index 4a51d6f..b51229f 100644
--- a/drivers/input/joystick/xpad.c
+++ b/drivers/input/joystick/xpad.c
@@ -194,7 +194,7 @@ struct usb_xpad {
  	unsigned char *idata;		/* input data */
  	dma_addr_t idata_dma;
-#ifdef CONFIG_JOYSTICK_XPAD_FF
+#if defined(CONFIG_JOYSTICK_XPAD_FF) || defined(CONFIG_JOYSTICK_XPAD_LEDS)
  	struct urb *irq_out;		/* urb for interrupt out report */
  	unsigned char *odata;		/* output data */
  	dma_addr_t odata_dma;
@@ -358,7 +358,7 @@ exit:
  		     __FUNCTION__, retval);
  }
-#ifdef CONFIG_JOYSTICK_XPAD_FF
+#if defined(CONFIG_JOYSTICK_XPAD_FF) || defined(CONFIG_JOYSTICK_XPAD_LEDS)
  static void xpad_irq_out(struct urb *urb)
  {
  	int retval;
@@ -385,28 +385,7 @@ exit:
  		   __FUNCTION__, retval);
  }
-int xpad_play_effect(struct input_dev *dev, void *data, struct ff_effect *effect)
-{
-	struct usb_xpad *xpad = input_get_drvdata(dev);
-
-	if (effect->type == FF_RUMBLE) {
-		__u16 strong = effect->u.rumble.strong_magnitude;
-		__u16 weak = effect->u.rumble.weak_magnitude;
-		xpad->odata[0] = 0x00;
-		xpad->odata[1] = 0x08;
-		xpad->odata[2] = 0x00;
-		xpad->odata[3] = strong / 256;
-		xpad->odata[4] = weak / 256;
-		xpad->odata[5] = 0x00;
-		xpad->odata[6] = 0x00;
-		xpad->odata[7] = 0x00;
-		usb_submit_urb(xpad->irq_out, GFP_KERNEL);
-	}
-
-	return 0;
-}
-
-static int xpad_init_ff(struct usb_interface *intf, struct usb_xpad *xpad)
+static int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad)
  {
  	struct usb_endpoint_descriptor *ep_irq_out;
  	int error = -ENOMEM;
@@ -433,25 +412,19 @@ static int xpad_init_ff(struct usb_inter
  	xpad->irq_out->transfer_dma = xpad->odata_dma;
  	xpad->irq_out->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
-	input_set_capability(xpad->dev, EV_FF, FF_RUMBLE);
-
-	error = input_ff_create_memless(xpad->dev, NULL, xpad_play_effect);
-	if (error)
-		goto fail2;
-
  	return 0;
   fail2:	usb_buffer_free(xpad->udev, XPAD_PKT_LEN, xpad->odata, xpad->odata_dma);
   fail1:	return error;
  }
-static void xpad_stop_ff(struct usb_xpad *xpad)
+static void xpad_stop_output(struct usb_xpad *xpad)
  {
  	if (xpad->xtype == XTYPE_XBOX360)
  		usb_kill_urb(xpad->irq_out);
  }
-static void xpad_deinit_ff(struct usb_xpad *xpad)
+static void xpad_deinit_output(struct usb_xpad *xpad)
  {
  	if (xpad->xtype == XTYPE_XBOX360) {
  		usb_free_urb(xpad->irq_out);
@@ -459,11 +432,43 @@ static void xpad_deinit_ff(struct usb_xp
  				xpad->odata, xpad->odata_dma);
  	}
  }
+#else
+static int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad) { return 0; }
+static void xpad_deinit_output(struct usb_xpad *xpad) {}
+static void xpad_stop_output(struct usb_xpad *xpad) {}
+#endif
+
+#ifdef CONFIG_JOYSTICK_XPAD_FF
+int xpad_play_effect(struct input_dev *dev, void *data, struct ff_effect *effect)
+{
+	struct usb_xpad *xpad = input_get_drvdata(dev);
+
+	if (effect->type == FF_RUMBLE) {
+		__u16 strong = effect->u.rumble.strong_magnitude;
+		__u16 weak = effect->u.rumble.weak_magnitude;
+		xpad->odata[0] = 0x00;
+		xpad->odata[1] = 0x08;
+		xpad->odata[2] = 0x00;
+		xpad->odata[3] = strong / 256;
+		xpad->odata[4] = weak / 256;
+		xpad->odata[5] = 0x00;
+		xpad->odata[6] = 0x00;
+		xpad->odata[7] = 0x00;
+		usb_submit_urb(xpad->irq_out, GFP_KERNEL);
+	}
+
+	return 0;
+}
+
+static int xpad_init_ff(struct usb_xpad *xpad)
+{
+	input_set_capability(xpad->dev, EV_FF, FF_RUMBLE);
+
+	return input_ff_create_memless(xpad->dev, NULL, xpad_play_effect);
+}
  #else
-static int xpad_init_ff(struct usb_interface *intf, struct usb_xpad *xpad) { return 0; }
-static void xpad_stop_ff(struct usb_xpad *xpad) { }
-static void xpad_deinit_ff(struct usb_xpad *xpad) { }
+static int xpad_init_ff(struct usb_xpad *xpad) { return 0; }
  #endif
  #if defined(CONFIG_JOYSTICK_XPAD_LEDS) 
@@ -599,7 +604,7 @@ static void xpad_close(struct input_dev
  	struct usb_xpad *xpad = input_get_drvdata(dev);
  	usb_kill_urb(xpad->irq_in);
-	xpad_stop_ff(xpad);
+	xpad_stop_output(xpad);
  }
  static void xpad_set_up_abs(struct input_dev *input_dev, signed short abs)
@@ -691,10 +696,14 @@ static int xpad_probe(struct usb_interfa
  		for (i = 0; xpad_abs_pad[i] >= 0; i++)
  		    xpad_set_up_abs(input_dev, xpad_abs_pad[i]);
-	error = xpad_init_ff(intf, xpad);
+	error = xpad_init_output(intf, xpad);
  	if (error)
  		goto fail2;
+	error = xpad_init_ff(xpad);
+	if (error)
+		goto fail3;
+
  	error = xpad_led_probe(xpad);
  	if (error)
  		goto fail3;
@@ -715,7 +724,7 @@ static int xpad_probe(struct usb_interfa
  	return 0;
  fail4:	usb_free_urb(xpad->irq_in);
-fail3:	xpad_deinit_ff(xpad);
+fail3:	xpad_deinit_output(xpad);
  fail2:	usb_buffer_free(udev, XPAD_PKT_LEN, xpad->idata, xpad->idata_dma);
  fail1:	input_free_device(input_dev);
  	kfree(xpad);
@@ -731,7 +740,7 @@ static void xpad_disconnect(struct usb_i
  	if (xpad) {
  		xpad_led_disconnect(xpad);
  		input_unregister_device(xpad->dev);
-		xpad_deinit_ff(xpad);
+		xpad_deinit_output(xpad);
  		usb_free_urb(xpad->irq_in);
  		usb_buffer_free(xpad->udev, XPAD_PKT_LEN,
  				xpad->idata, xpad->idata_dma);
-- 
1.4.3.4
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/