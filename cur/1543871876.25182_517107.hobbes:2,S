Date: Wed, 7 Mar 2007 12:56:07 -0800 (PST)
From: Davide Libenzi <>
Subject: Re: [patch 1/4] signalfd v1 - signalfd core ...
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/3/7/543

On Wed, 7 Mar 2007, Jeremy Fitzhardinge wrote:
> Davide Libenzi wrote:
> > On Wed, 7 Mar 2007, Linus Torvalds wrote:
> >
> > 
> >> On Wed, 7 Mar 2007, Stephen Rothwell wrote:
> >> 
> >>> You probably need the queue anyway because the real time signals are
> >>> supposed to queue.
> >>> 
> >> Davide - the *real* problem is (I think) that you try to allow signals to 
> >> be returned *both* by signalfd() and as a real signal.
> >>
> >> That's wrong, wrong, wrong.
> >>
> >> My original patch used "dequeue_signal()" to dequeue signals. Trust me, I 
> >> did that for a reason. Your re-design to think that you can get the signal 
> >> without using the real signal dequeueing is simply broken.
> >> 
> >
> > I think having the ability to have both can be usefull, so the idea of 
> > having multiple listeners fd (that both would not work with the single 
> > queue since they'd racing over dequeue_signal).
> > 
> 
> Do you have a specific use-case in mind?  Because I don't think this is
> very useful at all; in fact it may be the opposite of useful.
> 
> Generally signals are "owned" by one particular piece of code, and if
> you want to distribute the event further then you do that in the app, as
> you have to do with a normal signal handler.  This code is the fd-based
> analog of sigtimedwait, and so it should behave basically the same way. 
> If multiple threads call sigtimedwait on the same signal set, then one
> and only one will receive each signal.  This is good, because it means
> you can have a thread pool processing signals (and other events) knowing
> that there won't be duplicate processing.
> 
> I haven't looked at your code in detail, but it isn't clear from your
> description whether you can have multiple signalfds for different
> (distinct) sets of signals.  That would be useful as a first level of
> demultiplexing between multiple user-mode signal consumers.  If you
> allow that, you need to decide whether a read/poll on a signalfd blocks
> until the head queued signal is part of the signal set, or if any queued
> signal is in the set.
If you think a signal as a generic event source, than you see how more 
instances can attach to it and receive them.
You can have multiple signalfd with whatever sigmasks, even intersecting. 
You can pass the fd around, w/out the fear that a standard signal delivery 
would race with you on dequeue_signal (making you block after you got a 
POLLIN). You can have both standard and file based devliery, or you can 
not. Up to you. If you don't want to, you block them, otherwise you 
don't. It's flexible, and the code is like 20 lines more, and race-free.
Since the siginfo needed to be delivered too, at that point doing it over 
a read(2) would have messed up things [1], so I added a new syscall:
int signalfd_dequeue(int fd, siginfo_t *info, long timeo);
And the compat_ counter-part.
[1] I thought about having a compat-free siginfo to be pulled from 
    read(2), but that resulted to be messy, while we already have code to 
    ship siginfos to userspace.
- Davide
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/