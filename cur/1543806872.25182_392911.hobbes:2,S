Date: Thu, 02 Feb 2006 13:37:48 -0800
From: Roland Dreier <>
Subject: Re: Question about memory barriers
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/2/2/346

>>>>> "Alan" == Alan Stern <stern@rowland.harvard.edu> writes:
    Alan> The kernel's documentation about memory barriers is rather
    Alan> skimpy.  I gather that rmb() guarantees that all preceding
    Alan> reads will have completed before any following reads are
    Alan> made, and wmb() guarantees that all preceding writes will
    Alan> have completed before any following writes are made.  I also
    Alan> gather that mb() is essentially the same as rmb() and wmb()
    Alan> put together.
Most of this is correct, except that mb() is stronger than just rmb()
and wmb() put together.  All memory operations before the mb() will
complete before any operations after the mb().  A better way to
understand this is to look at the sparc64 definition:
#define mb()    \
        membar_safe("#LoadLoad | #LoadStore | #StoreStore | #StoreLoad")
    Alan> But suppose I need to prevent a read from being moved past a
    Alan> write?  It doesn't look like either rmb() or wmb() will do
    Alan> this.  And if mb() is the same as "rmb(); wmb();" then it
    Alan> won't either.  So what's the right thing to do?
As described above, mb() will work in this case.  It actually
guarantees more than you need, so you could conceivably define a new
primitive, but the current barriers are hard enough for people to
figure out ;)
 - R.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/