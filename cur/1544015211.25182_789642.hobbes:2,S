Date: Sat, 10 Jan 2009 02:08:51 +0100
From: Andi Kleen <>
Subject: Re: [patch] measurements, numbers about CONFIG_OPTIMIZE_INLINING=y impact
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2009/1/9/500

> I thought -Os actually disabled the basic-block reordering, doesn't it?
Not in current gcc head no (just verified by stepping through) 
> 
> And I thought it did that exactly because it generates bigger code and 
> much worse I$ patterns (ie you have a lot of "conditional branch to other 
> place and then unconditional branch back" instead of "conditional branch 
> over the non-taken code".
> 
> Also, I think we've had about as much good luck with guessing 
> "likely/unlikely" as we've had with "inline" ;)
That's true.
But if you look at the default heuristics that gcc has (gcc/predict.def
in the gcc sources) like == NULL, < 0, branch guarding etc.
I would expect a lot of them to DTRT for the kernel.
Honza at some point even fixed goto to be unlikely after I complained :)
> Sadly, apart from some of the "never happens" error cases, the kernel 
> doesn't tend to have lots of nice patterns. We have almost no loops (well, 
> there are loops all over, but most of them we hopefully just loop over 
> once or twice in any good situation), and few really predictable things.
That actually makes us well suited to gcc, it has a relatively poor
loop optimizer compared to other compilers ;-)
> Or rather, they can easily be very predictable under one particular load, 
> and the totally the other way around under another ..
Yes that is why we got good branch predictors in CPUs I guess.
-Andi
-- 
ak@linux.intel.com