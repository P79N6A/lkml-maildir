Date: Thu, 23 Jun 2005 11:09:13 -0400 (EDT)
From: "Richard B. Johnson" <>
Subject: Re: Possible spin-problem in nanosleep()
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/6/23/200

Andreas,
Additional input: It seems that it's not the usleep(), but
some kind of scheduling phenomena makes the difference.
The following code will show different amounts of CPU time
after a few hours of running on an otherwise unused
system (not even a network card), a real "quiet" system.
The first task forked() seems to get about 5 times the CPU
time of the second. Since the first task used nanosecond()
it was blamed on nanosecond(), but instead it seems to have
something to do with the order in which children are created.
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
int main(int argx, char *argv[])
{
     volatile int i;
     struct timespec ts;
     switch(fork())
     {
     case 0:	// Child
         strcpy(argv[0], "Using nanosleep()");
         for(;;)
         {
             ts.tv_sec = 0;
             ts.tv_nsec = 1000000;		// 1 milisecond
             (void)nanosleep(&ts, NULL);
             for(i=0; i< 0x00010000; i++)	// Do work
                 ;
         }
         break;
     case -1:	// Failure
         abort();
         break;
     default:
         break;
     }
     switch(fork())
     {
     case 0:	// Child
         strcpy(argv[0], "Using usleep()");
         for(;;)
         {
             (void)usleep(1000);			// 1 millisecond
             for(i=0; i< 0x00010000; i++)	// Do work
                 ;
         }
         break;
     case -1:	// Failure
         abort();
         break;
     default:
         break;
     }
     pause();
     return 0;
}
On Thu, 23 Jun 2005, Richard B. Johnson wrote:
> On Thu, 23 Jun 2005, Andreas Schwab wrote:
>
>> "Richard B. Johnson" <linux-os@analogic.com> writes:
>> 
>>> nanosleep() appears to have a problem. It may be just an
>>> 'accounting' problem, but it isn't pretty. Code that used
>>> to use usleep() to spend most of it's time sleeping, used
>>> little or no CPU time as shown by `top`. The same code,
>>> converted to nanosleep() appears to spend a lot of CPU
>>> cycles spinning. The result is that `top` or similar
>>> programs show lots of wasted CPU time.
>> 
>> usleep() is just a wrapper around nanosleep().  Are you sure you got the
>> units right?
>> 
>> Andreas.
>> 
>
> Yeah nano is -9 micro is -6, three more zeros when using nano.
> I note that the actual syscall is __NR_nanosleep = 162. I don't
> understand the discrepancy either.
>
>> -- 
>> Andreas Schwab, SuSE Labs, schwab@suse.de
>> SuSE Linux Products GmbH, Maxfeldstraße 5, 90409 Nürnberg, Germany
>> Key fingerprint = 58CA 54C7 6D53 942B 1756  01D3 44D5 214B 8276 4ED5
>> "And now for something completely different."
>> 
>
> Cheers,
> Dick Johnson
> Penguin : Linux version 2.6.12 on an i686 machine (5537.79 BogoMips).
> Notice : All mail here is now cached for review by Dictator Bush.
>                 98.36% of all statistics are fiction.
Cheers,
Dick Johnson
Penguin : Linux version 2.6.12 on an i686 machine (5537.79 BogoMips).
  Notice : All mail here is now cached for review by Dictator Bush.
                  98.36% of all statistics are fiction.