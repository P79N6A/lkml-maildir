Date: Tue, 20 Feb 2007 19:05:19 -0500
From: Trond Myklebust <>
Subject: Re: [PATCH] aio: propogate post-EIOCBQUEUED errors to completion event
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/2/20/379

On Tue, 2007-02-20 at 10:40 -0800, Zach Brown wrote:
> >> There are some strange O_DIRECT corner cases in here such that the  
> >> 'last
> >> writer' may actually be a 'last reader' and winning can mean have  
> >> a copy
> >> of the page in page cache older than the copy on disk.
> >
> > As long as it is marked dirty so that it eventually gets synced to  
> > disk,
> > it shouldn't matter.
> 
> No, Chris is pointing out that an an O_DIRECT write can leave clean  
> read pages in the page cache.
>
> All it takes is giving a source buffer for the write which is an mmap 
> ()ed apeture of the region that is being written to.  If you get the  
> offsets right you can get the get_user_pages() down in fs/direct-io.c  
> will populate the page cache before the actual O_DIRECT write gets to  
> it.
With invalidate_inode_pages2()? That is supposed to wait until the page
lock is taken -> read is done. It then calls unmap_mapping_range() which
will remove the offending page from any existing mappings. Sure an
application could get stale data, but if it is reading while an O_DIRECT
write is proceeding, then it gets what it deserves.
Trond
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/