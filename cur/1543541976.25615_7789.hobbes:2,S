Date: Mon, 21 Aug 2000 12:35:52 -0300
From: Arnaldo Carvalho de Melo <>
Subject: [PATCH] drivers/scsi/atp870u.c: resource alloc fixes
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/8/21/89

Hi,
     Please take a look and consider applying. The driver author/maintainer
was not found neither in the driver sources nor in CREDITS/MAINTAINERS.
                        - Arnaldo
PS.: this patch is dedicated to Mike Galbraith 8)
--- linux-2.4.0-test7-pre5/drivers/scsi/atp870u.c	Fri Jul  7 19:55:24 2000
+++ linux-2.4.0-test7-pre5.acme/drivers/scsi/atp870u.c	Mon Aug 21 12:26:40 2000
@@ -5,6 +5,7 @@
  *  2.1.x update (C) 1998  Krzysztof G. Baranowski
  *
  * Marcelo Tosatti <marcelo@conectiva.com.br> : SMP fixes
+ * Arnaldo Carvalho de Melo <marcelo@conectiva.com.br> : resource allocation fixes
  *
  * Wu Ching Chen : NULL pointer fixes  2000/06/02
  *		   support atp876 chip
@@ -1627,23 +1628,26 @@
 	struct Scsi_Host *shpnt = NULL;
 	int tmpcnt = 0;
 	int count = 0;
+	struct atp_unit *dev;
 
 	static unsigned short devid[8] = {
 		0x8002, 0x8010, 0x8020, 0x8030, 0x8040, 0x8050, 0x8060, 0
 	};
 
 	printk(KERN_INFO "aec671x_detect: \n");
-	if (!pci_present()) {
+	if (!pci_present()) {      /* FIXME: use new PCI API */
 		printk(KERN_INFO"   NO PCI SUPPORT.\n");
-		return count;
+		return 0;
 	}
 	tpnt->proc_name = "atp870u";
 
 	for (h = 0; h < 2; h++) {
-		struct atp_unit *dev = &atp_unit[h];
+		dev = &atp_unit[h];
 		for(k=0;k<16;k++)
 		{
 			dev->id[k].prd_tableu = kmalloc(1024, GFP_KERNEL);
+			if (!dev->id[k].prd_tableu)
+				goto cleanup_prd_tableu;
 			dev->id[k].devspu=0x20;
 			dev->id[k].devtypeu = 0;
 			dev->id[k].curr_req = NULL;
@@ -1698,7 +1702,7 @@
 			break;
 	}
 	for (h = 0; h < 2; h++) {
-		struct atp_unit *dev=&atp_unit[h];
+		dev = &atp_unit[h];
 		if (pdev[h]==NULL) {
 			return count;
 		}
@@ -1760,7 +1764,7 @@
 		tmport += 0x18;
 		outb(0, tmport);
 		tmport += 0x07;
-		while ((inb(tmport) & 0x80) == 0);
+		while ((inb(tmport) & 0x80) == 0); /* FIXME */
 		tmport -= 0x08;
 		inb(tmport);
 		tmport = base_io + 1;
@@ -1785,8 +1789,8 @@
 		shpnt->io_port = base_io;
 		shpnt->n_io_port = 0x40;	/* Number of bytes of I/O space used */
 		shpnt->irq = irq;
-		restore_flags(flags);
 		request_region(base_io, 0x40, "atp870u");       /* Register the IO ports that we use */
+		restore_flags(flags); /* makes request_region safer for now, but we need to get rid of check_region */
 		count++;
 		index++;
 		continue;
@@ -1798,6 +1802,12 @@
 	}
 
 	return count;
+cleanup_prd_tableu:
+	while(--k >= 0) {
+		kfree(dev->id[k].prd_tableu);
+		dev->id[k].prd_tableu = NULL;
+	}
+	return 0;
 }
 
 /* The abort command does not leave the device in a clean state where
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
Please read the FAQ at 
http://www.tux.org/lkml/