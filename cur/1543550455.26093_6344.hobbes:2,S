Date: Mon, 2 Oct 2000 16:51:21 -0700
From: Torrey Hoffman <>
Subject: [patch] Make linux logo centered, add margins, etc. for 2.2.17
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/10/2/58

This is a patch to linux-2.2.17.
As you all probably know, the current framebuffer driver (fbcon.c) 
displays an 80x80 pixel penguin logo at the top left of the screen.
This patch modifies fbcon.c to display the linux logo centered 
horizontally, with optional margins (LOGO_MARGIN) above and below.  
The boot console displays in the remaining space.
It also cleans up the code a little to move the LOGO_W and LOGO_H
defines to the linux_logo.h header file, where they ought to be.
I have successfully used this code to display a large (472x320) logo
with the vesa framebuffer on i386 during boot. That only requires
replacing the include/linux/linux_header.h file.
This patch is currently untested on anything else, and I would be 
interested in bug reports.
Note that using large logos can dramatically increase the size of
your zImage kernel. Also I'm not 100% confident the patch is correct,
as I'm not a kernel guru (yet). (Why does fbcon_show_logo() have a 
loop that looks at smp_num_cpus?)
Anyway, if you find this interesting, you may also like to know that 
I have updated the "glogo" gimp plugin, (which is GPL'ed and copyright
(C) 1998 Jens Ch. Restemeier <jrestemeier@currantbun.com>) to support:
 - this modified linux_logo.h header format
 - logos of variable size, instead of just 80x80 pixels
 - gimp 1.1.26
If you want my version of glogo, just ask me.  If this patch is
considered for inclusion in the official kernel, when I've recovered
from the shock I'll try to coordinate with with Jens Restemeier to 
keep the "official" glogo up to date.
This is my first submission to the Linux Kernel mailing list. If
I've done anything incorrectly, please gently correct me so I can
get it right next time.
This patch was created in /usr/src with the command:
  diff -u -r linux-2.2.17 linux
and can be applied in /usr/src/linux with the command
  patch -p1 < ../linux_logo.patch
Thanks!
Torrey Hoffman
torrey@arnor.net
thoffman1@hotmail.com
diff -u -r -x *.o -x *.flags -x *.depend linux-2.2.17/drivers/video/fbcon.c
linux/drivers/video/fbcon.c
--- linux-2.2.17/drivers/video/fbcon.c	Mon Sep  4 10:39:22 2000
+++ linux/drivers/video/fbcon.c	Mon Oct  2 08:50:46 2000
@@ -30,7 +30,9 @@
  *                         Jakub Jelinek (jj@ultra.linux.cz)
  *
  *  Random hacking by Martin Mares <mj@ucw.cz>
- *
+ * 
+ *  Small changes for arbitrary size, centered logos with margins 
+ *  by Torrey Hoffman (Torrey.Hoffman@myrio.com)
  *
  *  The low level operations for the various display memory organizations
are
  *  now in separate source files.
@@ -107,10 +109,6 @@
 #  define DPRINTK(fmt, args...)
 #endif
 
-#define LOGO_H			80
-#define LOGO_W			80
-#define LOGO_LINE	(LOGO_W/8)
-
 struct display fb_display[MAX_NR_CONSOLES];
 static int logo_lines;
 static int logo_shown = -1;
@@ -522,7 +520,7 @@
 	int cnt;
 	int step;
     
-    	logo_lines = (LOGO_H + fontheight(p) - 1) / fontheight(p);
+    	logo_lines = (LOGO_H + LOGO_MARGIN + LOGO_MARGIN + fontheight(p) -
1) / fontheight(p);
     	q = (unsigned short *)(conp->vc_origin + conp->vc_size_row *
old_rows);
     	step = logo_lines * old_cols;
     	for (r = q - logo_lines * old_cols; r < q; r++)
@@ -1957,7 +1955,10 @@
     /* Return if the frame buffer is not mapped */
     if (!fb)
 	return 0;
-	
+
+    /* Center the linux logo horizontally */
+    int x_start = (p->var.xres - LOGO_W) / 2;
+      
     /* Set colors if visual is PSEUDOCOLOR and we have enough colors, or
for
      * DIRECTCOLOR */
     if ((p->visual == FB_VISUAL_PSEUDOCOLOR && depth >= 4) ||
@@ -2015,7 +2016,7 @@
 
     for (x = 0; x < smp_num_cpus * (LOGO_W + 8) &&
     	 x < p->var.xres - (LOGO_W + 8); x += (LOGO_W + 8)) {
-    	 
+       
 #if defined(CONFIG_FBCON_CFB16) || defined(CONFIG_FBCON_CFB24) || \
     defined(CONFIG_FBCON_CFB32) || defined(CONFIG_FB_SBUS)
         if (p->visual == FB_VISUAL_DIRECTCOLOR) {
@@ -2032,12 +2033,13 @@
 		/* have at least 8 bits per color */
 		src = logo;
 		bdepth = depth/8;
-		for( y1 = 0; y1 < LOGO_H; y1++ ) {
-		    dst = fb + y1*line + x*bdepth;
+		for( y1 = LOGO_MARGIN; y1 < LOGO_H + LOGO_MARGIN; y1++ ) {
+		    dst = fb + y1*line + (x + x_start) * bdepth;
 		    for( x1 = 0; x1 < LOGO_W; x1++, src++ ) {
 			val = (*src << redshift) |
 			      (*src << greenshift) |
 			      (*src << blueshift);
+
 			if (bdepth == 4 && !((long)dst & 3)) {
 			    /* Some cards require 32bit access */
 			    *(u32 *)dst = val;
@@ -2058,8 +2060,8 @@
 		unsigned int pix;
 		src = linux_logo16;
 		bdepth = (depth+7)/8;
-		for( y1 = 0; y1 < LOGO_H; y1++ ) {
-		    dst = fb + y1*line + x*bdepth;
+		for( y1 = LOGO_MARGIN; y1 < LOGO_H + LOGO_MARGIN; y1++ ) {
+		    dst = fb + y1*line + (x + x_start) * bdepth;
 		    for( x1 = 0; x1 < LOGO_W/2; x1++, src++ ) {
 			pix = (*src >> 4) | 0x10; /* upper nibble */
 			val = (pix << redshift) |
@@ -2087,6 +2089,7 @@
 	    done = 1;
         }
 #endif
+
 #if defined(CONFIG_FBCON_CFB16) || defined(CONFIG_FBCON_CFB24) || \
     defined(CONFIG_FBCON_CFB32) || defined(CONFIG_FB_SBUS)
 	if ((depth % 8 == 0) && (p->visual == FB_VISUAL_TRUECOLOR)) {
@@ -2106,12 +2109,13 @@
 	    blueshift  = p->var.blue.offset  - (8-p->var.blue.length);
 
 	    src = logo;
-	    for( y1 = 0; y1 < LOGO_H; y1++ ) {
-		dst = fb + y1*line + x*bdepth;
+	    for( y1 = LOGO_MARGIN; y1 < LOGO_H + LOGO_MARGIN; y1++ ) {
+		dst = fb + y1*line + (x + x_start) * bdepth;
 		for( x1 = 0; x1 < LOGO_W; x1++, src++ ) {
 		    val = safe_shift((linux_logo_red[*src-32]   & redmask),
redshift) |
 		          safe_shift((linux_logo_green[*src-32] &
greenmask), greenshift) |
 		          safe_shift((linux_logo_blue[*src-32]  & bluemask),
blueshift);
+
 		    if (bdepth == 4 && !((long)dst & 3)) {
 			/* Some cards require 32bit access */
 			*(u32 *)dst = val;
@@ -2132,8 +2136,8 @@
 #if defined(CONFIG_FBCON_CFB4)
 	if (depth == 4 && p->type == FB_TYPE_PACKED_PIXELS) {
 		src = logo;
-		for( y1 = 0; y1 < LOGO_H; y1++) {
-			dst = fb + y1*line + x/2;
+		for( y1 = LOGO_MARGIN; y1 < LOGO_H + LOGO_MARGIN; y1++) {
+			dst = fb + y1*line + (x + x_start)/2;
 			for( x1 = 0; x1 < LOGO_W/2; x1++) {
 				u8 q = *src++;
 				q = (q << 4) | (q >> 4);
@@ -2148,8 +2152,8 @@
 	    /* depth 8 or more, packed, with color registers */
 		
 	    src = logo;
-	    for( y1 = 0; y1 < LOGO_H; y1++ ) {
-		dst = fb + y1*line + x;
+	    for( y1 = LOGO_MARGIN; y1 < LOGO_H + LOGO_MARGIN; y1++ ) {
+		dst = fb + y1*line + x + x_start;
 		for( x1 = 0; x1 < LOGO_W; x1++ )
 		    *dst++ = *src++;
 	    }
@@ -2180,7 +2184,7 @@
 			 (1 << ((8-((pix*logo_depth)&7)-logo_depth) + bit)))
 		
 	    src = logo;
-	    for( y1 = 0; y1 < LOGO_H; y1++ ) {
+	    for( y1 = LOGO_MARGIN; y1 < LOGO_H + LOGO_MARGIN; y1++ ) {
 		for( x1 = 0; x1 < LOGO_LINE; x1++, src += logo_depth ) {
 		    dst = fb + y1*line + MAP_X(x/8+x1);
 		    for( bit = 0; bit < logo_depth; bit++ ) {
@@ -2199,7 +2203,7 @@
 	     * special case for logo_depth == 4: we used color registers
16..31,
 	     * so fill plane 4 with 1 bits instead of 0 */
 	    if (depth > logo_depth) {
-		for( y1 = 0; y1 < LOGO_H; y1++ ) {
+		for( y1 = LOGO_MARGIN; y1 < LOGO_H + LOGO_MARGIN; y1++ ) {
 		    for( x1 = 0; x1 < LOGO_LINE; x1++ ) {
 			dst = fb + y1*line + MAP_X(x/8+x1) +
logo_depth*plane;
 			for( i = logo_depth; i < depth; i++, dst += plane )
@@ -2224,7 +2228,7 @@
 		? 0x00 : 0xff;
 
 	    /* can't use simply memcpy because need to apply inverse */
-	    for( y1 = 0; y1 < LOGO_H; y1++ ) {
+	    for( y1 = LOGO_MARGIN; y1 < LOGO_H + LOGO_MARGIN; y1++ ) {
 		src = logo + y1*LOGO_LINE;
 		dst = fb + y1*line + x/8;
 		for( x1 = 0; x1 < LOGO_LINE; ++x1 )
@@ -2240,9 +2244,10 @@
 		outb_p(5,0x3ce); outb_p(0,0x3cf);
 
 		src = logo;
-		for (y1 = 0; y1 < LOGO_H; y1++) {
-			for (x1 = 0; x1 < LOGO_W / 2; x1++) {
-				dst = fb + y1*line + x1/4 + x/8;
+
+		for (y1 = LOGO_MARGIN; y1 < LOGO_H + LOGO_MARGIN; y1++) {
+			for (x1 = 0; x1 < LOGO_W/2; x1++) {
+				dst = fb + y1*line + (x1 + x_start)/4 + x/8;
 
 				outb_p(0,0x3ce);
 				outb_p(*src >> 4,0x3cf);
@@ -2252,6 +2257,7 @@
 
 				outb_p(0,0x3ce);
 				outb_p(*src & 0xf,0x3cf);
+				/* outb_p(0xff & 0xf,0x3cf); */
 				outb_p(8,0x3ce);
 				outb_p(1 << (7 - (1 + x1 % 4 * 2)),0x3cf);
 				*(volatile char *) dst |= 1;
@@ -2270,7 +2276,7 @@
     /* Modes not yet supported: packed pixels with depth != 8 (does such a
      * thing exist in reality?) */
 
-    return done ? (LOGO_H + fontheight(p) - 1) / fontheight(p) : 0 ;
+    return done ? (LOGO_H + LOGO_MARGIN + LOGO_MARGIN + fontheight(p) - 1)
/ fontheight(p) : 0 ;
 }
 
 /*
diff -u -r -x *.o -x *.flags -x *.depend
linux-2.2.17/include/linux/linux_logo.h linux/include/linux/linux_logo.h
--- linux-2.2.17/include/linux/linux_logo.h	Wed Sep 30 14:16:33 1998
+++ linux/include/linux/linux_logo.h	Mon Oct  2 08:52:43 2000
@@ -4,22 +4,36 @@
  *
  * Copyright (C) 1996 Larry Ewing (lewing@isc.tamu.edu)
  * Copyright (C) 1996,1998 Jakub Jelinek (jj@sunsite.mff.cuni.cz)
+ * 
+ * Modified 2000 Torrey Hoffman (Torrey.Hoffman@myrio.com)
+ * in a patch to display the logo centered horizontally, with a margin
+ * above and below, removing the 80x80 size restriction, and supporting
+ * different logo sizes for different color depths.
  *
+ * Note that there is a GPL'ed gimp plugin called "glogo",
+ * copyright 1998 Jens Ch. Restemeier, which makes it much easier
+ * to create this file.  A modified version by Torrey Hoffman to
+ * support this updated version of the file, logos larger than 80x80, 
+ * and Gimp 1.1.26 is available from Torrey.Hoffman@myrio.com
+ * 
  * You can put anything here, but:
  * LINUX_LOGO_COLORS has to be less than 224
- * image size has to be 80x80
  * values have to start from 0x20
  * (i.e. RGB(linux_logo_red[0],
  *           linux_logo_green[0],
  *           linux_logo_blue[0]) is color 0x20)
- * BW image has to be 80x80 as well, with MS bit
- * on the left
+ * BW image has to have MS bit on the left.
  * Serial_console ascii image can be any size,
  * but should contain %s to display the version
  */
 
 #if LINUX_LOGO_COLORS == 214
 
+#define LOGO_H		80
+#define LOGO_W		80
+#define LOGO_LINE	(LOGO_W/8)
+#define LOGO_MARGIN	120
+
 unsigned char linux_logo_red[] __initdata = {
   0x02, 0x9E, 0xE9, 0xC4, 0x50, 0xC9, 0xC4, 0xE9,
   0x65, 0xE3, 0xC2, 0x25, 0xA4, 0xEC, 0x90, 0xA6,
@@ -917,6 +931,11 @@
 
 #ifdef INCLUDE_LINUX_LOGOBW
 
+#define LOGO_H		80
+#define LOGO_W		80
+#define LOGO_LINE	(LOGO_W/8)
+#define LOGO_MARGIN	120
+
 unsigned char linux_logo_bw[] __initdata = {
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x3F,
@@ -1023,6 +1042,11 @@
 #endif
 
 #ifdef INCLUDE_LINUX_LOGO16
+
+#define LOGO_H		80
+#define LOGO_W		80
+#define LOGO_LINE	(LOGO_W/8)
+#define LOGO_MARGIN	120
 
 unsigned char linux_logo16_red[] __initdata = {
     0x00, 0x90, 0xb0, 0x9c, 0xf7, 0x35, 0x83, 0xa5,
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
Please read the FAQ at 
http://www.tux.org/lkml/