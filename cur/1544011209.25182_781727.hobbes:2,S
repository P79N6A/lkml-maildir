Date: Wed, 17 Dec 2008 13:28:08 -0500
From: Eric Paris <>
Subject: Re: [PATCH 11/15] fixing audit rule ordering mess, part 1
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/12/17/303

On Wed, 2008-12-17 at 05:12 +0000, Al Viro wrote:
> Problem: ordering between the rules on exit chain is currently lost;
> all watch and inode rules are listed after everything else _and_
> exit,never on one kind doesn't stop exit,always on another from
> being matched.
> 
> Solution: assign priorities to rules, keep track of the current
> highest-priority matching rule and its result (always/never).
> 
> Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
> @@ -1258,6 +1258,9 @@ static int audit_add_watch(struct audit_krule *krule, struct nameidata *ndp,
>  	return ret;
>  }
>  
> +static u64 prio_low = ~0ULL/2;
> +static u64 prio_high = ~0ULL/2 - 1;
> +
>  /* Add rule to given filterlist if not a duplicate. */
>  static inline int audit_add_rule(struct audit_entry *entry,
>  				 struct list_head *list)
> @@ -1319,6 +1322,14 @@ static inline int audit_add_rule(struct audit_entry *entry,
>  		}
>  	}
>  
> +	entry->rule.prio = ~0ULL;
> +	if (entry->rule.listnr == AUDIT_FILTER_EXIT) {
> +		if (entry->rule.flags & AUDIT_FILTER_PREPEND)
> +			entry->rule.prio = ++prio_high;
> +		else
> +			entry->rule.prio = --prio_low;
> +	}
> +
>  	if (entry->rule.flags & AUDIT_FILTER_PREPEND) {
>  		list_add_rcu(&entry->list, list);
I don't see why prio is only important on AUDIT_FILTER_EXIT.  Couldn't I
end up with stupidity with entry,never  ?
-Eric