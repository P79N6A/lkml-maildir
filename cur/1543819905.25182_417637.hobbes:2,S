Date: Fri, 21 Apr 2006 12:05:13 +0200
From: "Claudio Scordino" <>
Subject: Re: [PATCH] Extending getrusage
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/4/21/97

> > I'd be reluctant to support this change without a compelling description of
> > why we actually want it.
>
> It offers nothing that isn't available elsewhere (I think), except more
> cheaply. It also has the potential to be multiplatform one day. Right now to
> get the CPU usage of a random pid, one has to implement the equivalent of
> /proc/ parsing for each platform.
>
> If at least Linux did 'getrusage for foreign pid', that would clean up
> things up somewhat already.
>
> It might even mean a 'portable top', and who knows, more unixes might
> follow.
>
> I for one would save work having a getrusage that does this.
>
>         Bert
Exactly! My modification was meant to add the possibility of having
usage information about another process at user level.
Recently, while writing some code at user level, I needed a fast way
to have such information about another process.
I wanted to use the getrusage syscall, then I found out that the
current implementation does not allow to get information about another
process. Therefore, I proposed my patch.
As Bert said, it offers nothing that isn't available elsewhere, but
more cheaply.
This patch with the changes that you asked me follows.
Thanks,
                Claudio
Signed-off-by: Claudio Scordino <cloud.of.andor@gmail.com>
diff -uprN linux-2.6.16.9/kernel/sys.c linux-2.6.16.9-new/kernel/sys.c
--- linux-2.6.16.9/kernel/sys.c	2006-04-19 02:10:14.000000000 -0400
+++ linux-2.6.16.9-new/kernel/sys.c	2006-04-21 05:53:16.000000000 -0400
@@ -1765,11 +1765,30 @@ int getrusage(struct task_struct *p, int
 	return copy_to_user(ru, &r, sizeof(r)) ? -EFAULT : 0;
 }
+/* who can be RUSAGE_SELF, RUSAGE_CHILDREN or a valid pid */
 asmlinkage long sys_getrusage(int who, struct rusage __user *ru)
 {
-	if (who != RUSAGE_SELF && who != RUSAGE_CHILDREN)
-		return -EINVAL;
-	return getrusage(current, who, ru);
+	struct rusage r;
+	struct task_struct *tsk = current;
+	read_lock(&tasklist_lock);
+	if (who != RUSAGE_SELF && who != RUSAGE_CHILDREN) {
+		if (who <= 0)
+			goto bad;
+		tsk = find_task_by_pid(who);
+		if (tsk == NULL)
+			goto bad;
+		if ((tsk != current) && security_ptrace(current, tsk))
+			goto bad;
+		/* current can get info about tsk */
+		who = RUSAGE_SELF;
+	}
+	k_getrusage(tsk, who, &r);
+	read_unlock(&tasklist_lock);
+	return copy_to_user(ru, &r, sizeof(r)) ? -EFAULT : 0;
+
+bad:
+	read_unlock(&tasklist_lock);
+	return tsk ? -EPERM : -EINVAL;
 }
 asmlinkage long sys_umask(int mask)
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/