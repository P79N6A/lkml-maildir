Date: Sun, 27 Feb 2000 17:23:36 -0700 (MST)
From: "Peter J. Braam" <>
Subject: [PATCH] rootfstype boot argument
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/2/27/181

Hi,
The attached patches implement a new boot argument: what file system to
try first for mounting "/". 
Both Ext3 and InterMezzo allow a "non-standard" choice of booting an Ext2
formatted partition, i.e. a single disk partition can be mounted in
multiple ways. This patch allows you to make that choice at boot time
flexibly.
E.g at the Lilo prompt you can type:
boot: linux rootfstype=InterMezzo
or you can add append="rootfstype=InterMezzo" option in /etc/lilo.conf to
select the file system.
Al, can you scrutinize, then I'd like to forward it to Linus (for 2.3) and
Alan for (2.2).   This patch should be totally inoccent.
Use with discretion - it's booting and your root file system you are
dealing with. 
- Peter -
--- fs/super.c.orig	Wed Feb 16 16:42:06 2000
+++ fs/super.c	Tue Feb 22 22:07:03 2000
@@ -1121,7 +1121,17 @@
 	return retval;
 }
 
-void __init mount_root(void)
+char root_fs_type[FS_TYPE_MAXLEN];
+
+__initfunc(void root_fstype_setup(char *line, int *ints))
+{
+	int n = strlen(line);
+	if (n >= sizeof(root_fs_type))
+		line[sizeof(root_fs_type) - 1] = '\0';
+	sprintf(root_fs_type, line);
+}
+
+void __init mount_root(char *type)
 {
 	struct file_system_type * fs_type;
 	struct super_block * sb;
@@ -1133,6 +1143,17 @@
 	char path[64];
 	int path_start = -1;
 
+	if ( type ) 
+	        fs_type = get_fs_type(type);
+	else 
+	        fs_type = file_systems;
+
+	if ( !fs_type ) {
+   	        printk("Warning: file system option %s not found\n", type);
+	        fs_type = file_systems;
+	}
+	  
+
 #ifdef CONFIG_ROOT_NFS
 	if (MAJOR(ROOT_DEV) == UNNAMED_MAJOR) {
 		ROOT_DEV = 0;
@@ -1247,6 +1268,7 @@
 			}
 			panic("VFS: add_vfsmnt failed for root fs");
 		}
+
 	}
 	panic("VFS: Unable to mount root fs on %s",
 		kdevname(ROOT_DEV));
@@ -1389,7 +1411,7 @@
 		else dput (dir_d);
 	}
 	ROOT_DEV = new_root_dev;
-	mount_root();
+	mount_root(NULL);
 	dput(old_root);
 	dput(old_pwd);
 #if 1
--- init/main.c.orig	Wed Feb 16 16:42:06 2000
+++ init/main.c	Tue Feb 22 22:10:21 2000
@@ -383,6 +383,7 @@
 __setup("ro", readonly);
 __setup("rw", readwrite);
 __setup("debug", debug_kernel);
+__setup("rootfstype", root_fstype_setup);
 
 /*
  * This is a simple kernel command line parsing function: it parses
@@ -690,7 +691,7 @@
 	init_pcmcia_ds();		/* Do this last */
 #endif
 	/* Mount the root filesystem.. */
-	mount_root();
+	mount_root(root_fs_type);
 
 	mount_devfs_fs ();
 
--- include/linux/fs.h.orig	Tue Feb 22 22:12:21 2000
+++ include/linux/fs.h	Tue Feb 22 22:12:23 2000
@@ -1022,7 +1022,11 @@
 
 
 extern void show_buffers(void);
-extern void mount_root(void);
+
+#define FS_TYPE_MAXLEN 32
+char root_fs_type[FS_TYPE_MAXLEN];
+extern void root_fstype_setup(char *line, int *ints);
+extern void mount_root(char *type);
 
 #ifdef CONFIG_BLK_DEV_INITRD
 extern kdev_t real_root_dev;--- ./include/linux/fs.h.orig	Wed Feb  9 09:52:26 2000
+++ ./include/linux/fs.h	Fri Feb 18 19:16:18 2000
@@ -883,7 +883,10 @@
 extern kdev_t ROOT_DEV;
 
 extern void show_buffers(void);
-extern void mount_root(void);
+#define FS_TYPE_MAXLEN 32
+char root_fs_type[FS_TYPE_MAXLEN];
+extern void root_fstype_setup(char *line, int *ints);
+extern void mount_root(char *type);
 
 #ifdef CONFIG_BLK_DEV_INITRD
 extern kdev_t real_root_dev;
--- fs/super.c.orig	Tue Feb 22 21:55:19 2000
+++ fs/super.c	Tue Feb 22 22:02:25 2000
@@ -1133,7 +1133,17 @@
 	goto dput_and_out;
 }
 
-void __init mount_root(void)
+char root_fs_type[FS_TYPE_MAXLEN];
+
+__initfunc(void root_fstype_setup(char *line, int *ints))
+{
+	int n = strlen(line);
+	if (n >= sizeof(root_fs_type))
+		line[sizeof(root_fs_type) - 1] = '\0';
+	sprintf(root_fs_type, line);
+}
+
+void __init mount_root(char *type)
 {
 	struct file_system_type * fs_type;
 	struct super_block * sb;
@@ -1142,6 +1152,17 @@
 	struct file filp;
 	int retval;
 
+	if ( type ) 
+	        fs_type = get_fs_type(type);
+	else 
+	        fs_type = file_systems;
+
+	if ( !fs_type ) {
+   	        printk("Warning: file system option %s not found\n", type);
+	        fs_type = file_systems;
+	}
+	  
+
 #ifdef CONFIG_ROOT_NFS
 	if (MAJOR(ROOT_DEV) == UNNAMED_MAJOR) {
 		ROOT_DEV = 0;
@@ -1216,7 +1237,7 @@
 		 */
 		printk("VFS: Cannot open root device %s\n",
 		       kdevname(ROOT_DEV));
-	else for (fs_type = file_systems ; fs_type ; fs_type = fs_type->next) {
+	else for ( ; fs_type ; fs_type = fs_type->next) {
   		if (!(fs_type->fs_flags & FS_REQUIRES_DEV))
   			continue;
   		sb = read_super(ROOT_DEV,fs_type->name,root_mountflags,NULL,1);
@@ -1232,6 +1253,7 @@
 				return;
 			panic("VFS: add_vfsmnt failed for root fs");
 		}
+
 	}
 	panic("VFS: Unable to mount root fs on %s",
 		kdevname(ROOT_DEV));
@@ -1255,7 +1277,7 @@
 		return -EBUSY;
 	}
 	ROOT_DEV = new_root_dev;
-	mount_root();
+	mount_root(NULL);
 	dput(old_root);
 	dput(old_pwd);
 #if 1
--- init/main.c.orig	Tue Jan  4 11:12:25 2000
+++ init/main.c	Tue Feb 22 22:00:36 2000
@@ -953,6 +953,7 @@
 
 static struct kernel_param raw_params[] __initdata = {
 	{ "root=", root_dev_setup },
+	{ "rootfstype=", root_fstype_setup},
 #ifdef CONFIG_ROOT_NFS
 	{ "nfsroot=", nfs_root_setup },
 	{ "nfsaddrs=", ip_auto_config_setup },
@@ -1420,7 +1421,7 @@
 	filesystem_setup();
 
 	/* Mount the root filesystem.. */
-	mount_root();
+	mount_root(root_fs_type);
 
 #ifdef CONFIG_BLK_DEV_INITRD
 	root_mountflags = real_root_mountflags;