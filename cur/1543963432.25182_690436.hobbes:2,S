Date: Thu, 8 May 2008 12:44:17 -0700
From: "David Schwartz" <>
Subject: RE: Two questions about scheduling and threading.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/5/8/374

> When I start my system for the first time, I start one thread for each
> processor/core in the machine (is this the correct thing to do)?  These
> threads set a busy flag, go to work and then go to sleep.  I put
> everything
> to sleep as opposed to killing the threads because it saves me on
> average of
> about 400ms each time around.
That's not unreasonable. However, you may wish to create a few extra
threads. Otherwise, if one thread is blocked on I/O, you can't use all the
CPUs.
> My problem is, and, it is very reproducable, that if CPU0 is at 100%, none
> of my threads see the wakeup!  It doesn't matter what the other CPU's are
> doing, if they're all at 0 or 100%, but if CPU0 is 100, I'm
> toast.  Is there
> anyway around this?
Sounds like a bug. What does your wakeup code look like? Do you put your
threads to sleep blocked on a condition variable? Is the c.v. code correctly
using a predicate, that's something easy to screw up. It's like 'select',
there's a dozen classic mistakes and someone often makes one or two of them
and their code still soemtimes works.
> Also, I know that we're supposed to sit back and let the scheduler do all
> the work for us; but, in the 2.6.16.16 kernel, is there a way to assign a
> specific thread and/or process to a designated processor???  I really need
> to be able to do this because even with the preemptive
> scheduling, I'm still
> real-time and it's not quite real-time enough!
Big mistake. If you bind threads to CPUs and the thread that gets a wakeup
is assigned to a CPU that's busy, the job that thread was going to do will
have to wait, while other CPUs sit idle.
DS