Date: Tue, 14 Dec 1999 00:54:44 -0500 (EST)
From: Alexander Viro <>
Subject: Re: Kernels do not compile anymore
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/12/14/1

On Mon, 13 Dec 1999, Richard B. Johnson wrote:
> I can contribute some work on company time on a "new" kernel if initrd
> would compile. It doesn't have to "work". It only has to be "reconnected"
> enough so I have a clue as to how its supposed to work. Given that, I
> should be able to get it to work.
Oh. My. God.
OK, let's see what happens. <exporting .13, grepping for memory_start>
<looking though the history and seeing that it was removed in .23>
<checking WTF was tested there>
Umhm... So it was verifying that boot-time allocations didn't overwrite
the image.
<looking at the patch in .23>
Lovely...
+       // FIXME, use the bootmem.h interface.
OK, where the hell did we use/set initrd_start?
<grep>
arch/*/kernel/setup.c
<checking history>
In .23:
 #ifdef CONFIG_BLK_DEV_INITRD
+// FIXME needs to do the new bootmem alloc stuff
Lovely. IOW, we should ask the allocator to leave the area alone. Sounds
reasonable and would make the test in main.c unneeded.
<checking further history>
In .24:
 #ifdef CONFIG_BLK_DEV_INITRD
-// FIXME needs to do the new bootmem alloc stuff
        if (LOADER_TYPE) {
-               initrd_start = INITRD_START ? INITRD_START + PAGE_OFFSET :
0;
-               initrd_end = initrd_start+INITRD_SIZE;
-               if (initrd_end > (max_low_pfn << PAGE_SHIFT)) {
+               if (INITRD_START + INITRD_SIZE < (max_low_pfn <<
PAGE_SHIFT)) {
+                       reserve_bootmem(INITRD_START, INITRD_SIZE);
+                       initrd_start =
+                               INITRD_START ? INITRD_START + PAGE_OFFSET
: 0;
+                       initrd_end = initrd_start+INITRD_SIZE;
+               }
+               else {
                        printk("initrd extends beyond end of memory "
                            "(0x%08lx > 0x%08lx)\ndisabling initrd\n",
-                           initrd_end,memory_end);
+                           INITRD_START + INITRD_SIZE,
+                           max_low_pfn << PAGE_SHIFT);
                        initrd_start = 0;
                }
        }
reserve_bootmem(INITRD_START, INITRD_SIZE) looks like the right thing.
Unless allocator is truly fscked up it should leave the thing alone.
<grepping for other calls of reserve_bootmem>
Umhm... In principle it might be buggy - other areas are either way up the
core or in the very bottom. Since the old "allocator" simply raised the
upper boundary (a-la brk(), except that init_foo_bar() usually received
the old value and returned old_value+how_much_did_it_grab) we might leave
some remnants around and not notice the clashes - supposedly protected
areas would be out of the way, so nobody would try to screw them.
However, unless we _really_ have such remnants around, code in main.c
seems to be obsolete. I'm not claiming that there is no other problems
with initrd - it might become totally broken in many other ways, but
the code in main.c is goner. Quite possibly left out as a lazy replacement
of
#ifdef CONFIG_INITRD
#error "It's broken"
#endif
The bottom line: if you want to try fixing it - remove the test in main.c
and go ahead.
<building>
well, at least it compiles and links, but I don't have the stuff to build
actual initrd image and try it. And don't want to, to be honest - you
asked for explanation of the stuff in main.c and something to start with,
so...
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/