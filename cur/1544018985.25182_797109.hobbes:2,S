Date: Mon, 26 Jan 2009 23:31:45 +0100
From: Oleg Nesterov <>
Subject: Re: [PATCH 2/3] work_on_cpu: Use our own workqueue.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2009/1/26/322

On 01/26, Andrew Morton wrote:
>
> On Mon, 26 Jan 2009 23:05:37 +0100
> Ingo Molnar <mingo@elte.hu> wrote:
>
> >
> > * Andrew Morton <akpm@linux-foundation.org> wrote:
> >
> > > Well it turns out that I was having a less-than-usually-senile moment:
> > >
> > > :     implement flush_work()
> >
> > > Why isn't that working in this case??
> >
> > how would that work in this case? We defer processing into the workqueue 
> > exactly because we want its per-CPU properties.
>
> It detaches the work item, moves it to head-of-queue, reinserts it then
> waits on it.  I think.
No, no helper works this way.
The reinsert doesn't make sense for cancel_work.
As for flush_work(), I think it is possible to do, but can't help to
avoid the deadlocks. Because we still have to wait for ->current_work.
> This might have a race+hole.  If a currently-running "unrelated"
> work item tries to take the lock which the flush_work() caller is holding
> then there's no way in which keventd will come back to execute
> the work item which we just put on the head of queue.
Yes.
> > We want work_on_cpu() to
> > be done in the workqueue context on the CPUs that were specified, not in
> > the local CPU context.
>
> flush_work() is supposed to work in the way which you describe.
Yes,
> But Oleg's "we may be running on a different CPU" comment has me all
> confused.
I meant, that
	> the caller of flush_work() can detach the work item
	> and run it directly.
this is not possible in work_on_cpu() case, we can't run it directly,
we want it to run on the target CPU.
Oleg.