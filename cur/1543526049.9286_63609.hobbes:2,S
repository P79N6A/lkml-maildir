Date: Wed, 16 Feb 2000 13:28:06 +0000 (GMT)
From: Tim Waugh <>
Subject: [patch] 2.3.46pre3: simplify lp.c
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/2/16/77

Hi Linus,
A while back I started adding support for poll in lp.  As it turns out,
lots of printers do completely the wrong thing when told to go to reverse
mode (they do it, and stop whatever else they were doing too [like
printing], until put back in forward mode).
Since the code was never fully enabled, and having a parport preemption
function for no good reason just adds to potential races, I'd like to take
it all out.
Tim.
*/
Index: linux/drivers/char/lp.c
diff -u linux/drivers/char/lp.c:1.1.1.9 linux/drivers/char/lp.c:1.15
--- linux/drivers/char/lp.c:1.1.1.9	Wed Feb 16 10:13:45 2000
+++ linux/drivers/char/lp.c	Wed Feb 16 10:09:33 2000
@@ -151,66 +151,6 @@
 
 #undef LP_DEBUG
 
-/* If you want to see if you can get lp_poll working, define this. */
-#undef SUPPORT_POLL
-
-/* --- parport support ----------------------------------------- */
-
-static int lp_preempt(void *handle)
-{
-       struct lp_struct *lps = (struct lp_struct *)handle;
-
-       if (!(lps->flags & LP_PORT_BUSY)) {
-	       /* Let the port go. */
-	       clear_bit (LP_HAVE_PORT_BIT, &lps->flags);
-	       return 0;
-       }
-
-       /* Don't actually release the port now */
-       return 1;
-}
-
-static void lp_check_data (struct lp_struct *lp)
-{
-#if !defined(CONFIG_PARPORT_1284) || !defined (SUPPORT_POLL)
-	return;
-#else
-	struct pardevice *dev = lp->dev;
-	if (!(lp->flags & LP_NO_REVERSE)) {
-		int err = parport_negotiate (dev->port, IEEE1284_MODE_NIBBLE);
-		if (err)
-			lp->flags |= LP_NO_REVERSE;
-		else {
-			unsigned char s = parport_read_status (dev->port);
-			if (s & PARPORT_STATUS_ERROR)
-				lp->flags &= ~LP_DATA_AVAIL;
-			else {
-				lp->flags |= LP_DATA_AVAIL;
-				if (waitqueue_active (&lp->dataq))
-					wake_up_interruptible (&lp->dataq);
-			}
-		}
-	}
-#endif /* IEEE 1284 support */
-}
-
-static void lp_parport_release (int minor)
-{
-	lp_check_data (&lp_table[minor]);
-	if (test_and_clear_bit (LP_HAVE_PORT_BIT, &lp_table[minor].flags))
-		parport_release (lp_table[minor].dev);
-
-	lp_table[minor].flags &= ~LP_PORT_BUSY;
-}
-
-static void lp_parport_claim (int minor)
-{
-	if (!test_and_set_bit (LP_HAVE_PORT_BIT, &lp_table[minor].flags))
-		parport_claim_or_block (lp_table[minor].dev);
-
-	lp_table[minor].flags |= LP_PORT_BUSY;
-}
-
 /* --- low-level port access ----------------------------------- */
 
 #define r_dtr(x)	(parport_read_data(lp_table[(x)].dev->port))
@@ -221,42 +161,15 @@
 static int lp_reset(int minor)
 {
 	int retval;
-	lp_parport_claim (minor);
+	parport_claim_or_block (lp_table[minor].dev);
 	w_ctr(minor, LP_PSELECP);
 	udelay (LP_DELAY);
 	w_ctr(minor, LP_PSELECP | LP_PINITP);
 	retval = r_str(minor);
-	lp_parport_release (minor);
+	parport_release (lp_table[minor].dev);
 	return retval;
 }
 
-static void lp_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-	struct lp_struct *lp_dev = (struct lp_struct *) dev_id;
-	if (!(lp_dev->flags & LP_PORT_BUSY))
-		/* We must have the port since we got an interrupt. */
-		lp_check_data (lp_dev);
-	if (waitqueue_active (&lp_dev->waitq))
-		wake_up_interruptible (&lp_dev->waitq);
-}
-
-static void lp_wakeup (void *handle)
-{
-	struct lp_struct *lp_dev = handle;
-
-	if (lp_dev->flags & LP_PORT_BUSY)
-		return;
-
-	/* Grab the port if it can help (i.e. reverse mode is possible). */
-	if (!(lp_dev->flags & LP_NO_REVERSE)) {
-		parport_claim (lp_dev->dev);
-		set_bit (LP_HAVE_PORT_BIT, &lp_dev->flags);
-		lp_check_data (lp_dev);
-		if (waitqueue_active (&lp_dev->waitq))
-			wake_up_interruptible (&lp_dev->waitq);
-	}
-}
-
 static void lp_error (int minor)
 {
 	int polling;
@@ -265,10 +178,10 @@
 		return;
 
 	polling = lp_table[minor].dev->port->irq == PARPORT_IRQ_NONE;
-	if (polling) lp_parport_release (minor);
+	if (polling) parport_release (lp_table[minor].dev);
 	interruptible_sleep_on_timeout (&lp_table[minor].waitq,
 					LP_TIMEOUT_POLLED);
-	if (polling) lp_parport_claim (minor);
+	if (polling) parport_claim_or_block (lp_table[minor].dev);
 	else parport_yield_blocking (lp_table[minor].dev);
 }
 
@@ -341,7 +254,7 @@
 
  	/* Claim Parport or sleep until it becomes available
  	 */
- 	lp_parport_claim (minor);
+ 	parport_claim_or_block (lp_table[minor].dev);
 
 	/* Go to compatibility mode. */
 	parport_negotiate (port, IEEE1284_MODE_COMPAT);
@@ -396,7 +309,7 @@
 	/* Not really necessary, but polite. */
 	parport_set_timeout (lp_table[minor].dev, old_to);
 
- 	lp_parport_release (minor);
+ 	parport_release (lp_table[minor].dev);
 
 	up (&lp_table[minor].port_mutex);
 
@@ -420,7 +333,7 @@
 	if (down_interruptible (&lp_table[minor].port_mutex))
 		return -EINTR;
 
-	lp_parport_claim (minor);
+	parport_claim_or_block (lp_table[minor].dev);
 
 	for (;;) {
 		retval = parport_read (port, kbuf, count);
@@ -441,7 +354,7 @@
 		}
 	}
 
-	lp_parport_release (minor);
+	parport_release (lp_table[minor].dev);
 
 	if (retval > 0 && copy_to_user (buf, kbuf, retval))
 		retval = -EFAULT;
@@ -473,9 +386,9 @@
 	   should most likely only ever be used by the tunelp application. */
 	if ((LP_F(minor) & LP_ABORTOPEN) && !(file->f_flags & O_NONBLOCK)) {
 		int status;
-		lp_parport_claim (minor);
+		parport_claim_or_block (lp_table[minor].dev);
 		status = r_str(minor);
-		lp_parport_release (minor);
+		parport_release (lp_table[minor].dev);
 		if (status & LP_POUTPA) {
 			printk(KERN_INFO "lp%d out of paper\n", minor);
 			MOD_DEC_USE_COUNT;
@@ -567,9 +480,9 @@
 				return -EFAULT;
 			break;
 		case LPGETSTATUS:
-			lp_parport_claim(minor);
+			parport_claim_or_block (lp_table[minor].dev);
 			status = r_str(minor);
-			lp_parport_release(minor);
+			parport_release (lp_table[minor].dev);
 
 			if (copy_to_user((int *) arg, &status, sizeof(int)))
 				return -EFAULT;
@@ -618,21 +531,6 @@
 	return retval;
 }
 
-#ifdef CONFIG_PARPORT_1284
-static unsigned int lp_poll (struct file *filp, struct poll_table_struct *wait)
-{
-	unsigned int minor = MINOR (filp->f_dentry->d_inode->i_rdev);
-	unsigned int mask = POLLOUT | POLLWRNORM; /* always writable */
-
-	poll_wait (filp, &lp_table[minor].dataq, wait);
-
-	if (lp_table[minor].flags & LP_DATA_AVAIL)
-		mask |= POLLIN | POLLRDNORM;
-
-	return mask;
-}
-#endif /* IEEE 1284 support */
-
 static struct file_operations lp_fops = {
 	write:		lp_write,
 	ioctl:		lp_ioctl,
@@ -640,7 +538,6 @@
 	release:	lp_release,
 #ifdef CONFIG_PARPORT_1284
 	read:		lp_read,
-	poll:		lp_poll,
 #endif
 };
 
@@ -665,12 +562,9 @@
 	ssize_t written;
 	signed long old_to;
 
-	if (!(lp_table[CONSOLE_LP].flags & (1<<LP_HAVE_PORT_BIT))) {
-		if (parport_claim (dev))
-			/* Nothing we can do. */
-			return;
-		set_bit (LP_HAVE_PORT_BIT, &lp_table[CONSOLE_LP].flags);
-	}
+	if (parport_claim (dev))
+		/* Nothing we can do. */
+		return;
 
 	old_to = parport_set_timeout (dev, 0);
 
@@ -711,6 +605,7 @@
 	} while (count > 0 && (CONSOLE_LP_STRICT || written > 0));
 
 	parport_set_timeout (dev, old_to);
+	parport_release (dev);
 }
 
 static kdev_t lp_console_device (struct console *c)
@@ -782,9 +677,7 @@
 static int lp_register(int nr, struct parport *port)
 {
 	lp_table[nr].dev = parport_register_device(port, "lp", 
-						   lp_preempt, lp_wakeup,
-						   lp_interrupt, 
-						   0,
+						   NULL, NULL, NULL, 0,
 						   (void *) &lp_table[nr]);
 	if (lp_table[nr].dev == NULL)
 		return 1;
@@ -943,8 +836,6 @@
 	for (offset = 0; offset < LP_NO; offset++) {
 		if (lp_table[offset].dev == NULL)
 			continue;
-		if (lp_table[offset].flags & (1<<LP_HAVE_PORT_BIT))
-			parport_release (lp_table[offset].dev);
 		parport_unregister_device(lp_table[offset].dev);
 	}
 }
Index: linux/include/linux/lp.h
diff -u linux/include/linux/lp.h:1.1.1.3 linux/include/linux/lp.h:1.3
--- linux/include/linux/lp.h:1.1.1.3	Wed Feb  9 09:31:12 2000
+++ linux/include/linux/lp.h	Wed Feb 16 09:50:13 2000
@@ -26,8 +26,6 @@
 #define LP_TRUST_IRQ_  0x0200 /* obsolete */
 #define LP_NO_REVERSE  0x0400 /* No reverse mode available. */
 #define LP_DATA_AVAIL  0x0800 /* Data is available. */
-#define LP_HAVE_PORT_BIT   12 /* (0x1000) Port is claimed. */
-#define LP_PORT_BUSY   (1<<13) /* Reading or writing. */
 
 /* 
  * bit defines for 8255 status port
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/