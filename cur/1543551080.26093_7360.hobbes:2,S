Date: Mon, 9 Oct 2000 23:45:18 +0100
From: Kenn Humborg <>
Subject: Re: Calling current() from interrupt context
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/10/9/214

On Tue, Oct 10, 2000 at 12:36:35AM +0200, Andi Kleen wrote:
> On Mon, Oct 09, 2000 at 11:30:50PM +0100, Alan Cox wrote:
> > > I think I'll go for the 'current is in a well-known register'
> > > approach and see how this goes...
> > 
> > Failing that the 2.0 approach will work, current is a global in uniprocessor
> > and a #define to an array indexed by cpu id in smp
> 
> The problem is where to get the cpuid from (see how smp_processor_id
> is currently defined ;) When you don't have a hidden register in the 
> CPU you're screwed. 
> [x86-64 has one btw] 
Simple.  Each interrupt stack is, say, 8 pages.  You have an array
of N interrupt stacks.  Then you calculate
   cpu_id = (sp & ~(INT_STACK_SIZE-1)) >> (PAGE_SHIFT + 3);
Actually, I'd put the interrupt stack and any other per-cpu data
structures together in this region.
I don't know yet how you decide which secondary processor is which
at boot time.  Maybe it doesn't matter, so you can just let them
fight over the per-cpu data structures by trying to claim spinlocks
on each one in turn.
Anyway, this SMP stuff will be quite academic for a while unless
someone wants to donate a workstation-sized SMP VAX (if such a
beast exists at all :-)
Later,
Kenn
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
Please read the FAQ at 
http://www.tux.org/lkml/