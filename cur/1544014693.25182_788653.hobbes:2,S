Date: Thu, 08 Jan 2009 13:43:36 +0900 (JST)
From: Atsushi Nemoto <>
Subject: Re: [PATCH] dmatest: flush and invalidate destination buffer before DMA
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2009/1/7/654

On Mon, 5 Jan 2009 11:31:57 -0700, "Dan Williams" <dan.j.williams@intel.com> wrote:
> >> > @@ -226,6 +227,12 @@ static int dmatest_func(void *data)
> >> >
> >> >             dmatest_init_srcbuf(thread->srcbuf, src_off, len);
> >> >             dmatest_init_dstbuf(thread->dstbuf, dst_off, len);
> >> > +           /* flush and invalidate caches for whole dstbuf */
> >> > +           dma_dest = dma_map_single(chan->device->dev,
> >> > +                           thread->dstbuf,
> >> > +                           test_buf_size, DMA_BIDIRECTIONAL);
> >> > +           dma_unmap_single(chan->device->dev, dma_dest,
> >> > +                           test_buf_size, DMA_BIDIRECTIONAL);
...
> > Well, let me explain more.
> >
> > On nono-coherent MIPS platforms, dma_map_single() for DMA_TO_DEVICE
> > writeback the cache, dma_map_single() for DMA_FROM_DEVICE invalidated
> > (without writeback) the cache.  dma_unmap_simgle() is a nop.
> >
> > If dst_off was not cacheline aligned, dma_map_single(...,
> > DMA_FROM_DEVICE) in dma_async_memcpy_buf_to_buf() invalidate whole
> > cachelines including dst_off.  So, for example, the initialized data
> > at dst_off - 1 will be just discarded.  This result mismatch error of
> > course.  Same error can be happen at end of the real DMA area.
> >
> > I added dma_map_single/dma_unmap_single to just flush all dstbuf to
> > main memory.
> 
> I am tempted to say this is a bug in the MIPS dma_map_single
> implementation.  It is at least a difference in behavior from ARM
> where partial cachelines are cleaned+invalidated in the
> DMA_FROM_DEVICE case [1].
I should argue another reason to do writeback/invalidate here in
dmatest for non-coherent archs (not only for MIPS).
The dmatest compares dstbuf outside the real DMA region to detect
illegal overwriting.  But on non-coherent archs, this comparison just
validates contents of cache, not main memory.  So dmatest might not
able to detect illegal overwriting.  Doing writeback/invalidate
_whole_ dstbuf are before dma_async_memcpy_buf_to_buf() will make
dmatest more strict.
This is why I used DMA_BIDIRECTIONAL for whole dstbuf area rather than
DMA_TO_DEVICE for two cache lines on both edges of the real DMA area.
Doesn't this make sense?
---
Atsushi Nemoto