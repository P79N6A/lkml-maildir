Date: Mon, 01 Aug 2005 15:26:45 -0400
From: Steven Rostedt <>
Subject: Re: [PATCH] Real-Time Preemption V0.7.52-07: rt_init_MUTEX_LOCKED declaration
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/8/1/192

On Mon, 2005-08-01 at 12:13 -0700, Sven-Thorsten Dietrich wrote:
> On Mon, 2005-08-01 at 19:05 +0000, Luca Falavigna wrote:
> >
> > 
> > Another solution could be this (as shown in drivers/cpufreq/cpufreq.c):
> > -	init_MUTEX_LOCKED(&policy->lock);
> > +	init_MUTEX(&policy->lock);
> > +	down(&policy->lock);
> > -
> 
> If the semaphore is being used as a mutex, 
> then it could be converted to an RT-mutex.
> 
> That would nicely side-step the problem.
> 
> Note this won't work if you are counting with the sema.
Well it's not really a counter.  It's one of these situations where the
semaphore is locked on init, later someone else ups it on a trigger, and
then the most horrible, it gets down again on module exit! I'm not
really sure what it is doing. The only place that an up is called is on
the watchdog trigger.  I guess it's being used to not let you unload the
module if the watchdog hasn't gone off yet, or something to that effect.
-- Steve
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/