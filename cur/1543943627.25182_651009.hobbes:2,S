Date: Sat, 09 Feb 2008 19:39:30 +0100
From: Peter Zijlstra <>
Subject: Re: [RFC PATCH] x86: explicit call to mmiotrace in do_page_fault()
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/2/9/216

On Sat, 2008-02-09 at 19:52 +0200, Pekka Paalanen wrote:
> +int mmiotrace_register_pf(pf_handler_func new_pfh)
>  {
> +	int ret = 0;
>  	unsigned long flags;
> +	spin_lock_irqsave(&mmiotrace_handler_lock, flags);
> +	if (mmiotrace_pf_handler)
> +		ret = -EBUSY;
> +	else
> +		mmiotrace_pf_handler = new_pfh;
> +	spin_unlock_irqrestore(&mmiotrace_handler_lock, flags);
> +	return ret;
>  }
> +EXPORT_SYMBOL_GPL(mmiotrace_register_pf);
> 
>  /**
> + * mmiotrace_unregister_pf:
>   * The caller must ensure @old_pfh is not in use anymore before freeing it.
> + * This function does not guarantee it. The handler function pointer is
> + * protected by RCU, so you can do this by e.g. calling synchronize_rcu().
>   */
> +int mmiotrace_unregister_pf(pf_handler_func old_pfh)
>  {
> +	int ret = 0;
>  	unsigned long flags;
> +	spin_lock_irqsave(&mmiotrace_handler_lock, flags);
> +	if (mmiotrace_pf_handler != old_pfh)
> +		ret = -EPERM;
> +	else
> +		mmiotrace_pf_handler = NULL;
> +	spin_unlock_irqrestore(&mmiotrace_handler_lock, flags);
> +	return ret;
>  }
So here you set/unset mmiotrace_pf_handler under protection of a
spinlock.
>  /* returns non-zero if do_page_fault() should return */
> +static inline int call_mmiotrace(struct pt_regs *regs,
> +					unsigned long error_code,
> +					unsigned long address)
>  {
> +#ifdef CONFIG_MMIOTRACE_HOOKS
>  	int ret = 0;
>  	rcu_read_lock();
> +	if (mmiotrace_pf_handler)
> +		ret = mmiotrace_pf_handler(regs, error_code, address);
>  	rcu_read_unlock();
>  	return ret;
>  #else
But here you use it under rcu_read_lock(). This doesn't match.