Date: Fri, 12 Dec 2008 15:40:24 +0000
From: Ralf Baechle <>
Subject: Re: [PATCH v2] Add preadv and pwritev system calls.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/12/12/189

On Fri, Dec 12, 2008 at 03:00:40PM +0100, Gerd Hoffmann wrote:
> This patch adds preadv and pwritev system calls.  These syscalls are a
> pretty straightforward combination of pread and readv (same for write).
> They are quite useful for doing vectored I/O in threaded applications.
> Using lseek+readv instead opens race windows you'll have to plug with
> locking.
> 
> Other systems have such system calls too, for example NetBSD, check
> here: 
http://www.daemon-systems.org/man/preadv.2.html
> 
> The patch sports the actual system call implementation and the windup in
> the x86 system call tables.  Other archs are TBD.
> +asmlinkage ssize_t sys_preadv(unsigned long fd, const struct iovec __user *vec,
> +                              unsigned long vlen, loff_t pos)
> +asmlinkage ssize_t sys_pwritev(unsigned long fd, const struct iovec __user *vec,
> +                               unsigned long vlen, loff_t pos)
As so often before the devil is in the function prototype.  On some
architectures - 32-bit MIPS and PARISC, maybe others - 64-bit arguments
such as loff_t need to be passed in an _aligned_ pair of 32-bit
arguments which effectivly requires another wrapper like this around
your compat wrapper:
asmlinkage int sys32_preadv(unsigned long fd,
       const struct compat_iovec __user *vec,
       unsigned long vlen, int dummy, unsigned a5, unsigned a6)
{
	return compat_sys_preadv(fd, vec, vlen, merge_64(a5, a6));
}
merge_64() takes two 32-bit halves of a 64-bit argument and combines them
into a 64-bit argument again.
I wonder, does that merging happen magically on x86 or?
  Ralf