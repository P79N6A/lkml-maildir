Date: Tue, 04 Oct 2005 23:12:02 +0200
From: Eric Dumazet <>
Subject: Re: [NUMA , x86_64] Why memnode_shift is chosen with the lowest possible value ?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/10/4/257

Andi Kleen a Ã©crit :
> On Friday 30 September 2005 11:09, Eric Dumazet wrote:
> 
>>+       while (populate_memnodemap(nodes, numnodes, shift + 1) >= 0)
>>+               shift++;
> 
> 
> 
> Why shift+1 here? 
Thank you Andi fo r reviewing this stuff
The idea it to find the highest shift value, and to break the loop as soon as 
the (shift + 1) value gives us an "shift too big" error.
Maybe you want to write :
         while (populate_memnodemap(nodes, numnodes, ++shift) >= 0) ;
	shift--;
Well, thats only style...
> 
> 
>>+               if ((end >> shift) >= NODEMAPSIZE)
>>+                       return 0;
> 
> 
> This should be >, not >= shouldn't it?
Let's take an example
end   = 0xffffffff;
start = 0xfff00000;
shift = 20
Suppose that NODEMAPSIZE == (end >> shift) == 0xfff
If the test is changed to :
if ((end >> shift) > NODEMAPSIZE)
	return 0;
We could do one of the iteration with (addr < end) but (addr >> shift) == 
NODEMAPSIZE
if (memnodemap[NODEMAPSIZE] != 0xff)
	return -1;
memnodemap[NODMAPSIZE] = i;
Thats bound violation of memnodemap[]
AFAIK, I wonder why NODEMAPSIZE is 0xfff and not 0x1000, because this off by 
one make half of memnodemap[] to be unused for power of two ram size.
> 
> -Andi
> 
> P.S.: Please cc x86-64 patches to discuss@x86-64.org
Ah thank you
Eric
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/