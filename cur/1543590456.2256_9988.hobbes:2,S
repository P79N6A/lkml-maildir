Date: Wed, 9 May 2001 14:52:28 -0300 (BRT)
From: Marcelo Tosatti <>
Subject: Race between try_to_swap_out() and swapin_readahead()
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2001/5/9/147

Ok, what prevents this from happening: 
CPU0				CPU1
try_to_swap_out()
...
entry = get_swap_page();
if (!entry.val)
	goto out_unlock_restore;
				swapin_readahead()
				finds valid swap entry just allocated by try_to_swap_out()
				lookup_swap_cache() fails...
				new_page = alloc_page();
				lock_page(new_page);
				add_to_swap_cache(new_page, entry);
				rw_swap_page(READ, new_page);
			 	return new_page;
/* Add it to the swap cache and mark it dirty */
add_to_swap_cache(page, entry);
set_page_dirty(page);
----
We'll end up with two pages with the same index in the hash tables, and
one of them has crap read from swap.
I know the window is really really small, but anyway... 
Comments? 
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/