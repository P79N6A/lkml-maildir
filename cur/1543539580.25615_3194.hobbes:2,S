Date: Sat, 22 Jul 2000 13:59:16 +0200
From: Vojtech Pavlik <>
Subject: Re: Direct access to hardware
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/7/22/95

On Sat, Jul 22, 2000 at 03:39:48PM +0400, Khimenko Victor wrote:
> In <8lal5l$1u7$1@enterprise.cistron.net> Miquel van Smoorenburg (miquels@cistron.nl) wrote:
> > In article <cistron.Pine.LNX.4.21.0007211543460.12570-100000@anime.net>,
> > Dan Hollis  <goemon@sasami.anime.net> wrote:
> >>On Sat, 22 Jul 2000, Ville Herva wrote:
> >>> So, would it be feasible to make it possible to disable direct hardware
> >>> access (/dev/mem, /dev/nvram, HD ioctls, what else?) completely in kernel
> >>> config?
> >>
> >>I would certainly feel better if this were possible, in which case Andre's
> >>patch would be more reasonable.
> 
> > It _is_ possible. Check out "capabilities".
> 
> HDIO_DRIVE_CMD is protected by ADMIN capability, not RAW I/O capability.
> IMNSHO is something should be fixed that's it. Perhaps better to require
> both.
I already posted a patch for this. But, in the huge amount of e-mails it
might have been lost. Here it goes again. I believe that this is the
only reasonable solution to the whole problem.
-- 
Vojtech Pavlik
SuSE Labs
--- ide.c.old	Sat Jul 22 10:19:37 2000
+++ ide.c	Sat Jul 22 10:22:02 2000
@@ -2557,7 +2557,7 @@
 			byte args[4], *argbuf = args;
 			byte xfer_rate = 0;
 			int argsize = 4;
-			if (!capable(CAP_SYS_ADMIN)) return -EACCES;
+			if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO)) return -EACCES;
 			if (NULL == (void *) arg)
 				return ide_do_drive_cmd(drive, &rq, ide_wait);
 			if (copy_from_user(args, (void *)arg, 4))
@@ -2595,7 +2595,7 @@
 		{
 			byte args[7], *argbuf = args;
 			int argsize = 7;
-			if (!capable(CAP_SYS_ADMIN)) return -EACCES;
+			if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO)) return -EACCES;
 			if (copy_from_user(args, (void *)arg, 7))
 				return -EFAULT;
 			err = ide_wait_cmd_task(drive, argbuf);