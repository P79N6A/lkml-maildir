Date: Wed, 13 Mar 2002 22:35:07 +0000 (GMT)
From: Alan Cox <>
Subject: Re: your mail
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2002/3/13/15

> +/*
> + * Deal with CONFIG_MODVERSIONS
> + */
> +#if 0 /* Pb with MODVERSIONS */
> +#if CONFIG_MODVERSIONS==1
> +#define MODVERSIONS
> +#include <linux/modversions.h>
> +#endif
> +#endif
[modversions.h is magically included by the kernel for you when its in 
 kernel if you haven't worked that one out yet]
> +#define PP_NO 3
> +struct tipar_struct  table[PP_NO];
static ?
> +               for(i=0; i < delay; i++) {
> +                       inbyte(minor);
> +               }
> +               schedule();
Oh random tip
		  if(current->need_resched)
			schedule();
will just give up the CPU when you are out of time
> +       if(table[minor].opened)
> +               return -EBUSY;
> +       table[minor].opened++;
Think about open/close at the same moment or SMP - the watchdog drivers all
had this problem and now do
	unsigned long opened = 0;
	if(test_and_set_bit(0, &opened))
		return -EBUSY;
	clear_bit(0, &opened)
[this generates atomic operations so is always safe]
> +       if(!table[minor].opened)
> +               return -EFAULT;
	BUG() may be better - it can't happen so BUG() will get a backtrace
and actually get it reported 8)
> +static long long tipar_lseek(struct file * file, long long offset, int origin)
> +{
> +       return -ESPIPE;
> +}
Can go (you now use no_llseek)
Basically except for the open/close one I'm now just picking holes. 
For the device major/minors see 
http://www.lanana.org
.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/