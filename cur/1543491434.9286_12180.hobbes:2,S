Date: Tue, 30 Mar 1999 11:05:38 -0500 (EST)
From: "Nicholas J. Leon" <>
Subject: Re: (no more) Solid freezes with 2.2.4
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/3/30/96

On Tue, 30 Mar 1999, Dave Cinege wrote:
 # Dave Cinege wrote:
 # > 
 # > 2.2.4 ran a few hours fine yesterday. Today it lasted 12 hours, then
 # > a solid freeze. I was loading a remote X window when it happened.
 # > No HD access present at all. No FPU, compiling, etc or otherwise heavy load.
 # 
Ahh... very interesting.... I've been experiencing lockups involving
networking (and, as it happens, using remote Xterms).
Andrea Arcangeli <andrea@e-mind.com> has been helping me with this issue.
There is a patch that he sent me that seems to fix my lockups entirely.
Interested? Its attached to this message and is appropriate for patching
into 2.2.3.
If it does anything for you, let Andrea know....
G'day! <>
--                                             n i c h o l a s  j  l e o n
elegance through simplicity*
http://mrnick.binary9.net
*nicholas@binary9.net
good fortune through truth*roaming:njllm@email.msn.com*ICQ#2170994*U+($++)
TRA#6805*not all questions have answers*pseudogeek:P+++($++)L+($++)W=lm@b9
2.3x10e-53*seek the path-not the destination*madison*pain builds character
From andrea@e-mind.com Fri Mar 26 16:02:25 1999
Date: Fri, 26 Mar 1999 21:56:26 +0100 (CET)
From: Andrea Arcangeli <andrea@e-mind.com>
To: Nicholas J. Leon <nicholas@binary9.net>
Subject: Re: [patch] af_unix fix for a panic a DoS and a memory leak [Re: (fwd)
With both the Oops, System.map and disassembling the .text.lock section of
the binary image of the kernel I finally discovered where the machine
lockedup, precisely in the first spinlock of ei_start_xmit().
But now I reviewed the 8390.c SMP locking code and it looks OK to me. So I
could send you some paranoid (shound-be-not-needed) patch to see if it
will make differences. I am searching for subtle bugs in disable_irq() or
similar.
Here it is the first patch, please try to reproduce with this patch
applyed. If this patch will help I'll have to think about it...
Basically it should make no differences (except that should be less
performant), but this way the SMP locking code make no assumption on the
correctness of synchronize_irq() enable/disable_irq().
Let me know...
Index: drivers/net/8390.c
===================================================================
RCS file: /var/cvs/linux/drivers/net/8390.c,v
retrieving revision 1.1.2.2
diff -u -r1.1.2.2 8390.c
--- 8390.c	1999/03/09 01:23:27	1.1.2.2
+++ linux/drivers/net/8390.c	1999/03/26 20:49:37
@@ -257,16 +257,24 @@
 
 		/* Ugly but a reset can be slow, yet must be protected */
 		
+#if 0
 		disable_irq(dev->irq);
 		synchronize_irq();
 		spin_lock(&ei_local->page_lock);
+#else
+		spin_lock_irqsave(&ei_local->page_lock, flags);
+#endif
 		
 		/* Try to restart the card.  Perhaps the user has fixed something. */
 		ei_reset_8390(dev);
 		NS8390_init(dev, 1);
 		
+#if 0
 		spin_unlock(&ei_local->page_lock);
 		enable_irq(dev->irq);
+#else
+		spin_unlock_irqrestore(&ei_local->page_lock, flags);
+#endif
 		dev->trans_start = jiffies;
 	}
     
@@ -286,17 +294,25 @@
 	 *	Slow phase with lock held.
 	 */
 	 
+#if 0
 	disable_irq(dev->irq);
 	synchronize_irq();
 	
 	spin_lock(&ei_local->page_lock);
+#else
+		spin_lock_irqsave(&ei_local->page_lock, flags);
+#endif
 	
 	if (dev->interrupt) 
 	{
 		printk(KERN_WARNING "%s: Tx request while isr active.\n",dev->name);
 		outb_p(ENISR_ALL, e8390_base + EN0_IMR);
+#if 0
 		spin_unlock(&ei_local->page_lock);
 		enable_irq(dev->irq);
+#else
+		spin_unlock_irqrestore(&ei_local->page_lock, flags);
+#endif
 		ei_local->stat.tx_errors++;
 		dev_kfree_skb(skb);
 		return 0;
@@ -339,8 +355,12 @@
 		ei_local->irqlock = 0;
 		dev->tbusy = 1;
 		outb_p(ENISR_ALL, e8390_base + EN0_IMR);
+#if 0
 		spin_unlock(&ei_local->page_lock);
 		enable_irq(dev->irq);
+#else
+		spin_unlock_irqrestore(&ei_local->page_lock, flags);
+#endif
 		ei_local->stat.tx_errors++;
 		return 1;
 	}
@@ -392,8 +412,12 @@
 	ei_local->irqlock = 0;
 	outb_p(ENISR_ALL, e8390_base + EN0_IMR);
 	
+#if 0
 	spin_unlock(&ei_local->page_lock);
 	enable_irq(dev->irq);
+#else
+		spin_unlock_irqrestore(&ei_local->page_lock, flags);
+#endif
 
 	dev_kfree_skb (skb);
 	ei_local->stat.tx_bytes += send_length;
@@ -410,6 +434,9 @@
 	int e8390_base;
 	int interrupts, nr_serviced = 0;
 	struct ei_device *ei_local;
+#if 1
+	unsigned long flags;
+#endif
     
 	if (dev == NULL) 
 	{
@@ -424,7 +451,11 @@
 	 *	Protect the irq test too.
 	 */
 	 
+#if 0
 	spin_lock(&ei_local->page_lock);
+#else
+		spin_lock_irqsave(&ei_local->page_lock, flags);
+#endif
 
 	if (dev->interrupt || ei_local->irqlock) 
 	{
@@ -436,7 +467,11 @@
 			   dev->name, inb_p(e8390_base + EN0_ISR),
 			   inb_p(e8390_base + EN0_IMR));
 #endif
+#if 0
 		spin_unlock(&ei_local->page_lock);
+#else
+		spin_unlock_irqrestore(&ei_local->page_lock, flags);
+#endif
 		return;
 	}
     
@@ -503,7 +538,11 @@
 		}
 	}
 	dev->interrupt = 0;
+#if 0
 	spin_unlock(&ei_local->page_lock);
+#else
+		spin_unlock_irqrestore(&ei_local->page_lock, flags);
+#endif
 	return;
 }
 
BTW, you are providing me a really great feedback ;).
Andrea Arcangeli