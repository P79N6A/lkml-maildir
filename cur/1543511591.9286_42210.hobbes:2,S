Date: Tue, 05 Oct 1999 11:37:01 -0400
From: Jordan Mendelson <>
Subject: Hybrid Thread/Process/Syscall Interprocess Communication?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/10/5/67

Has any thought been given to the idea of allowing different processes to call
each other's functions in their respected process space similar to how
programs call kernel functions via syscalls?
I have been looking at the various forms of IPC including shared memory, RPC,
the various message passing routines, and I've found that what I really want
is a more direct form of communication. The idea is to minimize the latency
and overhead required by some of the more heavy protocols where call times
should be measured in nanoseconds :)
The idea is to create a segment of memory shared between the two processes
which would allow the execution of functions between the two without any type
of basic message passing. This is sort of like how threads work, but between
processes which would allow more memory protection & allow processes running
under different users to share.
This is a very crude example:
P1:
	int hello(char *who) {
		printf("hello %s\n", who);
		return strlen(who);
	}
	...
	qid = shcget(P1_ID, IPC_CREAT);
	if (qid == -1) {
		fprintf(stderr, "Couldn't create P1 exposed segment\n");
		exit(-1);
	}
	shcadd(qid, &hello);
P2:
	qid = shcget(P1_ID, 0);
        if (qid == -1) {
		fprintf(stderr, "Couldn't obtain access to P1 exposed segment\n");
		exit(-1);
	}
	
	// This will cause *P1* to print Hello
	printf("%d\n", hello("P2");
So P2 would call P1's hello() and it would be executed in P1's process not
P2's.
Now there are a whole lot of problems with this including language problems
with functions it doesn't know about and segfault issues, conflicting
functions and a dozen other issues, but this sort of thing would provide a
fast & efficient method of calling functions between processes without having
to rely on things like the TCP/IP stack for communication.
I was just curious if such a thing existed in other OS's which was a bit more
refined than the crude example I gave. 
Are there any OS's with a CORBA ORB built right into the kernel where these
types of calls between two different processes are done directly instead of
over sockets?
This may not even be possible, but no harm in asking.
Just curious,
Jordan
--
Jordan Mendelson     : 
http://jordy.wserv.com
Web Services, Inc.   : 
http://www.wserv.com
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/