Date: Tue, 25 Jul 2000 17:06:06 +0200
From: Agust Karlsson <>
Subject: A20 gate handler
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/7/25/75

Hi
I am trying to get a Linux running on a AMD Elan SC400 board.
My problem seems to be that the A20 gate handler does not work.
According to the manuals there should be 3 possibilities that are ORed so if
ANY of them is turned on it should be turned on. I found some code to debug
cache and A20 from Jens Mauer at www.cck.uni-kl.de/tecra710 but I am not
quite sure if it is 100% OK. I.e. if it reports that the A20 is not working
even thoug it is.
If I boot with this kernel on my normal PC everything is OK, but on the
SC400 it writes only 00's from the caching bit and reports that there is no
A20 gate handler.
I have put the code from my setup.S below and those ifdef's are all defined
earlier and I have tried all combinations of those three.
Any hint, comment or advice is appreciated.
Agust Karlsson
Pallas Informatik
Alleroed Stationsvej 2D
DK-3450 Alleroed   Denmark
Tel: +45 4810 2410
Fax: +45 4810 2401
------------------------------------------------------------
!KAK If we are using 8042 
#ifdef KEYB_A20
	call	empty_8042
	mov	al,#0xD1		! command write
	out	#0x64,al
	call	empty_8042
	mov	al,#0xDF		! A20 on
	out	#0x60,al
	call	empty_8042
#endif
!KAK If we are using sysctl port for A20
#ifdef SYSCTL_A20
	mov	al,#0x2		!Gate A20
	out	#0x92,al	!via port 92h
#endif
!KAK If we are using dummy read from port 0xEE for A20
#ifdef ELAN_A20
	in	al,0xEE
#endif
!KAK some cache kludge
	seg	cs
	test	byte ptr loadflags,#LOADED_HIGH
	jz	end_cache_kludge
	mov	ax,#0xffff	! ds:si = 0x100000
	mov	ds,ax
	mov	si,#0x10
	cld
	mov	cx,#0x2000	! 16 KB
	rep
	lodsw
	mov	ax,cs
	mov	ds,ax		! restore DS
end_cache_kludge:
!KAK end indsaet
! wait until a20 really *is* enabled; it can take a fair amount of
! time on certain systems; Toshiba Tecras are known to have this
! problem.  The memory location used here is the int 0x1f vector,
! which should be safe to use; any *unused* memory location < 0xfff0
! should work here.  
#
#define	TEST_ADDR 0x7c
	push	ds
	xor	ax,ax			! segment 0x0000
	mov	ds,ax
	dec	ax			! segment 0xffff (HMA)
	mov	gs,ax
	mov	bx,[TEST_ADDR]		! we want to restore the value later
a20_wait:
	inc	ax
	mov	[TEST_ADDR],ax
	seg	gs
	cmp	ax,[TEST_ADDR+0x10]
	je	a20_wait		! loop until no longer aliased
	mov	[TEST_ADDR],bx		! restore original value
	pop	ds
	
!KAK debugging cache and A20
!Code from Jens Maurer was used on a Toshiba Tecra 710CDT laptop
#define DEBUG_CACHE 1
#define DEBUG_A20 1
	push	es
	mov	ax,#0xff00
	mov	es,ax
	mov	si,#0x1000
#if DEBUG_CACHE
	mov	cx,#0x10
	call	print_mem
	mov	si,#0x1000
	mov	cx,#0x10
	call	print_mem
	jmp	cache_end
!mem dump
print_mem:
	push	cx
	mov	cx,#2
	seg	es
	mov	dh, (si)
	call	print_digit
	call 	prtspc
	inc	si
	pop	cx
	loop	print_mem
print_nl:
	mov	ax, #0xe0d
	int	0x10
	mov	al, #0xa
	int	0x10
	ret
print_digit:
	rol	dx,#4
	mov	ax, #0xe0f
	and	al,dl
	add	al,#0x90
	daa
	adc	al,#0x40
	daa
	int	0x10
	loop	print_digit
	ret
#else	/* DEBUG_CACHE */
	mov	cx,#0x4000
cache_purge:
	seg	es
	mov	al, (si)
	inc	si
	loop	cache_purge
#endif	/* DEBUG_CACHE */
cache_end:
#if DEBUG_A20
	seg	es
	mov	bx,0x1000
#if 0
	push	ds
	xor	ax, ax
	mov	ds, ax
	cmp	bx,0x0
	pop	ds
	jne	a20_ok
#endif
	cmp	bx, #0xfafc
	je	a20_ok
	lea	si, no_a20_msg
	call	prtstr
no_a20_loop:
	jmp no_a20_loop		!loop forever
no_a20_msg:	.ascii "A20 gating failed"
	db 0x0
a20_ok:
#endif /* DEBUG_A20 */
	pop	es
! setup descriptor tables
	lidt	idt_48		! load idt with 0,0
	lgdt	gdt_48		! load gdt with whatever appr.
-----------------------------------------------
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/