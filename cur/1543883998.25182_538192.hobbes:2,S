Date: Tue, 01 May 2007 22:09:02 +1000
From: Nick Piggin <>
Subject: Re: How to make mmap'ed kernel buffer non-cacheable
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/5/1/212

Bhuvan Kumar MITTAL wrote:
> Hi Alan,Nick
> 
> Thanks for your inputs. I was able to solve the problem of mapping kernel buffer to user space. Just FYI, I am working on a sh4 based architecture proprietary board with Linux kernel 2.6.17.3
So... you used flush_dcache_page? Or what?
> Initially I was adopting the following approach: 
> 1.The kernel thread was copying some data and waiting on a semaphore for the user task to make an ioctl into the kernel space and relieve the wait.
> 2. Then the user task was getting spawned and taking the data from kernel.
> 
> ---> This was resulting in some initial data drop coz the kernel task was overwhelming and outspeeding the user task (Maybe someone can explain how)
> 
> How I solved the problem?
> 
> Instead of making the kernel wait for the user task, I reversed the sequence and did not let the kernel task be activated till the user task was spawned and waiting in kernel space(after making ioctl) for the kernel task. Then I started the kernel task and the problem of data dropping was resolved.
OK. Seems like a straightfoward producer-consumer problem.
I don't know why you should be dropping data if your kernel task blocks when
its output buffer is full and your user task blocks when it is empty. But anyway,
it seems you solved it. Good :)
> In continuation to this, I have another query:
> As mentioned above, If there is a kernel task waiting on a semaphore (maybe even in hung state) and I wish to kill the kernel task from user space by making an ioctl call into the kernel, then how is it possible? Is it feasible at all?
If the kernel task is hung because of some bug in your code, then it isn't
really possible in general. You could always just "up" the semaphore and hope,
but things might be corrupted.
If you just want to tell the kernel task to quit, I guess you'd just introduce
some quit ioctl message, and have the kernel thread respond to that.
-- 
SUSE Labs, Novell Inc.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/