Date: Thu, 07 Oct 1999 19:29:48 -0400
From: Jeff Garzik <>
Subject: [patch] PCI probe
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/10/7/194

Linus,
Attached is a patch against 2.3.20-pre1 which adds a PCI probe helper
function.
The intention is to provide a generic replacement for code which gets
duplicated frequently across the kernel.  It is called "simple" because
it only provides PCI probing, and not full driver registration system
like drivers/pci/scan.c found in 2.3.18ac kernels.
It incorporates comments from Martin Mares (code in separate module),
Petr Vandrovec (bus scan order) and others.
Regards,
	Jeff
-- 
Custom driver development	|    Never worry about theory as long
Open source programming		|    as the machinery does what it's
				|    supposed to do.  -- R. A. Heinleindiff -urN linux-2.3.20-pre1/include/linux/pci.h linux/include/linux/pci.h
--- linux-2.3.20-pre1/include/linux/pci.h	Thu Oct  7 18:43:09 1999
+++ linux/include/linux/pci.h	Thu Oct  7 19:19:18 1999
@@ -471,6 +471,28 @@
 		    int (*)(struct pci_dev *, u8, u8));
 
 /*
+ * simple PCI probing for drivers
+ */
+ 
+struct pci_simple_probe_entry;
+typedef int (*pci_simple_probe_callback) (struct pci_dev *dev, int match_num,
+				   	  const struct pci_simple_probe_entry *ent,
+					  void *drvr_data);
+
+struct pci_simple_probe_entry {
+	unsigned short vendor;	/* vendor id, PCI_ANY_ID, or 0 for last entry */
+	unsigned short device;	/* device id, PCI_ANY_ID, or 0 for last entry */
+	unsigned short subsys_vendor; /* subsystem vendor id, 0 for don't care */
+	unsigned short subsys_device; /* subsystem device id, 0 for don't care */
+	void *dev_data;		/* driver-private, entry-specific data */
+};
+
+int pci_simple_probe (struct pci_simple_probe_entry *list, size_t match_limit,
+		      pci_simple_probe_callback cb, void *drvr_data);
+
+
+
+/*
  *  If the system does not have PCI, clearly these return errors.  Define
  *  these as simple inline functions to avoid hair in drivers.
  */
@@ -505,6 +527,9 @@
 extern inline void pci_set_master(struct pci_dev *dev) 
 { return; }
 
+int pci_simple_probe (struct pci_simple_probe_entry *list, size_t match_limit,
+		      pci_simple_probe_callback cb, void *drvr_data)
+{ return 0; }
 
 #endif /* !CONFIG_PCI */
 
diff -urN linux-2.3.20-pre1/drivers/pci/Makefile linux/drivers/pci/Makefile
--- linux-2.3.20-pre1/drivers/pci/Makefile	Thu Oct  7 18:42:57 1999
+++ linux/drivers/pci/Makefile	Thu Oct  7 19:19:18 1999
@@ -25,7 +25,7 @@
 L_OBJS   += proc.o
 endif
 
-L_OBJS   += compat.o quirks.o names.o
+L_OBJS   += compat.o quirks.o names.o helper.o
 
 ifndef CONFIG_X86
 L_OBJS   += syscall.o setup.o
diff -urN linux-2.3.20-pre1/drivers/pci/helper.c linux/drivers/pci/helper.c
--- linux-2.3.20-pre1/drivers/pci/helper.c	Wed Dec 31 19:00:00 1969
+++ linux/drivers/pci/helper.c	Thu Oct  7 19:19:18 1999
@@ -0,0 +1,69 @@
+/*
+ * $Id$
+ *
+ * drivers/pci/helper.c
+ *
+ * Copyright 1999 Jeff Garzik <jgarzik@pobox.com>
+ * This software is free.  See the file COPYING for licensing details.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+
+
+int pci_simple_probe (struct pci_simple_probe_entry *list, size_t match_limit,
+		      pci_simple_probe_callback cb, void *drvr_data)
+{
+	struct pci_dev *dev;
+	struct pci_simple_probe_entry *ent;
+	size_t matches = 0;
+	unsigned short vendor, device;
+	int rc;
+
+	if (!list || !cb)
+		return -1;
+
+	dev = pci_find_device (PCI_ANY_ID, PCI_ANY_ID, NULL);
+	while (dev) {
+		ent = list;
+		while (ent->vendor && ent->device) {
+			vendor = ent->vendor;
+			device = ent->device;
+
+			if (((vendor != 0xFFFF) &&
+			     (vendor != dev->vendor)) ||
+			    ((device != 0xFFFF) &&
+			     (device != dev->device))) {
+			     	ent++;
+				continue;
+			}
+			    
+			if (((ent->subsys_vendor) &&
+			     (ent->subsys_vendor != dev->subsystem_vendor)) ||
+			    ((ent->subsys_device) &&
+			     (ent->subsys_device != dev->subsystem_device))) {
+			     	ent++;
+				continue;
+			}
+			    
+			rc = (* cb) (dev, matches, ent, drvr_data);
+			if (rc < 0)
+				return rc;
+
+			matches++;
+
+			if (match_limit && match_limit == matches)
+				return matches;
+
+			ent++;
+		}
+
+		dev = pci_find_device (PCI_ANY_ID, PCI_ANY_ID, dev);
+	}
+
+	return matches;
+}
+
+