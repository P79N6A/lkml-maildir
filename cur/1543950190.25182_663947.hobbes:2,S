Date: Wed, 5 Mar 2008 20:11:09 +0300
From: Oleg Nesterov <>
Subject: Re: [PATCH 0/3] orphaned pgrp fixes
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/3/5/270

On 03/04, Roland McGrath wrote:
>
> What seems most pedantically right for this check is:
> 		is_my_init(p, p->real_parent)
> i.e.
> 		if (task_session(p->real_parent) == task_session(p) &&
> 		    task_pgrp(p->real_parent) != pgrp &&
> 		    task_tgid_nr_ns(p->real_parent, p->nsproxy->pid_ns) != 1)
> 			return 0;
> It's excluded from counting as in your session if you consider to to be init.
Yes. Not that I really understand ;) But Eric also suggested to use
is_container_init().
> The write lock on
> tasklist_lock strictly serializes all exiting process's calls from
> exit_notify.  This call is after group_dead hits.  If some other
> process in the pgrp has ->signal->live > 0 then it has not exited yet
> and when it does it will do this same check, guaranteed to be after
> ours, and after our ->signal->live == 0.
Yes. I though about that too. But, unlike ->exit_state, signal->live
is not protected by tasklist, please see below.
> Since it's after our own
> group_dead hit, the "ignored_task" check for our own group leader is
> redundant with that.
Ah, good point. I didn't realize this when I was thinking about using
signal->live.
So perhaps it's:
> 
> 	do_each_pid_task(pgrp, PIDTYPE_PGID, p) {
> 		if (task_session(p->real_parent) == task_session(p) &&
> 		    task_pgrp(p->real_parent) != pgrp &&
>  		    atomic_read(&p->signal->live) > 0 &&
> 		    task_tgid_nr_ns(p->real_parent, p->nsproxy->pid_ns) != 1)
> 			return 0;
> 	} while_each_pid_task(pgrp, PIDTYPE_PGID, p);
I am hopeless, I can't understand orphaned pgrps.
But still. Let's suppose that pgrp should be considered as orphaned when
2 tasks A and B exit. They both exit at the same time and decrement ->live
down to zero. Now, they both can send SIGHUP to the stopped tasks.
No?
That said. Even if I am right, I agree that the signal->live check is
better. I like very much the possibility to kill the ugly "ignored_task".
> Now, about has_stopped_jobs.  It's a waste for it to be a separate loop
> across the pgrp just after we did one in will_become_orphaned_pgrp.  They
> should be merged together.
Yes sure. Looking at the code I was surprised why we don't do that.
Oleg.