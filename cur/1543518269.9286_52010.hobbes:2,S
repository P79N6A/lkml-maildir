Date: Wed, 8 Dec 1999 00:18:21 +0100
From: (Davide Libenzi)
Subject: Re: deadlock avoidance?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/12/7/163

Tuesday, December 07, 1999 11:56 PM
Johannes Erdfelt <jerdfelt@sventech.com> wrote :
> > AFAIK spin_lock_irq() does not permit IRQ firing.
>
> On that CPU, look at the SMP case.
>
> JE
>
spin_lock_irqsave() guaranteed that only an uninterrupted CPU execute the
code protected by the lock.
See at this implementation ( optimization = 0.0 ) :
struct s_nested_lock {
    spinlock_t lock;
    short int pid;
    short int count;
};
#define nested_lock(lock, flags) \
    if (lock->pid == getpid()) { \
        ++lock->count; \
    } else { \
        spin_lock_irqsave(&lock->lock, flags); \
        lock->pid = getpid(); \
    }
#define nested_unlock(lock, flags) \
    if (--lock->count == 0) { \
        lock->pid = 0; \
        spin_unlock_irqrestore(&lock->lock, flags); \
    }
Cheers,
    Davide.
--
"Debian, the Freedom in Freedom."
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/