Date: Mon, 10 Dec 2001 13:25:42 +0100
From: Niteshadow <>
Subject: Re: [PATCH] Make highly niced processes run only when idle
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2001/12/10/54

On Mon, Dec 10, 2001 at 12:46:23AM -0200, Rik van Riel wrote:
> On 9 Dec 2001, Robert Love wrote:
> 
> > Hmm, what if we only boosted it based on something like this:
> >
> > 	if (p->policy == SCHED_IDLE) {
> > 		weight = p->counter;
> > 		if (p->lock_depth >= 0 || signal_pending(p))
> > 			/* boost somehow ... */
> > 	}
> 
> Now what if the process is holding an inode or superblock
> semaphore ?
Even better:
What if the SCHED_IDLE task holds a POSIX read lock on a file ?
Say we have three processes:
A is SCHED_IDLE holding read lock on /foo/bar
B is SCHED_OTHER wanting to acquire write lock /foo/bar
C is SCHED_OTHER computing fractals and eating up every cycle it can get
What we want is A to get B's priority until it releases the lock on
/foo/bar and then revert it to SCHED_IDLE policy. Otherwise B would get
deadlocked with A while C (or any other CPU hog) is running.
I know this is a userspace problem (similar to real-time processes vs.
normal processes), but I think it would be nice to make SCHED_IDLE
non-priviliged policy.
-- 
Kind regards,
Robert Varga
------------------------------------------------------------------------------
n@hq.sk                                          
http://hq.sk/~nite/gpgkey.txt
 
[unhandled content-type:application/pgp-signature]