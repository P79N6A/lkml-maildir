Date: Mon, 22 Dec 2008 16:28:27 +0530
From: Niraj Kumar <>
Subject: Re: [RFC PATCH -v4 00/14] fsnotify, dnotify, and inotify
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/12/22/48

O Sun, Dec 21, 2008 at 10:22:06PM -0500, Eric Paris wrote:
> On Thu, 2008-12-18 at 18:36 -0500, C. Scott Ananian wrote:
> > On Fri, Dec 12, 2008 at 4:51 PM, Eric Paris <eparis@redhat.com> wrote:
> > > The following series implements a new generic in kernel filesystem
> > > notification system, fsnotify.  On top of fsnotify I reimplement dnotify and
> > > inotify.  I have not finished with the change from inotify although I think
> > > inotify_user should be completed.  In kernel inotify users (aka audit) still
> > > (until I get positive feedback) relay on the old inotify backend.  This can be
> > > 'easily' fixed.
> > > All of this is in preperation for fanotify and using fanotify as an on access
> > > file scanner.   So you better know it's coming.
Eric,
I was also getting my hands dirty with inotify (and friends)
but I see that you are already ahead. So, I thought I would
rather list my immediate requirements and see how far we can go with that.
My application is interested in only filesystem events (read/write/delete) but:
1)  wants notification of only those events which are generated by the
calling process and it's children.
2) Subject to the constraint as mentioned above (1), it would be nice if I 
can just say that I need to be notified of events on all filesystem
objects (perhaps within a namespace) rather than specifying each and 
every file/dir that I am interested in. This is somewhat similar to the
"recursive watch" problem that others have mentioned.
The first part is fairly easy to achieve and I had already created a
patch for that on top of inotify. (See patch below). I was still 
thinking about second part when I saw your patches. Can you tell me
whether your work is going to achive this? Maybe I can modify my
patch to work on top of what you are proposing ...
-Niraj
--------------------------------
Inotify: filter events only by the current process and it's children.
Adds a new flag (to be used with sys_inotify_init1) which
restricts notifications of only those events which has been
generated by the calling process and it's children.
This patch is on top of 2.6.28-rc5.
Signed-off-by: Niraj Kumar <niraj17@gmail.com>
diff --git a/fs/inotify.c b/fs/inotify.c
index 7bbed1b..f7ed34e 100644
--- a/fs/inotify.c
+++ b/fs/inotify.c
@@ -80,6 +80,8 @@ struct inotify_handle {
 	struct list_head	watches;	/* list of watches */
 	atomic_t		count;		/* reference count */
 	u32			last_wd;	/* the last wd allocated */
+	struct task_struct      *owner_task;    /* owner task_struct */
+	u32			flags;	        /* operations flags */
 	const struct inotify_operations *in_ops; /* inotify caller operations */
 };
 
@@ -310,6 +312,18 @@ void inotify_inode_queue_event(struct inode *inode, u32 mask, u32 cookie,
 		u32 watch_mask = watch->mask;
 		if (watch_mask & mask) {
 			struct inotify_handle *ih= watch->ih;
+			struct task_struct *curr = current;
+			int found = 0;
+			if (ih->flags & IN_ONLY_CHILD) {
+				for (curr = current; curr != &init_task;
+							 curr = curr->parent)
+					if (ih->owner_task == curr) {
+						found = 1;
+						break;
+					}
+				if (!found)
+					continue;
+			}
 			mutex_lock(&ih->mutex);
 			if (watch_mask & IN_ONESHOT)
 				remove_watch_no_event(watch, ih);
@@ -467,7 +481,8 @@ EXPORT_SYMBOL_GPL(inotify_inode_is_dead);
  * inotify_init - allocate and initialize an inotify instance
  * @ops: caller's inotify operations
  */
-struct inotify_handle *inotify_init(const struct inotify_operations *ops)
+struct inotify_handle *inotify_init(const struct inotify_operations *ops,
+			 int flags)
 {
 	struct inotify_handle *ih;
 
@@ -479,6 +494,8 @@ struct inotify_handle *inotify_init(const struct inotify_operations *ops)
 	INIT_LIST_HEAD(&ih->watches);
 	mutex_init(&ih->mutex);
 	ih->last_wd = 0;
+	ih->owner_task = current;
+	ih->flags = flags;
 	ih->in_ops = ops;
 	atomic_set(&ih->count, 0);
 	get_inotify_handle(ih);
diff --git a/fs/inotify_user.c b/fs/inotify_user.c
index d367e9b..15359e3 100644
--- a/fs/inotify_user.c
+++ b/fs/inotify_user.c
@@ -588,7 +588,7 @@ asmlinkage long sys_inotify_init1(int flags)
 	BUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);
 	BUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);
 
-	if (flags & ~(IN_CLOEXEC | IN_NONBLOCK))
+	if (flags & ~(IN_CLOEXEC | IN_NONBLOCK | IN_ONLY_CHILD))
 		return -EINVAL;
 
 	fd = get_unused_fd_flags(flags & O_CLOEXEC);
@@ -614,7 +614,7 @@ asmlinkage long sys_inotify_init1(int flags)
 		goto out_free_uid;
 	}
 
-	ih = inotify_init(&inotify_user_ops);
+	ih = inotify_init(&inotify_user_ops, flags);
 	if (IS_ERR(ih)) {
 		ret = PTR_ERR(ih);
 		goto out_free_dev;
diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index 37ea289..24adb0e 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -66,8 +66,10 @@ struct inotify_event {
 			 IN_MOVE_SELF)
 
 /* Flags for sys_inotify_init1.  */
-#define IN_CLOEXEC O_CLOEXEC
-#define IN_NONBLOCK O_NONBLOCK
+#define IN_CLOEXEC O_CLOEXEC     /* 02000000 */
+#define IN_NONBLOCK O_NONBLOCK   /* 00004000 */
+#define IN_ONLY_CHILD 0x00000002 /* only notify event generated by this
+					 process and children. */
 
 #ifdef __KERNEL__
 
@@ -117,7 +119,8 @@ extern u32 inotify_get_cookie(void);
 
 /* Kernel Consumer API */
 
-extern struct inotify_handle *inotify_init(const struct inotify_operations *);
+extern struct inotify_handle *inotify_init(const struct inotify_operations *,
+							 int);
 extern void inotify_init_watch(struct inotify_watch *);
 extern void inotify_destroy(struct inotify_handle *);
 extern __s32 inotify_find_watch(struct inotify_handle *, struct inode *,
diff --git a/kernel/audit.c b/kernel/audit.c
index 4414e93..c3c9e7d 100644
--- a/kernel/audit.c
+++ b/kernel/audit.c
@@ -983,7 +983,7 @@ static int __init audit_init(void)
 	audit_log(NULL, GFP_KERNEL, AUDIT_KERNEL, "initialized");
 
 #ifdef CONFIG_AUDITSYSCALL
-	audit_ih = inotify_init(&audit_inotify_ops);
+	audit_ih = inotify_init(&audit_inotify_ops, 0);
 	if (IS_ERR(audit_ih))
 		audit_panic("cannot initialize inotify handle");
 #endif
diff --git a/kernel/audit_tree.c b/kernel/audit_tree.c
index 8b50944..e631b60 100644
--- a/kernel/audit_tree.c
+++ b/kernel/audit_tree.c
@@ -907,7 +907,7 @@ static int __init audit_tree_init(void)
 {
 	int i;
 
-	rtree_ih = inotify_init(&rtree_inotify_ops);
+	rtree_ih = inotify_init(&rtree_inotify_ops, 0);
 	if (IS_ERR(rtree_ih))
 		audit_panic("cannot initialize inotify handle for rectree watches");
 