Date: Fri, 28 Jul 2000 14:25:40 -0700 (PDT)
From: Ivan Passos <>
Subject: Re: Updated 2.4 status/todo list
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/7/28/153

On Fri, 28 Jul 2000, Jeff Garzik wrote:
> 
> There's no specification for this scheme and driver examples are
> sometimes convoluted.
I hear you. :)
> for each PCI MMIO region you use, here is a quick summary of the
> "rules", vaguely in order of usage:
> 
> * obtain PCI region info using back-and-forward-portable macros
> pci_resource_{start,end,len,flags}
> * reserve using request_mem_region, check for NULL return
> * cookie = ioremap(), check for NULL return
> * communicate with MMIO region using {read,write}[bwl], memcpy*io,
> memset_io, and io_remap_page_range.  addressing is accomplished via
> offsets from the value in 'cookie'.
> * never directly de-reference an ioremap'd area
> * free region when done, with iounmap()
> * release acquired resource region with release_mem_region
The only thing that my drivers are not doing is the
[request|release]_mem_region() (I thought these functions existed only for
I/O regions, i.e. [request|release]_region() ). I'll update them.
Now, just out of curiosity: since the PCI allocation scheme makes sure
that MMIO regions do not overlap, why is it necessary to request these
regions to the OS?? For I/O regions, I understand, because an ISA device
can try and probe an area where a PCI device is mapped. However, for MMIO
regions, since most PCI devices are mapped above 1MB, ISA devices can't
foul around with them. Is this mostly to protect PCI devices mapped below
1MB, or is it also for other things?!?!
Thanks for your detailed answer!
Later,
Ivan
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/