Date: Tue, 22 Jan 2008 10:00:55 +0900
From: Tejun Heo <>
Subject: Re: [PATCHSET] printk: implement printk_header() and merging printk
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/1/21/363

Matt Mackall wrote:
> I suppose. I still find this approach less than ideal, especially
> putting something potentially large on the stack. The dangers are
> perhaps worse than a malloc, really. 
I pondered on this a bit but the thing is we already use several
hundreds bytes in a function which builds complex messages.  The
original ata_eh_report() implementation allocates 424 bytes on stack for
temp buffers and local variables.  In addition to that, it calls printk
with upto 30 arguments (~240 bytes).  While the new implementation
allocates 232 bytes sans the buffer and the maximum number of arguments
is about sixteen (~128 bytes).  ata_eh_report() uses a fixed buffer but
320byte buffer should be sufficient.
In total, it's 664 vs 680 and that's for a really big message.  mprintk
also allows fixed or malloc'd buffers so if you wanna go bigger,
malloc'd buffer should do the job.
> I also don't like your interface much. Consider this alternative:
> 
> struct mprintk *mp = mprintk_begin(KERN_INFO "ata%u.%2u: ", 1, 0);
> mprintk(mp, "ATA %d", 7);
> mprintk(mp, ", %u sectors\n", 1024);
> mprintk(mp, "everything seems dandy\n");
> mprintk_end(mp);
> 
> That keeps all the "normal" printks short and makes the flush more
> explict.
I like that the more used function is shorter.  Hmmm... The reason why I
first used mprintk_push() is to make it clear that the function
accumulates messages unlike mprintk() which flushes what's accumulated
and prints its own message.
> Now we make mprintk_begin attempt to do a kmalloc of a moderate size
> (512 bytes?) and failing that, return null. Then mprintk can fall
> through to printk in the NULL case.
If you wanna do that implicitly, you need GFP_ flag in mprintk_begin()
and atomic allocation should be used from interrupt handlers and friends
and they fail easily under the right (or wrong) conditions.  Forcing
kmalloc isn't a good idea.  Having multiple initializers is one way to
do it.  Any suggestions?
Thanks.
-- 
tejun