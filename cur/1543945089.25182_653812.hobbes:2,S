Date: Thu, 14 Feb 2008 12:47:44 -0800
From: Greg KH <>
Subject: Re: Handshaking on USB serial devices
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/2/14/366

On Thu, Feb 14, 2008 at 07:55:44PM +1030, David Newall wrote:
> The current 2.6 driver maintains it's own buffer.  I think that's a bad
> thing: usbserial already buffers writes, and the extra buffer copy seems
> unnecessary, however it does solve the putchar problem.  Buffered (i.e.
> by the 2.6 series pl2303 driver) data is written as soon as practicable,
> regardless of CTS/DTR.  The same general workaround, but placed in
> pl2303_send seems correct to me; that is, stop submitting write urbs
> when the remote end lowers CTS/DTR, and trigger the resume from the
> interrupt callback (specifically in update_line_status.)
Where does the usbserial core buffer writes on 2.6?  The serial_write()
function just passes the data straight down to the usb-serial child
driver directly, no copying or buffering happens that I can see.
> To make it clear: Even aside from the buffer in 2.6's pl2303.c, there's
> a race: An in-flight write URB can fill all hardware buffers, making
> unsafe what previously appeared to be a safe write.  I think it's
> essential to delay submission of the URB on a stop-transmit condition.
It's up to the individual driver to know when their buffers are filled
up.  The big problem is, a lot of these cheap usb-serial devices (like
the pl2303) don't have a way to report the uart queue filled-state back
to the host, so things can easily get over-run as you have found out.
If you really want to use a usb-serial device in an environment where
such kinds of flow control are essential, then you have to buy the more
expensive ones.  The I/O networks devices handle this kind of thing very
well, and have done so since the 2.3 days, but they cost much more than
the cheap pl2303-based devices.
thanks,
greg k-h