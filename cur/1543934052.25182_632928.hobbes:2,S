Date: Mon, 31 Dec 2007 13:10:31 -0500
From: Mike Frysinger <>
Subject: Re: asm-x86/msr.h for sanitized headers: clean it or punt it
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/12/31/100

On Monday 31 December 2007, Andi Kleen wrote:
> > can you enumerate which functions need to actually go to userspace then ?
> >  the
>
> rdtscl/rdtscll/rdpmc primarily
i'll just mark out the useless C funcs then
> > __KERNEL__ markings are a crapshoot at the moment.  you must also be
> > jumping through hoops in order to use the header in the first place since
> > the vanilla one wont compile out of the box.
>
> At least the 64bit one or older 32bit one works without hoops. Agreed that
> the paravirt changes destroyed it on newer 32bit though. That's an
> unfortunate regression.
i dont see how when the exported code has prototypes with "u32" types in them.
but at any rate ...
---
Use __asm__ and __volatile__ in code that is exported to userspace.  Wrap
kernel functions with __KERNEL__ so they get scrubbed.
Signed-off-by: Mike Frysinger <vapier@gentoo.org>
---
diff --git a/include/asm-x86/msr.h b/include/asm-x86/msr.h
index ba4b314..ffb9319 100644
--- a/include/asm-x86/msr.h
+++ b/include/asm-x86/msr.h
@@ -193,7 +193,7 @@ static inline int wrmsr_safe_on_cpu(unsigned int cpu, u32 msr_no, u32 l, u32 h)
 
 /* wrmsr with exception handling */
 #define wrmsr_safe(msr,a,b) ({ int ret__;			\
-	asm volatile("2: wrmsr ; xorl %0,%0\n"			\
+	__asm__ __volatile__("2: wrmsr ; xorl %0,%0\n"			\
 		     "1:\n\t"					\
 		     ".section .fixup,\"ax\"\n\t"		\
 		     "3:  movl %4,%0 ; jmp 1b\n\t"		\
@@ -210,7 +210,7 @@ static inline int wrmsr_safe_on_cpu(unsigned int cpu, u32 msr_no, u32 l, u32 h)
 
 #define rdmsr_safe(msr,a,b) \
 	({ int ret__;						\
-	  asm volatile ("1:       rdmsr\n"			\
+	  __asm__ __volatile__ ("1:       rdmsr\n"			\
 			"2:\n"					\
 			".section .fixup,\"ax\"\n"		\
 			"3:       movl %4,%0\n"			\
@@ -230,17 +230,17 @@ static inline int wrmsr_safe_on_cpu(unsigned int cpu, u32 msr_no, u32 l, u32 h)
      __asm__ __volatile__ ("rdtsc" : "=a" (low) : : "edx")
 
 #define rdtscp(low,high,aux) \
-     asm volatile (".byte 0x0f,0x01,0xf9" : "=a" (low), "=d" (high), "=c" (aux))
+     __asm__ __volatile__ (".byte 0x0f,0x01,0xf9" : "=a" (low), "=d" (high), "=c" (aux))
 
 #define rdtscll(val) do { \
      unsigned int __a,__d; \
-     asm volatile("rdtsc" : "=a" (__a), "=d" (__d)); \
+     __asm__ __volatile__("rdtsc" : "=a" (__a), "=d" (__d)); \
      (val) = ((unsigned long)__a) | (((unsigned long)__d)<<32); \
 } while(0)
 
 #define rdtscpll(val, aux) do { \
      unsigned long __a, __d; \
-     asm volatile (".byte 0x0f,0x01,0xf9" : "=a" (__a), "=d" (__d), "=c" (aux)); \
+     __asm__ __volatile__ (".byte 0x0f,0x01,0xf9" : "=a" (__a), "=d" (__d), "=c" (aux)); \
      (val) = (__d << 32) | __a; \
 } while (0)
 
@@ -320,6 +320,7 @@ static inline unsigned int cpuid_edx(unsigned int op)
 	return edx;
 }
 
+#ifdef __KERNEL__
 #ifdef CONFIG_SMP
 void rdmsr_on_cpu(unsigned int cpu, u32 msr_no, u32 *l, u32 *h);
 void wrmsr_on_cpu(unsigned int cpu, u32 msr_no, u32 l, u32 h);
@@ -343,6 +344,7 @@ static inline int wrmsr_safe_on_cpu(unsigned int cpu, u32 msr_no, u32 l, u32 h)
 	return wrmsr_safe(msr_no, l, h);
 }
 #endif  /* CONFIG_SMP */
+#endif  /* __KERNEL__ */
 #endif  /* __ASSEMBLY__ */
 
 #endif  /* !__i386__ */