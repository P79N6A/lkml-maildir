Date: Fri, 10 Dec 1999 14:43:35 +0000 (GMT)
From: Tigran Aivazian <>
Subject: to make vmalloc()/vfree() one needs to...
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/12/10/78

Hi,
Goal: it would be a good idea to make vmalloc()/vfree() SMP-safe
Proposal: have a spinlock_t vmlist_lock to protect vmlist list
Problem: vread() calls put_user() while walking through the list
So, we are back to the old classical problem of walking through the list
protected by the spinlock and copying the elements thereof to the
userspace.
When I asked a similar (well, identical almost) question in the context of
module_list, the suggestions I received were:
a) use kmap()/kunmap() to pin user buffer before taking the spinlock.
b) drop the spinlock and rediscover position in the vmlist after
put_user() (i.e. assuming that we *may* have slept)
Looks like kmap() can only map a (single) page so it is not good enough
for vread(). Is this true?
So, my only option is b)?
Regards,
Tigran.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/