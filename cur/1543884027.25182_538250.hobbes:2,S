Date: Tue, 1 May 2007 19:55:38 +0530
From: "Satyam Sharma" <>
Subject: Re: [PATCH 16/21] sysfs: implement bin_buffer
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/5/1/270

On 4/28/07, Tejun Heo <htejun@gmail.com> wrote:
> Implement bin_buffer which contains a mutex and pointer to PAGE_SIZE
> buffer to properly synchronize accesses to per-openfile buffer and
> prepare for immediate-kobj-disconnect.
>
> Signed-off-by: Tejun Heo <htejun@gmail.com>
> ---
> [...]
> @@ -135,14 +160,22 @@ static int open(struct inode * inode, struct file * file)
>                 goto Error;
>
>         error = -ENOMEM;
> -       file->private_data = kmalloc(PAGE_SIZE, GFP_KERNEL);
> -       if (!file->private_data)
> +       bb = kzalloc(sizeof(*bb), GFP_KERNEL);
> +       if (!bb)
>                 goto Error;
>
> +       bb->buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
You could simply do a __get_free_page() here instead of a kmalloc(PAGE_SIZE).
> @@ -155,11 +188,12 @@ static int release(struct inode * inode, struct file * file)
>         struct kobject * kobj = to_kobj(file->f_path.dentry->d_parent);
>         struct sysfs_dirent *attr_sd = file->f_path.dentry->d_fsdata;
>         struct bin_attribute *attr = attr_sd->s_elem.bin_attr.bin_attr;
> -       u8 * buffer = file->private_data;
> +       struct bin_buffer *bb = file->private_data;
>
>         kobject_put(kobj);
>         module_put(attr->attr.owner);
> -       kfree(buffer);
> +       kfree(bb->buffer);
And so this would become free_page().
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/