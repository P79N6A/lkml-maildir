Date: Mon, 30 Aug 2004 18:57:28 +0400
From: Brad Campbell <>
Subject: Re: [PATCH] libata ATA vs SATA detection and workaround.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2004/8/30/110

Brad Campbell wrote:
> 
> It works here anyway.
> Patch against vanilla 2.6.9-rc1 attached (including your ata.h patch)
> 
Lets try this one that won't undo the work that the sata_sil Seagate/Maxtor blacklist does!
Regards,
Brad.
diff -ur orig/linux/drivers/scsi/libata-core.c linux-2.6.9-rc1/drivers/scsi/libata-core.c
--- orig/linux/drivers/scsi/libata-core.c	2004-08-30 18:52:54.000000000 +0400
+++ linux-2.6.9-rc1/drivers/scsi/libata-core.c	2004-08-30 18:53:42.000000000 +0400
@@ -1150,6 +1150,15 @@
 		ata_dev_identify(ap, i);
 		if (ata_dev_present(&ap->device[i])) {
 			found = 1;
+			/* limit bridge transfers to udma5, 200 sectors */
+			if ((ap->cbl == ATA_CBL_SATA) && (!ata_id_is_sata(ap->device))) {
+				printk(KERN_INFO "ata%u(%u): applying bridge limits\n",
+					ap->id, ap->device->devno);
+				ap->udma_mask &= ATA_UDMA5;
+				ap->host->max_sectors = ATA_MAX_SECTORS;
+				ap->host->hostt->max_sectors = ATA_MAX_SECTORS;
+				ap->device->flags |= ATA_DFLAG_LOCK_SECTORS;
+			}
 			if (ap->ops->dev_config)
 				ap->ops->dev_config(ap, &ap->device[i]);
 		}
@@ -1226,7 +1235,7 @@
 		ata_port_disable(ap);
 		return;
 	}
-
+	ap->cbl = ATA_CBL_SATA;
 	ata_bus_reset(ap);
 }
 
diff -ur orig/linux/include/linux/ata.h linux-2.6.9-rc1/include/linux/ata.h
--- orig/linux/include/linux/ata.h	2004-08-30 18:52:54.000000000 +0400
+++ linux-2.6.9-rc1/include/linux/ata.h	2004-08-30 18:42:41.000000000 +0400
@@ -218,6 +218,7 @@
 };
 
 #define ata_id_is_ata(dev)	(((dev)->id[0] & (1 << 15)) == 0)
+#define ata_id_is_sata(dev)	((dev)->id[93] == 0)
 #define ata_id_rahead_enabled(dev) ((dev)->id[85] & (1 << 6))
 #define ata_id_wcache_enabled(dev) ((dev)->id[85] & (1 << 5))
 #define ata_id_has_flush(dev) ((dev)->id[83] & (1 << 12))