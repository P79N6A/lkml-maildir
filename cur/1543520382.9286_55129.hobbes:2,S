Date: Fri, 24 Dec 1999 13:48:24 +0100 (CET)
From: Frank Bernard <>
Subject: [PATCH] 2.3.34/pre-2.3.35-3 ramdisk/initrd NOT as a module in kernel
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/12/24/26

As B.D.Elliot and Richard B. Johnson pointed out before, the kernel has to
be patched to compile ramdisk and initrd _NOT_ as a module but into the
kernel (e.g. for boot floppies). As with pre-2.3.35-3 it's not in the
kernel sources, and there is also no maintainer for those parts.
I only made the references corroct for 2.3.34.
Please apply the patch in some of the next sources.
Mit freundlichen Grüßen / kind regards
Frank Bernard
Frank Bernard Informationstechnik GmbH              
vanity +49 700 FIREWALL (0700 FIREWALL)    phone  : +49 69 477169
Dipl.-Inform. Frank Bernard                fax    : +49 69 47885616     
Wehrheimerstr. 9                           email  : fb@fbit.de
60389 Frankfurt                            www    : 
http://www.fbit.de
Germany                                             
http://www.linuxwall.de
diff -ur linux-2.3.34/arch/i386/kernel/setup.c linux/arch/i386/kernel/setup.c
--- linux-2.3.34/arch/i386/kernel/setup.c	Wed Dec 15 17:44:20 1999
+++ linux/arch/i386/kernel/setup.c	Fri Dec 24 12:45:48 1999
@@ -709,7 +709,7 @@
 #endif
 
 #ifdef CONFIG_BLK_DEV_INITRD
-	if (LOADER_TYPE) {
+	if (LOADER_TYPE && INITRD_START) {
 		if (INITRD_START + INITRD_SIZE < (max_low_pfn << PAGE_SHIFT)) {
 			reserve_bootmem(INITRD_START, INITRD_SIZE);
 			initrd_start =
diff -ur linux-2.3.34/drivers/block/rd.c linux/drivers/block/rd.c
--- linux-2.3.34/drivers/block/rd.c	Mon Dec 13 08:02:23 1999
+++ linux/drivers/block/rd.c	Fri Dec 24 12:45:48 1999
@@ -185,6 +185,8 @@
 {
 	unsigned int minor;
 	unsigned long offset, len;
+	struct buffer_head *rbh;
+	struct buffer_head *sbh;
 
 repeat:
 	INIT_REQUEST;
@@ -211,16 +213,66 @@
 	}
 
 	/*
-	 * If we're reading, fill the buffer with 0's.  This is okay since
-         * we're using protected buffers which should never get freed...
+	 * This has become somewhat more complicated with the addition of
+	 * the page cache.  The problem is that in some cases the furnished
+	 * buffer is "real", i.e., part of the existing ramdisk, while in
+	 * others it is "unreal", e.g., part of a page.  In the first case
+	 * not much needs to be done, while in the second, some kind of
+	 * transfer is needed.
+ 	 *
+	 * The two cases are distinguished here by checking whether the
+	 * real buffer is already in the buffer cache, and whether it is
+	 * the same as the one supplied.
 	 *
-	 * If we're writing, we protect the buffer.
-  	 */
-
-	if (CURRENT->cmd == READ) 
-		memset(CURRENT->buffer, 0, len); 
-	else
-		set_bit(BH_Protected, &CURRENT->bh->b_state);
+	 * There are three cases with read/write to consider:
+	 *
+	 * 1. Supplied buffer matched one in the buffer cache:
+	 *    Read - Clear the buffer, as it wasn't already valid.
+	 *    Write - Mark the buffer as "Protected".
+	 *
+	 * 2. Supplied buffer mismatched one in the buffer cache:
+	 *    Read - Copy the data from the buffer cache entry.
+	 *    Write - Copy the data to the buffer cache entry.
+	 *
+	 * 3  No buffer cache entry existed:
+	 *    Read - Clear the supplied buffer, but do not create a real
+	 *    one.
+	 *    Write - Create a real buffer, copy the data to it, and mark
+	 *    it as "Protected".
+	 *
+	 * NOTE: There seems to be some schizophrenia here - the logic
+	 * using "len" seems to assume arbitrary request lengths, while
+	 * the "protect" logic assumes a single buffer cache entry.
+	 * This seems to be left over from the ancient contiguous ramdisk
+	 * logic.
+	 */
+
+	sbh = CURRENT->bh;
+	rbh = get_hash_table(sbh->b_dev, sbh->b_blocknr, sbh->b_size);
+	if (sbh == rbh) {
+		if (CURRENT->cmd == READ) 
+			memset(CURRENT->buffer, 1, len);
+	} else if (rbh) {
+		if (CURRENT->cmd == READ)
+			memcpy(CURRENT->buffer, rbh->b_data, rbh->b_size);
+		else
+			memcpy(rbh->b_data, CURRENT->buffer, rbh->b_size);
+	} else { /* !rbh */
+		if (CURRENT->cmd == READ)
+			memset(sbh->b_data, 2, len);
+		else {
+			rbh = getblk(sbh->b_dev, sbh->b_blocknr, sbh->b_size);
+			if (rbh)
+				memcpy(rbh->b_data, CURRENT->buffer,
+				    rbh->b_size);
+			else
+				BUG();	/* No buffer, what to do here? */
+		}
+	}
+	if (rbh) {
+ 		set_bit(BH_Protected, &rbh->b_state);
+		brelse(rbh);
+	}
 
 	end_request(1);
 	goto repeat;
diff -ur linux-2.3.34/init/main.c linux/init/main.c
--- linux-2.3.34/init/main.c	Sat Nov 20 19:09:05 1999
+++ linux/init/main.c	Fri Dec 24 12:45:48 1999
@@ -484,6 +484,7 @@
 	kmem_cache_init();
 	sti();
 	calibrate_delay();
+#if 0000
 #ifdef CONFIG_BLK_DEV_INITRD
 	// FIXME, use the bootmem.h interface.
 	if (initrd_start && !initrd_below_start_ok && initrd_start < memory_start) {
@@ -492,6 +493,7 @@
 		initrd_start = 0;
 	}
 #endif
+#endif /* 0000 */
 	mem_init();
 	kmem_cache_sizes_init();
 #ifdef CONFIG_PROC_FS