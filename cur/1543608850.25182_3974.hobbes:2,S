Date: Tue, 06 Nov 2001 22:40:49 +0000
From: David Woodhouse <>
Subject: Re: Cannot unlock spinlock... Was: Problem in yenta.c, 2nd edition
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2001/11/6/253

linux@hazard.jcu.cz said:
>  The last message I got from kernel is:  request_irq: desc->handler->
> startup(irq)
> Then problem is in the spin_unlock_irqrestore()???
> Any ideas, recomendations, suggestions?
It's dying in an IRQ storm. Something is permanently asserting IRQ 11, and 
unless you can work out what's doing it and make it stop, the machine will 
die whenever you enable that IRQ.
Try this hack, just to make sure:
Index: arch/i386/kernel/irq.c
===================================================================
RCS file: /inst/cvs/linux/arch/i386/kernel/irq.c,v
retrieving revision 1.4.2.29
diff -u -r1.4.2.29 irq.c
--- arch/i386/kernel/irq.c	2001/06/21 09:33:54	1.4.2.29
+++ arch/i386/kernel/irq.c	2001/08/15 16:50:01
@@ -552,6 +552,8 @@
 	spin_unlock_irqrestore(&desc->lock, flags);
 }
 
+static unsigned int stormcount[NR_IRQS];
+
 /*
  * do_IRQ handles all normal device IRQ's (the special
  * SMP cross-CPU interrupts have their own specific
@@ -576,6 +578,15 @@
 	unsigned int status;
 
 	kstat.irqs[cpu][irq]++;
+	if (++stormcount[irq] > 200) {
+		printk(KERN_CRIT "IRQ storm detected on IRQ %d. Disabling\n", irq);
+		disable_irq(irq);
+	}
+	if(irq==0) {
+		int i; 
+		for (i=0; i<NR_IRQS; i++)
+			stormcount[i] = 0;
+	}
 	spin_lock(&desc->lock);
 	desc->handler->ack(irq);
 	/*
--
dwmw2
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/