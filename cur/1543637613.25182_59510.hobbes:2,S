Date: Sat, 27 Jul 2002 19:11:19 +0100
From: Russell King <>
Subject: Serial Oopsen caused by global IRQ chanes
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2002/7/27/29

Hi,
Two people have now reported to me a couple of oopsen which appear to be
caused by a change in 2.5.29 to synchronize_irq(), which I believe has
made synchronize_irq() useless.
In effect, we no longer guarantee that any IRQ handlers for a particular
IRQ will have finished running by the time free_irq() returns.  So, code
which has:
int bar;
int *foo = &bar;
irq_handler()
{
	*foo = 0;
}
void module_exit(void)
{
	free_irq(irq, NULL);
	foo = NULL;
}
is currently broken in two ways:
1. it's possible for irq_handler to dereference foo on another CPU _after_
   free_irq has returned.
2. it's possible for the module to be unloaded while the irq_handler is
   still running on another CPU.
Would someone else (Ingo?) like to comment on the above please?
The serial code regularly trips up because of this on SMP boxen.
Thanks.
-- 
Russell King (rmk@arm.linux.org.uk)                The developer of ARM Linux
             
http://www.arm.linux.org.uk/personal/aboutme.html
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/