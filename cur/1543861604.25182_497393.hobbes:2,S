Date: Mon, 08 Jan 2007 08:53:52 -0700
From: (Eric W. Biederman)
Subject: PATCH 2/4] x86_64 io_apic: Implement irq_from_pin
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/1/8/154

Another helper needed for guessing the routing of the timer
irq.
irq_from_pin looks at the irq_2_pin mapping and figures
out which irq is connected to a given apic and pin combination.
We need to know this to avoid guessing an apic pin that is already
in use by another irq.
Despite the nested loops this is O(N) walk through the irq_2_pin
data structure.
Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
---
 arch/x86_64/kernel/io_apic.c |   14 ++++++++++++++
 1 files changed, 14 insertions(+), 0 deletions(-)
diff --git a/arch/x86_64/kernel/io_apic.c b/arch/x86_64/kernel/io_apic.c
index 7365f5f..5ad210f 100644
--- a/arch/x86_64/kernel/io_apic.c
+++ b/arch/x86_64/kernel/io_apic.c
@@ -262,6 +262,20 @@ static void set_ioapic_affinity_irq(unsigned int irq, cpumask_t mask)
 }
 #endif
 
+static int irq_from_pin(int apic, int pin)
+{
+	int irq;
+	for (irq = 0; irq < NR_IRQS; irq++) {
+		struct irq_pin_list *entry = irq_2_pin + irq;
+		while (entry->next && ((entry->apic != apic) || (entry->pin != pin)))
+			entry = irq_2_pin + entry->next;
+
+		if ((entry->pin == pin) && (entry->apic == apic))
+			return irq;
+	}
+	return -1;
+}
+
 /*
  * The common case is 1:1 IRQ<->pin mappings. Sometimes there are
  * shared ISA-space IRQs, so we have to support them. We are super
-- 
1.4.4.1.g278f
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/