Date: Mon, 31 Mar 2003 17:27:43 -0500
From: "Zephaniah E. Hull" <>
Subject: More on HID keyboard handling.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2003/3/31/126

I still have not heard anything back from you either way on the attached
patch.
It goes on top of the grabbing patch you already accepted, but it allows
for /much/ more flexibility.
If this is not an approach you would like to take, do you have any
alternate ideas?
-- 
	1024D/E65A7801 Zephaniah E. Hull <warp@babylon.d2dc.net>
	   92ED 94E4 B1E6 3624 226D  5727 4453 008B E65A 7801
	    CCs of replies from mailing lists are requested.
     "First they came for the Jews, and I didn't speak out - because I
was not a jew. Then they came for the Communists, and I did not speak
out - because I was not a Communist. Then they came for the trade
unionists, and I did not speak out - because I was not a trade unionist.
Then they came for me and there was no one left to speak for me!"
  - Pastor Niemoeller - victim of Hitler's Nazis
diff -ur linux-2.5.63/drivers/char/keyboard.c linux-2.5.63.input/drivers/char/keyboard.c
--- linux-2.5.63/drivers/char/keyboard.c	2003-03-13 18:09:29.000000000 -0500
+++ linux-2.5.63.input/drivers/char/keyboard.c	2003-03-15 07:23:12.000000000 -0500
@@ -1174,6 +1174,7 @@
 	handle->dev = dev;
 	handle->handler = handler;
 	handle->name = kbd_name;
+	handle->mask = ~BIT(0);
 
 	input_open_device(handle);
 	kbd_refresh_leds(handle);
diff -ur linux-2.5.63/drivers/input/evdev.c linux-2.5.63.input/drivers/input/evdev.c
--- linux-2.5.63/drivers/input/evdev.c	2003-03-15 08:35:36.000000000 -0500
+++ linux-2.5.63.input/drivers/input/evdev.c	2003-03-15 07:20:29.000000000 -0500
@@ -36,6 +36,7 @@
 	struct input_event buffer[EVDEV_BUFFER_SIZE];
 	int head;
 	int tail;
+	unsigned long mask;
 	struct fasync_struct *fasync;
 	struct evdev *evdev;
 	struct list_head node;
@@ -47,11 +48,15 @@
 {
 	struct evdev *evdev = handle->private;
 	struct evdev_list *list;
+	struct timeval time;
+	unsigned long mask = input_get_device_mask(handle->dev);
+
+	do_gettimeofday(&time);
 
 	if (evdev->grab) {
 		list = evdev->grab;
 
-		do_gettimeofday(&list->buffer[list->head].time);
+		list->buffer[list->head].time = time;
 		list->buffer[list->head].type = type;
 		list->buffer[list->head].code = code;
 		list->buffer[list->head].value = value;
@@ -60,14 +65,15 @@
 		kill_fasync(&list->fasync, SIGIO, POLL_IN);
 	} else
 		list_for_each_entry(list, &evdev->list, node) {
+			if (~list->mask & mask) {
+				list->buffer[list->head].time = time;
+				list->buffer[list->head].type = type;
+				list->buffer[list->head].code = code;
+				list->buffer[list->head].value = value;
+				list->head = (list->head + 1) & (EVDEV_BUFFER_SIZE - 1);
 
-			do_gettimeofday(&list->buffer[list->head].time);
-			list->buffer[list->head].type = type;
-			list->buffer[list->head].code = code;
-			list->buffer[list->head].value = value;
-			list->head = (list->head + 1) & (EVDEV_BUFFER_SIZE - 1);
-
-			kill_fasync(&list->fasync, SIGIO, POLL_IN);
+				kill_fasync(&list->fasync, SIGIO, POLL_IN);
+			}
 		}
 
 	wake_up_interruptible(&evdev->wait);
@@ -286,6 +292,28 @@
 				return 0;
 			}
 
+		case EVIOCGMASK:
+			if (put_user(~list->mask, ((unsigned long *) arg) + 0))
+				return -EFAULT;
+			return 0;
+
+		case EVIOCSMASK:
+			list->mask = ~arg;
+			return 0;
+
+		case EVIOCGDMASK:
+			{
+				unsigned long mask;
+				mask = input_get_device_mask (dev);
+				if (put_user(mask, ((unsigned long *) arg) + 0))
+					return -EFAULT;
+				return 0;
+			}
+
+		case EVIOCSDMASK:
+			input_set_device_mask(dev, arg);
+			return 0;
+
 		default:
 
 			if (_IOC_TYPE(cmd) != 'E' || _IOC_DIR(cmd) != _IOC_READ)
diff -ur linux-2.5.63/drivers/input/input.c linux-2.5.63.input/drivers/input/input.c
--- linux-2.5.63/drivers/input/input.c	2003-03-15 08:35:36.000000000 -0500
+++ linux-2.5.63.input/drivers/input/input.c	2003-03-15 07:17:52.000000000 -0500
@@ -33,6 +33,8 @@
 EXPORT_SYMBOL(input_unregister_handler);
 EXPORT_SYMBOL(input_register_minor);
 EXPORT_SYMBOL(input_unregister_minor);
+EXPORT_SYMBOL(input_get_device_mask);
+EXPORT_SYMBOL(input_set_device_mask);
 EXPORT_SYMBOL(input_grab_device);
 EXPORT_SYMBOL(input_release_device);
 EXPORT_SYMBOL(input_open_device);
@@ -183,7 +185,7 @@
 		dev->grab->handler->event(dev->grab, type, code, value);
 	else
 		list_for_each_entry(handle, &dev->h_list, d_node)
-			if (handle->open)
+			if (handle->open && (~handle->mask & ~dev->mask))
 				handle->handler->event(handle, type, code, value);
 }
 
@@ -208,6 +210,16 @@
 	return 0;
 }
 
+unsigned long input_get_device_mask (struct input_dev *dev)
+{
+	return ~dev->mask;
+}
+
+void input_set_device_mask (struct input_dev *dev, unsigned long mask)
+{
+	dev->mask = ~mask;
+}
+
 int input_grab_device(struct input_handle *handle)
 {
 	if (handle->dev->grab)
diff -ur linux-2.5.63/drivers/input/joydev.c linux-2.5.63.input/drivers/input/joydev.c
--- linux-2.5.63/drivers/input/joydev.c	2003-03-13 18:09:29.000000000 -0500
+++ linux-2.5.63.input/drivers/input/joydev.c	2003-03-15 07:23:50.000000000 -0500
@@ -400,6 +400,7 @@
 	joydev->handle.name = joydev->name;
 	joydev->handle.handler = handler;
 	joydev->handle.private = joydev;
+	joydev->handle.mask = ~BIT(0);
 	sprintf(joydev->name, "js%d", minor);
 
 	for (i = 0; i < ABS_MAX; i++)
diff -ur linux-2.5.63/drivers/input/mousedev.c linux-2.5.63.input/drivers/input/mousedev.c
--- linux-2.5.63/drivers/input/mousedev.c	2003-03-13 18:09:29.000000000 -0500
+++ linux-2.5.63.input/drivers/input/mousedev.c	2003-03-15 07:23:58.000000000 -0500
@@ -419,6 +419,7 @@
 	mousedev->handle.name = mousedev->name;
 	mousedev->handle.handler = handler;
 	mousedev->handle.private = mousedev;
+	mousedev->handle.mask = ~BIT(0);
 	sprintf(mousedev->name, "mouse%d", minor);
 
 	if (mousedev_mix.open)
diff -ur linux-2.5.63/include/linux/input.h linux-2.5.63.input/include/linux/input.h
--- linux-2.5.63/include/linux/input.h	2003-03-15 08:35:36.000000000 -0500
+++ linux-2.5.63.input/include/linux/input.h	2003-03-15 08:10:53.000000000 -0500
@@ -77,7 +77,11 @@
 #define EVIOCRMFF		_IOW('E', 0x81, int)			/* Erase a force effect */
 #define EVIOCGEFFECTS		_IOR('E', 0x84, int)			/* Report number of effects playable at the same time */
 
-#define EVIOCGRAB		_IOW('E', 0x90, int)			/* Grab/Release device */
+#define EVIOCGRAB		_IOW('E', 0x90, int)	/* Grab/Release device */
+#define EVIOCGMASK		_IOR('E', 0x91, unsigned long *)	/* Get our input mask */
+#define EVIOCSMASK		_IOW('E', 0x92, unsigned long)		/* Set our input mask */
+#define EVIOCGDMASK		_IOR('E', 0x93, unsigned long *)	/* Get device input mask */
+#define EVIOCSDMASK		_IOW('E', 0x94, unsigned long)		/* Set device input mask */
 
 /*
  * Event types
@@ -801,6 +805,7 @@
 	int (*upload_effect)(struct input_dev *dev, struct ff_effect *effect);
 	int (*erase_effect)(struct input_dev *dev, int effect_id);
 
+	unsigned long mask;
 	struct input_handle *grab;
 
 	struct list_head	h_list;
@@ -874,6 +879,7 @@
 
 	int open;
 	char *name;
+	unsigned long mask;
 
 	struct input_dev *dev;
 	struct input_handler *handler;
@@ -893,6 +899,9 @@
 void input_register_handler(struct input_handler *);
 void input_unregister_handler(struct input_handler *);
 
+unsigned long input_get_device_mask(struct input_dev *);
+void input_set_device_mask(struct input_dev *, unsigned long mask);
+
 int input_grab_device(struct input_handle *);
 void input_release_device(struct input_handle *);
 [unhandled content-type:application/pgp-signature]