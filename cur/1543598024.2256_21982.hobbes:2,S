Date: 17 Aug 2001 10:15:30 +0200
From: Terje Eggestad <>
Subject: Re: [PATCH] processes with shared vm
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2001/8/17/36

Man......
Is there any other way I can do this wrong!?!?, guess I need to write
more patches :-)
--- array.c.orig	Mon Mar 19 21:34:55 2001
+++ array.c	Thu Aug 16 16:33:56 2001
@@ -50,6 +50,12 @@
  * Al Viro & Jeff Garzik :  moved most of the thing into base.c and
  *			 :  proc_misc.c. The rest may eventually go into
  *			 :  base.c too.
+ *
+ * Terje Eggestad    :  added in /proc/<pid>/status a VmClones: n
+ *                   :  that tells how many proc that uses the same VM (mm_struct).
+ *                   :  if there are clones add another field VmFirstClone with the
+ *                   :  clone with the lowest pid. Needed for things like gtop that adds 
+ *                   :  mem usage of groups of proc, or else they add up the usage of threads.
  */
 
 #include <linux/config.h>
@@ -178,7 +184,7 @@
 static inline char * task_mem(struct mm_struct *mm, char *buffer)
 {
 	struct vm_area_struct * vma;
-	unsigned long data = 0, stack = 0;
+ 	unsigned long data = 0, stack = 0;
 	unsigned long exec = 0, lib = 0;
 
 	down_read(&mm->mmap_sem);
@@ -206,12 +212,24 @@
 		"VmData:\t%8lu kB\n"
 		"VmStk:\t%8lu kB\n"
 		"VmExe:\t%8lu kB\n"
-		"VmLib:\t%8lu kB\n",
+		"VmLib:\t%8lu kB\n"
+		"VmClones:\t%d\n",
 		mm->total_vm << (PAGE_SHIFT-10),
 		mm->locked_vm << (PAGE_SHIFT-10),
 		mm->rss << (PAGE_SHIFT-10),
 		data - stack, stack,
-		exec - lib, lib);
+		exec - lib, lib, 
+		mm->mm_users.counter-2);
+	/* if we've vm clones, find the lowest/first pid of the clones */	
+	if (mm->mm_users.counter > 2) {
+	  struct task_struct *p;
+	  read_lock(&tasklist_lock);
+	  for_each_task(p) {
+	    if (p->mm == mm) break;
+	  };
+	  buffer += sprintf(buffer, "VmFirstClone:\t%d\n", p->pid);
+	  read_unlock(&tasklist_lock);
+	};
 	up_read(&mm->mmap_sem);
 	return buffer;
 }
Den 17 Aug 2001 04:08:53 -0400, skrev Robert Love:
> On 17 Aug 2001 10:04:04 +0200, Terje Eggestad wrote:
> > OK
> the patch is backwards :) i think your original one was too
> 
> diff -u <old> <new>
> 
> -- 
> Robert M. Love
> rml at ufl.edu
> rml at tech9.net
> 
> -
> To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  
http://vger.kernel.org/majordomo-info.html
> Please read the FAQ at  
http://www.tux.org/lkml/
-- 
_________________________________________________________________________
Terje Eggestad                  terje.eggestad@scali.no
Scali Scalable Linux Systems    
http://www.scali.com
Olaf Helsets Vei 6              tel:    +47 22 62 89 61 (OFFICE)
P.O.Box 70 Bogerud                      +47 975 31 574  (MOBILE)
N-0621 Oslo                     fax:    +47 22 62 89 51
NORWAY            
_________________________________________________________________________--- array.c.orig	Mon Mar 19 21:34:55 2001
+++ array.c	Thu Aug 16 16:33:56 2001
@@ -50,6 +50,12 @@
  * Al Viro & Jeff Garzik :  moved most of the thing into base.c and
  *			 :  proc_misc.c. The rest may eventually go into
  *			 :  base.c too.
+ *
+ * Terje Eggestad    :  added in /proc/<pid>/status a VmClones: n
+ *                   :  that tells how many proc that uses the same VM (mm_struct).
+ *                   :  if there are clones add another field VmFirstClone with the
+ *                   :  clone with the lowest pid. Needed for things like gtop that adds 
+ *                   :  mem usage of groups of proc, or else they add up the usage of threads.
  */
 
 #include <linux/config.h>
@@ -178,7 +184,7 @@
 static inline char * task_mem(struct mm_struct *mm, char *buffer)
 {
 	struct vm_area_struct * vma;
-	unsigned long data = 0, stack = 0;
+ 	unsigned long data = 0, stack = 0;
 	unsigned long exec = 0, lib = 0;
 
 	down_read(&mm->mmap_sem);
@@ -206,12 +212,24 @@
 		"VmData:\t%8lu kB\n"
 		"VmStk:\t%8lu kB\n"
 		"VmExe:\t%8lu kB\n"
-		"VmLib:\t%8lu kB\n",
+		"VmLib:\t%8lu kB\n"
+		"VmClones:\t%d\n",
 		mm->total_vm << (PAGE_SHIFT-10),
 		mm->locked_vm << (PAGE_SHIFT-10),
 		mm->rss << (PAGE_SHIFT-10),
 		data - stack, stack,
-		exec - lib, lib);
+		exec - lib, lib, 
+		mm->mm_users.counter-2);
+	/* if we've vm clones, find the lowest/first pid of the clones */	
+	if (mm->mm_users.counter > 2) {
+	  struct task_struct *p;
+	  read_lock(&tasklist_lock);
+	  for_each_task(p) {
+	    if (p->mm == mm) break;
+	  };
+	  buffer += sprintf(buffer, "VmFirstClone:\t%d\n", p->pid);
+	  read_unlock(&tasklist_lock);
+	};
 	up_read(&mm->mmap_sem);
 	return buffer;
 }