Date: Thu, 8 Feb 2007 08:55:01 +0100
From: Milan Svoboda <>
Subject: Re: posix-timers overrun broken?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/2/8/27

> On Wed, 2007-02-07 at 14:36 +0100, Milan Svoboda wrote:
> > But if the next interrupt arrives before function collect_signal is 
called 
> > to actually deliver the
> > siginfo_t to userspace, the si.overrun is cleared in posix_timer_event 
and 
> > we have just forgotten
> > one overrun...
> > 
> > Am I wrong?
> 
> Yes. posix_timer_event() is only called when the timer expires the first
> time. When the signal has been queued, the timer is not rearmed and the
> overrun is calculated in the actual signal delivery path, which calls
> do_schedule_next_timer().
Ok understand.
So it seems to me that drivers/char/mmtimer.c is wrong. It is
driver to additional hardware timers and mmtimer exports them as a posix 
timer.
When interrupt happens, they call posix_timer_event and set hardware 
interrupt
to the next tick. I use the same practise in my driver and found
that overruns are reported wrongly.
How to plug "external" source of ticks to the posix timers?
As far as I know current HRT doesn't allow us to use more sources of
ticks together, only one is selected, correct?
Milan
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/