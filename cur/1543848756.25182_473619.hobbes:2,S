Date: Mon, 16 Oct 2006 16:51:25 -0700
From: Andrew Morton <>
Subject: Re: [patch 01/12] fuse: fix hang on SMP
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/10/16/339

On Mon, 16 Oct 2006 18:27:10 +0200
Miklos Szeredi <miklos@szeredi.hu> wrote:
> Fuse didn't always call i_size_write() with i_mutex held which caused
> rare hangs on SMP/32bit.
Yes, that is a bit of a trap.  I'll maintain a patch in -mm which spits a
warning if i_size_write() is called without i_mutex held.
--- a/include/linux/fs.h~mm-only-i_size_write-debugging
+++ a/include/linux/fs.h
@@ -646,25 +646,7 @@ static inline loff_t i_size_read(struct 
 #endif
 }
 
-/*
- * NOTE: unlike i_size_read(), i_size_write() does need locking around it
- * (normally i_mutex), otherwise on 32bit/SMP an update of i_size_seqcount
- * can be lost, resulting in subsequent i_size_read() calls spinning forever.
- */
-static inline void i_size_write(struct inode *inode, loff_t i_size)
-{
-#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
-	write_seqcount_begin(&inode->i_size_seqcount);
-	inode->i_size = i_size;
-	write_seqcount_end(&inode->i_size_seqcount);
-#elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPT)
-	preempt_disable();
-	inode->i_size = i_size;
-	preempt_enable();
-#else
-	inode->i_size = i_size;
-#endif
-}
+void i_size_write(struct inode *inode, loff_t i_size);
 
 static inline unsigned iminor(struct inode *inode)
 {
diff -puN fs/inode.c~mm-only-i_size_write-debugging fs/inode.c
--- a/fs/inode.c~mm-only-i_size_write-debugging
+++ a/fs/inode.c
@@ -1384,6 +1384,23 @@ void __init inode_init(unsigned long mem
 		INIT_HLIST_HEAD(&inode_hashtable[loop]);
 }
 
+void i_size_write(struct inode *inode, loff_t i_size)
+{
+	WARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));
+#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
+	write_seqcount_begin(&inode->i_size_seqcount);
+	inode->i_size = i_size;
+	write_seqcount_end(&inode->i_size_seqcount);
+#elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPT)
+	preempt_disable();
+	inode->i_size = i_size;
+	preempt_enable();
+#else
+	inode->i_size = i_size;
+#endif
+}
+EXPORT_SYMBOL(i_size_write);
+
 void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)
 {
 	inode->i_mode = mode;
_
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/