Date: Thu, 27 Apr 2006 10:17:50 +0200
From: Bart Hartgers <>
Subject: Re: [PATCH] likely cleanup: remove unlikely for kfree(NULL)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/4/27/61

Kyle Moffett wrote:
> Here's code that I've found works as well as can be expected under both
> GCC 3 and GCC 4.  If xp is a known-NULL constant the whole function will
> be optimized out completely.  If xp is known-not-NULL, then it will
> optimize to a kfree function without the null check.  Otherwise it
> optimizes to call the out-of-line version.
> 
> Cheers,
> Kyle Moffett
> 
> static inline void kfree(void *ptr)
> {
>     if (__builtin_constant_p((ptr == NULL))) {
>         if (ptr)
>             kfree_nonnull(ptr);
>     } else {
>         kfree_unknown(ptr);
>     }
> }
> 
> void kfree_nonnull(void *ptr)
> {
>     /* kfree code here, no null check */
> }
> 
> void kfree_unknown(void *ptr)
> {
>     if (ptr)
>         kfree_nonnull(ptr);
> }
I still think there is an inconsistency in gcc. If I call your kfree
with the following:
void test( char *ptr )
{
        char *null = NULL;
        kfree(ptr);	/* unknown */
        *ptr = 'a';
        kfree(ptr);	/* nonnull */
        kfree(null);	/* should be optimised away */
}
,the compiler (4.1) generates two calls to kfree_unknown instead of one
to kfree_nonnull and one to kfree_unknown. It seems that the
__builtin_constant_p((ptr==NULL)) check does not always trigger, even if
the compiler 'knows' ptr to be equal to NULL. I posted a nasty hack
around this problem yesterday.
Groeten,
Bart
-- 
Bart Hartgers - TUE Eindhoven - 
http://plasimo.phys.tue.nl/bart/contact/
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/