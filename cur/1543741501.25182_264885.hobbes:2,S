Date: Tue, 26 Oct 2004 17:43:36 +0200 (MEST)
From: Jan Engelhardt <>
Subject: Re: Problems with close() system call
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2004/10/26/147

>> Best is to put a printk("i'm in ioctl()") in the ioctl() function and a
>> printk("i'm in close()") in the close() one, to be really sure whether the
>> close() function of your module is called.
>
>Yes, that is exactly what I am doing. I basically implement the
>flush() call (for close) as the release() call was never called on
>close. So my release call does nothing. What I see is that the flush
Uh, then something's wrong. Your device fops should look like this:
{
  .release = my_close, // which is called upon close(2)
}
Anything else is of course, never working.
>function gets called, even though I have never called the close()
>system call from my user app.
>
>I also print out the module counter, and it doesn't make sense who
>increments it:
From that output, I would not either get any idea.
Try opening only one device at a time.
Then, put a dump_stack() where you see fit.
>My user app looks something like this:
>    fd[i] = open(dev, O_RDWR | O_SYNC);
I don't think O_SYNC has any effect on unregular files.
>    if(status != 0)
>    {
>      printf("%s - %s\n", dev, strerror(errno));
>    }
>  } /* for(port_id = 0; port_id < nr_ports; port_id++) */
Well, WHERE do you close() the fd?
Jan Engelhardt
-- 
Gesellschaft für Wissenschaftliche Datenverarbeitung
Am Fassberg, 37077 Göttingen, www.gwdg.de
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/