Date: 27 Mar 1999 18:01:43 +0100
From: Andreas Jaeger <>
Subject: popen/pclose problem in Linux 2.2.x with vfork/glibc 2.1
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/3/27/56

Hi,
Juergen Heinzl reported a bug in the implementation of popen/pclose to 
the glibc maintainers.  Looking closer at the bug the problem might be 
in the kernel since the test program runs fine with Linux 2.0.36 but
fails with Linux 2.2.x.  The IMO significant difference is the vfork
implementation in Linux 2.2 which popen uses with glibc 2.1.
Has anybody an idea what's broken ?
Here are some parts of Juergen's reports (the full report is available
via the bug database as PR 966 and 967 at
http://www-gnats.gnu.org:8080/cgi-bin/wwwgnats.pl
)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[...]
configuring man_db-2.3.10 tells me pclose() is broken with this version
of the library. With some really old programme I get this too ...
   96   1 S    0:00 /sbin/restore 
   97   1 S    0:00 /bin/gunzip -c /var/archive/sun/cpio.22.mar.98.gz 
  102   1 S    0:00 /bin/gunzip -c /var/archive/mon/cpio.30.nov.98.gz 
  107   1 S    0:00 /bin/gunzip -c /var/archive/mon/cpio.08.feb.99.gz 
  109   1 S    0:00 /bin/gunzip -c /var/archive/sun/cpio.14.feb.99.gz 
.. where restore call gunzip via popen() but only one at a time. All
instances of gunzip go away as soon as one leaves restore and the ones
above hang around after calling pclose(). I wrote it years ago and never
have had that effect, cannot tell for sure about 2.0.112 of the glibc
though.
With man_db the effect was an ESPIPE (Illegal seek) error and I yet try
to reproduce it within a smaller test programme.
[...]
Me again,
it was *very* late due to that, so forgive me 8-} ... here's the code
of the man_db configure script that fails ...
#include <stdio.h>
#include <sys/wait.h>
int
try_pclose (FILE *f, int expected)
{
  int s;
  s = pclose (f);
  if (s != -1 && WIFEXITED (s))
    return WEXITSTATUS (s) != expected;
  else 
    return 1;
}
int
main (void)
{
  FILE *f, *t;
  int i, sf, st;
  for (i = 0;  i <= 1;  ++i) {
    f = popen ("false", "r");
    sleep (1);
    t = popen ("true", "r");
    sleep (1);
    if (i) {
      st = try_pclose (t, 0);
      sf = try_pclose (f, 1);
    } else {
      sf = try_pclose (f, 1);
      st = try_pclose (t, 0);
    }
    if (sf || st) exit(1);
  }
  exit(0);
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
With Linux 2.2 the program exits with 1 instead of 0.
I just checked the code with 2.2.5pre2 and got the buggy exit value of 
1.
Andreas
-- 
 Andreas Jaeger   aj@arthur.rhein-neckar.de    jaeger@informatik.uni-kl.de
  for pgp-key finger ajaeger@aixd1.rhrk.uni-kl.de
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/