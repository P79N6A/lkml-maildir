Date: Sun, 3 Feb 2008 21:02:08 +0000
From: Al Viro <>
Subject: Re: section breakage on ppc64 (aka __devinitconst is broken by design)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/2/3/176

On Sun, Feb 03, 2008 at 09:30:02PM +0100, Sam Ravnborg wrote:
> And I'm suprised to see that gcc thinks bar is writeable.
> If I try to assign it gcc error out as expected.
That's because "not modifiable" and "goes into r/o section" are not the
same thing.  The former belongs to C and is target-independent, of course.
The latter is up to implementation, except that modifiable objects
obviously *can not* go into r/o.  You are not guaranteed the reverse.
> We could invent a __initstr annotation but I dunno if that would suffice.
> Do you see any pattern when gcc do the r/w choice compared to the
> r/o choise. Maybe it is only const char[] that happens to be considered
> r/o and the rest is r/w?
On ppc64 relocs => r/w, AFAICS.  On other targets we might have any number
of other rules.
> Should a gcc-bug be filed for this btw?
Why?  gcc is entirely within its rights - it's not even a matter of ABI,
it's way below that.  Note that you are meddling with section assignment
rules and those are target-dependent, so target-independent overrides
are nowhere near being promised to work.
Frankly, "do not ever make __initdata et.al. const" is probably the best
we can do - adding __initconst, __initconst_but_has_relocs,
__initconst_but_has_something_that_puts_it_into_writable_on_this_weird_target,
__initconst_but_has_something_that_puts_it_into_writable_on_that_weird_target,
etc. is not feasible - we'll keep getting portability bugs all the time since
nobody will remember all rules (or care about ones that do not apply on
amd64).
Suppose we have an array of ad-hoc structs with a bunch of ints
in those.  Used only in ->probe(), so __devinitdata.  Constant, so
__devinitconst (and no special per-target rules trigger on the current
struct contents).  Fast forward half a year; somebody adds a string field
to those.  Oops - suddenly it's __devinitconst_but_has_relocs, but author
of that patch has never heard of ppc64 oddities; on all targets he knows
__devinitconst still works fine.