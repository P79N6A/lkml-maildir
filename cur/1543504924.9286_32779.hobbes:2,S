Date: Thu, 5 Aug 1999 08:53:51 -0700 (PDT)
From: Linus Torvalds <>
Subject: Re: New resources - pls, explain :-(
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/8/5/125

On Thu, 5 Aug 1999, Petr Vandrovec Ing. VTEI wrote:
> these my questions, I'll be very happy.
>   (1) There is something wrong with /proc/iomem on my kernel :-(
> readdir shows it, but open/stat says ENOENT :-( I did not find any change
> which could cause this; but it is side issue for me currently
It's because I forgot to update the length field of the /proc entry.
It's fixed in my current stuff, I'll make a new release.
>   (2) What should I do with this resource? From your code it seems that
>      (a) resource is already plugged into resource tree, so no
>          {request,release}_resource should be in driver
>      (b) start contain base, end end address and flags some ids (maybe
>          there should be some additional macros - it is not clear whether
>          MMIO region is detected as !(flags & PCI_BASE_ADDRESS_SPACE_IO) or
>          by something else.
>          Probably IS_PCI_SPACE_IO() & IS_PCI_SPACE_MMIO() should be invented
>          (otherwise I'll ignore these flags - hardware manual says, that
>          region 0 for my matrox is always MMIO, so why bother with check)
You don't =have= to do anything with the resource. Many drivers can just
do
	mmio_base = dev->resource[0].start;
because for those drivers the driver documentation says that it's always
the first aperture, and it's always a memory region. So you don't have to
use the flags if you don't want to.
There are other drivers where different chip versions have different
apertures (it's actually fairly uncommon, but it happens, and PCI
obviously gives enough information that it can be worked around), and
those drivers might for example search through each of the six resources
to find the one tey are interested in.
So the code might look something like this:
	int find_io_base(struct pci_dev * dev)
	{
		for (i = 0; i < 6; i++) {
			if (dev->resource[i].flags & PCI_BASE_ADDRESS_SPACE_IO)
				return dev->resource[i].start;
		}
		return -1;
	}
but that's usually not actually needed.		
>   (3) check_region currently returns already allocated (so I have to comment
>       out check_region checks from ide-dma.c & de4x5.c). And (2a) implies
>       that there is no way to tell kernel that device (or resource) is
>       allocated now. Did I oversight something or is there planned
>       {request,release,check}_pci_dev(struct pci_dev*) for 2.3.13-pre6?
There's a planned fix for check_region() and friends coming soon, so this
will just work again. None of the drivers I needed had a problem with it,
because they were either pure PCI anddin't bother with check-region at
all, or they were old ISA-like and didn't show up in the PCI address space
allocations anyway.
Expect a update later today,
		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/