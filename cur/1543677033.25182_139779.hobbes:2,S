Date: Thu, 12 Jun 2003 02:00:06 +0000 (UTC)
From: (Linus Torvalds)
Subject: Re: Compiling kernel with SuSE 8.2/gcc 3.3
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2003/6/11/291

In article <3EE7D659.2000003@austin.rr.com>,
Steve French  <smfrench@austin.rr.com> wrote:
>Although it fixes it for building on 32 bit architectures, won't changing
>
>
>	__u64 uid = 0xFFFFFFFFFFFFFFFF;
>to
>
>	__u64 uid = 0xFFFFFFFFFFFFFFFFULL;
>
>generate a type mismatch warning on ppc64 and similar 64 bit
>architecutres since __u64 is not a unsigned long long on ppc64 
>(it is unsigned long)?
No, why would it? 
If you do
	char c = 1;
do you expect a warning? The right side of the assignent 
is an "int", and the left side is a "char", but it's perfectly ok to
assign a wider type to a narrower one.
And so if "__u64" were to be a plain "unsigned long" on a 64-bit
architecture (and even if "unsigned long long" were to be 128 bits), the
constant 0xFFFFFFFFFFFFFFFFULL is (a) a perfectly valid unsigned long
long value and (b) fits perfectly well even in an "unsigned long", so
the compiler has no reason to complain about the assignment losing bits
(which it otherwise might do).
So I'd much rather make the constants too big than too small. And yes,
Andrew's suggestion about just assigning -1 works, but it's actually a
very subtle cast at that point.
		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/