Date: Mon, 26 Apr 1999 21:54:24 -0400 (EDT)
From: Eddie Mansu <>
Subject: [PATCH]: aha1542.c, support for insmod parameters
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/4/26/178

	I've got an aha1542 SCSI card using a non-standard base address,
but I'm loading the driver as a module.. Previously, this driver didn't
support insmod parameters, and that sucked, so I added them..  Currently,
this only supports one card.  I had no need to add support for more, and
the people I talked to had no real need for more than one when loading as
a module.  
	I'd appreciate any comments/feedback about this patch.  Please
send them to spackle@one.net, I won't see them otherwise.
Here we go:
----->8--------
--- orig.aha1542.c	Mon Apr 26 18:09:12 1999
+++ aha1542.c	Mon Apr 26 18:24:20 1999
@@ -18,6 +18,10 @@
  *        1-Jan-97
  *  Modified by Bjorn L. Thordarson and Einar Thor Einarsson
  *        Recognize that DMA0 is valid DMA channel -- 13-Jul-98
+ *  Modified by Eddie Mansu <spackle@one.net>
+ *        Added support for insmod commandline parameter -- 18-Apr-99
+ *        Currently only supports one card
+ *        (same format as LILO commandline)
  */
 
 #include <linux/module.h>
@@ -73,6 +77,9 @@
 #define MAXBOARDS 2	/* Increase this and the sizes of the
 			   arrays below, if you need more.. */
 
+#define NUMPARMS 4      /* The maximum number of integers passed to the
+			   module (insmod commandline) */
+
 static unsigned int bases[MAXBOARDS]={0x330, 0x334};
 
 /* set by aha1542_setup according to the command line */
@@ -83,6 +90,29 @@
 
 static char *setup_str[MAXBOARDS] = {(char *)NULL,(char *)NULL};
 
+/* These are used with insmod parameters */
+static int aha1542[NUMPARMS] = {
+  0x0, /* base address */
+  0, /* buson */
+  0, /* busoff */
+  0, /* dmaspeed */
+};
+
+static int base_address = 0;
+
+static int allowed_base_address[] = {0x130,0x134,0x230,0x234,0x330,0x334};
+static int buson        = 0;
+static int allowed_buson[] = {2,3,4,5,6,7,8,9,10,11,12,13,14,15};
+static int busoff       = 0;
+static int allowed_busoff[] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,
+			       17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,
+			       33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
+			       49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64};
+static int dmaspeed     = 0;
+static int allowed_dmaspeed[] = {5,6,7,8,10};
+
+MODULE_PARM(aha1542, "1-" __MODULE_STRING(NUMPARMS) "i");
+
 /*
  * LILO params:  aha1542=<PORTBASE>[,<BUSON>,<BUSOFF>[,<DMASPEED>]]
  *
@@ -100,6 +130,15 @@
  *		    Factory default is 5 MB/s.
  */
 
+/*
+ * insmod params:  Follow same conventions as above.
+ */
+  
+#define DEFAULT_BASE_ADDRESS 0x330
+#define DEFAULT_BUSON        11
+#define DEFAULT_BUSOFF       4
+#define DEFAULT_DMASPEED     5
+
 #define BIOS_TRANSLATION_1632 0  /* Used by some old 1542A boards */
 #define BIOS_TRANSLATION_6432 1 /* Default case these days */
 #define BIOS_TRANSLATION_25563 2 /* Big disk case */
@@ -1591,6 +1630,111 @@
 /* Eventually this will go into an include file, but this will be later */
 Scsi_Host_Template driver_template = AHA1542;
 
-#include "scsi_module.c"
-#endif
+int init_module(void) {
 
+    int atbt = -1;
+    int ii;
+    const char *ahausage = "aha1542: usage: [aha1542=<a>,<b>,<c>,<d>]
+	  <a> = <0x130,0x134,0x230,0x234,0x330,0x334>
+	  <b> = <2..15>
+	  <c> = <1..64>
+	  <d> = <5..8,10>
+";
+
+    /* Deal with parameters passed to insmod */
+    base_address = aha1542[0];
+    buson        = aha1542[1];
+    busoff       = aha1542[2];
+    dmaspeed     = aha1542[3];
+    
+    if ( base_address == 0 ) 
+      /* User didn't specify an address, choose the default. */
+      base_address = DEFAULT_BASE_ADDRESS;
+    if ( buson        == 0 )
+      /* User didn't specify a setting for buson, choose the default. */
+      buson        = DEFAULT_BUSON;
+    if ( busoff       == 0 )
+      /* User didn't specify a setting for busoff, choose the default. */
+      busoff       = DEFAULT_BUSOFF;
+    if ( dmaspeed    == 0 )
+      /* User didn't specify a setting for dmaspeed, choose the default. */
+      dmaspeed    = DEFAULT_DMASPEED;
+
+    /* Make sure valid options were used, otherwise print usage and quit. */
+    for ( ii = 0 ; ii < sizeof(allowed_base_address)/sizeof(int) ; ii++ ) {
+      if ( base_address == allowed_base_address[ii] )
+	break;
+    }
+
+    if ( ii == sizeof(allowed_base_address)/sizeof(int) ) {
+      printk(ahausage);
+      return -1;
+    }
+    bases[0]          = base_address;
+    
+    for ( ii = 0 ; ii < sizeof(allowed_buson)/sizeof(int) ; ii++ ) {
+      if ( buson == allowed_buson[ii] )
+	break;
+    }
+    
+    if ( ii == sizeof(allowed_buson)/sizeof(int) ) {
+      printk(ahausage);
+      return -1;
+    }
+    setup_buson[0]    = buson;
+    
+    for ( ii = 0 ; ii < sizeof(allowed_busoff)/sizeof(int) ; ii++ ) {
+      if ( busoff == allowed_busoff[ii] )
+	break;
+    }
+    
+    if ( ii == sizeof(allowed_busoff)/sizeof(int) ) {
+      printk(ahausage);
+      return -1;
+    }
+    setup_busoff[0]   = busoff;
+    
+    for ( ii = 0 ; ii < sizeof(allowed_dmaspeed)/sizeof(int) ; ii++ ) {
+      if ( dmaspeed == allowed_dmaspeed[ii] )
+	break;
+    }
+    
+    if ( ii == sizeof(allowed_dmaspeed)/sizeof(int) ) {
+      printk(ahausage);
+      return -1;
+    }
+    
+    switch (dmaspeed) {
+    case 5:
+      atbt = 0x00;
+      break;
+    case 6:
+      atbt = 0x04;
+      break;
+    case 7:
+      atbt = 0x01;
+      break;
+    case 8:
+      atbt = 0x02;
+      break;
+    case 10:
+      atbt = 0x03;
+      break;
+    }
+    
+    setup_dmaspeed[0] = atbt;
+
+    driver_template.module = &__this_module;
+    scsi_register_module(MODULE_SCSI_HA, &driver_template);
+    if (driver_template.present)
+        return 0;
+
+    scsi_unregister_module(MODULE_SCSI_HA, &driver_template);
+    return -1;
+}
+
+void cleanup_module( void) {
+    scsi_unregister_module(MODULE_SCSI_HA, &driver_template);
+}
+
+#endif
----->8----------
Again, please E-Mail to spackle@one.net; I may not see the replies posted
to the list.  Thanks.
Eddie Mansu
spackle@one.net
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/