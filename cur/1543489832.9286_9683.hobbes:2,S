Date: Sat, 13 Mar 1999 15:28:18 -0500 (EST)
From: Chuck Lever <>
Subject: /proc/<pid>/rlimit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/3/13/92

here's a patch that adds a new file in /proc/<pid> called "rlimit".  it
follows the same format as /proc/<pid>/status, and reports current rlimit
information for a process.  it applies against stock 2.2.3.
can people try this out and make suggestions?  i think it would be
appropriate to include with the large fdset patch in the ac series.
ps:  this patch is also available to download:
http://www.citi.umich.edu/projects/citi-netscape/patches/rlimit.patch
thanks,
	- Chuck Lever
--
corporate:	<chuckl@netscape.com>
personal:	<chucklever@netscape.net> or <cel@monkey.org>
The Linux Scalability project:
	
http://www.citi.umich.edu/projects/citi-netscape/
diff -urN linux-2.2.3-reference/fs/proc/array.c linux/fs/proc/array.c
--- linux-2.2.3-reference/fs/proc/array.c	Sat Mar 13 15:05:46 1999
+++ linux/fs/proc/array.c	Sat Mar 13 14:54:51 1999
@@ -42,6 +42,8 @@
  * Alan Cox	     :  security fixes.
  *			<Alan.Cox@linux.org>
  *
+ * Chuck Lever      :  /proc/<pid>/rlimit
+ *			<cel@monkey.org>
+ *
  */
 
 #include <linux/types.h>
@@ -1225,6 +1227,41 @@
 }
 #endif
 
+static int get_rlimit(int pid, char * buffer)
+{
+	unsigned len = 0;
+	struct task_struct *tsk;
+
+	read_lock(&tasklist_lock);
+
+	if (tsk = find_task_by_pid(pid)) {
+		len = sprintf(buffer,
+			"CPU time:\t%lu\n"
+			"File size:\t%lu\n"
+			"Data size:\t%lu\n"
+			"Stack size:\t%lu\n"
+			"Core size:\t%lu\n"
+			"Res size:\t%lu\n"
+			"Proc count:\t%lu\n"
+			"Open files:\t%lu\n"
+			"Mem lock:\t%lu\n"
+			"As size:\t%lu\n",
+		tsk->rlim ? tsk->rlim[RLIMIT_CPU].rlim_cur : 0,
+		tsk->rlim ? tsk->rlim[RLIMIT_FSIZE].rlim_cur : 0,
+		tsk->rlim ? tsk->rlim[RLIMIT_DATA].rlim_cur : 0,
+		tsk->rlim ? tsk->rlim[RLIMIT_STACK].rlim_cur : 0,
+		tsk->rlim ? tsk->rlim[RLIMIT_CORE].rlim_cur : 0,
+		tsk->rlim ? tsk->rlim[RLIMIT_RSS].rlim_cur : 0,
+		tsk->rlim ? tsk->rlim[RLIMIT_NPROC].rlim_cur : 0,
+		tsk->rlim ? tsk->rlim[RLIMIT_NOFILE].rlim_cur : 0,
+		tsk->rlim ? tsk->rlim[RLIMIT_MEMLOCK].rlim_cur : 0,
+		tsk->rlim ? tsk->rlim[RLIMIT_AS].rlim_cur : 0);
+	}
+	
+	read_unlock(&tasklist_lock);
+	return len;
+}
+
 #ifdef CONFIG_MODULES
 extern int get_module_list(char *);
 extern int get_ksyms_list(char *, char **, off_t, int);
@@ -1375,6 +1412,7 @@
 		case PROC_PID_MAPS:
 		case PROC_PID_CMDLINE:
 		case PROC_PID_CPU:
+		case PROC_PID_RLIMIT:
 			return 0;	
 	}
 	if(capable(CAP_DAC_OVERRIDE) || (current->fsuid == euid && ok))
@@ -1400,6 +1438,8 @@
 		case PROC_PID_CPU:
 			return get_pidcpu(pid, page);
 #endif
+		case PROC_PID_RLIMIT:
+			return get_rlimit(pid, page);
 	}
 	return -EBADF;
 }
diff -urN linux-2.2.3-reference/fs/proc/base.c linux/fs/proc/base.c
--- linux-2.2.3-reference/fs/proc/base.c	Mon Aug 24 16:02:43 1998
+++ linux/fs/proc/base.c	Sat Mar 13 14:21:26 1999
@@ -175,6 +175,13 @@
 };
 #endif
 
+static struct proc_dir_entry proc_pid_rlimit = {
+	PROC_PID_RLIMIT, 6, "rlimit",
+	S_IFREG | S_IRUGO, 1, 0, 0,
+	0, &proc_array_inode_operations,
+	NULL, proc_pid_fill_inode,
+};
+
 __initfunc(void proc_base_init(void))
 {
 #if CONFIG_AP1000
@@ -194,14 +201,5 @@
 #ifdef __SMP__	
 	proc_register(&proc_pid, &proc_pid_cpu);
 #endif	
+	proc_register(&proc_pid, &proc_pid_rlimit);
 };
-
-
-
-
-
-
-
-
-
-
diff -urN linux-2.2.3-reference/include/linux/proc_fs.h linux/include/linux/proc_fs.h
--- linux-2.2.3-reference/include/linux/proc_fs.h	Sat Mar 13 15:05:47 1999
+++ linux/include/linux/proc_fs.h	Sat Mar 13 14:17:54 1999
@@ -72,6 +72,7 @@
 	PROC_PID_RINGBUF,
 #endif
 	PROC_PID_CPU,
+	PROC_PID_RLIMIT,
 };
 
 enum pid_subdirectory_inos {