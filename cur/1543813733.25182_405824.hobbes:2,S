Date: Mon, 13 Mar 2006 08:57:09 +1100
From: Neil Brown <>
Subject: Re: [PATCH] Fix shrink_dcache_parent() against shrink_dcache_memory() race (3rd updated patch)]
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/3/12/141

On Friday March 10, jblunck@suse.de wrote:
> On Fri, Mar 10, Neil Brown wrote:
> 
> > -static void prune_dcache(int count)
> > +static void prune_dcache(int count, struct super_block *sb)
> >  {
> >  	spin_lock(&dcache_lock);
> >  	for (; count ; count--) {
> > @@ -417,8 +425,10 @@ static void prune_dcache(int count)
> >   			spin_unlock(&dentry->d_lock);
> >  			continue;
> >  		}
> > -		/* If the dentry was recently referenced, don't free it. */
> > -		if (dentry->d_flags & DCACHE_REFERENCED) {
> > +		/* If the dentry was recently referenced, or is for
> > +		 * a unmounting filesystem, don't free it. */
> > +		if ((dentry->d_flags & DCACHE_REFERENCED) ||
> > +		    (dentry->d_sb != sb && dentry->d_sb->s_root == NULL)) {
> >  			dentry->d_flags &= ~DCACHE_REFERENCED;
> >   			list_add(&dentry->d_lru, &dentry_unused);
> >   			dentry_stat.nr_unused++;
> 
> You have to down_read the rw-semaphore sb->s_umount since sb->s_root is
> protected by it :(
No you don't.
sb->s_root is set precisely twice for any filesystem.
Once when the filesystem is mounted, typically in the fill_super
function, and once in generic_shutdown_super where it is set to NULL.
There is no need to lock against the first change as the sb is not
globally visible until after s_root is set.  So for the present
purpose we only need to worry about the second change.
For this, the current usage of dcache_lock is enough to remove any
possible race.  generic_shutdown_super sets s_root to NULL and then
takes dcache_lock (via wait_for_prunes) before it cares if anyone has
noticed the NULL or not.  prune_dcache holds dcache_lock while testing
for NULL.  So there is no room for a race.
s_umount is sometimes taken before testing s_root.  This is always
because the sb has just been found on the list of all superblocks, and
so the thread doesn't hold a proper reference to it.  In our case
we are holding a dentry which in turn holds a real reference to the
superblock.
So I stand by my patch - s_root can be safely tested here.
NeilBrown
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/