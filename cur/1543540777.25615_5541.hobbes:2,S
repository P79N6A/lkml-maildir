Date: Fri, 4 Aug 2000 19:06:50 +0530
From: "Madan A S" <>
Subject: chardev.o:unresolved symbol __put_user_X
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/8/4/106

hi,
How can see the man pages for function provided by kernel like put_user(...)
, printk(...)
I have some problem with the below stated code for a char driver ....
make ............ works fine with no errors and warnings
insmod chardev.o gives following error
chardev.o:unresolved symbol __put_user_X
Within ksyms : I see (copied  only needed)
c0113ea8 printk_R1b7d4074
c01dad90 __put_user_1
c01dada4 __put_user_2
c01dadc0 __put_user_4
I compiled this on my Redhat 6.2 . kernel 2.2.14
#include <linux/kernel.h>
#include <linux/module.h>
/*
#if CONFIG_MODVERSIONS==1
#define MODVERSIONS
#include <linux/modversions.h>
#endif
*/
#include <linux/fs.h>
#include <linux/wrapper.h>
file://I used here #include <asm/uaccess.h> ... didn't work
#include </usr/src/linux-2.2.14/include/asm-i386/uaccess.h>  /* for put_user
*/
#include <asm/segment.h>
#define SUCCESS 0
#define DEVICE_NAME "char_dev"
#define BUF_LEN 80
static int Device_Open = 0;
static char Message[BUF_LEN];
static char *Message_Ptr;
static int device_open(struct inode *inode,
         struct file *file)
{
static int counter = 0;
#ifdef DEBUG
printk ("device_open(%p,%p)\n", inode, file);
#endif
printk("Device: %d.%d\n",inode->i_rdev >> 8, inode->i_rdev & 0xFF);
if (Device_Open)
    return -EBUSY;
Device_Open++;
sprintf(Message,"If I told you once, I told you %d times -
%s",counter++,"Hello, world\n");
Message_Ptr = Message;
MOD_INC_USE_COUNT;
return SUCCESS;
}
static int device_release(struct inode *inode,
                          struct file *file)
{
#ifdef DEBUG
printk ("device_release(%p,%p)\n", inode, file);
#endif
Device_Open --;
MOD_DEC_USE_COUNT;
return 0;
}
static ssize_t device_read(struct file *file,
      char *buffer,
             size_t length,
      loff_t *offset)
{
int bytes_read = 0;
if (*Message_Ptr == 0)
    return 0;
file://memcpy_tofs(buffer,Message_Ptr,length);
while (length && *Message_Ptr)
{
put_user(*(Message_Ptr++), buffer++);
length --;
bytes_read ++;
}
#ifdef DEBUG
printk ("Read %d bytes, %d left\n",bytes_read, length);
#endif
return bytes_read;
}
static ssize_t device_write(struct file *file,
              const char *buffer,
       size_t length,
       loff_t *offset)
{
return -EINVAL;
}
static int Major;
struct file_operations Fops = {
    NULL,   /* seek */
    device_read,
    device_write,
    NULL,   /* readdir */
    NULL,   /* select */
    NULL,   /* ioctl */
    NULL,   /* mmap */
    device_open,
    NULL,   /* flush */
    device_release  /* a.k.a. close */
};
int init_module()
{
Major = module_register_chrdev(0,DEVICE_NAME,&Fops);
if (Major < 0) {
 printk ("Sorry registering char device failed with %d\n",Major);
return Major;
}
printk ("registration is a success The major device number is %d.\n",Major);
printk ("If you want to talk to the device driver,\n");
printk ("you'll have to create a device file. \n");
printk ("We suggest you use:\n");
printk ("mknod <name> c %d <minor>\n", Major);
printk ("You can try different minor numbers %s","and see what happens.\n");
return 0;
}
void cleanup_module()
{
int ret;
ret = module_unregister_chrdev(Major, DEVICE_NAME);
if (ret < 0)
    printk("Error in unregister_chrdev: %d\n", ret);
}
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/