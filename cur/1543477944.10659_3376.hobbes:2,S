Date: Fri, 15 Jan 1999 14:00:29 +0000
From: Neil Conway <>
Subject: Re: [uPATCH] SMP scheduling fix (?)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/1/15/80

Robert M. Hyatt wrote:
> 
> On Fri, 15 Jan 1999, Rik van Riel wrote:
> 
> > On Thu, 14 Jan 1999, Robert M. Hyatt wrote:
> >
> > > This would make a good discussion point, since it is a topic I am
> > > highly interested in.  Take a process whose nice value is 0.  And
> > > a process that has been niced to +10.  What is the expectation there?
> >
> > The expectation is that the +10 niced program gets half the
> > CPU time from the 'normal' process.
> 
> ok... then '20'???  IE it would seem that that might be 1/4th using
> the same 'what number is next in this series?'  :)  That's not bad,
Rather simpler than that... A nice value of 20 means you get about
1/20th as much as a process with a nice value of 0.  5% is too big for
lots of things, and this is one of the reasons I like Rik et al.'s
patches for sched_idle.
Does anyone know why Linus doesn't like sched_idle things? (*Does* he
dislike them??).
Neil
PS:  Having bravely said the above without checking, I foolishly decided
to check.  It wasn't the case.  Running two CPU-hogs, one non-niced and
the other "nice +20", I got not the 95/5 split (actually 20/21 vs. 1/21
was what I expected), but a roughly 91.5/8.5 split.  This means that the
niced process got about one eleventh of the CPU time.
This doesn't square with what I read in the source code.  "nice +20"
should give the niced process (i386 values here) ONE time-slice in every
round, while the non-niced should have 20 timeslices.
Argh.
(That's on my 2.0.35 desktop box btw.  Quick inspection suggests 2.1.131
is better behaved but not sure.)
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/