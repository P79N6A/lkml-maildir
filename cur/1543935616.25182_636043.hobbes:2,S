Date: Tue, 08 Jan 2008 17:21:42 -0800
From: Jeremy Fitzhardinge <>
Subject: Re: [PATCH 00 of 10] x86: unify asm/pgtable.h
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/1/8/584

Ingo Molnar wrote:
> * Jeremy Fitzhardinge <jeremy@goop.org> wrote:
>
> 
>> This isn't correct, because it will set _PAGE_GLOBAL on 32-bit 
>> unconditionally.  It needs to be something like:
>> 
>
> hm, why is that a problem? Ah, the VDSO page must not be global-mapped, 
> right? It's getting late here, i should stop modifying the kernel ;)
> 
No, because old processors don't support global pages, and the 32-bit 
setup code makes sure to only set _PAGE_GLOBAL in __PAGE_KERNEL once it 
has been identified, whereas 64-bit can assume its always present.
Erk.  Hm.  The old pgtable_64.h defines both PAGE_KERNEL_VSYSCALL, which 
is global, and PAGE_KERNEL_VSYSCALL32 which is not.  However, it looks 
like PAGE_KERNEL_VSYSCALL is used exactly once in setting up a fixmap, 
and PAGE_KERNEL_VSYSCALL32 is not used at all.
>> +#define GLOBAL_PGPROT(prot)	__pgprot(prot | _PAGE_GLOBAL)
>> +
>> +#define PAGE_KERNEL			GLOBAL_PGPROT(__PAGE_KERNEL)
>> +#define PAGE_KERNEL_RO			GLOBAL_PGPROT(__PAGE_KERNEL_RO)
>> +#define PAGE_KERNEL_EXEC		GLOBAL_PGPROT(__PAGE_KERNEL_EXEC)
>> +#define PAGE_KERNEL_RX			GLOBAL_PGPROT(__PAGE_KERNEL_RX)
>> +#define PAGE_KERNEL_NOCACHE		GLOBAL_PGPROT(__PAGE_KERNEL_NOCACHE)
>> +#define PAGE_KERNEL_LARGE		GLOBAL_PGPROT(__PAGE_KERNEL_LARGE)
>> +#define PAGE_KERNEL_LARGE_EXEC		GLOBAL_PGPROT(__PAGE_KERNEL_LARGE_EXEC)
>> +#define PAGE_KERNEL_VSYSCALL		GLOBAL_PGPROT(__PAGE_KERNEL_VSYSCALL)
>> +#define PAGE_KERNEL_VSYSCALL_NOCACHE	GLOBAL_PGPROT(__PAGE_KERNEL_VSYSCALL_NOCACHE)
>> 
>
> i suspect you wanted to make GLOBAL_PGPROT a NOP on 32-bit?
> 
Yeah, cut'n'paste from a stale buffer.
> but i think it would be better to just do this distinction for the 
> PAGE_KERNEL_VSYSCALL?
> 
?  The _PAGE_GLOBAL issue is distinct from the VSYSCALL one.
    J