Date: Tue, 18 Jan 2005 14:44:58 -0500
From: Mike Waychison <>
Subject: Re: [RFC] shared subtrees
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/1/18/166

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
Al Viro wrote:
> On Mon, Jan 17, 2005 at 03:11:18PM -0500, Mike Waychison wrote:
>  
> 
>>I don't think that solves the problem.  B should receive copies (with
>>shared semantics if called for) of all mountpoints C1,..,Cn that are
>>children of A if A->A.  This is regardless of whether or not propagation
>>occurs before or after the attach.
> 
> 
> ... when that makes sense.  Do you see any real problems with the proposed
> behaviour (i.e. propagation happens before attachment)?
> 
> BTW, you do realize that rbind also has "copy before attaching" semantics,
> right?
Ya, okay, that semantic will work.  Please add it to the RFC though :)
>  
> 
>>Allowing this is like allowing directory aliasing in the sense that an
>>aliased directory that is nested within itself opens us to
>>badness/headaches 8)
>>
>>I still think the only way to handle this is to disallow vfsmounts in a
>>p-node to have (grand)parent-child relationships.  This may have to be
>>extended to the 'owned by' case as well.
> 
> 
> Not feasible (and think what _that_ will do to --move, especially since
> propagation can span namespace boundaries).
Fair enough.
Changing the topic slightly: How should we handle propagation events for
the detach_mnt() case?  Is it fair to say: a detach_mnt of A mounted on
dentry d on parent B will 'umount -l Ai' all Ai where Ai is mounted on
dentry d in all peers and private derivatives of the p-node which B
belong to?
Steps to above:
- - Detaching A from parent B (mounted on dentry d)
  - Let S = set of all peer vfsmounts in B's p-node p (if any)
    unioned with all vfsmounts owned by p (expanding owned p-nodes
    recursively):
  - For each C in S
    - If (C has a child mountpoint D mounted on dentry d)
      && (D is equivalent to A)
      - umount -l D
Thoughts?
Also, brainstorming mountpoint expiry: How about something like this:
- - Each p-node has a recently-touched flag, like how vfsmount currently
has a mnt_expiry_mark.
- - A call to umount with MNT_EXPIRE of vfsmount A which is in a non-empty
p-node will:
  - Will check to see if *all* Ai in A's p-node (and derivatives) are
not busy, if not, return -EBUSY
  - Otherwise:
    - Will clear the recently-touched flag of the p-node if set
    - Otherwise it will umount all Ai.
This only works btw for autofs iff we have vfs native traps.  Otherwise
we'll need to do recursive MNT_EXPIRE (overload MNT_EXPIRE | MNT_DETACH?)
- --
Mike Waychison
Sun Microsystems, Inc.
1 (650) 352-5299 voice
1 (416) 202-8336 voice
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
NOTICE:  The opinions expressed in this email are held by me,
and may not represent the views of Sun Microsystems, Inc.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.2.5 (GNU/Linux)
Comment: Using GnuPG with Thunderbird - 
http://enigmail.mozdev.org
iD8DBQFB7Wc6dQs4kOxk3/MRAo9/AJ415IkSmKqT7rpvo7Uwr8HZqI0okwCfXYs+
iuXoqlEyzGMCnPKwLlSfgvI=
=OAAC
-----END PGP SIGNATURE-----
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/