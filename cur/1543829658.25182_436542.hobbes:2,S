Date: Sat, 24 Jun 2006 09:24:51 +0000
From: "許洛豪" <>
Subject: A question about behavior of SCHED_FIFO: Only one process in run queue at any time.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/6/24/48

Sorry for my poor English, I will try to explain clearly at my best.
The main question I have is that why even I have lots of SCHED_FIFO
process with same
priority, it still have time sharing behavior? And at any time point,
there is always only one
process in the runqueue?
Following is the full story:
I have to do a homework that tearcher asks us impelement an EDF
real-time process
scheduling policy in Linux, so I am trying to understanding how Linux
real-time process
scheduling work, and do the homework baed on this.
I have read some textbook about OS and Linux kernel, according to these books,
SCHED_FIFO is a real-time scheduling policy, and when a process is a SCHED_FIFO
process, it will be preempted only when follwing case happend:
1.There are some process with higher priority.
2.The process is in blocking opreation.
3.The process is dead.
4.sched_yield()
Man page of sched_setscheduler even says:"SCHED_FIFO is a  simple
scheduling  algorithm  without  time slicing."
Then I worte an user space program (in the attachment),
which fork an SCHED_FIFO child process, it does nothing expect an infinite loop
and print something on screen.
Beside this, I also modify kernel/sched.c and add the following code
after line of
"next = list_entry(queue->next, task_t, run_list);"
====== Code Start =======
        /* Print all element in the real-time task runqueue */
        if ( idx < 100 ) {
            struct task_struct * i;
            printk ( "RT-Queue[%d]:", idx );
            list_for_each_entry ( i, queue, run_list ) {
                printk ( "P[%d] ->", i->pid );
            }
            printk ( "\n" );
        }
====== Code  End =======
As I mentioned, after these modify, no matter how many SCHED_FIFO process I
am running, there are always only one process in the runqueue, why?
Here is the dmesg result, it is clearly these process is in the same
queue, and there
is only one process in the queue at any time point.
RT-Queue[1]:P[9822] ->
RT-Queue[1]:P[9822] ->
RT-Queue[1]:P[9810] ->
RT-Queue[1]:P[9810] ->
RT-Queue[1]:P[9816] ->
RT-Queue[1]:P[9816] ->
RT-Queue[1]:P[9822] ->
RT-Queue[1]:P[9822] ->
Did I misunderstand about SCHED_FIFO policy?
#include <stdio.h>
#include <asm/unistd.h>
#include <errno.h>
#include <sched.h>
_syscall1 ( int, fork_rt_process, int , deadline );
int main ( int argc, char * argv[] )
{
    int pid = -1;
    long deadline = 0;
    struct sched_param tmp;
    tmp.sched_priority = 98;
    if ( argc != 2 ) {
        printf ( "USE:%s deadline\n", argv[0] ); 
        return;
    }
    deadline = time(NULL) + atoi ( argv[1] );
    pid = fork ();
    if ( pid == 0 ) {
        int i = 0;
        int code = sched_setscheduler ( getpid(), SCHED_FIFO, &tmp );
        while ( 1 ) {
            printf ( "New PID:%d:%d\n", getpid(),i );
            i++;
            if ( (long) time(NULL) > deadline )
                break;
        }
        printf ( "End of PID:%d,%d\n", getpid(),code );
    } else {
        wait();
    }
}