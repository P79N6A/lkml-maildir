Date: Wed, 6 Aug 2003 15:33:16 +0100
From: Russell King <>
Subject: [PATCH] Fix Yenta ISA IRQs
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2003/8/6/134

Hi,
While looking at the Yenta IRQ problem, I discovered that some of
the merges from the -ac tree a while ago did something undesirable,
effectively disabling all ISA interrupts for Yenta sockets.
The following patch checks for the presence of ISA interrupts
_before_ deciding that we don't have any rather than deciding we
don't have any and then trying to probe for ISA interrupts.
Could people with Yenta interrupt problems:
(1) report the dmesg from bootup
(2) try with this patch applied with their standard configuration
(3) same as (2), but try disabling PNP support in their kernel,
    leaving i82365 enabled
(4) same as (2), but try leaving PNP support enabled, and disable
    i82365
diff -u ref/drivers/pcmcia/ti113x.h linux/drivers/pcmcia/ti113x.h
--- ref/drivers/pcmcia/ti113x.h	Fri Aug  1 14:05:11 2003
+++ linux/drivers/pcmcia/ti113x.h	Wed Aug  6 15:22:45 2003
@@ -258,31 +258,6 @@
 	if (new != reg)
 		exca_writeb(socket, I365_INTCTL, new);
 
-	/*
-	 * If ISA interrupts don't work, then fall back to routing card
-	 * interrupts to the PCI interrupt of the socket.
-	 *
-	 * Tweaking this when we are using serial PCI IRQs causes hangs
-	 *   --rmk
-	 */
-	if (!socket->socket.irq_mask) {
-		u8 irqmux, devctl;
-
-		devctl = config_readb(socket, TI113X_DEVICE_CONTROL);
-		if ((devctl & TI113X_DCR_IMODE_MASK) != TI12XX_DCR_IMODE_ALL_SERIAL) {
-			printk (KERN_INFO "ti113x: Routing card interrupts to PCI\n");
-
-			devctl &= ~TI113X_DCR_IMODE_MASK;
-
-			irqmux = config_readl(socket, TI122X_IRQMUX);
-			irqmux = (irqmux & ~0x0f) | 0x02; /* route INTA */
-			irqmux = (irqmux & ~0xf0) | 0x20; /* route INTB */
-
-			config_writel(socket, TI122X_IRQMUX, irqmux);
-			config_writeb(socket, TI113X_DEVICE_CONTROL, devctl);
-		}
-	}
-
 	socket->socket.ops->init = ti_init;
 	return 0;
 }
diff -u ref/drivers/pcmcia/yenta_socket.c linux/drivers/pcmcia/yenta_socket.c
--- ref/drivers/pcmcia/yenta_socket.c	Tue Aug  5 11:22:02 2003
+++ linux/drivers/pcmcia/yenta_socket.c	Wed Aug  6 15:22:42 2003
@@ -506,7 +506,34 @@
 	socket->socket.irq_mask = yenta_probe_irq(socket, isa_irq_mask);
 	socket->socket.cb_dev = socket->dev;
 
-	printk("Yenta IRQ list %04x, PCI irq%d\n", socket->socket.irq_mask, socket->cb_irq);
+	printk(KERN_INFO "Yenta: ISA IRQ list %04x, PCI irq%d\n",
+	       socket->socket.irq_mask, socket->cb_irq);
+
+	/*
+	 * If we didn't detect any ISA interrupts, fall back to routing
+	 * card interrupts to the PCI interrupt of the socket.
+	 *
+	 * Tweaking this when we are using serial PCI IRQs causes hangs
+	 *   --rmk
+	 */
+	if (socket->dev->vendor == PCI_VENDOR_ID_TI &&
+	    socket->socket.irq_mask == 0) {
+		u8 irqmux, devctl;
+
+		devctl = config_readb(socket, TI113X_DEVICE_CONTROL);
+		if ((devctl & TI113X_DCR_IMODE_MASK) != TI12XX_DCR_IMODE_ALL_SERIAL) {
+			printk (KERN_INFO "Yenta: Routing card interrupts to PCI\n");
+
+			devctl &= ~TI113X_DCR_IMODE_MASK;
+
+			irqmux = config_readl(socket, TI122X_IRQMUX);
+			irqmux = (irqmux & ~0x0f) | 0x02; /* route INTA */
+			irqmux = (irqmux & ~0xf0) | 0x20; /* route INTB */
+
+			config_writel(socket, TI122X_IRQMUX, irqmux);
+			config_writeb(socket, TI113X_DEVICE_CONTROL, devctl);
+		}
+	}
 }
 
 
-- 
Russell King (rmk@arm.linux.org.uk)                The developer of ARM Linux
             
http://www.arm.linux.org.uk/personal/aboutme.html
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/