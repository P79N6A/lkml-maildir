Date: Fri, 1 Jul 2005 08:57:21 +0200
From: Ingo Molnar <>
Subject: Re: 2.6.13-rc1 CONFIG_DEBUG_SPINLOCK is useless on SMP
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/7/1/20

* Keith Owens <kaos@ocs.com.au> wrote:
> 2.6.13-rc1 built with SMP=Y and DEBUG_SPINLOCK=y.  That uses 
> kernel/spinlock.c instead of the inline definitions of the spinlock 
> functions.  Alas only the inline definitions test for 
> DEBUG_SPINLOCK=y, none of the code in in spinlock.c has any debug 
> facilities.
the spinlock cleanups in -mm (not yet in -git) obsolete most of the 
debugging approach of the current kernel.
but even in terms of 2.6.13-rc1, i'm not completely sure what you mean.
Yes, there's no debugging code in kernel/spinlock.c because much of the
DEBUG_SPINLOCK code (under the old method) is located in the arch
spinlock.h files. I.e. on x86 you'll get SMP spinlock debugging from
asm-i386/spinlock.h:
 static inline void _raw_spin_lock(spinlock_t *lock)
 {
 #ifdef CONFIG_DEBUG_SPINLOCK
         if (unlikely(lock->magic != SPINLOCK_MAGIC)) {
                 printk("eip: %p\n", __builtin_return_address(0));
                 BUG();
         }
 #endif
the only practical exception is when CONFIG_PREEMPT is enabled: the arch 
level trylock, upon which the PREEMPT spinlocks rely on heavily, has no 
meaningful DEBUG_SPINLOCK checks. (but PREEMPT has other checks which 
partly offset this.) In any case, this too is fixed by my spinlock 
cleanups - there all debugging is done centrally in 
lib/spinlock_debug.c.
	Ingo
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/