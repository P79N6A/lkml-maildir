Date: Wed, 12 Mar 2003 00:28:46 -0800 (PST)
From: Dawson Engler <>
Subject: Re: [CHECKER] more potential deadlocks
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2003/3/12/33

> James Morris writes:
> > BUG: seems like it, if they can point to the same thing.  ERROR: 1 thread deadlock.
> >    <struct in_device.lock (<local>:0)>-><struct ip_mc_list.lock (<local>:0)> occurred 5 times
> >    <struct ip_mc_list.lock (<local>:0)>-><struct in_device.lock (<local>:0)> occurred 5 times
> 
> See below.
> 
> > BUG? very hard to follow, but interesting if a real bug.  unfortunately,
> > could also be a false positive because of 
> > 	1. infeasible callchain path or 
> > 
> > 	2. the various in_dev and im pointers never actually point to
> > 	   the same object.
> > 
> > requires three threads: 
> > 	thread 1: acquires im->lock then tries to get inetdev_lock
> > 	thread 2: acquires inetdev_lock and tries to get in_dev->lock.
> > 	thread 3: acquires in_dev->lock and tries to get im->lock.
> > 
> > ERROR: 2 thread deadlock.
> >    <struct ip_mc_list.lock (<local>:0)>-><&inetdev_lock> occurred 5 times
> >    <&inetdev_lock>-><struct ip_mc_list.lock (<local>:0)> occurred 4 times
> 
> These are indeed potential deadlock cases, caused by holding im->lock for
> too long, now fixed by Alexey (in 2.5 bk at least).
great!  Thanks very much for the feedback.  I'd given up on anyone
looking at these.
If people are interested, I can release more deadlock bugs pretty easily.
Dawson
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/