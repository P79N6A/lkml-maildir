Date: Thu, 29 Apr 1999 20:18:26 +0200 (CEST)
From: Andrea Arcangeli <>
Subject: [patch] swapfile fragmentation [was Re: SwapCache bug?]
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/4/29/103

yOn Mon, 5 Apr 1999, Stephen C. Tweedie wrote:
>>   Finally, shouldn't swap_free() only update p->lowest_bit and
>> p->highest_bit when p->swap_map[offset] == 0?
>
>Probably!
Agreed. I also developed the code to start a cluster on an empty region of
swapfile.
It make differences: if I set SWAPFILE_CLUSTER to 0x40 my swap-bench run
in 85 sec, with 0x200 (as in the patch) it runs in 65sec. Also I don't
hear a lot of seek on disk as I was used to hear before.
Index: swapfile.c
===================================================================
RCS file: /var/cvs/linux/mm/swapfile.c,v
retrieving revision 1.1.2.7
diff -u -r1.1.2.7 swapfile.c
--- linux/mm/swapfile.c	1999/04/09 17:04:59	1.1.2.7
+++ linux/mm/swapfile.c	1999/04/29 18:11:24
@@ -23,11 +23,15 @@
 
 struct swap_info_struct swap_info[MAX_SWAPFILES];
 
-#define SWAPFILE_CLUSTER 256
+#define SWAPFILE_CLUSTER 0x200
+#define SWAPFILE_CLUSTER_MASK ~(SWAPFILE_CLUSTER-1)
+#define SWAPFILE_CLUSTER_ALIGN(offset)				\
+	(((offset)+SWAPFILE_CLUSTER-1) & SWAPFILE_CLUSTER_MASK)
 
 static inline int scan_swap_map(struct swap_info_struct *si)
 {
 	unsigned long offset;
+	int first_pass;
 	/* 
 	 * We try to cluster swap pages by allocating them
 	 * sequentially in swap.  Once we've allocated
@@ -37,31 +41,71 @@
 	 * swap partition, so that we reduce overall disk seek times
 	 * between swap pages.  -- sct */
 	if (si->cluster_nr) {
-		while (si->cluster_next <= si->highest_bit) {
-			offset = si->cluster_next++;
-			if (si->swap_map[offset])
-				continue;
-			if (test_bit(offset, si->swap_lockmap))
-				continue;
+		if (si->cluster_next <= si->highest_bit) {
+			offset = si->cluster_next;
 			si->cluster_nr--;
+			if (si->swap_map[offset] ||
+			    test_bit(offset, si->swap_lockmap))
+			{
+				offset++;
+				goto cluster_broken;
+			}
 			goto got_page;
 		}
 	}
 	si->cluster_nr = SWAPFILE_CLUSTER;
-	for (offset = si->lowest_bit; offset <= si->highest_bit ; offset++) {
-		if (si->swap_map[offset])
-			continue;
-		if (test_bit(offset, si->swap_lockmap))
+
+	/* here we try to find an empty aligned cluster -Andrea */
+	first_pass = 1;
+	offset = si->cluster_next;
+ second_pass:
+	offset = SWAPFILE_CLUSTER_ALIGN(offset);
+ check_next_cluster:
+	if (offset+SWAPFILE_CLUSTER-1 <= si->highest_bit)
+	{
+		int nr;
+		for (nr = offset; nr < offset+SWAPFILE_CLUSTER; nr++)
+			if (si->swap_map[nr] ||
+			    test_bit(nr, si->swap_lockmap))
+			{
+				offset += SWAPFILE_CLUSTER;
+				goto check_next_cluster;
+			}
+		/* Cool we found a completly empty aligned cluster, so start
+		 * using it!! -Andrea
+		 */
+		goto got_page;
+	}
+	if (first_pass)
+	{
+		first_pass = 0;
+		offset = si->lowest_bit;
+		goto second_pass;
+	}
+
+	offset = si->cluster_next;
+ cluster_broken:
+	first_pass = 1;
+ second_broken_pass:
+	for (; offset <= si->highest_bit ; offset++) {
+		if (si->swap_map[offset] || test_bit(offset, si->swap_lockmap))
 			continue;
-		si->lowest_bit = offset;
-got_page:
-		si->swap_map[offset] = 1;
-		nr_swap_pages--;
+	got_page:
+		if (offset == si->lowest_bit)
+			si->lowest_bit++;
 		if (offset == si->highest_bit)
 			si->highest_bit--;
-		si->cluster_next = offset;
+		si->swap_map[offset] = 1;
+		nr_swap_pages--;
+		si->cluster_next = offset+1;
 		return offset;
 	}
+	if (first_pass)
+	{
+		first_pass = 0;
+		offset = si->lowest_bit;
+		goto second_broken_pass;
+	}
 	return 0;
 }
 
@@ -130,15 +174,17 @@
 	offset = SWP_OFFSET(entry);
 	if (offset >= p->max)
 		goto bad_offset;
-	if (offset < p->lowest_bit)
-		p->lowest_bit = offset;
-	if (offset > p->highest_bit)
-		p->highest_bit = offset;
 	if (!p->swap_map[offset])
 		goto bad_free;
 	if (p->swap_map[offset] < SWAP_MAP_MAX) {
 		if (!--p->swap_map[offset])
+		{
+			if (offset < p->lowest_bit)
+				p->lowest_bit = offset;
+			if (offset > p->highest_bit)
+				p->highest_bit = offset;
 			nr_swap_pages++;
+		}
 	}
 #ifdef DEBUG_SWAP
 	printk("DebugVM: swap_free(entry %08lx, count now %d)\n",
Andrea Arcangeli
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/