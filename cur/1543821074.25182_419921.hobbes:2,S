Date: Fri, 28 Apr 2006 16:34:09 -0700
From: Andrew Morton <>
Subject: Re: [PATCH] catch valid mem range at onlining memory
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/4/28/238

KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com> wrote:
>
> This patch allows hot-add memory which is not aligned to section.
> Based on linux-2.6.17-rc2-mm1 + memory hotadd ioresource register patch.
> 
> iomem resource patch is here.
> 
http://www.uwsg.indiana.edu/hypermail/linux/kernel/0604.3/1188.html
> 
> Now, hot-added memory has to be aligned to section size.
> Considering big section sized archs, this is not useful.
> 
> When hot-added memory is registerd as iomem resoruce by iomem resource patch,
> we can make use of that information to detect valid memory range.
> 
> Note: With this, not-aligned memory can be registerd. To allow hot-add
>       memory with holes, we have to do more work around add_memory().
>       (It doesn't allows add memory to already existing mem section.)
> 
> 
Looks sane, thanks.
> +#ifdef CONFIG_MEMORY_HOTPLUG
> +/*
> + * Finds the lowest memory reosurce exists within [res->start.res->end)
> + * the caller must specify res->start, res->end, res->flags.
> + * If found, returns 0, res is overwritten, if not found, returns -1.
> + */
> +int find_next_system_ram(struct resource *res)
> +{
> +	u64 start, end;
> +	struct resource *p;
> +
> +	BUG_ON(!res);
> +
> +	start = res->start;
> +	end = res->end;
> +
> +	read_lock(&resource_lock);
> +	for( p = iomem_resource.child; p ; p = p->sibling) {
> +		/* system ram is just marked as IORESOURCE_MEM */
> +		if (p->flags != res->flags)
> +			continue;
> +		if (p->start > end) {
> +			p = NULL;
> +			break;
> +		}
> +		if (p->start >= start)
> +			break;
> +	}
> +	read_unlock(&resource_lock);
> +	if (!p)
> +		return -1;
> +	/* copy data */
> +	res->start = p->start;
> +	res->end = p->end;
> +	return 0;
> +}
> +
> +#endif
This all looks fairly (but trivially) dependent upon the 64-bit-resource
patches in Greg's tree.  Greg, were you planning on merging them in the
post-2.6.17 flood?
> ===================================================================
> --- linux-2.6.17-rc2-mm1.orig/include/linux/ioport.h	2006-04-27 18:00:16.000000000 +0900
> +++ linux-2.6.17-rc2-mm1/include/linux/ioport.h	2006-04-27 21:47:25.000000000 +0900
> @@ -105,6 +105,10 @@
>  			     void *alignf_data);
>  int adjust_resource(struct resource *res, u64 start,
>  		    u64 size);
> +#ifdef CONFIG_MEMORY_HOTPLUG
> +/* get registered SYSTEM_RAM resources in specified area */
> +extern int find_next_system_ram(struct resource *res);
> +#endif
I'll remove the ifdefs - the only thing they give us if someone makes a
mistake is an additional compile-time warning, and I don't think that's
beneficial enough to warrant the addition of an ifdef.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/