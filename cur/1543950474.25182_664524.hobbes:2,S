Date: Thu, 06 Mar 2008 11:27:11 -0500
From: Mark Lord <>
Subject: Re: [patch] Re: using long instead of atomic_t when only set/read is required
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/3/6/253

Linus Torvalds wrote:
> 
> On Thu, 6 Mar 2008, Mark Lord wrote:
>> But also consider something like this:
>>
>> 	void store_task(void)
>> 	{
>> 		*the_task = current;
>> 	}
>>
>> In this case, there is no guarantee that the assignment
>> can be done atomically on all CPU types.  Some RISC archs
>> (eg. MIPS R2xxx) require an (interruptible) instruction pair
>> to store values to a potentially unaligned address.
> 
> You'd better not be using unaligned accesses for memory-ordering-sensitive 
> things (I think x86 happens get even that right for most cases, but I 
> don't think the architecture specification guarantees it, and I'm pretty 
> sure that you might find problems on cache crossing writes, for example)
..
Yeah.  For the MIPS R2xxx CPU, the question was whether the compiler
could guarantee the alignment of the things the pointer could point at.
In cases where it could not, it would emit the interruptable instruction
pair instead of a single load instruction.
I don't know what gcc does on MIPS for this.  Perhaps it simply always
assumes an aligned access?  In that case, there's no issue unless some
putz actually creates/uses a pointer to an unaligned data object.
What about other architectures like ARM ?  Probably also assumes aligned,
in which case all is well.
> But quite frankly, if you have an architecture that can't do the above as 
> a single write when it's a pointer, then you have a totally broken 
> architecture. It's not worth supporting.
> 
> (There are data structures that are harder than native words: bytes and 
> shorts can require load-modify-write cycles, and "u64" and friends can 
> obviously be multiple words, so you shouldn't depend on things for those 
> "complex" cases. But we *definitely* depend on atomicity for regular word 
> accesses).