Date: Sun, 25 Sep 2005 23:41:00 +0200
From: Thomas Gleixner <>
Subject: Re: HRT on opteron / rt14 on opteron
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/9/25/105

On Fri, 2005-09-23 at 16:04 -0700, Darren Hart wrote:
> I am trying to run all the tests in the above tarball on a 2.6.13 kernel with 
> ktimers+tod+hrt + a hrt compatibility patch which uses the normal clocks when a 
> _HR clock is requested since ktimers treats them the same.  I remember there 
> used to be a run_tests script or something when this was a kernel patch, but I 
do_test
> am not seeing that or any kind of documentation on how to interpret the output 
> of the tests which output numbers rather than pass/fail.  For instance:
> 
> # ./1-4
> it value left is 3 999985323
> What does that even mean?  
Cryptic POSIX compliance test output.
The test does the following:
Arm a timer with 2 seconds and a intervall of 5 seconds
(signal to deliver is SIGCONT).
Sleep for 3 seconds
Read the remaining time for the timer
The flow of events is
0	arm timer
 	sleep(3)
0+2sec	timer expires and interupts the sleep. 
	The delivered signal is sigcont, so the sleep is resumed and sleeps the
full 3 seconds. Timer is rearmed with 5 secs.
0+3sec  sleep returns
	  timer_gettime() is called to retrieve the time until the next expiry
of the timer, which should be ~4sec.
> Should I only be running executables that end in 
> -test perhaps?  Are some of these for use by the other tests?
do_test is the script running all the relevant tests AFAICT.
> # ./clock_nanosleep
> Clock resolution        1.000 usec
> Requested delay    actual delay(sec) error(sec)
>   4.000001000      4.000015298     0.000014298
> 
> Looks like clock_nanosleep has errors < 15 usecs, actually seems like a lot for 
> a kernel built with 1us resolution (unloaded) - or does this test include some load?
No. Yoe see the following
t1 = gettime()
nanosleep()
	timer is programmed
timer event interrupt happens
	soft interrupt is invoked
soft interrupt wakes task
return from nanosleep
t2 = gettime()
delta = t2 - t1
So what you see is the overhead of syscalls, the possible interrupt
delay and the overhead of the softirq and the task switch / return to
userspace.
> # ./nanosleep_jitter
> Iteration iter time (secs)           min sleep max sleep
>    0        0.051953  0.051952 0.000052    0.000052
>    1        0.051953  0.051952 0.000052    0.000052
>    ...
> 
> Is this what is expected?  I believe the test intends to sleep for .05 seconds 
> (50 milliseconds), I seem to be sleeping an extra 2 milliseconds.  Seems like a 
> lot actually.
The tests sleeps for 1000 x 50us = 50ms. So having a sleep of ~52usec
each time gives you the 52ms per test
> # ./sigevthread-test
> perror: Invalid argument
> timer_create failed.
> 
> I gather is a conflict with the ktimer implementation?
I think not. It never worked for me. I ignored it as it is not part of
the do_test tests.
> 
> # ./timerlimit
> 7168: timer id = 7167
> timer_create: Resource temporarily unavailable
> 
> Is that a reasonable number of successfully created clocks?
Depends on the number of timers available on your system. But sounds
reasonable.
I have no idea about the plots. George ?
tglx
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/