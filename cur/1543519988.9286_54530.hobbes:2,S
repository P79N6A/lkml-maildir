Date: Mon, 20 Dec 1999 15:06:32 +0100 (CET)
From: Rik van Riel <>
Subject: Re: Allow swapping over nbd and more similar magic
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/12/20/45

On Sat, 18 Dec 1999, Pavel Machek wrote:
> This is (quite simple) patch to linux, which makes it possible to use
> things like nbd and crypted file for swapping. It was tested by
> several people and seems to work. It makes linux less picky about
> devices it can swap on...
It seems that your test people were just lucky,
kreclaimd as below should not do much that
kswapd doesn't do...
> --- clean/mm/vmscan.c	Sat Dec 11 21:44:13 1999
> +++ linux/mm/vmscan.c	Tue Dec  7 22:17:22 1999
>  /*
> + * The background page discarder, started from the init process. 
> + *
> + * This basically executes once a second, trickling out pages
> + * so that we have _some_ free memory available even if there
> + * is no other activity that frees anything up.
> + * We want this to be separate from kswapd, because we do not
> + * want to block, no matter what happens. As long as there are
> + * some clean pages backed it file (which is true under normal
> + * conditions, SCT tells me), we can swap over anything.
I guess this means that you want to do two things:
- swap out dirty pages when we have memory left
- swap out / free _clean_ pages when we are short on
  memory
That is something completely different from the naive
tactic you're trying to use in the next code fragment.
> +int kreclaimd(void *unused)
[snip]
> +	while (1) {
> +		do {
> +			int count = SWAP_CLUSTER_MAX;
> +
> +			/* Normally, lets let kswapd do its work. If memory gets really low,
> +			   we'll want to clean up something to break the deadlock. */
> +			if (nr_free_pages() >= freepages.low)
> +				break;
> +			while (do_try_to_free_pages(0) && count--)	/* We don't want it to do any I/O */
> +				;
> +//			printk( "kreclaimd: Freed %d pages\n", SWAP_CLUSTER_MAX - count );
> +		} while (!tsk->need_resched);
	}
Now what if:
- there already are a number of async swapouts
  in progress (likely since kreclaimd only runs if
  memory is tight)
- kreclaimd tries to swap out a few dirty pages
  and runs into trouble
I guess you want to change the system a bit so that
one daemon only reclaims clean pages and the other
daemon has a condition where it cleans up dirty
pages without freeing memory on a periodic basis.
(ie. kswapd calling swap_out() but never shrink_mmap()
when free memory is high enough)
regards,
Rik
--
The Internet is not a network of computers. It is a network
of people. That is its real strength.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/