Date: Wed, 21 Jul 1999 02:04:46 +0200 (CEST)
From: Andrea Arcangeli <>
Subject: [patch] ll_rw_block fixes and cleanups
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/7/20/190

All these patches are against pre-2.3.11-pre6 (that I still can't boot
btw).
This little patch will avoid the system to account failed read/write
requests.
--- 2.3.11-pre6-LRU/drivers/block/ll_rw_blk.c.~1~	Tue Jul 13 02:02:22 1999
+++ 2.3.11-pre6-LRU/drivers/block/ll_rw_blk.c	Wed Jul 21 01:37:35 1999
@@ -559,7 +559,7 @@
 /* if no request available: if rw_ahead, forget it; otherwise try again blocking.. */
 	if (!req) {
 		if (rw_ahead)
-			goto end_io;
+			goto failed_ahead;
 		req = __get_request_wait(max_req, bh->b_rdev);
 	}
 
@@ -577,6 +577,16 @@
 	add_request(major+blk_dev,req);
 	return;
 
+failed_ahead:
+	switch (rw)
+	{
+	case READ:
+		kstat.pgpgin--;
+		break;
+	case WRITE:
+		kstat.pgpgout--;
+		break;
+	}
 end_io:
 	bh->b_end_io(bh, test_bit(BH_Uptodate, &bh->b_state));
 }
This _incremental_ patch will avoid us to corrupt the filesystem if
there are no free slots available at ll_rw_block time and we are doing a
WRITEA request.
--- 2.3.11-pre6-LRU/drivers/block/ll_rw_blk.c.~2~	Wed Jul 21 01:37:35 1999
+++ 2.3.11-pre6-LRU/drivers/block/ll_rw_blk.c	Wed Jul 21 01:41:04 1999
@@ -584,6 +584,9 @@
 		kstat.pgpgin--;
 		break;
 	case WRITE:
+		if (test_and_set_bit(BH_Dirty, &bh->b_state))
+			BUG();
+		refile_buffer(bh);
 		kstat.pgpgout--;
 		break;
 	}
This patch changes the semantics of ll_rw_block. Now in the array of bh
passed as parameter there must be only valid (not null) bh. That's the
common case and IMO it worth to optimize it.
--- 2.3.11-pre6-LRU/drivers/block/ll_rw_blk.c.~3~	Wed Jul 21 01:41:04 1999
+++ 2.3.11-pre6-LRU/drivers/block/ll_rw_blk.c	Wed Jul 21 01:43:39 1999
@@ -605,12 +605,14 @@
 	struct blk_dev_struct * dev;
 	int i;
 
+#if 0 /* optimize the callers in the 2.3.x cycle */
 	/* Make sure that the first block contains something reasonable */
 	while (!*bh) {
 		bh++;
 		if (--nr <= 0)
 			return;
 	}
+#endif
 
 	dev = NULL;
 	if ((major = MAJOR(bh[0]->b_dev)) < MAX_BLKDEV)
This last patch remove some not needed check for NULL. They are not
necessary since in the previous loop we would have just Oopsed if the bh
pointers would be NULL.
--- 2.3.11-pre6-LRU/drivers/block/ll_rw_blk.c.~4~	Wed Jul 21 01:43:39 1999
+++ 2.3.11-pre6-LRU/drivers/block/ll_rw_blk.c	Wed Jul 21 01:48:29 1999
@@ -663,26 +663,22 @@
 	}
 
 	for (i = 0; i < nr; i++) {
-		if (bh[i]) {
-			set_bit(BH_Req, &bh[i]->b_state);
+		set_bit(BH_Req, &bh[i]->b_state);
 #ifdef CONFIG_BLK_DEV_MD
-			if (MAJOR(bh[i]->b_dev) == MD_MAJOR) {
-				md_make_request(MINOR (bh[i]->b_dev), rw, bh[i]);
-				continue;
-			}
-#endif
-			make_request(MAJOR(bh[i]->b_rdev), rw, bh[i]);
+		if (MAJOR(bh[i]->b_dev) == MD_MAJOR) {
+			md_make_request(MINOR (bh[i]->b_dev), rw, bh[i]);
+			continue;
 		}
+#endif
+		make_request(MAJOR(bh[i]->b_rdev), rw, bh[i]);
 	}
 	return;
 
       sorry:
 	for (i = 0; i < nr; i++) {
-		if (bh[i]) {
-			clear_bit(BH_Dirty, &bh[i]->b_state);
-			clear_bit(BH_Uptodate, &bh[i]->b_state);
-			bh[i]->b_end_io(bh[i], 0);
-		}
+		clear_bit(BH_Dirty, &bh[i]->b_state);
+		clear_bit(BH_Uptodate, &bh[i]->b_state);
+		bh[i]->b_end_io(bh[i], 0);
 	}
 	return;
 }
Andrea
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/