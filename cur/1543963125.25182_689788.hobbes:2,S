Date: Wed, 7 May 2008 20:35:55 +0200
From: "Rafael J. Wysocki" <>
Subject: Re: [RFC][PATCH 2/2] Freezer: Try to handle killable tasks
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/5/7/203

On Wednesday, 7 of May 2008, Matthew Wilcox wrote:
> On Wed, May 07, 2008 at 11:41:50AM +0200, Pavel Machek wrote:
> > > @@ -182,6 +183,8 @@ __mutex_lock_common(struct mutex *lock, 
> > >  		/* didnt get the lock, go to sleep: */
> > >  		spin_unlock_mutex(&lock->wait_lock, flags);
> > >  		schedule();
> > > +		if (state == TASK_KILLABLE)
> > > +			try_to_freeze();
> > >  		spin_lock_mutex(&lock->wait_lock, flags);
> > >  	}
> > > 
> > 
> > I'm not comfortable with this one. Can the task be killable, but still
> > hold some _other_ mutex? (and then release it only if it actually gets
> > the signal?)
> 
> Yes, that's exactly what's supposed to happen.
The question, though, is whether there is a driver that will try to lock this
mutex in its .suspend() or .resume() callback.  If there is one, TASK_KILLABLE
won't help the freezer indeed.
Thanks,
Rafael