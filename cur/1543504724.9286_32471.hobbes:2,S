Date: 03 Aug 1999 11:47:00 +0200
From: (Kai Henningsen)
Subject: Re: WARNING: GCC 2.9.5 & Linux
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/8/3/97

vonbrand@sleipnir.valparaiso.cl (Horst von Brand)  wrote on 02.08.99 in <199908030032.UAA01464@sleipnir.valparaiso.cl>:
> Steve Dodd <dirk@loth.demon.co.uk> said:
>
> [...]
>
> > What /is/ the issue with the strict aliasing code? I was under the
> > impression that it "merely" screwed up code that did icky things with
> > pointers to members of unions. Comments made here about Linus' view on
> > the thing sounds like it is some horrendous problem that may never get
> > sorted. Which is the case?
>
> The ANSI C standard prohibits accessing data through a pointer to a
> different type. I.e., this is wrong:
>
>    int *pi = ...;
>    char *pc;
>
>    pc = (char *) pi;
>
>    *pi = 117;  /* 1st */
>    *pc = 'a';  /* 2nd */
>    ... *pi ... /* 3rd: Illegal */
>
> Note that 3rd is illegal because we stored there through pc, an char * and
> we are going to access it again at 3rd through a int *. It is fine (AFAIU)
> if you store a char though pc and access it as a char later.  The point is
> that this is _hard_ (probably impossible in the general case) to detect for
> a compiler, so the compiler is allowed to assume that *pi does not change,
> since no accesses through an int * could have changed *pi. So it could
> reorder stuff so that the setting at 2nd is done _after_ the line marked
> 3rd above...
Nearly. Except it's defined to be ok if one of your two pointers is a  
char* pointer, so your example doesn't work. Try int* and short*, for  
example.
MfG Kai
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/