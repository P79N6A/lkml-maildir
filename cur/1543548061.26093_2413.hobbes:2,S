Date: Thu, 7 Sep 2000 17:32:42 +0200
From: "Andi Kleen" <>
Subject: Re: [RFC] Wine speedup through kernel module
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/9/7/142

On Thu, Sep 07, 2000 at 04:25:29PM +0100, David Howells wrote:
> 
> Andi Kleen <ak@suse.de> wrote:
> > But that's not race free on SMP. Two CPUs can set the bit in parallel
> > and you'll never notice. You would need at least a protecting spinlock 
> > between the test bit and set bit (or a cmpxchg on x86) 
> 
> Are you sure? I understood that the "lock" prefix on a i386 made the
> instruction it guarded SMP safe.
> 
> If not, I suppose I can use the xchg() macro instead.
> 
> Hold on a moment... You said "between the test bit and set bit"... this is a
> single CPU instruction! With the lock prefix, there should be no between.
This is far from a single CPU instruction between the test_bit and the
set_bit. Even with a single CPU instruction you would need a cmpxchg with 
retry BTW, to handle the case of multiple CPUs entering the instruction at 
the same time. The easiest fix is to add a spinlock per mutex.
if (test_bit(0,&mutex->wm_state) || mutex->wm_owner!=filp) {
		ret = 0; /* false */
} else {
	ret = 1;
	mutex->wm_owner = NULL;
	set_bit(0,&mutex->wm_state);
	SignalObject(obj,1);
}
-Andi
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
Please read the FAQ at 
http://www.tux.org/lkml/