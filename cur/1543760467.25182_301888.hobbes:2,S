Date: Fri, 11 Mar 2005 15:00:11 +1100
From: Peter Chubb <>
Subject: Microstate Accounting for 2.6.11, patch 3/6
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/3/10/348

Microstate accounting:  
Provide I386-dependent MSA clocks, and Kconfig options.
 arch/i386/Kconfig      |   39 ++++++++++++++++++++++++++++++++++++++-
 include/asm-i386/msa.h |   49 +++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 87 insertions(+), 1 deletion(-)
Signed-off-by: Peter Chubb <peterc@gelato.unsw.edu.au>
Index: linux-2.6-ustate/arch/i386/Kconfig
===================================================================
--- linux-2.6-ustate.orig/arch/i386/Kconfig	2005-03-11 09:59:38.773632446 +1100
+++ linux-2.6-ustate/arch/i386/Kconfig	2005-03-11 09:59:38.777538666 +1100
@@ -923,8 +923,45 @@
 
 	  If unsure, say Y. Only embedded should say N here.
 
-endmenu
+config MICROSTATE
+       bool "Microstate accounting"
+       help
+         This option causes the kernel to keep very accurate track of
+	 how long your threads spend on the runqueues, running, or asleep or
+	 stopped.  It will slow down your kernel.
+	 Times are reported in /proc/pid/msa and through a new msa()
+	 system call.
+
+choice 
+       depends on MICROSTATE
+       prompt "Microstate timing source"
+       default MICROSTATE_TSC
+
+config MICROSTATE_PM
+       bool "Use Power-Management timer for microstate timings"
+       depends on X86_PM_TIMER
+       help
+	 If your machine is ACPI enabled and uses power-management, then the 
+	 TSC runs at a variable rate, which will distort the 
+	 microstate measurements.  This timer, although having
+	 slightly more overhead, and a lower resolution (279
+	 nanoseconds or so) will always run at a constant rate.
+
+config MICROSTATE_TSC
+       bool "Use on-chip TSC for microstate timings"
+       depends on X86_TSC
+       help
+         If your machine's clock runs at constant rate, then this timer 
+	 gives you cycle precision in measureing times spent in microstates.
+
+config MICROSTATE_TOD
+       bool "Use time-of-day clock for microstate timings"
+       help
+         If none of the other timers are any good for you, this timer 
+	 will give you micro-second precision.
+endchoice
 
+endmenu
 
 menu "Power management options (ACPI, APM)"
 	depends on !X86_VOYAGER
Index: linux-2.6-ustate/include/asm-i386/msa.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6-ustate/include/asm-i386/msa.h	2005-03-11 09:59:38.779491777 +1100
@@ -0,0 +1,49 @@
+/************************************************************************
+ * asm-i386/msa.h
+ *
+ * Provide an architecture-specific clock.
+ */
+
+#ifndef _ASM_I386_MSA_H
+# define _ASM_I386_MSA_H
+
+# include <linux/config.h>
+
+
+# if defined(CONFIG_MICROSTATE_TSC)
+/*
+ * Use the processor's time-stamp counter as a timesource
+ */
+#  include <asm/msr.h>
+#  include <asm/div64.h>
+
+#  define MSA_NOW(now)  rdtscll(now)
+
+extern unsigned long cpu_khz;
+#  define MSA_TO_NSEC(clk) ({ clk_t _x = ((clk) * 1000000ULL); do_div(_x, cpu_khz); _x; })
+
+# elif defined(CONFIG_MICROSTATE_PM)
+/*
+ * Use the system's monotonic clock as a timesource.
+ * This will only be enabled if the Power Management Timer is enabled.
+ */
+unsigned long long monotonic_clock(void);
+#  define MSA_NOW(now) do { now = monotonic_clock(); } while (0)
+#  define MSA_TO_NSEC(clk) (clk)
+
+# elif defined(CONFIG_MICROSTATE_TOD)
+/*
+ * Fall back to gettimeofday.
+ * This one is incompatible with interrupt-time measurement on some processors.
+ */
+static inline void msa_now(clk_t *nsp) {
+	struct timeval tv;
+	do_gettimeofday(&tv);
+	*nsp = tv.tv_sec * 1000000 + tv.tv_usec;
+}
+#   define MSA_NOW(x) msa_now(&x)
+#   define MSA_TO_NSEC(clk) ((clk) * 1000)
+# endif
+
+
+#endif /* _ASM_I386_MSA_H */
I386
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/