Date: Tue, 08 Jan 2008 15:10:41 -0800
From: Jim Keniston <>
Subject: Re: [PATCH] Kprobes: Add kprobes smoke tests that run on boot
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/1/8/480

On Tue, 2008-01-08 at 22:00 +0100, Andi Kleen wrote:
> Ananth N Mavinakayanahalli <ananth@in.ibm.com> writes:
> >  kernel/kprobes.c        |    2 
> >  kernel/test_kprobes.c   |  216 ++++++++++++++++++++++++++++++++++++++++++++++++
> 
> Can you put this somewhere else please? I know there are already some
> test files in kernel/* but imho they all belong into some other directory.
> 
> +	if (!err)
> +		init_test_probes();
>  	return err;
> 
> Couldn't this be just a normal initcall? Perhaps even a module_init(),
> then it would be possible to use as a module too.
> 
> -Andi
I have no problem with that, but if we want to make it buildable as a
module, the call to get_kprobe() needs to be replaced with some other
gcc-inline-defeating mechanism, or we need to export get_probe().  I
much prefer the former, since get_kprobe() is a kprobes-internal
function.
Anybody know an architecture-independent way (other than noinline, which
doesn't always work) of making gcc decide not to inline a function?
E.g., does taking (and using) the function's address do it?
Jim Keniston
>From Ananth's patch:
+static noinline u32 kprobe_target(u32 value)
+{
+       /*
+        * gcc ignores noinline on some architectures unless we stuff
+        * sufficient lard into the function. The get_kprobe() here is
+        * just for that.
+        *
+        * NOTE: We aren't concerned about the correctness of
get_kprobe()
+        * here; hence, this call is neither under !preempt nor with the
+        * kprobe_mutex held. This is fine(tm)
+        */
+       if (get_kprobe((void *)0xdeadbeef))
+               printk(KERN_INFO "Kprobe smoke test: probe on
0xdeadbeef!\n");
+
+       return (value / div_factor);
+}