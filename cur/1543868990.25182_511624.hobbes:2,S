Date: Wed, 21 Feb 2007 21:36:14 +0000
From: Simon Arlott <>
Subject: [PATCH 1/2] usbatm: Increment module refcount when atm device is opened.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/2/21/381

Increment usbatm driver module refcount when atm device is opened, this prevents the driver for the device being removed if it's in use. (I continue to allow removing the driver without unplugging the device if it's not being used). No problems occur if the atm device is open while the device is unplugged.
Signed-off-by: Simon Arlott <simon@fire.lp0.eu>
---
 drivers/usb/atm/cxacru.c     |    1 +
 drivers/usb/atm/speedtch.c   |    1 +
 drivers/usb/atm/ueagle-atm.c |    1 +
 drivers/usb/atm/usbatm.c     |   14 ++++++++++++--
 drivers/usb/atm/usbatm.h     |    1 +
 drivers/usb/atm/xusbatm.c    |    1 +
 6 files changed, 17 insertions(+), 2 deletions(-)
diff --git a/drivers/usb/atm/cxacru.c b/drivers/usb/atm/cxacru.c
index 1049e34..424b0f4 100644
--- a/drivers/usb/atm/cxacru.c
+++ b/drivers/usb/atm/cxacru.c
@@ -980,6 +980,7 @@ static const struct usb_device_id cxacru
 MODULE_DEVICE_TABLE(usb, cxacru_usb_ids);
 
 static struct usbatm_driver cxacru_driver = {
+	.owner		= THIS_MODULE,
 	.driver_name	= cxacru_driver_name,
 	.bind		= cxacru_bind,
 	.heavy_init	= cxacru_heavy_init,
diff --git a/drivers/usb/atm/speedtch.c b/drivers/usb/atm/speedtch.c
index 638b800..5d6a0eb 100644
--- a/drivers/usb/atm/speedtch.c
+++ b/drivers/usb/atm/speedtch.c
@@ -924,6 +924,7 @@ static void speedtch_unbind(struct usbat
 ***********/
 
 static struct usbatm_driver speedtch_usbatm_driver = {
+	.owner		= THIS_MODULE,
 	.driver_name	= speedtch_driver_name,
 	.bind		= speedtch_bind,
 	.heavy_init	= speedtch_heavy_init,
diff --git a/drivers/usb/atm/ueagle-atm.c b/drivers/usb/atm/ueagle-atm.c
index dae4ef1..e32c93f 100644
--- a/drivers/usb/atm/ueagle-atm.c
+++ b/drivers/usb/atm/ueagle-atm.c
@@ -1735,6 +1735,7 @@ static void uea_unbind(struct usbatm_dat
 }
 
 static struct usbatm_driver uea_usbatm_driver = {
+	.owner = THIS_MODULE,
 	.driver_name = "ueagle-atm",
 	.bind = uea_bind,
 	.atm_start = uea_atm_open,
diff --git a/drivers/usb/atm/usbatm.c b/drivers/usb/atm/usbatm.c
index d91ed11..83cea01 100644
--- a/drivers/usb/atm/usbatm.c
+++ b/drivers/usb/atm/usbatm.c
@@ -828,6 +828,12 @@ static int usbatm_atm_open(struct atm_vc
 
 	mutex_lock(&instance->serialize);	/* vs self, usbatm_atm_close, usbatm_usb_disconnect */
 
+ 	if (!try_module_get(instance->driver->owner)) {
+ 		atm_dbg(instance, "%s: try_module_get failed\n", __func__);
+ 		ret = -ENODEV;
+ 		goto fail;
+ 	}
+
 	if (instance->disconnected) {
 		atm_dbg(instance, "%s: disconnected!\n", __func__);
 		ret = -ENODEV;
@@ -854,7 +860,7 @@ static int usbatm_atm_open(struct atm_vc
 	if (!new->sarb) {
 		atm_err(instance, "%s: no memory for SAR buffer!\n", __func__);
 		ret = -ENOMEM;
-		goto fail;
+		goto fail_free;
 	}
 
 	vcc->dev_data = new;
@@ -876,8 +882,10 @@ static int usbatm_atm_open(struct atm_vc
 
 	return 0;
 
-fail:
+fail_free:
 	kfree(new);
+fail:
+	module_put(instance->driver->owner);
 	mutex_unlock(&instance->serialize);
 	return ret;
 }
@@ -922,6 +930,8 @@ static void usbatm_atm_close(struct atm_
 	clear_bit(ATM_VF_PARTIAL, &vcc->flags);
 	clear_bit(ATM_VF_ADDR, &vcc->flags);
 
+	module_put(instance->driver->owner);
+
 	mutex_unlock(&instance->serialize);
 
 	atm_dbg(instance, "%s successful\n", __func__);
diff --git a/drivers/usb/atm/usbatm.h b/drivers/usb/atm/usbatm.h
index d3c0ee4..4a172a9 100644
--- a/drivers/usb/atm/usbatm.h
+++ b/drivers/usb/atm/usbatm.h
@@ -103,6 +103,7 @@ struct usbatm_data;
 */
 
 struct usbatm_driver {
+	struct module *owner;
 	const char *driver_name;
 
 	/* init device ... can sleep, or cause probe() failure */
diff --git a/drivers/usb/atm/xusbatm.c b/drivers/usb/atm/xusbatm.c
index 70125c6..8c425d7 100644
--- a/drivers/usb/atm/xusbatm.c
+++ b/drivers/usb/atm/xusbatm.c
@@ -205,6 +205,7 @@ static int __init xusbatm_init(void)
 		xusbatm_usb_ids[i].idVendor	= vendor[i];
 		xusbatm_usb_ids[i].idProduct	= product[i];
 
+		xusbatm_drivers[i].owner	= THIS_MODULE;
 		xusbatm_drivers[i].driver_name	= xusbatm_driver_name;
 		xusbatm_drivers[i].bind		= xusbatm_bind;
 		xusbatm_drivers[i].unbind	= xusbatm_unbind;
-- 
1.4.3.1
-- 
Simon Arlott
[unhandled content-type:application/pgp-signature]