Date: Tue, 22 Jun 1999 18:11:48 -0300 (EST)
From: Marcelo Tosatti <>
Subject: [patch] Re: Compile error report pre-2.3.8-2
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/6/22/206

Ouch...
Lots of places missing #ifdef __SMP__ 
Should compile with this patch...
  - Marcelo
On Tue, 22 Jun 1999, Steve Bergman wrote:
> Marcelo Tosatti wrote:
> > 
> > This should fix.
> 
> Thanks.  That worked. :-)  But here is another one:
> 
> 
> ip_masq_mod.c: In function `ip_masq_mod_lkp_unlink':
> ip_masq_mod.c:92: `masq_mod_lock' undeclared (first use in this
> function)
> ip_masq_mod.c:92: (Each undeclared identifier is reported only once
> ip_masq_mod.c:92: for each function it appears in.)
> ip_masq_mod.c: In function `ip_masq_mod_lkp_link':
> ip_masq_mod.c:108: `masq_mod_lock' undeclared (first use in this
> function)
> make[3]: *** [ip_masq_mod.o] Error 1
> make[2]: *** [first_rule] Error 2
> make[1]: *** [_subdir_ipv4] Error 2
> make: *** [_dir_net] Error 2
> 
> -Steve
> 
diff -Nur linux.duh/net/ipv4/ip_masq.c linux/net/ipv4/ip_masq.c
--- linux.duh/net/ipv4/ip_masq.c	Wed Mar 17 02:52:05 1999
+++ linux/net/ipv4/ip_masq.c	Tue Jun 22 18:08:31 1999
@@ -46,6 +46,7 @@
  *	Juan Jose Ciarlante	: 	make masq_proto_doff() robust against fake sized/corrupted packets
  *	Kai Bankett		:	do not toss other IP protos in proto_doff()
  *	Dan Kegel		:	pointed correct NAT behavior for UDP streams
+ *  Marcelo Tosatti : minor #ifdef fixes
  *	
  */
 
@@ -795,14 +796,17 @@
 {
 	__u16 mport;
 	
+#ifdef __SMP__
 	spin_lock_irq(&masq_port_lock);
+#endif
 	/*
 	 *	Try the next available port number
 	 */
 	mport = htons(masq_port++);
 	if (masq_port==PORT_MASQ_END) masq_port = PORT_MASQ_BEGIN;
-
+#ifdef __SMP__
 	spin_unlock_irq(&masq_port_lock);
+#endif
 	return mport;
 }
 
diff -Nur linux.duh/net/ipv4/ip_masq_mfw.c linux/net/ipv4/ip_masq_mfw.c
--- linux.duh/net/ipv4/ip_masq_mfw.c	Wed May 26 22:14:37 1999
+++ linux/net/ipv4/ip_masq_mfw.c	Tue Jun 22 18:08:53 1999
@@ -12,6 +12,7 @@
  *	JuanJo Ciarlante:	added u-space sched support
  *	JuanJo Ciarlante:	if rport==0, use packet dest port *grin*
  *	JuanJo Ciarlante:	fixed tcp syn&&!ack creation
+ *  Marcelo Tosatti:   minor #ifdef fixes
  *
  *
  */
@@ -192,11 +193,14 @@
 	mfw_host = mfw_host_new(mu);
 	if (!mfw_host) 
 		return -ENOMEM;
-
+#ifdef __SMP__
 	write_lock_bh(&mfw->lock);
+#endif
 	list_add(&mfw_host->list, attail? mfw->hosts.prev : &mfw->hosts);
 	atomic_inc(&mfw->nhosts);
+#ifdef __SMP__
 	write_unlock_bh(&mfw->lock);
+#endif
 
 	return 0;
 }
@@ -213,8 +217,9 @@
 	struct ip_masq_mfw_host *h;
 	int n_del = 0;
 	l = &mfw->hosts;
-
+#ifdef __SMP__
 	write_lock_bh(&mfw->lock);
+#endif
 	for (e=l->next; e!=l; e=e->next)
 	{
 		h = list_entry(e, struct ip_masq_mfw_host, list);
@@ -343,17 +348,23 @@
 {
 	struct ip_masq_mfw *mfw;
 	struct ip_masq_mfw_host *h = NULL;
-
+#ifdef __SMP__
 	read_lock(&mfw_lock);
+#endif
 	mfw = __mfw_get(fwmark);
 
 	if (mfw) {
+#ifdef __SMP__
 		write_lock(&mfw->lock);
 		h = __mfw_sched(mfw, 0);
 		write_unlock(&mfw->lock);
+#else
+		h = __mfw_sched(mfw, 0);
+#endif
 	}
-
+#ifdef __SMP__
 	read_unlock(&mfw_lock);
+#endif
 	return h;
 }
 
@@ -382,10 +393,14 @@
 
         for(idx = 0; idx < IP_MASQ_MFW_HSIZE; idx++)
 	{
+#ifdef __SMP__
 		read_lock(&mfw_lock);
+#endif
 		for(mfw = ip_masq_mfw_table[idx]; mfw ; mfw = mfw->next)
 		{
+#ifdef __SMP__
 			read_lock_bh(&mfw->lock);
+#endif
 			l=&mfw->hosts;
 
 			for(e=l->next;l!=e;e=e->next) {
@@ -403,14 +418,20 @@
 				len += sprintf(buffer+len, "%-63s\n", temp);
 
 				if(len >= length) {
+#ifdef __SMP__
 					read_unlock_bh(&mfw->lock);
 					read_unlock(&mfw_lock);
+#endif
 					goto done;
 				}
 			}
+#ifdef __SMP__
 			read_unlock_bh(&mfw->lock);
+#endif
 		}
+#ifdef __SMP__
 		read_unlock(&mfw_lock);
+#endif
 	}
 
 done:
@@ -447,11 +468,14 @@
 	struct ip_masq_mfw *mfw_next;
 	int idx;
 	struct list_head *l,*e;
-
+#ifdef __SMP__
 	write_lock_bh(&mfw_lock);
+#endif
 	memcpy(local_table, ip_masq_mfw_table, sizeof ip_masq_mfw_table);
 	memset(ip_masq_mfw_table, 0, sizeof ip_masq_mfw_table);
+#ifdef __SMP__
 	write_unlock_bh(&mfw_lock);
+#endif
 
 	/*
 	 *	For every hash table row ...
@@ -558,10 +582,13 @@
 		 *
 		 */
 		down(&mfw_sema);
-
+#ifdef __SMP__
 		read_lock(&mfw_lock);
+#endif
 		mfw = __mfw_get(mu->fwmark);
+#ifdef __SMP__
 		read_unlock(&mfw_lock);
+#endif
 		
 		/*
 		 *	If first host, create m-entry
@@ -583,9 +610,13 @@
 			 *	Already protected by global lock.
 			 */
 			if (ret == 0 && atomic_read(&mfw->nhosts) == 1)  {
+#ifdef __SMP__
 				write_lock_bh(&mfw_lock);
+#endif
 				__mfw_add(mfw);
+#ifdef __SMP__
 				write_unlock_bh(&mfw_lock);
+#endif
 			} 
 			if (atomic_read(&mfw->nhosts) == 0) {
 				mfw_destroy(mfw);
@@ -599,10 +630,13 @@
 	case IP_MASQ_CMD_DEL:
 		down(&mfw_sema);
 
+#ifdef __SMP__
 		read_lock(&mfw_lock);
 		mfw = __mfw_get(mu->fwmark);
 		read_unlock(&mfw_lock);
-
+#else
+		mfw = __mfw_get(mu->fwmark);
+#endif
 		if (mfw) {
 			ret = mfw_delhost(mfw, mu);
 
@@ -611,9 +645,13 @@
 			 *	XXX check logic XXX
 			 */
 			if (atomic_read(&mfw->nhosts) == 0) {
+#ifdef __SMP__
 				write_lock_bh(&mfw_lock);
 				__mfw_del(mfw);
 				write_unlock_bh(&mfw_lock);
+#else
+				__mfw_del(mfw);
+#endif
 				mfw_destroy(mfw);
 			}
 		} else 
@@ -633,11 +671,15 @@
 		 *	No need to semaphorize here, main list is not 
 		 *	modified.
 		 */
+#ifdef __SMP__
 		read_lock(&mfw_lock);
+#endif
 		
 		mfw = __mfw_get(mu->fwmark);
 		if (mfw) {
+#ifdef __SMP__
 			write_lock_bh(&mfw->lock);
+#endif
 			
 			if (mu->flags & IP_MASQ_MFW_SCHED) {
 				struct ip_masq_mfw_host *h;
@@ -651,8 +693,9 @@
 				
 			write_unlock_bh(&mfw->lock);
 		}
-
+#ifdef __SMP__
 		read_unlock(&mfw_lock);
+#endif
 		break;
 	}
 out:
@@ -671,9 +714,13 @@
 static int mfw_in_rule(const struct sk_buff *skb, const struct iphdr *iph)
 {
 	int val;
+#ifdef __SMP__
 	read_lock(&mfw_lock);
 	val = ( __mfw_get(skb->fwmark) != 0);
 	read_unlock(&mfw_lock);
+#else 
+	val = ( __mfw_get(skb->fwmark) != 0);
+#endif
 	return val;
 }
 
diff -Nur linux.duh/net/ipv4/ip_masq_mod.c linux/net/ipv4/ip_masq_mod.c
--- linux.duh/net/ipv4/ip_masq_mod.c	Sun Oct  4 15:21:45 1998
+++ linux/net/ipv4/ip_masq_mod.c	Tue Jun 22 18:04:51 1999
@@ -13,6 +13,7 @@
  *
  * Changes:
  *		Cyrus Durgin:		fixed kerneld stuff for kmod.
+ *		Marcelo Tosatti:    minor #ifdef fixes
  */
 
 #include <linux/config.h>
@@ -88,18 +89,23 @@
 int ip_masq_mod_lkp_unlink(struct ip_masq_mod *mmod)
 {
 	struct ip_masq_mod **mmod_p;
-
+	
+#ifdef __SMP__
 	write_lock_bh(&masq_mod_lock);
+#endif 
 
 	for (mmod_p = &ip_masq_mod_lkp_base; *mmod_p ; mmod_p = &(*mmod_p)->next)
 		if (mmod == (*mmod_p))  {
 			*mmod_p = mmod->next;
 			mmod->next = NULL;
+#ifdef __SMP__
 			write_unlock_bh(&masq_mod_lock);
+#endif
 			return 0;
 		}
-
+#ifdef __SMP__
 	write_unlock_bh(&masq_mod_lock);
+#ifdef
 	return -EINVAL;
 }
 
diff -Nur linux.duh/net/ipv4/ip_masq_portfw.c linux/net/ipv4/ip_masq_portfw.c
--- linux.duh/net/ipv4/ip_masq_portfw.c	Mon Jan  4 21:31:35 1999
+++ linux/net/ipv4/ip_masq_portfw.c	Tue Jun 22 17:57:00 1999
@@ -78,8 +78,9 @@
 	int nent;
 
 	nent = atomic_read(&mmod_self->mmod_nent);
-
+#ifdef __SMP__
 	write_lock_bh(&portfw_lock);
+#endif
 
 	for (entry=list->next;entry != list;entry = entry->next)  {
 		n = list_entry(entry, struct ip_portfw, list);
@@ -93,7 +94,9 @@
 			MOD_DEC_USE_COUNT;
 		}
 	}
+#ifdef __SMP__
 	write_unlock_bh(&portfw_lock);
+#endif
 	
 	return nent==atomic_read(&mmod_self->mmod_nent)? ESRCH : 0;
 }
@@ -108,9 +111,9 @@
 	struct list_head *l;
 	struct list_head *e;
 	struct ip_portfw *n;
-
+#ifdef __SMP__
 	write_lock_bh(&portfw_lock);
-
+#endif
 	for (prot = 0; prot < 2;prot++) {
 		l = &portfw_list[prot];
 		while((e=l->next) != l) {
@@ -121,8 +124,9 @@
 			MOD_DEC_USE_COUNT;
 		}
 	}
-
+#ifdef __SMP__
 	write_unlock_bh(&portfw_lock);
+#endif
 }
 
 /*
@@ -167,8 +171,10 @@
 	struct list_head *l, *e;
 	int count = 0;
 
-
+#ifdef __SMP__
 	read_lock_bh(&portfw_lock);
+#endif
+
 
 	l = &portfw_list[prot];
 
@@ -183,9 +189,9 @@
 			count++;
 		}
 	}
-
+#ifdef __SMP__
 	read_unlock_bh(&portfw_lock);
-
+#endif
 	return count;
 }
 
@@ -226,15 +232,17 @@
 
 	atomic_set(&npf->pref_cnt, npf->pref);
 	INIT_LIST_HEAD(&npf->list);
-
+#ifdef __SMP__
 	write_lock_bh(&portfw_lock);
+#endif
 
 	/*
 	 *	Add at head
 	 */
 	list_add(&npf->list, &portfw_list[prot]);
-
+#ifdef __SMP__
 	write_unlock_bh(&portfw_lock);
+#endif
 
 	ip_masq_mod_inc_nent(mmod_self);
         return 0;
@@ -327,8 +335,9 @@
                 len = sprintf(buffer, "%-63s\n", temp);
         }
         pos = 64;
-
+#ifdef __SMP__
 	read_lock_bh(&portfw_lock);
+#endif
 
         for(ind = 0; ind < 2; ind++)
         {
@@ -354,7 +363,9 @@
 		}
         }
 done:
+#ifdef __SMP__
 	read_unlock_bh(&portfw_lock);
+#endif
 
         begin = len - (pos - offset);
         *start = buffer + begin;
@@ -390,10 +401,13 @@
 		skb->dev->name, skb->dev->ifindex, rt->rt_iif, rt->rt_flags,
 		rt->u.dst.dev->name,
 		NIPQUAD(iph->daddr), ntohs(portp[1]));
-
+#ifdef __SMP__
 	read_lock(&portfw_lock);
+#endif
 	pfw = ip_portfw_lookup(iph->protocol, portp[1], iph->daddr, NULL, NULL);
+#ifdef __SMP__
 	read_unlock(&portfw_lock);
+#ifdef
 	return (pfw!=0);
 }
 
@@ -414,7 +428,9 @@
 	/*
 	 *	Lock for writing.
 	 */
+#ifdef __SMP__
 	write_lock(&portfw_lock);
+#endif
 
 	if ((pf=ip_portfw_lookup(iph->protocol, 
 			portp[1], iph->daddr, 
@@ -450,7 +466,9 @@
 		}
 	}
 out:
+#ifdef __SMP__
 	write_unlock(&portfw_lock);
+#endif
 	return ms;
 }
 