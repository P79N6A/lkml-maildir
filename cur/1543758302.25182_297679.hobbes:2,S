Date: Sun, 27 Feb 2005 11:58:06 +0100
From: "Giovanni Tusa" <>
Subject: sched_yield behavior
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/2/27/20

Hi all,
I have a question about the sched_yield behavior of Linux O(1) scheduler,
for RT tasks.
By reading some documentation, I found that " ....real-time tasks are a
special case, because
when they want to explicitly yield the processor to other waiting processes,
they are merely
moved to the end of their priority list (and not inserted into the expired
array, like conventional
processes)."
I have to implement an RT task with the highest priority in the system (it
is also the only task within the
priority list for such priority level). Moreover, it has to be a SCHED_FIFO
task,  so that it can preempt
SCHED_RR ones, because of its strong real-time requirements. However,
sometimes it should relinquish the
CPU, to give to other tasks a chance to run.
Now, what happen if it gives up the CPU by means of the sched_yield() system
call?
If  I am not wrong, the scheduler will choose it again (it will be still the
higher priority task, and the only of its priority list).
I have to add an explicit sleep to effectively relinquish the CPU for some
time, or the scheduler can deal with such a
situation in another way?
Any advice will be appreciated.
Giovanni
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/