Date: Sun, 31 Jul 2005 13:59:12 +0300
From: Denis Vlasenko <>
Subject: Re: 2.6.11-rc5 and 2.6.12: cannot transmit anything
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/7/31/58

On Monday 25 July 2005 08:17, Denis Vlasenko wrote:
> I reported earlied that around linux-2.6.11-rc5 my home box sometimes
> does not want to send anything over ethernet. That report is repeated below
> sig.
> 
> I finally managed to nail down where this happens.
> I instrumented sch_generic.c to trace what happens with packets
> to be sent over interface named "if". 
> 
> On 'good' boot, I see   
> 
> 2005-07-12_17:26:29.72158 kern.info: qdisc_restart: start
> 2005-07-12_17:26:29.72164 kern.info: qdisc_restart: skb!=NULL
> 2005-07-12_17:26:29.72166 kern.info: qdisc_restart: if !netif_queue_stopped...
> 2005-07-12_17:26:29.72167 kern.info: qdisc_restart: ...hard_start_xmit
> 
> in the log, on 'bad' one only "qdisc_restart: start".
On Monday 25 July 2005 08:28, David S. Miller wrote:
> Probably your link is never coming up.  We won't send packets
> over the wire unless the device is in the link-up state.
> 
> However, if ->dequeue() is returning NULL, there really aren't
> any packets in the device queue to be sent.
> 
> If you want, add more tracing to pfifo_fast_dequeue() since
> that's almost certainly which queueing discipline is hooked
> up to your VIA Rhine device as it's the default.
I have move info.
kernel log of "ping 1.1.4.1 -i 0.01" when everything is good:
...
2005-07-30_22:30:35.00559 kern.info: pfifo_fast_enqueue returns 0
2005-07-30_22:30:35.00563 kern.info: qdisc_restart: start
2005-07-30_22:30:35.00568 kern.info: pfifo_fast_dequeue returns a skb
2005-07-30_22:30:35.00570 kern.info: qdisc_restart: skb!=NULL
2005-07-30_22:30:35.00571 kern.info: qdisc_restart: start
2005-07-30_22:30:35.00573 kern.info: pfifo_fast_dequeue returns NULL
2005-07-30_22:30:35.01458 kern.info: pfifo_fast_enqueue returns 0
2005-07-30_22:30:35.01460 kern.info: qdisc_restart: start
2005-07-30_22:30:35.01462 kern.info: pfifo_fast_dequeue returns a skb
2005-07-30_22:30:35.01463 kern.info: qdisc_restart: skb!=NULL
2005-07-30_22:30:35.01468 kern.info: qdisc_restart: start
2005-07-30_22:30:35.01470 kern.info: pfifo_fast_dequeue returns NULL
2005-07-30_22:30:35.02358 kern.info: pfifo_fast_enqueue returns 0
2005-07-30_22:30:35.02360 kern.info: qdisc_restart: start
...
Kernel log when 'no tx syndrome' is in effect:
2005-07-30_21:28:25.15338 kern.info: qdisc_restart: start
2005-07-30_21:28:25.16438 kern.info: qdisc_restart: start
2005-07-30_21:28:25.17538 kern.info: qdisc_restart: start
2005-07-30_21:28:25.18638 kern.info: qdisc_restart: start
2005-07-30_21:28:25.19738 kern.info: qdisc_restart: start
2005-07-30_21:28:25.20837 kern.info: qdisc_restart: start
2005-07-30_21:28:25.21937 kern.info: qdisc_restart: start
2005-07-30_21:28:25.23037 kern.info: qdisc_restart: start
2005-07-30_21:28:25.24137 kern.info: qdisc_restart: start
2005-07-30_21:28:25.25237 kern.info: qdisc_restart: start
2005-07-30_21:28:25.26337 kern.info: qdisc_restart: start
2005-07-30_21:28:25.27436 kern.info: qdisc_restart: start
2005-07-30_21:28:25.28536 kern.info: qdisc_restart: start
I instrumented sch_generic.c as follows:
int qdisc_restart(struct net_device *dev)
{
        struct Qdisc *q = dev->qdisc;
        struct sk_buff *skb;
int track = (dev->name[0]=='i' && dev->name[1]=='f' && dev->name[2]=='\0');
if(track) { printk("qdisc_restart: start\n"); }
        /* Dequeue packet */
        if ((skb = q->dequeue(q)) != NULL) {
if(track) { printk("qdisc_restart: skb!=NULL\n"); }
...
static struct sk_buff *
pfifo_fast_dequeue(struct Qdisc* qdisc)
{
        int prio;
        struct sk_buff_head *list = qdisc_priv(qdisc);
        struct sk_buff *skb;
        for (prio = 0; prio < 3; prio++, list++) {
                skb = __skb_dequeue(list);
                if (skb) {
                        qdisc->q.qlen--;
printk("pfifo_fast_dequeue returns a skb\n");
                        return skb;
                }
        }
printk("pfifo_fast_dequeue returns NULL\n");
        return NULL;
}
Since I don't see "pfifo_fast_dequeue returns..." messages,
it looks like interface "if" doesn't use pfifo_fast qdisc... ?!
I positively sure I do not use any shaping on that box,
and all interfaces ought to use default qdisc. Strange.
Will collect "ip l" output when it will happen next time.
Instrumented source file is attached.
--
vda
[unhandled content-type:application/x-bzip2]