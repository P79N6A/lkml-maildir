Date: Thu, 17 Jun 1999 16:56:48 +0200 (METDST)
From:  niessene@natlab ...
Subject: Can't burst with an INTEL 440BX AGP Bridge.do burst with an INTEL 440BX AGP Bridge.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/6/17/83

We are using the Linux 2.2.1 kernel.
We have a DELL optiplex GX 1 PC with a Pentium II processer, an INTEL 440BX 
AGPset: 82443BX Host Brigde/Controller, main memory and a homemade PCI card 
with a pci-controller implemented in a FPGA (Altera Flex 10KE) which can burst. 
When we are using copy_to_user() and copy_from_user() the PCI card won't burst.
When we do a pci bus analyse, we see that the bridge starts a new transaction 
on the PCI bus for every DWord instead of a continuous burst. 
The frame signal in table 1 shows that the initiator (bridge) never intends to
transfer more than a DWord. 
Table 2 shows that a read transaction is even worse: of course the PCI card
needs extra TW cycles to respond, but now the initiator waits many cycles 
between transactions.
We think there are two possible solutions:
1. Can we set some bits in the bridge to enable bursting and/or speed up 
   transactions?
2. Use a function to set up a DMA transfer by the bridge?
Any help is welcome!
    Erik
Table 1. Write transaction to PCI card
======================================
Sample  TimeRel  State  C/BE#  AD[31:0]  FRAME#  DEVSEL#  IRDY#  TRDY#  
TRIG:    0.0ns   Addr   MemWri F7000000    0       1        1      1
   1:   30.1ns   TW     0000   0A303030    1       1        0      1
   2:   30.1ns   Data   0000   0A303030    1       0        0      0
   3:   30.1ns   ....   0000   0A303030    1       1        1      1
   4:   30.1ns   ....   0111   F7000004    1       1        1      1
   5:   30.1ns   Addr   MemWri 0A313030    0       1        1      1
   6:   30.1ns   TW     0000   0A313030    1       1        0      1
   7:   30.1ns   Data   0000   0A313030    1       0        0      0
   8:   30.1ns   ....   0000   0A313030    1       1        1      1
   9:   30.1ns   Addr   MemWri F7000008    0       1        1      1
  10:   30.1ns   TW     0000   0A323030    1       1        0      1
  11:   30.1ns   Data   0000   0A323030    1       0        0      0
  12:   30.1ns   ....   0000   0A323030    1       1        1      1
  13:   30.1ns   Addr   MemWri F700000C    0       1        1      1
  14:   30.1ns   TW     0000   0A333030    1       1        0      1
  15:   30.1ns   Data   0000   0A333030    1       0        0      0
  16:   30.1ns   ....   0000   0A333030    1       1        1      1
  17:   30.1ns   ....   0111   F7000010    1       1        1      1
  18:   30.1ns   Addr   MemWri F7000010    0       1        1      1
  19:   30.1ns   TW     0000   0A343030    1       1        0      1
  20:   30.1ns   Data   0000   0A343030    1       0        0      0
Table 2. Read transaction from PCI card
=======================================
Sample  TimeRel  State  C/BE#  AD[31:0]  FRAME#  DEVSEL#  IRDY#  TRDY#  
TRIG:    0.0ns   Addr   MemRd  F7000000    0       1        1      1
   1:   30.1ns   TW     0000   F7000000    1       1        0      1
   2:   30.1ns   TW     0000   00000000    1       0        0      1
   3:   30.1ns   TW     0000   0A353532    1       0        0      1
   4:   30.1ns   Data   0000   0A303030    1       0        0      0
   5:   30.1ns   ....   0000   0A303030    1       1        1      1
   6:   30.1ns   ....   0000   F7000000    1       1        1      1
   7:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
   8:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
   9:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  10:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  11:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  12:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  13:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  14:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  15:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  16:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  17:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  18:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  19:   30.1ns   Addr   MemRd  F7000004    0       1        1      1
  20:   30.1ns   TW     0000   F7000004    1       1        0      1
  21:   30.1ns   TW     0000   00000000    1       0        0      1
  22:   30.1ns   TW     0000   0A353532    1       0        0      1
  23:   30.1ns   Data   0000   0A313030    1       0        0      0
  24:   30.1ns   ....   0000   0A313030    1       1        1      1
  25:   30.1ns   ....   0000   F7000004    1       1        1      1
  26:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  27:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  28:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  29:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  30:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  31:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  32:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  33:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  34:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  35:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  36:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  37:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  38:   30.1ns   Addr   MemRd  F7000008    0       1        1      1
  39:   30.1ns   TW     0000   F7000008    1       1        0      1
  40:   30.1ns   TW     0000   00000000    1       0        0      1
  41:   30.1ns   TW     0000   0A353532    1       0        0      1
  42:   30.1ns   Data   0000   0A323030    1       0        0      0
  43:   30.1ns   ....   0000   0A323030    1       1        1      1
  44:   30.1ns   ....   0000   F7000008    1       1        1      1
  45:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  46:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  47:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  48:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  49:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
  50:   30.1ns   ....   1111   FFFFFFFF    1       1        1      1
Table 3. Read and Write functions in the driver  
===============================================
static ssize_t pciram_read (struct file *fp, char *buf, size_t count,
 loff_t *ppos) {
  unsigned int br;  /* bytes to read */
  unsigned int bl;  /* bytes left to read */
  /* reading 'count' bytes is done in blocks of MAX_BLOCK_SIZE or less bytes. */
  bl=count;
  do {
    br=min(MAX_BLOCK_SIZE, bl);
    /* read a block of br bytes from pci input card */
    if (copy_to_user(buf, pciram_ba0, br)) return -EFAULT;
    buf+=br;    
    if ((dbg&2)==2) printk("pciram_read: memcpy_tofs from buf=%p  br=%d\n", buf, br);
    gr_tbc+=br; bl-=br;
    if ((dbg&2)==2) printk("pciram_read: br=%d  bl=%d\n", br, bl);
  } while (bl>0);
  gr_blkc++;
  if (dbg&1) { printk("pciram_read: count = %d\n", count); }
  
  return count;
}
static ssize_t pciram_write (struct file *fp, const char *buf, size_t count,
  loff_t *ppos) {
  unsigned int bw; /* bytes to write */
  unsigned int bl; /* bytes left to write */
  
  if (dbg&1) { printk("pciram_write\n"); }
  /* writing 'count' bytes is done in blocks of MAX_BLOCK_SIZE or less bytes. */
  bl=count;
  do {  
    bw=min(MAX_BLOCK_SIZE, bl);
    /* write a block of bw bytes to pci card */
    if (copy_from_user(pciram_ba0, buf, bw)) return -EFAULT; 
    buf+=bw; se_tbc+=bw; bl-=bw;
  } while (bl>0);  
  se_blkc++;
  if (dbg&1) { printk("pciram_write: count = %d\n", count); }
  return count;
}
Table 4. pci topology
=====================
-[00]-+-00.0  8086:7190
      +-01.0-[01]----00.0  1002:4742
      +-07.0  8086:7110
      +-07.1  8086:7111
      +-07.2  8086:7112
      +-07.3  8086:7113
      +-0d.0  1131:190a
      +-0f.0-[02]----0b.0  9004:8178
      \-11.0  10b7:9055             
Table 5. /proc/pci
==================
PCI devices found:
  Bus  0, device   0, function  0:
    Host bridge: Intel 440BX - 82443BX Host (rev 2).
      Medium devsel.  Master Capable.  Latency=64.  
      Prefetchable 32 bit memory at 0xf0000000 [0xf0000008].
  Bus  0, device   1, function  0:
    PCI bridge: Intel 440BX - 82443BX AGP (rev 2).
      Medium devsel.  Master Capable.  Latency=64.  Min Gnt=136.
  Bus  0, device   7, function  0:
    ISA bridge: Intel 82371AB PIIX4 ISA (rev 2).
      Medium devsel.  Fast back-to-back capable.  Master Capable.  No bursts.  
  Bus  0, device   7, function  1:
    IDE interface: Intel 82371AB PIIX4 IDE (rev 1).
      Medium devsel.  Fast back-to-back capable.  Master Capable.  Latency=32.  
      I/O at 0xffa0 [0xffa1].
  Bus  0, device   7, function  2:
    USB Controller: Intel 82371AB PIIX4 USB (rev 1).
      Medium devsel.  Fast back-to-back capable.  IRQ 11.  Master Capable.  Latency=64.  
      I/O at 0xcce0 [0xcce1].
  Bus  0, device   7, function  3:
    Bridge: Intel 82371AB PIIX4 ACPI (rev 2).
      Medium devsel.  Fast back-to-back capable.  
  Bus  0, device  13, function  0:
    Multimedia controller: Philips Unknown device (rev 3).
      Vendor id=1131. Device id=190a.
      Medium devsel.  Fast back-to-back capable.  
      Prefetchable 32 bit memory at 0xf7000000 [0xf7000008].
      I/O at 0xccd0 [0xccd1].
  Bus  0, device  15, function  0:
    PCI bridge: DEC DC21152 (rev 3).
      Medium devsel.  Fast back-to-back capable.  Master Capable.  Latency=64.  Min Gnt=2.
  Bus  0, device  17, function  0:
    Ethernet controller: 3Com 3C905B 100bTX (rev 36).
      Medium devsel.  IRQ 11.  Master Capable.  Latency=64.  Min Gnt=10.Max Lat=10.
      I/O at 0xcc00 [0xcc01].
      Non-prefetchable 32 bit memory at 0xff000000 [0xff000000].
  Bus  1, device   0, function  0:
    VGA compatible controller: ATI Mach64 GB (rev 92).
      Medium devsel.  Fast back-to-back capable.  IRQ 11.  Master Capable.  Latency=64.  Min Gnt=8.
      Non-prefetchable 32 bit memory at 0xfd000000 [0xfd000000].
      I/O at 0xec00 [0xec01].
      Non-prefetchable 32 bit memory at 0xfcfff000 [0xfcfff000].
  Bus  2, device  11, function  0:
    SCSI storage controller: Adaptec AIC-7881U (rev 0).
      Medium devsel.  Fast back-to-back capable.  IRQ 10.  Master Capable.  Latency=64.  Min Gnt=8.Max Lat=8.
      I/O at 0xdc00 [0xdc01].
      Non-prefetchable 32 bit memory at 0xfafff000 [0xfafff000].
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/