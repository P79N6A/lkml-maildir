Date: Tue, 14 Aug 2001 17:03:06 +0200
From: Kurt Garloff <>
Subject: Re: [PATCH] make psaux reconnect adjustable
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2001/8/14/89

On Tue, Aug 14, 2001 at 11:57:01AM +0200, Kurt Garloff wrote:
> Linus, Alan, I'd like to have your input:
> 
> Do you like the patch as is? 
Well, probably not, as it contains a typo which lets machines without kbd
hang. Fixed version attached. Sorry!
Regards,
-- 
Kurt Garloff  <garloff@suse.de>                          Eindhoven, NL
GPG key: See mail header, key servers         Linux kernel development
SuSE GmbH, Nuernberg, DE                                SCSI, Security
diff -uNr linux-2.4.7.kurt-1/drivers/char/pc_keyb.c linux-2.4.7.kurt-1-psaux/drivers/char/pc_keyb.c
--- linux-2.4.7.kurt-1/drivers/char/pc_keyb.c	Tue Jul 24 18:42:36 2001
+++ linux-2.4.7.kurt-1-psaux/drivers/char/pc_keyb.c	Tue Aug 14 16:56:58 2001
@@ -81,8 +81,9 @@
 
 static int __init psaux_init(void);
 
-#define AUX_RECONNECT 170 /* scancode when ps2 device is plugged (back) in */
- 
+#define AUX_RECONNECT1 170 /* scancode when ps2 device is plugged (back) in */
+#define AUX_RECONNECT2 0   /* scancode when ps2 device is plugged (back) in */
+
 static struct aux_queue *queue;	/* Mouse data buffer. */
 static int aux_count;
 /* used when we send commands to the mouse that expect an ACK. */
@@ -92,8 +93,83 @@
 #define AUX_INTS_ON  (KBD_MODE_KCC | KBD_MODE_SYS | KBD_MODE_MOUSE_INT | KBD_MODE_KBD_INT)
 
 #define MAX_RETRIES	60		/* some aux operations take long time*/
+
 #endif /* CONFIG_PSMOUSE */
 
+/* We want to be able to handle the psmouse reconnect token; unfortunately the
+ * Synaptics touchpads (and probably others too) use it for their extented
+ * functionality and produce them in extended mode (as set by gpm -t synps2).
+ * So we make this adjustable via a sysctl.  garloff@suse.de, 2001-08-01 */
+
+#ifdef CONFIG_SYSCTL
+#include <linux/sysctl.h>
+#ifdef CONFIG_PSMOUSE
+int sysctl_psmouse_reconnect = 1;
+#endif
+int sysctl_kbd_report_unkn = 1;
+int sysctl_kbd_report_to = 1;
+
+static int psaux_sysctl_handler (ctl_table *ctl, int write, struct file *filp,
+				 void *buffer, size_t *lenp)
+{
+	int *valp = ctl->data;
+	int ret = proc_dointvec(ctl, write, filp, buffer, lenp); 
+	if (write) {
+		if (*valp > 2)
+			*valp = 2;
+	}
+	return ret;
+}
+			
+
+ctl_table psaux_table[] = {
+#ifdef CONFIG_PSMOUSE   
+        {DEV_PSMOUSE_RECONNECT, "psmouse_reconnect", &sysctl_psmouse_reconnect,
+                sizeof(int), 0644, NULL, &psaux_sysctl_handler},
+#endif   
+	{DEV_KBD_REPORT_UNKN, "kbd_report_unknown", &sysctl_kbd_report_unkn,
+                sizeof(int), 0644, NULL, &psaux_sysctl_handler},
+        {DEV_KBD_REPORT_TO, "kbd_report_timeout", &sysctl_kbd_report_to,
+                sizeof(int), 0644, NULL, &psaux_sysctl_handler},
+	{0}
+};
+
+ctl_table psaux_psaux_table[] = {
+        {DEV_CDROM, "ps2", NULL, 0, 0555, psaux_table},
+        {0}
+        };
+
+ctl_table psaux_root_table[] = {
+#ifdef CONFIG_PROC_FS
+        {CTL_DEV, "dev", NULL, 0, 0555, psaux_psaux_table},
+#endif /* CONFIG_PROC_FS */
+        {0}
+        };
+static struct ctl_table_header *psaux_sysctl_header;
+
+static void psaux_sysctl_register (void)
+{
+	static int initialized;
+	if (initialized) return;
+	
+	psaux_sysctl_header = register_sysctl_table (psaux_root_table, 1);
+	/*psaux_root_table->child->de->owner = THIS_MODULE;*/
+	initialized++;
+}
+
+/*
+static void psaux_sysctl_unregister (void)
+{
+	if (psaux_sysctl_header)
+		unregister_sysctl_table (psaux_sysctl_header);
+}
+ */
+#else /* CONFIG_SYSCTL */
+#define sysctl_psmouse_reconnect 1
+#define sysctl_kbd_report_unkn 1
+#define sysctl_kbd_report_to 1
+#endif /* CONFIG_SYSCTL */
+
 /*
  * Wait for keyboard controller input buffer to drain.
  *
@@ -123,9 +199,8 @@
 		mdelay(1);
 		timeout--;
 	} while (timeout);
-#ifdef KBD_REPORT_TIMEOUTS
-	printk(KERN_WARNING "Keyboard timed out[1]\n");
-#endif
+	if (sysctl_kbd_report_to)
+		printk(KERN_WARNING "Keyboard timed out[1]\n");
 }
 
 /*
@@ -324,10 +399,8 @@
 		  *keycode = E1_PAUSE;
 		  prev_scancode = 0;
 	      } else {
-#ifdef KBD_REPORT_UNKN
-		  if (!raw_mode)
+		  if (!raw_mode && sysctl_kbd_report_unkn)
 		    printk(KERN_INFO "keyboard: unknown e1 escape sequence\n");
-#endif
 		  prev_scancode = 0;
 		  return 0;
 	      }
@@ -352,11 +425,9 @@
 	      if (e0_keys[scancode])
 		*keycode = e0_keys[scancode];
 	      else {
-#ifdef KBD_REPORT_UNKN
-		  if (!raw_mode)
+		  if (!raw_mode && sysctl_kbd_report_unkn)
 		    printk(KERN_INFO "keyboard: unknown scancode e0 %02x\n",
 			   scancode);
-#endif
 		  return 0;
 	      }
 	  }
@@ -374,11 +445,9 @@
 	  *keycode = high_keys[scancode - SC_LIM];
 
 	  if (!*keycode) {
-	      if (!raw_mode) {
-#ifdef KBD_REPORT_UNKN
+	      if (!raw_mode && sysctl_kbd_report_unkn) {
 		  printk(KERN_INFO "keyboard: unrecognized scancode (%02x)"
 			 " - ignored\n", scancode);
-#endif
 	      }
 	      return 0;
 	  }
@@ -397,6 +466,7 @@
 	    return 0200;
 }
 
+static unsigned char psaux_prev;
 static inline void handle_mouse_event(unsigned char scancode)
 {
 #ifdef CONFIG_PSMOUSE
@@ -407,13 +477,24 @@
 		}
 		mouse_reply_expected = 0;
 	}
-	else if(scancode == AUX_RECONNECT){
+	else if(scancode == AUX_RECONNECT1 
+		&& sysctl_psmouse_reconnect == 2) {
+		printk (KERN_DEBUG "PS2 mouse reconnect detected.\n");
+		queue->head = queue->tail = 0;  /* Flush input queue */
+		__aux_write_ack(AUX_ENABLE_DEV);  /* ping the mouse :) */
+		return;
+	}
+	else if (scancode == AUX_RECONNECT2 && psaux_prev == AUX_RECONNECT1
+		 && sysctl_psmouse_reconnect == 1 ) {
+		printk (KERN_DEBUG "PS2 mouse reconnect detected.\n");
 		queue->head = queue->tail = 0;  /* Flush input queue */
 		__aux_write_ack(AUX_ENABLE_DEV);  /* ping the mouse :) */
 		return;
 	}
 
 	add_mouse_randomness(scancode);
+	psaux_prev = scancode;
+
 	if (aux_count) {
 		int head = queue->head;
 
@@ -516,16 +597,14 @@
 				break;
 			mdelay(1);
 			if (!--timeout) {
-#ifdef KBD_REPORT_TIMEOUTS
-				printk(KERN_WARNING "keyboard: Timeout - AT keyboard not present?\n");
-#endif
+				if (sysctl_kbd_report_to)
+					printk(KERN_WARNING "keyboard: Timeout - AT keyboard not present?\n");
 				return 0;
 			}
 		}
 	} while (retries-- > 0);
-#ifdef KBD_REPORT_TIMEOUTS
-	printk(KERN_WARNING "keyboard: Too many NACKs -- noisy kbd cable?\n");
-#endif
+	if (sysctl_kbd_report_to)
+		printk(KERN_WARNING "keyboard: Too many NACKs -- noisy kbd cable?\n");
 	return 0;
 }
 
@@ -755,6 +834,7 @@
 
 	/* Ok, finally allocate the IRQ, and off we go.. */
 	kbd_request_irq(keyboard_interrupt);
+	psaux_sysctl_register ();
 }
 
 #if defined CONFIG_PSMOUSE
diff -uNr linux-2.4.7.kurt-1/include/linux/sysctl.h linux-2.4.7.kurt-1-psaux/include/linux/sysctl.h
--- linux-2.4.7.kurt-1/include/linux/sysctl.h	Tue Jul 24 18:48:05 2001
+++ linux-2.4.7.kurt-1-psaux/include/linux/sysctl.h	Tue Aug 14 10:37:54 2001
@@ -594,7 +594,8 @@
 	DEV_HWMON=2,
 	DEV_PARPORT=3,
 	DEV_RAID=4,
-	DEV_MAC_HID=5
+	DEV_MAC_HID=5,
+	DEV_PSAUX=6,
 };
 
 /* /proc/sys/dev/cdrom */
@@ -653,6 +654,13 @@
 	DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE=4,
 	DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE=5,
 	DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES=6
+};
+
+/* /proc/sys/dev/psaux */
+enum {
+	DEV_PSMOUSE_RECONNECT=1,
+	DEV_KBD_REPORT_UNKN=2,
+	DEV_KBD_REPORT_TO=3,
 };
 
 #ifdef __KERNEL__[unhandled content-type:application/pgp-signature]