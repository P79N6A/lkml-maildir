Date: Sun,  5 Dec 1999 05:54:33 +0200 (EET)
From: Andrei Pitis <>
Subject: Toshiba keyboard repeat delay problem, better...
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/12/4/82

Well, when, while using my patch, pressed Shift-PgUp and got 3-4 pages 
up - I realized two things:
1. It's better to take care of arrow key, pgup, pgdown, home, end,
   ... all with the 0xE0 prefix (ignoring the Break key which uses
   that 0xE1 prefix and doesn't repeat, IIRC).
2. In order to do 1, being impossible to do a universally valid
   implementation of software controlled repeat in a few hrs - it's
   better to patch pc_keyb.c than keyboard.c...
Ok, now the current patch, that I will continue to test and tell you if
smth is broken (please ignore that I'm using 2.2.12 :-)):
------------------
*** /usr/src/linux-2.2.12/drivers/char/pc_keyb.c	Mon Aug  9 22:04:39 1999
--- /usr/src/linux-2.2.12-patched/drivers/char/pc_keyb.c	Sun Dec  5 04:38:33 1999
***************
*** 411,416 ****
--- 411,468 ----
  }
  
  /*
+  * Made initially for Toshiba Satellite 2595XDVD.  Under some
+  * circumstances, its keyboards behaves like ignoring the
+  * kbd repeat _delay_.  This happens in conjunction with shift
+  * keys (ctrl, alt, shift) and leads to undesirable repeat
+  * of a key even if pressed briefly.  Fixed it by ignoring any
+  * subsequent occurence of the second identical scancode for
+  * 250 ms.  Takes into account keys with 0xE0, doesn't care about
+  * the Break key.  IMO, this doesn't break anything on a good keyboard,
+  * only enforces the kbd delay to be 250ms.
+  * Andrei Pitis <pink@roedu.net> Dec 1999
+  */
+ static void handle_delay(unsigned char scancode)
+ {
+     static int E0_detected = 0;
+     static int prev_scancode = 0;
+     static int stop_jiffies = 0;
+ 
+     /* Silently ignore the E0 prefix, will take care
+        of it in the next call.  */
+     if (scancode == 0xE0)
+     {
+ 	E0_detected = 1;
+ 	return;
+     }
+ 	
+     /* New scancode, trigger delay and update prev_scancode.  */
+     if (scancode != prev_scancode)
+     {
+ 	prev_scancode = scancode;
+ 	stop_jiffies = jiffies;
+     }
+     /* Same scancode, reject if within delay, reset E0 detection.  */
+     else if (jiffies - stop_jiffies < 25)
+     {
+ 	E0_detected = 0;
+ 	return;
+     }
+     
+     /* Handle the scancode if different from the previous one, or
+        if the same, but after the delay passed.  Don't forget
+        the E0 prefix, if it was detected.  */
+     if (E0_detected)
+     {
+ 	handle_scancode(0xE0, 0);
+         E0_detected = 0;
+     }
+     
+     handle_scancode(scancode, !(scancode & 0x80));
+ }
+ 
+ 
+ /*
   * This reads the keyboard status port, and does the
   * appropriate action.
   *
***************
*** 430,436 ****
  			handle_mouse_event(scancode);
  		} else {
  			if (do_acknowledge(scancode))
! 				handle_scancode(scancode, !(scancode & 0x80));
  			mark_bh(KEYBOARD_BH);
  		}
  
--- 482,489 ----
  			handle_mouse_event(scancode);
  		} else {
  			if (do_acknowledge(scancode))
! 			        handle_delay(scancode);
! 
  			mark_bh(KEYBOARD_BH);
  		}
  
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/