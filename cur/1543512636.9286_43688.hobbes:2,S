Date: Tue, 12 Oct 1999 01:18:39 -0400 (EDT)
From: Chris Noe <>
Subject: 2.3.21, more bootcode fixes; should be the last patch (bootsect.S, setup.S, video.S)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/10/12/20

Almost asleep when I realized that setup.S and video.S hold the same
treasure trove of 16-bit bases. So much for 'has been well tested' - guess
all the testers had the same version of binutils. Bugger.
Now why couldn't the 'index/base must be 32 bit' error just be a warning
instead of something that bombs a compile.
This is an accumulated patch that has all the previous fixes included and
should fix *all* of the various buglets in 2.3.21's bootcode caused by the
incompatibility of certain binutils versions.
Chris Noe
(stiker@northlink.com)
--- bootsect.S.orig	Mon Oct 11 19:07:40 1999
+++ bootsect.S	Tue Oct 12 00:41:48 1999
@@ -104,7 +104,7 @@
 	movw	%cx, %fs		# set fs to 0
 	movw	$0x78, %bx		# fs:bx is parameter table address
 	pushw	%ds
-	ldsw	%fs:(%bx), %si		# ds:si is source
+	ldsw	%fs:(%ebx), %si		# ds:si is source
 	movb	$3, %cl			# copy 12 bytes
 	cld
 	pushw	%di			# di = 0x4000-12.
@@ -112,9 +112,9 @@
 	movsl
 	popw	%di
 	popw	%ds
-	movb	$36, 0x4(%di)		# patch sector count
-	movw	%di, %fs:(%bx)
-	movw	%es, %fs:2(%bx)
+	movb	$36, 0x4(%edi)		# patch sector count
+	movw	%di, %fs:(%ebx)
+	movw	%es, %fs:2(%ebx)
 
 # Load the setup-sectors directly after the bootblock.
 # Note that 'es' is already set up.
@@ -184,7 +184,7 @@
 	movb	$0x03, %ah		# read cursor pos
 	xorb	%bh, %bh
 	int	$0x10
-	movw	$9, %cx
+	movw	$5, %cx			# size of string
 	movw	$0x0007, %bx		# page 0, attribute 7 (normal)
 	movw    $msg1, %bp
 	movw    $0x1301, %ax		# write string, move cursor
@@ -247,7 +247,7 @@
 	xorw	%bx, %bx		# bx is starting address within segment
 rp_read:
 #ifdef __BIG_KERNEL__
-	lcall	bootsect_kludge		# in setup.S
+	.word 0x1eff, 0x0220		# lcall *bootsect_kludge in setup.S
 #else
 	movw	%es, %ax
 	subw	$SYSSEG, %ax
@@ -380,7 +380,7 @@
 
 print_hex:
 	movw	$4, %cx				# 4 hex digits
-	movw	(%bp), %dx			# load word into dx
+	movw	(%ebp), %dx			# load word into dx
 print_digit:
 	rolw	$4, %dx				# rotate to use low 4 bits
 	movw	$0xe0f, %ax			# ah = request
@@ -397,18 +397,17 @@
 # that we enter the kernel in a known state, and
 # don't have to worry about it later.
 
+# Nothing depends on %dx being saved
+#  saves us some bytes by not saving it on the stack
 kill_motor:
-	pushw	%dx
 	movw	$0x3f2, %dx
 	xorb	%al, %al
-	outw	%al, %dx
-	popw	%dx
+	outb	%al, %dx
 	ret
 
 sectors:	.word 0
 disksizes:	.byte 36, 18, 15, 9
-msg1:		.byte 13, 10
-		.ascii "Loading"
+msg1:		.ascii "Linux"
 
 # XXX: This is a *very* snug fit.
 
--- setup.S.orig	Tue Oct 12 00:23:45 1999
+++ setup.S	Tue Oct 12 00:42:51 1999
@@ -292,7 +292,7 @@
 	cmpl	$0x534d4150, %eax		# check the return is `SMAP'
 	jne	bail820				# fall to e801 if it fails
 
-#	cmpl	$1, 16(%di)			# is this usable memory?
+#	cmpl	$1, 16(%edi)			# is this usable memory?
 #	jne	again820
 
 	# If this is usable memory, we save it by simply advancing %di by
@@ -414,7 +414,7 @@
 	movw	%ax, %es
 	movw	%bx, %si
 	movw	$0xa0, %di
-	movw	(%si), %cx
+	movw	(%esi), %cx
 	addw	$2, %cx				# table length is a short
 	cmpw	$0x10, %cx
 	jc	sysdesc_ok
--- video.S.orig	Tue Oct 12 00:26:37 1999
+++ video.S	Tue Oct 12 01:02:15 1999
@@ -105,6 +105,7 @@
 #define DO_STORE
 #endif /* CONFIG_VIDEO_RETAIN */
 
+.code16
 # This is the main entry point called by setup.S
 # %ds *must* be pointing to the bootsector
 video:	pushw	%ds		# We use different segments
@@ -203,23 +204,23 @@
 mopar_gr:
 	leaw	modelist+1024, %di
 	movb	$0x23, %fs:(PARAM_HAVE_VGA)
-	movw	16(%di), %ax
+	movw	16(%edi), %ax
 	movw	%ax, %fs:(PARAM_LFB_LINELENGTH)
-	movw	18(%di), %ax
+	movw	18(%edi), %ax
 	movw	%ax, %fs:(PARAM_LFB_WIDTH)
-	movw	20(%di), %ax
+	movw	20(%edi), %ax
 	movw	%ax, %fs:(PARAM_LFB_HEIGHT)
-	movb	25(%di), %al
+	movb	25(%edi), %al
 	movb	$0, %ah
 	movw	%ax, %fs:(PARAM_LFB_DEPTH)
-	movb	29(%di), %al	
+	movb	29(%edi), %al	
 	movb	$0, %ah
 	movw	%ax, %fs:(PARAM_LFB_PAGES)
-	movl	40(%di), %eax
+	movl	40(%edi), %eax
 	movl	%eax, %fs:(PARAM_LFB_BASE)
-	movl	31(%di), %eax
+	movl	31(%edi), %eax
 	movl	%eax, %fs:(PARAM_LFB_COLORS)
-	movl	35(%di), %eax
+	movl	35(%edi), %eax
 	movl	%eax, %fs:(PARAM_LFB_COLORS+4)
 
 # get video mem size
@@ -227,7 +228,7 @@
 	movw	$0x4f00, %ax
 	int	$0x10
 	xorl	%eax, %eax
-	movw	18(%di), %ax
+	movw	18(%edi), %ax
 	movl	%eax, %fs:(PARAM_LFB_SIZE)
 # get protected mode interface informations
 	movw	$0x4f0a, %ax
@@ -285,7 +286,7 @@
 	call	prtstr
 	movb	$0x30, %dl			# DL holds mode number
 	leaw	modelist, %si
-lm1:	cmpw	$ASK_VGA, (%si)			# End?
+lm1:	cmpw	$ASK_VGA, (%esi)		# End?
 	jz	lm2
 
 	movb	%dl, %al			# Menu selection number
@@ -294,7 +295,7 @@
 	lodsw
 	call	prthw				# Mode ID
 	call	prtsp2
-	movb	0x1(%si), %al
+	movb	0x1(%esi), %al
 	call	prtdec				# Rows
 	movb	$0x78, %al			# the letter 'x'
 	call	prtchr
@@ -342,20 +343,20 @@
 	call	prtchr
 	jmp	lm3
 	
-lment:	movb	$0, (%di)
+lment:	movb	$0, (%edi)
 	leaw	crlft, %si
 	call	prtstr
 	leaw	edit_buf, %si
-	cmpb	$0, (%si)			# Empty string = default mode
+	cmpb	$0, (%esi)			# Empty string = default mode
 	jz	lmdef
 
-	cmpb	$0, 1(%si)			# One character = menu selection
+	cmpb	$0, 1(%esi)			# One character = menu selection
 	jz	mnusel
 
-	cmpw	$0x6373, (%si)			# "scan" => mode scanning
+	cmpw	$0x6373, (%esi)			# "scan" => mode scanning
 	jnz	lmhx
 
-	cmpw	$0x6e61, 2(%si)
+	cmpw	$0x6e61, 2(%esi)
 	jz	lmscan
 
 lmhx:	xorw	%bx, %bx			# Else => mode ID in hex
@@ -510,7 +511,7 @@
 	cmpw	%di, %si
 	jnc	setbad
 	
-	movw	(%si), %ax			# Fetch mode ID
+	movw	(%esi), %ax			# Fetch mode ID
 _m_s:	jmp	mode_set
 
 setres:	pushw	%bx				# Set mode chosen by resolution
@@ -525,7 +526,7 @@
 	cmpw	%bx, %ax
 	jnz	setr1
 	
-	movw	-4(%si), %ax			# Fetch mode ID
+	movw	-4(%esi), %ax			# Fetch mode ID
 	jmp	_m_s
 
 check_vesa:
@@ -538,12 +539,12 @@
 	cmpw	$0x004f, %ax
 	jnz	setbad
 
-	movb	(%di), %al			# Check capabilities.
+	movb	(%edi), %al			# Check capabilities.
 	andb	$0x19, %al
 	cmpb	$0x09, %al
 	jz	setvesa				# This is a text mode
 
-	movb	(%di), %al			# Check capabilities.
+	movb	(%edi), %al			# Check capabilities.
 	andb	$0x99, %al
 	cmpb	$0x99, %al
 	jnz	_setbad				# Doh! No linear frame buffer.
@@ -936,11 +937,11 @@
 	jz	cmt2
 
 	leaw	modelist, %bx			# Find in previous entries
-	movw	2(%si), %cx
+	movw	2(%esi), %cx
 cmt3:	cmpw	%bx, %si
 	jz	cmt4
 
-	cmpw	2(%bx), %cx			# Found => don't copy this entry
+	cmpw	2(%ebx), %cx			# Found => don't copy this entry
 	jz	cmt5
 
 	addw	$4, %bx
@@ -955,7 +956,7 @@
 cmt2:
 #endif	/* CONFIG_VIDEO_COMPACT */
 
-	movw	$ASK_VGA, (%di)			# End marker
+	movw	$ASK_VGA, (%edi)		# End marker
 	movw	%di, mt_end
 mtab1:	leaw	modelist, %si			# SI=mode list, DI=list end
 ret0:	ret
@@ -995,19 +996,20 @@
 	cmpw	$0x004f, %ax			# Successful?
 	jnz	ret0
 	
-	cmpw	$0x4556, 0x200(%di)
+	cmpw	$0x4556, 0x200(%edi)
 	jnz	ret0
 	
-	cmpw	$0x4153, 0x202(%di)
+	cmpw	$0x4153, 0x202(%edi)
 	jnz	ret0
 	
 	movw	$vesa_name, card_name		# Set name to "VESA VGA"
 	pushw	%gs
-	lgsw	0x20e(%di), %si			# GS:SI=mode list
+	lgsw	0x20e(%edi), %si		# GS:SI=mode list
 	movw	$128, %cx			# Iteration limit
+	xorw	%dx, %dx			# works around 127 byte jmp limit
 vesa1:
 # gas version 2.9.1, using BFD version 2.9.1.0.23 buggers the next inst.
-# XXX:	lodsw	%gs:(%si), %ax			# Get next mode in the list
+# XXX:	lodsw	%gs:(%esi), %ax			# Get next mode in the list
 	.byte 0x66, 0x65, 0xAD
 	cmpw	$0xffff, %ax			# End of the table?
 	jz	vesar
@@ -1031,29 +1033,29 @@
 	cmpw	$0x004f, %ax
 	jnz	vesan			# Don't report errors (buggy BIOSES)
 
-	movb	(%di), %al			# Check capabilities. We require
+	movb	(%edi), %al			# Check capabilities. We require
 	andb	$0x19, %al			# a color text mode.
 	cmpb	$0x09, %al
 	jnz	vesan
 	
-	cmpw	$0xb800, 8(%di)		# Standard video memory address required
+	cmpw	$0xb800, 8(%edi)	# Standard video memory address required
 	jnz	vesan
 
-	testb	$2, (%di)			# Mode characteristics supplied?
-	movw	%bx, (%di)			# Store mode number
+	testb	$2, (%edi)			# Mode characteristics supplied?
+	movw	%bx, (%edi)			# Store mode number
 	jz	vesa3
 	
-	xorw	%dx, %dx
-	movw	0x12(%di), %bx			# Width
+						# %dx is zero from above
+	movw	0x12(%edi), %bx			# Width
 	orb	%bh, %bh
 	jnz	vesan
 	
-	movb	%bl, 0x3(%di)
-	movw	0x14(%di), %ax			# Height
+	movb	%bl, 0x3(%edi)
+	movw	0x14(%edi), %ax			# Height
 	orb	%ah, %ah
 	jnz	vesan
 	
-	movb	%al, 2(%di)
+	movb	%al, 2(%edi)
 	mulb	%bl
 	cmpw	$8193, %ax		# Small enough for Linux console driver?
 	jnc	vesan
@@ -1066,8 +1068,8 @@
 	cmpw	$5, %bx
 	jnc	vesan
 
-	movw	vesa_text_mode_table(%bx), %ax
-	movw	%ax, 2(%di)
+	movw	vesa_text_mode_table(%ebx), %ax
+	movw	%ax, 2(%edi)
 vesaok:	addw	$4, %di				# The mode is valid. Store it.
 vesan:	loop	vesa1			# Next mode. Limit exceeded => error
 vesae:	leaw	vesaer, %si
@@ -1564,11 +1566,11 @@
 	decw	%di
 l1:	incw	%si
 	incw	%di
-	movb	(%si), %al
+	movb	(%esi), %al
 	testb	%al, %al
 	jz	l2
 
-	cmpb	%es:(%di), %al
+	cmpb	%es:(%edi), %al
 l2:	loope 	l1
 	orw	%cx, %cx
 	je	isgen