Date: Sun, 09 Mar 2008 23:34:22 -0700
From: Junio C Hamano <>
Subject: Re: [ANNOUNCE] GIT 1.5.4.4
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/3/10/15

Jeff Garzik <jeff@garzik.org> writes:
> Yes, I regularly run both 'git gc' and 'git prune'.
>
> But since (ref original email) I was doing some rebasing, there are
> inevitably changesets left dangling after such an operation.
Yeah, I'd say it is stupid if "am" ran "gc --auto" for every patch.  I
recall that we had the same issue with git-svn and we made it run once
every 1k round, and we probably should do the same for "am" and "rebase",
running once at the very end.
I notice however that git-am does exactly that.  It runs "gc --auto" only
at the end, and does not run it when it stops upon unapplicable patch.
Perhaps we would want to raise the default "gc --auto" limit?  Currently
when it estimates that you have roughly 6700 objects unpacked it runs
"repack --prune-packed", and if there still are that many unpacked objects
after that, it suggests you to run "git prune" to remove them.  If you are
rebasing, the commits in the old history that are rewritten will _not_
immediately become dangling because they will still be reachable from your
reflog.  If you are getting the message, these objects were already
dangling (ancient commits that are not even reachable from your reflog
entries that are by default kept for 90 days) even before you started your
rebase or am run.
After you finished your day's work on a typical day, what does the output
from "git count-objects -v" and "git fsck-objects" look like, I wonder?