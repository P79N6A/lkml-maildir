Date: Wed, 24 Nov 1999 23:43:35 +0100
From: Manfred Spraul <>
Subject: Re: spin_unlock optimization(i386)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/11/24/119

Erich Boleyn wrote:
> 
> I presume this is single-processor situation, or just referring to
> interrupts on the same processor.  This is clearly not a thread/multi-
> processor safe code sequence.
> 
This should be multiprocessor safe 8), I copied these lines from the
current kernel.
CPU1:
add_wait_queue(&WAKE_LIST)
		 /* smp safe function, adds us to WAKE_LIST */
xchg(TASK_UNINTERRUITPBLE, &current->state);
		/* use xchg to force memory ordering */
if(inode->i_state & I_LOCK) {
	schedule();
		/* this function only returns if current->state
		   is TASK_RUNNING */
}
printk(KERN_DEBUG "no lock-up!\n");
CPU2:
inode->i_state &= ~I_LOCK; 
	/* we are the only thread that has write access to 
	   this variable, no "lock;" required */
wake_up(&WAKE_LIST); 
	/* smp safe function, sets current->state of all
	entries in WAKE_LIST back to TASK_RUNNING */
I think that Andrea want's to know if he could replace the xchg with a
normal "mov" instruction.
"smp safe function" means that they begin with a spin_lock(), ie
"lock;bts"
Btw, thank you for your clarification of the spin_unlock question,
	Manfred Spraul
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/