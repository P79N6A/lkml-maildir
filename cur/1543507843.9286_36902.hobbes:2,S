Date: Wed, 1 Sep 1999 18:53:43 -0400 (EDT)
From: "Steven N. Hirsch" <>
Subject: Oops trace for lockd (at last)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/9/1/168

Trond,
Ok, here's what happens when attempting to lock a file on the server. This
is under kernel 2.2.13pre1 with your latest 2.2.12 nfs3 patch and the
following patches from hjl:
linux-2.2.7-sunrpc.patch
nfsd-2.2.7-3.patch
nfsd-2.2.7-nfsfh.patch
I've attached the test program and starter shell I use to reproduce this.
It is 100% repeatable here, BTW.
Steve
ksymoops 0.7c on i686 2.2.13pre1nfs3.  Options used
     -V (default)
     -k /proc/ksyms (default)
     -l /proc/modules (default)
     -o /lib/modules/2.2.13pre1nfs3/ (default)
     -m /usr/src/linux/System.map (default)
Warning: You did not tell me where to find symbol information.  I will
assume that the log matches the kernel and modules that are running
right now and I'll use the default options above for symbol resolution.
If the current kernel and/or modules do not match the log, you can get
more accurate output by telling me the kernel version and where to find
map, modules, ksyms etc.  ksymoops -h explains the options.
Using defaults from ksymoops -t elf32-i386 -a i386
Sep  1 18:43:40 pii kernel: Unable to handle kernel NULL pointer dereference at virtual address 0000000c 
Sep  1 18:43:40 pii kernel: current->tss.cr3 = 00101000, %cr3 = 00101000 
Sep  1 18:43:40 pii kernel: *pde = 00000000 
Sep  1 18:43:40 pii kernel: Oops: 0002 
Sep  1 18:43:40 pii kernel: CPU:    1 
Sep  1 18:43:40 pii kernel: EIP:    0010:[rpcauth_holdcred+56/84] 
Sep  1 18:43:40 pii kernel: EIP:    0010:[<c0183aac>] 
Sep  1 18:43:40 pii kernel: EFLAGS: 00010202 
Sep  1 18:43:40 pii kernel: eax: 00000004   ebx: cf313160   ecx: 400eeb30   edx: 00000004 
Sep  1 18:43:40 pii kernel: esi: fffffff4   edi: c015784c   ebp: 00000002   esp: cf3f5de8 
Sep  1 18:43:40 pii kernel: ds: 0018   es: 0018   ss: 0018 
Sep  1 18:43:40 pii kernel: Process lockd (pid: 1545, process nr: 35, stackpage=cf3f5000) 
Sep  1 18:43:40 pii kernel: Stack: cf313160 cf8c53e0 cf260000 00000004 0000000f cf3f5e00 fffffeff ffffffff  
Sep  1 18:43:40 pii kernel:        400f00f4 400f0148 400f01c8 400f024c 400f02cc 400f033c 00000000 40103e08  
Sep  1 18:43:40 pii kernel:        00000000 00000000 00000000 00000000 00000000 00000000 ffffffff 400f04e0  
Sep  1 18:43:40 pii kernel: Call Trace: [nlmclnt_async_call+149/172] [nlmsvc_callback_exit+0/84] [nlmsvc_callback+112/136] [nlmsvc_callback_exit+0/84] [nlmsvc_proc_granted_msg+0/92] [nlmsvc_proc_granted_msg+79/92] [wake_up_process+82/104]  
Sep  1 18:43:40 pii kernel: Call Trace: [<c0154e81>] [<c015784c>] [<c0157834>] [<c015784c>] [<c0157444>] [<c0157493>] [<c01130ae>]  
Sep  1 18:43:40 pii kernel:        [<c0116084>] [<c01583b3>] [<c015840a>] [<c018480d>] [<c0155dda>] [<c01089e7>]  
Sep  1 18:43:40 pii kernel: Code: 66 ff 40 08 8b 43 14 8b 4b 1c 8b 50 18 a1 40 68 21 c0 03 42  
>>EIP; c0183aac <rpcauth_holdcred+38/54>   <=====
Trace; c0154e81 <nlmclnt_async_call+95/ac>
Trace; c015784c <nlmsvc_callback_exit+0/54>
Trace; c0157834 <nlmsvc_callback+70/88>
Trace; c015784c <nlmsvc_callback_exit+0/54>
Trace; c0157444 <nlmsvc_proc_granted_msg+0/5c>
Trace; c0157493 <nlmsvc_proc_granted_msg+4f/5c>
Trace; c01130ae <wake_up_process+52/68>
Trace; c0116084 <do_fork+7ac/8c8>
Trace; c01583b3 <nlmsvc_decode_testargs+ab/1a8>
Trace; c015840a <nlmsvc_decode_testargs+102/1a8>
Trace; c018480d <svc_process+231/554>
Trace; c0155dda <lockd+21a/294>
Trace; c01089e7 <kernel_thread+23/30>
Code;  c0183aac <rpcauth_holdcred+38/54>
00000000 <_EIP>:
Code;  c0183aac <rpcauth_holdcred+38/54>   <=====
   0:   66 ff 40 08               incw   0x8(%eax)   <=====
Code;  c0183ab0 <rpcauth_holdcred+3c/54>
   4:   8b 43 14                  movl   0x14(%ebx),%eax
Code;  c0183ab3 <rpcauth_holdcred+3f/54>
   7:   8b 4b 1c                  movl   0x1c(%ebx),%ecx
Code;  c0183ab6 <rpcauth_holdcred+42/54>
   a:   8b 50 18                  movl   0x18(%eax),%edx
Code;  c0183ab9 <rpcauth_holdcred+45/54>
   d:   a1 40 68 21 c0            movl   0xc0216840,%eax
Code;  c0183abe <rpcauth_holdcred+4a/54>
  12:   03 42 00                  addl   0x0(%edx),%eax
8 warnings and 7 errors issued.  Results may not be reliable.
#!/bin/sh
> test.file
./locker &
sleep 1
echo ""
./locker
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <time.h>
/* From Stevens APUE book. */
int
lock_reg(int fd, int cmd, int type, off_t offset, int whence, off_t len)
{
	struct flock	lock;
	lock.l_type = type;		/* F_RDLCK, F_WRLCK, F_UNLCK */
	lock.l_start = offset;	/* byte offset, relative to l_whence */
	lock.l_whence = whence;	/* SEEK_SET, SEEK_CUR, SEEK_END */
	lock.l_len = len;		/* #bytes (0 means to EOF) */
	return( fcntl(fd, cmd, &lock) );
}
int
main( void )
{
  char buf[128];
  time_t t;
  int fd;
  pid_t me;
  int tries = 10;
  
  me = getpid();
  
  fd = open( "test.file", O_APPEND|O_RDWR, S_IRUSR|S_IWUSR );
  assert(fd != -1);
    
  while (tries) {
    if ( lock_reg(fd, F_SETLK, F_WRLCK, 0, SEEK_SET, 0 ) == -1 ) {
      printf("%d: Can't get write lock, I'll sleep on it..\n", me);
      if ( lock_reg(fd, F_SETLKW, F_WRLCK, 0, SEEK_SET, 0 == -1 ) ) {
	perror("locktest");
	exit(1);
      }
    }
    
    printf("%d: Have write lock, appending to file\n", me);
    
    sprintf(buf, "%d: ", me);
    time(&t);
    strcat(buf, ctime(&t));
    write(fd, buf, strlen(buf));
    
    sleep(5);
    
    printf("%d: Releasing lock..\n", me);
    
    if ( lock_reg(fd, F_SETLK, F_UNLCK, 0, SEEK_SET, 0 ) == -1 ) {
      perror("locktest");
      exit(1);
    }
    sleep(1);
    tries--;
  }
  
  close(fd);
  return 0;
  
}