Date: Fri, 26 Aug 2005 09:52:14 -0400
From: Steven Rostedt <>
Subject: Re: [RFC] RT-patch update to remove the global pi_lock
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/8/26/61

Ingo,
The following code segment from pick_new_owner:
	waiter = plist_first_entry(&lock->wait_list, struct rt_mutex_waiter, list);
 try_again:
	trace_special_pid(waiter->ti->task->pid, waiter->ti->task->prio, 0);
#ifdef ALL_TASKS_PI
	check_pi_list_present(lock, waiter, old_owner);
#endif
	new_owner = waiter->ti;
	/*
	 * The new owner is still blocked on this lock, so we
	 * must release the lock->wait_lock before grabing 
	 * the new_owner lock.
	 */
	__raw_spin_unlock(&lock->wait_lock);
	__raw_spin_lock(&new_owner->task->pi_lock);
	__raw_spin_lock(&lock->wait_lock);
	/*
	 * In this split second of releasing the lock, a high priority 
	 * process could have come along and blocked as well.
	 */
	waiter = plist_first_entry(&lock->wait_list, struct rt_mutex_waiter, list);
	if (unlikely(waiter->ti != new_owner)) {
		__raw_spin_unlock(&new_owner->task->pi_lock);
		goto try_again;
	}
Is basically a waste on UP. Should the following patch be applied
instead?
--- linux_realtime_ernie/kernel/rt.c.orig	2005-08-26 09:46:34.000000000 -0400
+++ linux_realtime_ernie/kernel/rt.c	2005-08-26 09:48:17.000000000 -0400
@@ -1046,7 +1046,9 @@ pick_new_owner(struct rt_mutex *lock, st
 	 */
 	waiter = plist_first_entry(&lock->wait_list, struct rt_mutex_waiter, list);
 
+#ifdef CONFIG_SMP
  try_again:
+#endif
 	trace_special_pid(waiter->ti->task->pid, waiter->ti->task->prio, 0);
 
 #ifdef ALL_TASKS_PI
@@ -1065,11 +1067,13 @@ pick_new_owner(struct rt_mutex *lock, st
 	 * In this split second of releasing the lock, a high priority 
 	 * process could have come along and blocked as well.
 	 */
+#ifdef CONFIG_SMP
 	waiter = plist_first_entry(&lock->wait_list, struct rt_mutex_waiter, list);
 	if (unlikely(waiter->ti != new_owner)) {
 		__raw_spin_unlock(&new_owner->task->pi_lock);
 		goto try_again;
 	}
+#endif
 	plist_del_init(&waiter->list, &lock->wait_list);
 
 	__raw_spin_lock(&old_owner->task->pi_lock);
-- Steve
PS.  I notice I have a large CC on this thread.  If anyone wants me to
take them off, just send me a private email, and I'll do that.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/