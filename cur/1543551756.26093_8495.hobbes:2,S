Date: Mon, 16 Oct 2000 17:34:02 -0500
From: Sudhindra Herle <>
Subject: RE: Is this a valid construct?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/10/16/131

You have a race condition.
> int flagvar = 0;
> struct semaphore blocking_sem;
> 
> void function_called_from_kernel_thread(void)
> {
>   chew_on_hardware();
^^^^^^^^^^^^^^^^^^^^^^^
As soon as you do/did this, the IRQ must've happened. So, before the next
statement is executed, the IRQ handler is called which clears flagvar.
>   flagvar = 1;
This is executed _after_ the IRQ handler completes. So, you stomp over
whatever
the IRQ handler did.
>   down(blocking_sem);
Since the IRQ handler did up(), this down() won't sleep.
Try setting flagvar = 1 _before_ you chew_on_hardware().
Make sure that what ever you do is SMP safe.
Store the tick count of when you do the IRQ handler and when you do
chew_on_hardware(). You'll see if I am right.
i.e., try:
before = system_ticks_NOW
flagvar = 1;
chew_on_hardware ();
after = system_ticks_NOW
printk (..., before, after, irq)
....
interrupt_handler ( ..)
{
irq = system_ticks_NOW
...
}
Cheers,
-Sudhi.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
Please read the FAQ at 
http://www.tux.org/lkml/