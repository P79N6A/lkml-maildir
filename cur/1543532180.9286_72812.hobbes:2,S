Date: 28 Mar 2000 16:27:42 -0800
From: Ulrich Drepper <>
Subject: Re: Slow pthread_create() under high load
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/3/28/189

yodaiken@fsmlabs.com writes:
> Signals generated by processes outside the thread group can be directed
> to the manager thread which can then use the same mechanism to send
> them a second time, this time to the appropriate target.
No.  I've told you their is the signal context, data to transport and
whatever.  This is not so easy.  All your explanation of how you can
make it work depends on sending only the signal itself, without
additional information.  This is not what is expected.
> I don't follow this problem. When SIGSTOP is sent to a process all threads
> are supposed to stop. 
>       manager_sigstop_handler: 
>              forall threads kill(thread_to_pid(thread),SIGSTOP);
When did you receive SIGSTOP at the user level?  This is a signal
processed in the kernel.
> It would still be active, but in the kernel instead of in user space.
> Thus, every program would pay a price for Pthreads, whether it used it 
> or not.
This completely depends on the implementation.  You certainly can hide
the use of the shared signal queue which is not needed if your are not
using clone().
-- 
---------------.      drepper at gnu.org  ,-.   1325 Chesapeake Terrace
Ulrich Drepper  \    ,-------------------'   \  Sunnyvale, CA 94089 USA
Red Hat          `--' drepper at redhat.com   `------------------------
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/