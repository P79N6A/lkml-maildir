Date: Fri, 1 Jun 2007 13:43:04 -0700 (PDT)
From: Christoph Lameter <>
Subject: Re: [RFC] [PATCH] cpuset operations causes Badness at mm/slab.c:777 warning
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/6/1/330

On Fri, 1 Jun 2007, Paul Jackson wrote:
> > There are no checks necessary. Your function worked fine so far for 
> > the case of zero objects with the pointer returned by kmalloc. If the 
> > code is correct then it will not dereference the pointer to the zero 
> > sized array. If not then we may find a bug and fix it.
> 
> I suspect you got lucky.  The check for a full pidarray[] in the routine
> pid_array_load() occurs -after- a pid is put in the array.  If a task
> showed up in this cpuset at the wrong time, we would fall over and die
> in the code:
Then you are deferencing an element in the pidarray that you did not 
allocate! This is a bug in cpuset code. So we would need to allocate at 
mininum one array element? Or would we need to allocate npids + 1 to be 
safe???
---
 kernel/cpuset.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
Index: linux-2.6/kernel/cpuset.c
===================================================================
--- linux-2.6.orig/kernel/cpuset.c	2007-06-01 13:41:24.000000000 -0700
+++ linux-2.6/kernel/cpuset.c	2007-06-01 13:42:08.000000000 -0700
@@ -1741,7 +1741,7 @@ static int cpuset_tasks_open(struct inod
 	 * show up until sometime later on.
 	 */
 	npids = atomic_read(&cs->count);
-	pidarray = kmalloc(npids * sizeof(pid_t), GFP_KERNEL);
+	pidarray = kmalloc(max(1, npids) * sizeof(pid_t), GFP_KERNEL);
 	if (!pidarray)
 		goto err1;
 
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/