Date: Sun, 11 Sep 2005 15:15:13 +0300
From: Denis Vlasenko <>
Subject: 2.6.13: "via-rhine + link loss + autoneg off" bug is still not fixed
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/9/11/54

Just a heads-up.
The recipe:
* have via-rhine NIC
* unplug network cable
* reboot box
* force HDX (I do in with ethtool -s if autoneg off duplex half)
* plug cable back
* kernel still thinks that carrier is off despite "ethtool if"
  saying that link is detected.
Why:
...
        if (intr_status & IntrLinkChange)
                rhine_check_media(dev, 0);
...
static void rhine_check_media(struct net_device *dev, unsigned int init_media)
{
        struct rhine_private *rp = netdev_priv(dev);
        void __iomem *ioaddr = rp->base;
        mii_check_media(&rp->mii_if, debug, init_media);
...
unsigned int mii_check_media (struct mii_if_info *mii,
                              unsigned int ok_to_print,
                              unsigned int init_media)
{
        unsigned int old_carrier, new_carrier;
        int advertise, lpa, media, duplex;
        int lpa2 = 0;
        /* if forced media, go no further */
        if (mii->force_media)   <============================ HERE
                return 0; /* duplex did not change */
        /* check current and old link status */
        old_carrier = netif_carrier_ok(mii->dev) ? 1 : 0;
        new_carrier = (unsigned int) mii_link_ok(mii);
        /* if carrier state did not change, this is a "bounce",
         * just exit as everything is already set correctly
         */
        if ((!init_media) && (old_carrier == new_carrier))
                return 0; /* duplex did not change */
        /* no carrier, nothing much to do */
        if (!new_carrier) {
                netif_carrier_off(mii->dev);
                if (ok_to_print)
                        printk(KERN_INFO "%s: link down\n", mii->dev->name);
                return 0; /* duplex did not change */
        }
        /*
         * we have carrier, see who's on the other end
         */
        netif_carrier_on(mii->dev);
...
We can never reach netif_carrier_on if mii->force_media == TRUE!
If I disable that "if(...) return 0;" it works.
Instrumented log:
17:54:20.07751 kern.info: qdisc_restart: start, q->dequeue=c03e86c6 <== noop_dequeue
17:54:21.07736 kern.info: qdisc_restart: start, q->dequeue=c03e86c6
17:54:23.14445 kern.info: rhine_check_media(init_media:0)
17:54:23.14454 kern.info: mii_check_media
17:54:23.14457 kern.info: mii_check_media: mii->force_media == TRUE, bailing DISABLED --vda
Would bail out, but I killed that if, and we proceed:
17:54:23.14462 kern.info: mii_check_media: old_carrier:0 new_carrier:1
17:54:23.14466 kern.info: mii_check_media: netif_carrier_on
17:54:23.14469 kern.info: if: link up, 10Mbps, half-duplex, lpa 0x0000
17:54:23.14474 kern.info: dev_activate(if);
17:54:23.14477 kern.info: dev_activate(): dev->qdisc = dev->qdisc_sleeping
17:54:24.64489 kern.info: pfifo_fast_enqueue returns 0
17:54:24.64496 kern.info: pfifo_fast_dequeue returns a skb
17:54:24.64499 kern.info: pfifo_fast_dequeue returns NULL
17:54:24.64584 kern.info: pfifo_fast_enqueue returns 0
17:54:24.64588 kern.info: qdisc_restart: start, q->dequeue=c03e87b6 <== pfifo_fast_dequeue
17:54:24.64597 kern.info: pfifo_fast_dequeue returns a skb
17:54:24.64601 kern.info: qdisc_restart: skb!=NULL
Patch is not made because I suspect that this isn't a proper fix.
--
vda
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/