Date: Wed, 01 Sep 1999 22:32:24 -0400
From: Jeff Garzik <>
Subject: [patch] via82cxxx IDE timing update
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/9/1/195

Andre,
The attached patch against 2.3.16 updates the IDE via82c586.c driver. 
It has been tested on my system with no problems resulting.  Changelog:
o Add support for VT8501 host bridge (you may need pci.patch for its PCI
id)
o Add support for VT82C686 ISA bridge
o Add several host bridge/ISA bridge combinations; reference:
www.via.com.tw
o Verified that VT82C686 IDE controller (ATA-66) registers are
compatible with current code
o Rewrote PCI probing.  Now uses a static table instead of several long,
ugly cut-n-paste loops.
o Fix typo in naming: s/68/86/ in ide-pci.c and via82c586.c
You might want to rename this module to via82cxxx.
Regards,
	Jeff
-- 
Americans' greatest fear is that America will turn out to have been a
phenomenon, not a civilization.
                -- Shirley Hazzard, "Transit of Venus"Index: ide-pci.c
===================================================================
RCS file: /home/cvsgarzik/linux_2_3/drivers/block/ide-pci.c,v
retrieving revision 1.1.1.4
diff -u -r1.1.1.4 ide-pci.c
--- ide-pci.c	1999/08/31 03:11:17	1.1.1.4
+++ ide-pci.c	1999/09/02 02:09:48
@@ -107,10 +107,10 @@
 #endif
 
 #ifdef CONFIG_BLK_DEV_VIA82C586
-extern unsigned int pci_init_via82c568(struct pci_dev *, const char *);
+extern unsigned int pci_init_via82c586(struct pci_dev *, const char *);
 extern void ide_init_via82c586(ide_hwif_t *);
 extern void ide_dmacapable_via82c586(ide_hwif_t *, unsigned long dmabase);
-#define	PCI_VIA82C586	&pci_init_via82c568
+#define	PCI_VIA82C586	&pci_init_via82c586
 #define	INIT_VIA82C586	&ide_init_via82c586
 #define	DMA_VIA82C586	&ide_dmacapable_via82c586
 #else
Index: via82c586.c
===================================================================
RCS file: /home/cvsgarzik/linux_2_3/drivers/block/via82c586.c,v
retrieving revision 1.1.1.4
diff -u -r1.1.1.4 via82c586.c
--- via82c586.c	1999/08/31 03:11:17	1.1.1.4
+++ via82c586.c	1999/09/02 02:09:49
@@ -4,6 +4,7 @@
  *  Copyright (C) 1998 Michel Aubry, Maintainer
  *  Copyright (C) 1998 Andre Hedrick, Maintainer
  *
+ *  The VIA MVP-4 is reported OK with UDMA.
  *  The VIA MVP-3 is reported OK with UDMA.
  *  The TX Pro III is also reported OK with UDMA.
  *
@@ -39,6 +40,14 @@
  *  Note that by default (if no command line is provided) and if a channel
  *  has been disabled in Bios, all the fifo is given to the active channel,
  *  and its threshold is set to 3/4.
+ *
+ *************************************************************************
+ *
+ * Updates:
+ *
+ * 1999/09/01  Jeff Garzik <jgarzik@pobox.com>
+ *	- VIA MVP-4 support
+ *
  */
 
 #include <linux/config.h>
@@ -57,8 +66,8 @@
 
 #include <asm/io.h>
 
-static struct pci_dev *host_dev;
-static struct pci_dev *isa_dev;
+static struct pci_dev *host_dev = NULL;
+static struct pci_dev *isa_dev = NULL;
 
 #define DISPLAY_VIA_TIMINGS
 
@@ -80,6 +89,94 @@
 	"192"
 };
 
+/* define probe order and list of host bridges supported */
+static const struct {
+	unsigned short host_id;
+} ApolloHostChipInfo[] __initdata = {
+	{ PCI_DEVICE_ID_VIA_82C585, },
+	{ PCI_DEVICE_ID_VIA_82C595, },
+	{ PCI_DEVICE_ID_VIA_82C597_0, },
+	{ PCI_DEVICE_ID_VIA_82C598_0, },
+	{ PCI_DEVICE_ID_VIA_82C680, },
+	{ PCI_DEVICE_ID_VIA_82C691, },
+	{ PCI_DEVICE_ID_VIA_82C693, },
+	{ PCI_DEVICE_ID_VIA_8501_0, },
+};
+
+#define NUM_APOLLO_ISA_CHIP_DEVICES	2
+#define VIA_FLAG_CHECK_REV		0x00000001
+#define VIA_FLAG_ATA_66			0x00000002
+
+/* define list of host bridge<->isa bridge combinations supported */
+static const struct {
+	unsigned short host_id;
+	unsigned short isa_id;
+	unsigned int flags;
+} ApolloISAChipInfo[] __initdata = {
+	/* 82c585 */
+	{ PCI_DEVICE_ID_VIA_82C585,
+		PCI_DEVICE_ID_VIA_82C586_1,
+		VIA_FLAG_CHECK_REV },
+
+	/* 82c595 */
+	{ PCI_DEVICE_ID_VIA_82C595,
+		PCI_DEVICE_ID_VIA_82C586_1,
+		VIA_FLAG_CHECK_REV },
+
+	/* 82c597 */
+	{ PCI_DEVICE_ID_VIA_82C597_0,
+		PCI_DEVICE_ID_VIA_82C586_1,
+		VIA_FLAG_CHECK_REV },
+
+	/* 82c598 */
+	{ PCI_DEVICE_ID_VIA_82C598_0,
+		PCI_DEVICE_ID_VIA_82C586_1,
+		VIA_FLAG_CHECK_REV },
+
+	{ PCI_DEVICE_ID_VIA_82C598_0,
+		PCI_DEVICE_ID_VIA_82C596,
+		0 },
+
+	{ PCI_DEVICE_ID_VIA_82C598_0,
+		PCI_DEVICE_ID_VIA_82C686,
+		VIA_FLAG_ATA_66 },
+
+	/* 82c680 */
+	{ PCI_DEVICE_ID_VIA_82C680,
+		PCI_DEVICE_ID_VIA_82C586_1,
+		VIA_FLAG_CHECK_REV },
+
+	/* 82c691 */
+	{ PCI_DEVICE_ID_VIA_82C691,
+		PCI_DEVICE_ID_VIA_82C596,
+		0 },
+
+	{ PCI_DEVICE_ID_VIA_82C691,
+		PCI_DEVICE_ID_VIA_82C686,
+		VIA_FLAG_ATA_66 },
+
+	/* 82c693 */
+	{ PCI_DEVICE_ID_VIA_82C693,
+		PCI_DEVICE_ID_VIA_82C596,
+		0 },
+
+	{ PCI_DEVICE_ID_VIA_82C693,
+		PCI_DEVICE_ID_VIA_82C686,
+		VIA_FLAG_ATA_66 },
+
+	/* VT8501 */
+	{ PCI_DEVICE_ID_VIA_8501_0,
+		PCI_DEVICE_ID_VIA_82C596,
+		0 },
+
+	{ PCI_DEVICE_ID_VIA_8501_0,
+		PCI_DEVICE_ID_VIA_82C686,
+		VIA_FLAG_ATA_66 },
+
+};
+
+#define arraysize(x)    (sizeof(x)/sizeof(*(x)))
+
 static int via_get_info(char *, char **, off_t, int, int);
 extern int (*via_display_info)(char *, char **, off_t, int, int); /* ide-proc.c */
 static struct pci_dev *bmide_dev;
@@ -112,7 +209,7 @@
 			((tm & 0x0c)>>2) + 1,
 			(tm & 0x03) + 1 );
  
-	/* UltraDMA33 Extended Timing Control */
+	/* UltraDMA Extended Timing Control */
  	rc = pci_read_config_dword(dev, 0x50, &time);
  	p += sprintf(p, "------------------UDMA-Timing-Control------------------------\n");
  	p += sprintf(p, "Enable Meth.:    %01d           %01d            %01d           %01d\n",
@@ -146,6 +243,7 @@
 	int rc;
 	char *p = buf;  
  
+	/* IDE configuration */
 	rc = pci_read_config_byte(dev, 0x41, &time);
 	p += sprintf(p, "Prefetch Buffer :      %s                     %s\n",
 		(time & 128)	? "on " : "off",
@@ -363,7 +461,7 @@
 }
 
 /*
- *  Sets VIA 82c586 FIFO configuration:
+ *  Sets VIA 82cxxx FIFO configuration:
  *  This chipsets gets a splitable fifo. This can be driven either by command
  *  line option (eg "splitfifo=2,2,3" which asks this driver to switch all the 
  *  16 fifo levels to the second drive, and give it a threshold of 3 for (u)dma 
@@ -441,129 +539,60 @@
 	return 0;
 }
 
-unsigned int __init pci_init_via82c568 (struct pci_dev *dev, const char *name)
+unsigned int __init pci_init_via82c586 (struct pci_dev *dev, const char *name)
 {
 	struct pci_dev *host;
 	struct pci_dev *isa;
+	int i, j, ata33, ata66;
 
 	byte revision = 0;
-
-	for (host = pci_devices; host; host=host->next) {
-		if (host->vendor == PCI_VENDOR_ID_VIA &&
-		    host->device == PCI_DEVICE_ID_VIA_82C585) {
-			host_dev = host;
-			printk("VT 82C585 Apollo VP1/VPX");
-			for (isa = pci_devices; isa; isa=isa->next) {
-				if (isa->vendor == PCI_VENDOR_ID_VIA &&
-				    isa->device == PCI_DEVICE_ID_VIA_82C586_1) {
-					isa_dev = isa;
-					pci_read_config_byte(isa_dev, 0x0d, &revision);
-					if (revision >= 0x20)
-						printk(" Chipset Core ATA-33");
-					break;
-				}
-			}
-			printk("\n");
-			break;
-		} else if (host->vendor == PCI_VENDOR_ID_VIA &&
-			   host->device == PCI_DEVICE_ID_VIA_82C595) {
-			host_dev = host;
-			printk("VT 82C595 Apollo VP2");
-			for (isa = pci_devices; isa; isa=isa->next) {
-				if (isa->vendor == PCI_VENDOR_ID_VIA &&
-				    isa->device == PCI_DEVICE_ID_VIA_82C586_1) {
-					isa_dev = isa;
-					pci_read_config_byte(isa_dev, 0x0d, &revision);
-					if (revision >= 0x20)
-						printk(" Chipset Core ATA-33");
-					break;
-				}
-			}
-			printk("\n");
-			break;
-		} else if (host->vendor == PCI_VENDOR_ID_VIA &&
-			   host->device == PCI_DEVICE_ID_VIA_82C597_0) {
-			host_dev = host;
-			printk("VT 82C597 Apollo VP3");
-			for (isa = pci_devices; isa; isa=isa->next) {
-				if (isa->vendor == PCI_VENDOR_ID_VIA &&
-				    isa->device == PCI_DEVICE_ID_VIA_82C586_1) {
-					isa_dev = isa;
-					pci_read_config_byte(isa_dev, 0x0d, &revision);
-					if (revision >= 0x20)
-						printk(" Chipset Core ATA-33");
-					break;
-				}
-			}
-			printk("\n");
-			break;
-	} else if (host->vendor == PCI_VENDOR_ID_VIA &&
-		   host->device == PCI_DEVICE_ID_VIA_82C598_0) {
-			host_dev = host;
-			printk("VT 82C598 Apollo MVP3");
-			for (isa = pci_devices; isa; isa=isa->next) {
-				if (isa->vendor == PCI_VENDOR_ID_VIA &&
-				    isa->device == PCI_DEVICE_ID_VIA_82C586_1) {
-					isa_dev = isa;
-					pci_read_config_byte(isa_dev, 0x0d, &revision);
-					if (revision >= 0x20)
-						printk(" Chipset Core ATA-33");
-					break;
-				} else if (isa->vendor == PCI_VENDOR_ID_VIA &&
-					   isa->device == PCI_DEVICE_ID_VIA_82C596) {
-					isa_dev = isa;
-					printk(" Chipset Core ATA-33");
-					break;
-				}
-			}
-			printk("\n");
-			break;
-	} else if (host->vendor == PCI_VENDOR_ID_VIA &&
-		   host->device == PCI_DEVICE_ID_VIA_82C680) {
-			host_dev = host;
-			printk("VT 82C680 Apollo P6");
-			for (isa = pci_devices; isa; isa=isa->next) {
-				if (isa->vendor == PCI_VENDOR_ID_VIA &&
-				    isa->device == PCI_DEVICE_ID_VIA_82C586_1) {
-					isa_dev = isa;
-					pci_read_config_byte(isa_dev, 0x0d, &revision);
-					if (revision >= 0x20)
-						printk(" Chipset Core ATA-33");
-					break;
-				}
+	
+	for (i = 0; i < arraysize (ApolloHostChipInfo) && !host_dev; i++) {
+		host = pci_find_device (PCI_VENDOR_ID_VIA,
+					ApolloHostChipInfo[i].host_id,
+					NULL);
+		if (!host)
+			continue;
+			
+		host_dev = host;
+		printk(dev->name);
+
+		for (j = 0; j < arraysize (ApolloISAChipInfo) && !isa_dev; j++) {
+			if (ApolloISAChipInfo[j].host_id !=
+			    ApolloHostChipInfo[i].host_id)
+				continue;
+				
+			isa = pci_find_device (PCI_VENDOR_ID_VIA,
+					ApolloISAChipInfo[i].isa_id,
+					NULL);
+			if (!isa)
+				continue;
+
+			isa_dev = isa;
+			
+			ata33 = 1;
+			ata66 = 0;
+			
+			if (ApolloISAChipInfo[i].flags & VIA_FLAG_CHECK_REV) {
+				ata33 = 0;
+				pci_read_config_byte(isa_dev, 0x0d, &revision);
+				if (revision >= 0x20)
+					ata33 = 1;
 			}
-			printk("\n");
-			break;
-	} else if (host->vendor == PCI_VENDOR_ID_VIA &&
-		   host->device == PCI_DEVICE_ID_VIA_82C691) {
-			host_dev = host;
-			printk("VT 82C691 Apollo Pro");
-			for (isa = pci_devices; isa; isa=isa->next) {
-				if (isa->vendor == PCI_VENDOR_ID_VIA &&
-				    isa->device == PCI_DEVICE_ID_VIA_82C596) {
-					isa_dev = isa;
-					printk(" Chipset Core ATA-33");
-					break;
-				}
+			else if (ApolloISAChipInfo[i].flags & VIA_FLAG_ATA_66) {
+				ata33 = 0;
+				ata66 = 1;
 			}
-			printk("\n");
-			break;
-	} else if (host->vendor == PCI_VENDOR_ID_VIA &&
-		   host->device == PCI_DEVICE_ID_VIA_82C693) {
-			host_dev = host;
-			printk("VT 82C693 Apollo Pro Plus");
-			for (isa = pci_devices; isa; isa=isa->next) {
-				if (isa->vendor == PCI_VENDOR_ID_VIA &&
-				    isa->device == PCI_DEVICE_ID_VIA_82C596) {
-					isa_dev = isa;
-					printk(" Chipset Core ATA-33");
-					break;
-				}
-			}
-			printk("\n");
-			break;
+
+			
+			if (ata33 | ata66)
+				printk(" Chipset Core ATA-%s",
+					ata66 ? "66" : "33");
 		}
+
+		printk("\n");
 	}
+
 	return 0;
 }
 
@@ -573,7 +602,7 @@
 }
 
 /*
- *  ide_dmacapable_via82c568(ide_hwif_t *, unsigned long)
+ *  ide_dmacapable_via82c586(ide_hwif_t *, unsigned long)
  *  checks if channel "channel" of if hwif is dma
  *  capable or not, according to kernel command line,
  *  and the new fifo settings.Index: pci.h
===================================================================
RCS file: /home/cvsgarzik/linux_2_3/include/linux/pci.h,v
retrieving revision 1.1.1.8
retrieving revision 1.1.1.8.2.1
diff -u -r1.1.1.8 -r1.1.1.8.2.1
--- pci.h	1999/09/01 01:48:32	1.1.1.8
+++ pci.h	1999/09/01 10:12:54	1.1.1.8.2.1
@@ -865,6 +865,7 @@
 #define PCI_DEVICE_ID_TTI_HPT366	0x0004
 
 #define PCI_VENDOR_ID_VIA		0x1106
+#define PCI_DEVICE_ID_VIA_8501_0	0x0501
 #define PCI_DEVICE_ID_VIA_82C505	0x0505
 #define PCI_DEVICE_ID_VIA_82C561	0x0561
 #define PCI_DEVICE_ID_VIA_82C586_1	0x0571
@@ -888,6 +889,7 @@
 #define PCI_DEVICE_ID_VIA_82C686_5	0x3058
 #define PCI_DEVICE_ID_VIA_82C686_6	0x3068
 #define PCI_DEVICE_ID_VIA_86C100A	0x6100
+#define PCI_DEVICE_ID_VIA_8501_1	0x8501
 #define PCI_DEVICE_ID_VIA_82C597_1	0x8597
 #define PCI_DEVICE_ID_VIA_82C598_1	0x8598
 