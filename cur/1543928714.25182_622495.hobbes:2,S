Date: Thu, 29 Nov 2007 14:45:35 +0100
From: Andi Kleen <>
Subject: Re: [RFC] kmemcheck: trap uses of uninitialized memory (v2)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/11/29/146

> We don't need to flush all CPUs. This is my rationale: The debug
> exception (single-step trap) will always happen on the same CPU that
> the page fault occurred on. Page fault shows the page, debug exception
> hides the page again. Between those two operations, nothing else can
You're ignoring preemptible kernels for once.
Also there is always a race. e.g. consider another CPU fetches
the entry into its TLB while you have it temporarily unprotected.
Then you protect it again but the other CPU still keeps the unprotected
entry in its TLBs which you don't flush.
In general any changes to the direct mapping have to be done globally.
> happen that will use the TLB entry in question (unless you have some
> weird race condition, but then the code is in error anyway).
> 
> What is c_p_a() and what is a flush object?
change_page_attr() is designed to queue flush requests for later which
are then done by global_tlb_flush() For that it creates a list of pages.
It cannot be safely used without global_flush_tlb() otherwise the flush
list will just grow unbounded.
You could in theory write an equivalent optimized for your case that does
not require that, but it's not even safe for your case anyways.
-Andi
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/