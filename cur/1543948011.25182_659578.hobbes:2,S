Date: Tue, 26 Feb 2008 01:33:42 +0300
From: Alexey Starikovskiy <>
Subject: Re: new regression in 2.6.25-rc3: no keyboard/lid acpi events on thinkpad T61p
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/2/25/400

Michael S. Tsirkin wrote:
> On Mon, Feb 25, 2008 at 10:50 PM, Alexey Starikovskiy
> <astarikovskiy@suse.de> wrote:
>> Michael S. Tsirkin wrote:
>>  > Did you guys stop accepting reports by mail?
>>  > I hope not.
>>  It is easier to track bug information in bugzilla.
>>  If you for some reason do not wish to create a bug report,
>>  I can do it for you. You only need to provide acpidump.
> 
> Great.
> 
>>  >> and attach acpidump?
>>  >
>>  > I'll see if I can get acpidump output - in which state do you want it?
>>  > Right after boot on the broken kernel?
>>  acpidump output does not change over time, you could get it even with some other kernel.
>>
>>
> 
> Attached is the acpidump output run under 2.6.23-rc3 + with reverted
> 37f9b4c7c612fcbeb8fb6faddaef4ccdb5350145
> (IOW - this is a working configuration).
Thanks, you've got round 10100 bug number.
Please check if the following patch on top of Linus git tree helps.
Regards,
Alex 
> 
> HTH,
> MST
> 
ACPI: EC: fix regression
From: Alexey Starikovskiy <astarikovskiy@suse.de>
---
 drivers/acpi/ec.c |   18 +++++++++++-------
 1 files changed, 11 insertions(+), 7 deletions(-)
diff --git a/drivers/acpi/ec.c b/drivers/acpi/ec.c
index caf873c..d6f9956 100644
--- a/drivers/acpi/ec.c
+++ b/drivers/acpi/ec.c
@@ -129,7 +129,8 @@ static struct acpi_ec {
 	struct mutex lock;
 	wait_queue_head_t wait;
 	struct list_head list;
-	u8 handlers_installed;
+	u8 handlers_installed:1;
+	u8 from_ecdt:1;
 } *boot_ec, *first_ec;
 
 /* --------------------------------------------------------------------------
@@ -772,16 +773,18 @@ static int acpi_ec_add(struct acpi_device *device)
 
 	/* Check for boot EC */
 	if (boot_ec) {
-		if (boot_ec->handle == device->handle) {
-			/* Pre-loaded EC from DSDT, just move pointer */
-			ec = boot_ec;
-			boot_ec = NULL;
-			goto end;
-		} else if (boot_ec->handle == ACPI_ROOT_OBJECT) {
+		if (boot_ec->from_ecdt &&
+		    (boot_ec->handle == device->handle ||
+		     boot_ec->handle == ACPI_ROOT_OBJECT)) {
 			/* ECDT-based EC, time to shut it down */
 			ec_remove_handlers(boot_ec);
 			kfree(boot_ec);
 			first_ec = boot_ec = NULL;
+		} else if (boot_ec->handle == device->handle) {
+			/* Pre-loaded EC from DSDT, just move pointer */
+			ec = boot_ec;
+			boot_ec = NULL;
+			goto end;
 		}
 	}
 
@@ -943,6 +946,7 @@ int __init acpi_ec_ecdt_probe(void)
 		boot_ec->command_addr = ecdt_ptr->control.address;
 		boot_ec->data_addr = ecdt_ptr->data.address;
 		boot_ec->gpe = ecdt_ptr->gpe;
+		boot_ec->from_ecdt = 1;
 		if (ACPI_FAILURE(acpi_get_handle(NULL, ecdt_ptr->id,
 				&boot_ec->handle))) {
 			pr_info("Failed to locate handle for boot EC\n");