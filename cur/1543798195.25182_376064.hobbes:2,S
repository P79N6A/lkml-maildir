Date: Wed, 14 Dec 2005 15:28:05 +0100
From: Rui Sousa <>
Subject: Re: [spi-devel-general] Re: [PATCH 2.6-git 0/4] SPI core refresh
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/12/14/157

On Wed, 2005-12-14 at 09:57 +0300, Vitaly Wool wrote:
> Looks like we'll have to remove explicit wait_for_completion from 
> spi_trasnfer to make it (potentially) work.
> Rui, your turn will then be
> a) not to use thread async message handling which is the default but
> b) use some kind of PIO method for reading from the SPI bus.
This is what I'm doing now (sync + PIO). In any case the SPI bus
controller I'm using only supports PIO.
> The other solution which looks preferable to me is to have a pretty 
> simple interrupt handler which just wakes up a thread which in turn 
> reads what it wants not caring much about sleeps (as it's not gonna be 
> interrupt context any more).
The main problem is that just to be able to ack the interrupt I need to
write on the SPI bus. So now I need to (1) modify my GPIO interrupt
handler so that it let's me exit before acking the interrupt on the
device (2) no longer share this GPIO with other devices interrupts...
It's possible to use the proposed API, it's just that in my case it will
increase the SPI slave driver complexity.
> Vitaly
Rui
> Rui Sousa wrote:
> 
> >On Tue, 2005-12-13 at 15:09 +0300, dmitry pervushin wrote:
> > 
> >
> >>On Mon, 2005-12-12 at 19:01 +0100, Rui Sousa wrote:
> >> 
> >>
> >>>How do you handle IRQ's generated by a SPI device (e.g ack the
> >>>interrupt, check if it was the SPI device that generated the
> >>>interrupt, ...) if you can't read/write on the SPI bus from interrupt
> >>>context?
> >>> 
> >>>
> >>Hmm... what do you mean by "cannot read/write" ? Normally you can
> >>write/read registers in interrupt context
> >> 
> >>
> >
> >The registers I want to read are from a SPI device (a SPI slave attached
> >to a SPI bus). I need to use SPI bus transfers to access them.
> >
> > 
> >
> >>, and then set the
> >>flag/complete the completion/what else ?
> >> 
> >>
> >
> >If I read the API correctly reading/writing a byte from the SPI bus
> >(synchronously) always implies putting the task doing the read to sleep:
> >
> >int spi_transfer(struct spi_msg *msg, void (*callback) (struct spi_msg
> >*, int))
> >{
> >
> >...
> >	err = TO_SPI_BUS_DRIVER(bus->driver)->queue(msg);
> >	wait_for_completion(&msg->sync);
> >...
> >}
> >
> >So, how can I, from an interrupt handler, read/write a couple of bytes
> >from my SPI device using this API?
> >
> > 
> >
> >>In other words, could you please share the code that causes problems ? 
> >>
> >> 
> >>
> >
> >Rui
> >
> >
> > 
> >
> 
> 
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/