Date: Tue, 11 Jan 2000 15:50:56 -0500
From: Mike Phillips <>
Subject: [PATCH] Smp updates for olympic driver, kernel 2.3.39
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/1/11/193

Attached is a patch for the olympic driver for kernel 2.3.39 that adds
spinlocks to enable the driver to work correctly in smp machines.
Mike
Linux Token Ring Project
http://www.linuxtr.net
--- linux-2.3.39.orig/drivers/net/tokenring/olympic.h	Tue Jan 11 13:48:55 2000
+++ linux-2.3.39/drivers/net/tokenring/olympic.h	Tue Jan 11 13:54:11 2000
@@ -245,6 +245,8 @@
 	__u8 *olympic_lap;
 	char *olympic_card_name ; 
 
+	spinlock_t olympic_lock ; 
+
 	volatile int srb_queued;    /* True if an SRB is still posted */	
 	wait_queue_head_t srb_wait;
 
--- linux-2.3.39.orig/drivers/net/tokenring/olympic.c	Tue Jan 11 13:48:55 2000
+++ linux-2.3.39/drivers/net/tokenring/olympic.c	Tue Jan 11 14:18:59 2000
@@ -25,10 +25,11 @@
  *  8/18/99 - Updated driver for 2.3.13 kernel to use new pci
  *	      resource. Driver also reports the card name returned by
  *            the pci resource.
+ *  1/11/00 - Added spinlocks for smp
  *  
  *  To Do:
  *
- *  Sanitize for smp
+ *  IPv6 Multicast
  *
  *  If Problems do Occur
  *  Most problems can be rectified by either closing and opening the interface
@@ -69,6 +70,7 @@
 #include <linux/stddef.h>
 #include <linux/init.h>
 #include <linux/pci.h>
+#include <linux/spinlock.h>
 #include <net/checksum.h>
 
 #include <asm/io.h>
@@ -86,7 +88,7 @@
  */
 
 static char *version = 
-"Olympic.c v0.3.0 8/18/99 - Peter De Schrijver & Mike Phillips" ; 
+"Olympic.c v0.3.1 1/11/00 - Peter De Schrijver & Mike Phillips" ; 
 
 static char *open_maj_error[]  = {"No error", "Lobe Media Test", "Physical Insertion",
 				   "Address Verification", "Neighbor Notification (Ring Poll)",
@@ -251,6 +253,8 @@
 		}
 	}
 
+	spin_lock_init(&olympic_priv->olympic_lock) ; 
+
 #if OLYMPIC_DEBUG
 	printk("BCTL: %x\n",readl(olympic_mmio+BCTL));
 	printk("GPR: %x\n",readw(olympic_mmio+GPR));
@@ -757,6 +761,8 @@
 	if (!(sisr & SISR_MI)) /* Interrupt isn't for us */ 
 		return ;
 
+	spin_lock(&olympic_priv->olympic_lock);
+
 	if (dev->interrupt) 
 		printk(KERN_WARNING "%s: Re-entering interrupt \n",dev->name) ; 
 
@@ -835,15 +841,20 @@
 	dev->interrupt = 0 ;  
 
 	writel(SISR_MI,olympic_mmio+SISR_MASK_SUM);
-
+	
+	spin_unlock(&olympic_priv->olympic_lock) ; 
 }	
 
 static int olympic_xmit(struct sk_buff *skb, struct net_device *dev) 
 {
 	struct olympic_private *olympic_priv=(struct olympic_private *)dev->priv;
-    __u8 *olympic_mmio=olympic_priv->olympic_mmio;
+	__u8 *olympic_mmio=olympic_priv->olympic_mmio;
+	unsigned long flags ; 
+
+	spin_lock_irqsave(&olympic_priv->olympic_lock, flags);
 
 	if (test_and_set_bit(0, (void*)&dev->tbusy) != 0) {
+		spin_unlock_irqrestore(&olympic_priv->olympic_lock,flags);
 		return 1;
 	}
 
@@ -860,10 +871,12 @@
 		writew((((readw(olympic_mmio+TXENQ_1)) & 0x8000) ^ 0x8000) | 1,olympic_mmio+TXENQ_1);
 
 		dev->tbusy=0;		
-
+		spin_unlock_irqrestore(&olympic_priv->olympic_lock,flags);
 		return 0;
-	} else 
+	} else {
+		spin_unlock_irqrestore(&olympic_priv->olympic_lock,flags);
 		return 1;
+	} 
 
 }
 	