Date: Wed, 23 May 2007 20:36:03 -0400
From: "Josef 'Jeff' Sipek" <>
Subject: [PATCH 13/21] Unionfs: Don't leak resources when copyup fails partially
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/5/23/455

Original-patch-by: Erez Zadok <ezk@cs.sunysb.edu>
Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
---
 fs/unionfs/copyup.c |   24 ++++++++++++++++++++++--
 1 files changed, 22 insertions(+), 2 deletions(-)
diff --git a/fs/unionfs/copyup.c b/fs/unionfs/copyup.c
index 0975b6e..a80ece6 100644
--- a/fs/unionfs/copyup.c
+++ b/fs/unionfs/copyup.c
@@ -632,7 +632,7 @@ static struct dentry *create_parents_named(struct inode *dir,
 	unsigned int childnamelen;
 
 	int nr_dentry;
-	int count;
+	int count = 0;
 
 	int old_bstart;
 	int old_bend;
@@ -660,7 +660,6 @@ static struct dentry *create_parents_named(struct inode *dir,
 	/* assume the negative dentry of unionfs as the parent dentry */
 	parent_dentry = dentry;
 
-	count = 0;
 	/*
 	 * This loop finds the first parent that exists in the given branch.
 	 * We start building the directory structure from there.  At the end
@@ -772,6 +771,23 @@ static struct dentry *create_parents_named(struct inode *dir,
 							 hidden_dentry);
 			unlock_dir(hidden_parent_dentry);
 			if (err) {
+				struct inode *inode = hidden_dentry->d_inode;
+				/*
+				 * If we get here, it means that we created a new
+				 * dentry+inode, but copying permissions failed.
+				 * Therefore, we should delete this inode and dput
+				 * the dentry so as not to leave cruft behind.
+				 *
+				 * XXX: call dentry_iput() instead, but then we have
+				 * to export that symbol.
+				 */
+				if (hidden_dentry->d_op && hidden_dentry->d_op->d_iput)
+					hidden_dentry->d_op->d_iput(hidden_dentry,
+								    inode);
+				else
+					iput(inode);
+				hidden_dentry->d_inode = NULL;
+
 				dput(hidden_dentry);
 				hidden_dentry = ERR_PTR(err);
 				goto out;
@@ -786,6 +802,10 @@ static struct dentry *create_parents_named(struct inode *dir,
 		child_dentry = path[--count];
 	}
 out:
+	/* cleanup any leftover locks from the do/while loop above */
+	if (IS_ERR(hidden_dentry))
+		while (count)
+			unionfs_unlock_dentry(path[count--]);
 	kfree(path);
 	return hidden_dentry;
 }
-- 
1.5.2.rc1.165.gaf9b
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/