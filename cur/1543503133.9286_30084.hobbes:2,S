Date: Sun, 18 Jul 1999 14:51:01 -0400 (EDT)
From: Alexander Viro <>
Subject: Re: gdb strangness Under 2.3.11-pre1
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/7/18/87

On Sun, 18 Jul 1999, Ingo Molnar wrote:
> 
> On Sun, 18 Jul 1999, Tim Waugh wrote:
> 
> > On Sun, 18 Jul 1999, Ingo Molnar wrote:
> > 
> > > btw., in case you can reproduce the 'bad page middle entry ...'
> > > messages, do they go away if you remove the lazy-TLB support for
> > > bdflush? (the PF_LAZY_TLB changes in buffer.c)
> > 
> > No.  In sys_bdflush, I made the func==1 case just return sync_old_buffers,
> > as before, but the messages still occur when shutting down.
> 
> and if you disable CLONE_TLB completely, ie. if you comment out these
> lines from fork.c:
> 
>         if ((clone_flags & CLONE_TLB) && capable(CAP_SYS_ADMIN))
>                 new_flags |= PF_LAZY_TLB;
> 
> do the messages go away?
See if the following patch will help. It boots, runs and leak had gone. No
problems so far. I'm submitting it to Linus.
							Cheers,
								Al
diff -urN linux-2.3.11-pre5/arch/i386/kernel/entry.S linux-bird.lazy-TLB/arch/i386/kernel/entry.S
--- linux-2.3.11-pre5/arch/i386/kernel/entry.S	Mon Jun 21 12:35:51 1999
+++ linux-bird.lazy-TLB/arch/i386/kernel/entry.S	Sun Jul 18 14:33:04 1999
@@ -153,11 +153,9 @@
 	ALIGN
 	.globl	ret_from_fork
 ret_from_fork:
-#ifdef __SMP__
 	pushl %ebx
 	call SYMBOL_NAME(schedule_tail)
 	addl $4, %esp
-#endif /* __SMP__ */
 	GET_CURRENT(%ebx)
 	jmp	ret_from_sys_call
 
diff -urN linux-2.3.11-pre5/arch/i386/kernel/process.c linux-bird.lazy-TLB/arch/i386/kernel/process.c
--- linux-2.3.11-pre5/arch/i386/kernel/process.c	Thu Jul 15 05:38:52 1999
+++ linux-bird.lazy-TLB/arch/i386/kernel/process.c	Sun Jul 18 14:33:04 1999
@@ -512,7 +512,7 @@
 	/*
 	 * Load the LDT entry of init_task.
 	 */
-	load_LDT(init_task.mm);
+	load_LDT(&init_mm);
 }
 
 /*
diff -urN linux-2.3.11-pre5/drivers/char/sysrq.c linux-bird.lazy-TLB/drivers/char/sysrq.c
--- linux-2.3.11-pre5/drivers/char/sysrq.c	Sat Jul  3 23:57:21 1999
+++ linux-bird.lazy-TLB/drivers/char/sysrq.c	Sun Jul 18 14:33:04 1999
@@ -40,7 +40,8 @@
 	struct task_struct *p;
 
 	for_each_task(p) {
-		if (p->pid && p->mm != &init_mm) {	    /* Not swapper nor kernel thread */
+		if (p->pid && p->mm != &init_mm && !(p->flags & PF_LAZY_TLB)) {
+		/* Not swapper nor kernel thread */
 			if (p->pid == 1 && even_init)	    /* Ugly hack to kill init */
 				p->pid = 0x8000;
 			force_sig(sig, p);
diff -urN linux-2.3.11-pre5/fs/exec.c linux-bird.lazy-TLB/fs/exec.c
--- linux-2.3.11-pre5/fs/exec.c	Thu Jul 15 05:37:06 1999
+++ linux-bird.lazy-TLB/fs/exec.c	Sun Jul 18 14:33:04 1999
@@ -366,9 +366,11 @@
 static int exec_mmap(void)
 {
 	struct mm_struct * mm, * old_mm;
+	int was_lazy;
 	int retval;
 
 	if (atomic_read(&current->mm->count) == 1) {
+		current->flags &= ~PF_LAZY_TLB;
 		flush_cache_mm(current->mm);
 		mm_release();
 		release_segments(current->mm);
@@ -391,7 +393,9 @@
 	copy_segments(current, mm);
 
 	old_mm = current->mm;
+	was_lazy = current->flags & PF_LAZY_TLB;
 	current->mm = mm;
+	current->flags &= ~PF_LAZY_TLB;
 	retval = new_page_tables(current);
 	if (retval)
 		goto fail_restore;
@@ -406,6 +410,7 @@
 	 */
 fail_restore:
 	current->mm = old_mm;
+	current->flags |= was_lazy;
 	/* restore the ldt for this task */
 	copy_segments(current, NULL);
 	release_segments(mm);
diff -urN linux-2.3.11-pre5/fs/proc/array.c linux-bird.lazy-TLB/fs/proc/array.c
--- linux-2.3.11-pre5/fs/proc/array.c	Thu Jul 15 05:37:22 1999
+++ linux-bird.lazy-TLB/fs/proc/array.c	Sun Jul 18 14:35:01 1999
@@ -471,7 +471,7 @@
 	read_lock(&tasklist_lock);
 	p = find_task_by_pid(pid);
 	read_unlock(&tasklist_lock);	/* FIXME!! This should be done after the last use */
-	if (!p || !p->mm)
+	if (!p || !p->mm || (p->flags & PF_LAZY_TLB))
 		return 0;
 	return get_array(p, p->mm->arg_start, p->mm->arg_end, buffer);
 }
@@ -742,7 +742,7 @@
 {
 	struct mm_struct * mm = p->mm;
 
-	if (mm && mm != &init_mm) {
+	if (!(p->flags & PF_LAZY_TLB) && mm && mm != &init_mm) {
 		struct vm_area_struct * vma = mm->mmap;
 		unsigned long data = 0, stack = 0;
 		unsigned long exec = 0, lib = 0;
@@ -868,7 +868,7 @@
 		return 0;
 	state = *get_task_state(tsk);
 	vsize = eip = esp = 0;
-	if (tsk->mm && tsk->mm != &init_mm) {
+	if (!(tsk->flags & PF_LAZY_TLB) && tsk->mm && tsk->mm != &init_mm) {
 		struct vm_area_struct *vma = tsk->mm->mmap;
 		while (vma) {
 			vsize += vma->vm_end - vma->vm_start;
@@ -1025,7 +1025,7 @@
 	read_unlock(&tasklist_lock);	/* FIXME!! This should be done after the last use */
 	if (!tsk)
 		return 0;
-	if (tsk->mm && tsk->mm != &init_mm) {
+	if (!(tsk->flags & PF_LAZY_TLB) && tsk->mm && tsk->mm != &init_mm) {
 		struct vm_area_struct * vma = tsk->mm->mmap;
 
 		while (vma) {
@@ -1111,7 +1111,7 @@
 	if (!p)
 		goto freepage_out;
 
-	if (!p->mm || p->mm == &init_mm || count == 0)
+	if ((p->flags & PF_LAZY_TLB) || !p->mm || p->mm == &init_mm || count == 0)
 		goto getlen_out;
 
 	/* Check whether the mmaps could change if we sleep */
diff -urN linux-2.3.11-pre5/include/asm-i386/mmu_context.h linux-bird.lazy-TLB/include/asm-i386/mmu_context.h
--- linux-2.3.11-pre5/include/asm-i386/mmu_context.h	Thu Jul 15 05:42:12 1999
+++ linux-bird.lazy-TLB/include/asm-i386/mmu_context.h	Sun Jul 18 14:33:05 1999
@@ -16,12 +16,12 @@
  */
 #define get_mmu_context(prev, next) \
 	do { if (next->flags & PF_LAZY_TLB) \
-		{ mmget(prev->mm); next->mm = prev->mm; \
+		{ if (next->mm) panic("foo"); mmget(prev->mm); next->mm = prev->mm; \
 			next->thread.cr3 = prev->thread.cr3; } } while(0)
 
 #define put_mmu_context(prev, next) \
 	do { if (prev->flags & PF_LAZY_TLB) \
-			{ mmput(prev->mm); } } while(0)
+			{ mmput(prev->mm); prev->mm = NULL; } } while(0)
 
 #define init_new_context(mm)	do { } while(0)
 /*
diff -urN linux-2.3.11-pre5/include/asm-i386/pgtable.h linux-bird.lazy-TLB/include/asm-i386/pgtable.h
--- linux-2.3.11-pre5/include/asm-i386/pgtable.h	Thu Jul 15 05:42:12 1999
+++ linux-bird.lazy-TLB/include/asm-i386/pgtable.h	Sun Jul 18 14:33:05 1999
@@ -307,9 +307,6 @@
 do { \
 	unsigned long __pgdir = __pa(pgdir); \
 	(tsk)->thread.cr3 = __pgdir; \
-	/* do not inherit lazy-TLB after exec() */ \
-	if ((pgdir != swapper_pg_dir) && ((tsk)->flags & PF_LAZY_TLB)) \
-		(tsk)->flags &= ~PF_LAZY_TLB; \
 	if ((tsk) == current) \
 		__asm__ __volatile__("movl %0,%%cr3": :"r" (__pgdir)); \
 } while (0)
diff -urN linux-2.3.11-pre5/kernel/fork.c linux-bird.lazy-TLB/kernel/fork.c
--- linux-2.3.11-pre5/kernel/fork.c	Thu Jul 15 05:42:50 1999
+++ linux-bird.lazy-TLB/kernel/fork.c	Sun Jul 18 14:33:05 1999
@@ -366,6 +366,10 @@
 	tsk->cmin_flt = tsk->cmaj_flt = 0;
 	tsk->nswap = tsk->cnswap = 0;
 
+	if (clone_flags & CLONE_TLB) {
+		tsk->mm = NULL;
+		return 0;
+	}
 	if (clone_flags & CLONE_VM) {
 		mmget(current->mm);
 		/*
diff -urN linux-2.3.11-pre5/kernel/sched.c linux-bird.lazy-TLB/kernel/sched.c
--- linux-2.3.11-pre5/kernel/sched.c	Thu Jul 15 05:42:50 1999
+++ linux-bird.lazy-TLB/kernel/sched.c	Sun Jul 18 14:33:05 1999
@@ -624,6 +624,7 @@
  */
 static inline void __schedule_tail (struct task_struct *prev)
 {
+	put_mmu_context(prev, current);
 #ifdef __SMP__
 	if ((prev->state == TASK_RUNNING) &&
 			(prev != idle_task(smp_processor_id())))
@@ -783,7 +784,6 @@
 	 */
 	get_mmu_context(prev, next);
 	switch_to(prev, next, prev);
-	put_mmu_context(prev, next);
 	__schedule_tail(prev);
 
 same_process:
diff -urN linux-2.3.11-pre5/mm/vmscan.c linux-bird.lazy-TLB/mm/vmscan.c
--- linux-2.3.11-pre5/mm/vmscan.c	Thu Jul 15 05:38:17 1999
+++ linux-bird.lazy-TLB/mm/vmscan.c	Sun Jul 18 14:33:05 1999
@@ -354,6 +354,8 @@
 		for (; p != &init_task; p = p->next_task) {
 			if (!p->swappable)
 				continue;
+			if (!p->mm)
+				continue;
 	 		if (p->mm->rss <= 0)
 				continue;
 			/* Refresh swap_cnt? */
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/