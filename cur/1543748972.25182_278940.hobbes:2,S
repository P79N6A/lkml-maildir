Date: Tue, 14 Dec 2004 12:15:13 -0800 (PST)
From: Linus Torvalds <>
Subject: Re: Question about memcpy_fromio prototype
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2004/12/14/163

On Tue, 14 Dec 2004, Matthew Wilcox wrote:
> 
> Hi Linus.  On x86 and ia64, memcpy_fromio is protoyped as:
> 
> static inline void memcpy_fromio(void *dst, volatile void __iomem *src, int count)
> 
> ALSA does this (except on x86 and sparc32, so you don't see it):
> 
> int copy_to_user_fromio(void __user *dst, const void __iomem *src, size_t count)
> [...]
>                 memcpy_fromio(buf, src, c);
> 
> which provokes a warning from gcc that we're discarding a qualifier (the
> 'const') from src.  Is ALSA just wrong?  Or is the 'volatile' wrong?
Neither. The right thing for a read-only IO pointer is actually
	const volatile void __iomem *
which looks funny ("const volatile"?) but makes sense for prototypes,
exactly because a "const volatile" pointer is the most permissive kind of
pointer there is. And it actually does describe the thing perfectly: it is
"const" because we don't write to it ("const" in C does not mean that the
thing is constant, and never has, confusing name and some C++ semantic
changes aside) and obviously as an IO area it's both "volatile" and
"__iomem".
On x86, readb/w/l already gets that right, so I'll just fix
memcpy_fromio(). Other architectures can sort out themselves (ppc64 is
already correct, at least for eeh).
		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/