Date: Wed, 22 Sep 1999 15:12:35 +0400
From: Ivan Kokshaysky <>
Subject: [PATCH] compile errors on Alpha (2.3.18ac)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/9/22/32

Exactly the same changes (strnlen_user related) are already in 2.2.13pre.
With it 2.3.18ac8 compiles and boots fine.
Ivan.
diff -ur 2.3.18ac8/arch/alpha/kernel/alpha_ksyms.c linux/arch/alpha/kernel/alpha_ksyms.c
--- 2.3.18ac8/arch/alpha/kernel/alpha_ksyms.c	Tue Aug 31 21:50:39 1999
+++ linux/arch/alpha/kernel/alpha_ksyms.c	Tue Sep 21 13:12:59 1999
@@ -139,7 +139,7 @@
 EXPORT_SYMBOL_NOVERS(__copy_user);
 EXPORT_SYMBOL_NOVERS(__do_clear_user);
 EXPORT_SYMBOL(__strncpy_from_user);
-EXPORT_SYMBOL(__strlen_user);
+EXPORT_SYMBOL(__strnlen_user);
 
 /*
  * The following are specially called from the semaphore assembly stubs.
diff -ur 2.3.18ac8/arch/alpha/lib/strlen_user.S linux/arch/alpha/lib/strlen_user.S
--- 2.3.18ac8/arch/alpha/lib/strlen_user.S	Sun Apr 25 04:54:08 1999
+++ linux/arch/alpha/lib/strlen_user.S	Tue Sep 21 13:12:11 1999
@@ -3,6 +3,13 @@
  *
  * Return the length of the string including the NUL terminator
  * (strlen+1) or zero if an error occurred.
+ *
+ * In places where it is critical to limit the processing time,
+ * and the data is not trusted, strnlen_user() should be used.
+ * It will return a value greater than its second argument if
+ * that limit would be exceeded. This implementation is allowed
+ * to access memory beyond the limit, but will not cross a page
+ * boundary when doing so.
  */
 
 #include <alpha/regdef.h>
@@ -27,6 +34,14 @@
 
 	.align 3
 __strlen_user:
+	ldah	a1, 32767(zero)	# do not use plain strlen_user() for strings
+				# that might be almost 2 GB long; you should
+				# be using strnlen_user() instead
+
+	.globl __strnlen_user
+
+	.align 3
+__strnlen_user:
 	ldgp	$29,0($27)	# we do exceptions -- we need the gp.
 	.prologue 1
 
@@ -37,9 +52,17 @@
 	or      t1, t0, t0
 	subq	a0, 1, a0	# get our +1 for the return 
 	cmpbge  zero, t0, t1	# t1 <- bitmask: bit i == 1 <==> i-th byte == 0
+	subq	a1, 7, t2
+	subq	a0, v0, t0
 	bne     t1, $found
 
-$loop:	EX( ldq t0, 8(v0) )
+	addq	t2, t0, t2
+	addq	a1, 1, a1
+
+	.align 3
+$loop:	ble	t2, $limit
+	EX( ldq t0, 8(v0) )
+	subq	t2, 8, t2
 	addq    v0, 8, v0	# addr += 8
 	cmpbge  zero, t0, t1
 	beq     t1, $loop
@@ -59,6 +82,11 @@
 	nop			# dual issue next two on ev4 and ev5
 	subq    v0, a0, v0
 $exception:
+	ret
+
+	.align 3		# currently redundant
+$limit:
+	subq	a1, t2, v0
 	ret
 
 	.end __strlen_user
diff -ur 2.3.18ac8/include/asm-alpha/uaccess.h linux/include/asm-alpha/uaccess.h
--- 2.3.18ac8/include/asm-alpha/uaccess.h	Fri Jul 30 00:37:22 1999
+++ linux/include/asm-alpha/uaccess.h	Tue Sep 21 13:16:07 1999
@@ -487,6 +487,15 @@
 	return access_ok(VERIFY_READ,str,0) ? __strlen_user(str) : 0;
 }
 
+/* Returns: 0 if exception before NUL or reaching the supplied limit (N),
+ * a value greater than N if the limit would be exceeded, else strlen.  */
+extern long __strnlen_user(const char *, long);
+
+extern inline long strnlen_user(const char *str, long n)
+{
+	return access_ok(VERIFY_READ,str,0) ? __strnlen_user(str, n) : 0;
+}
+
 /*
  * About the exception table:
  *
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/