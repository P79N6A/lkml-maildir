Date: Tue, 17 Aug 1999 17:48:29 +0200
From: Ferdinand Prantl <>
Subject: Re: Threads in linux.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/8/17/142

On Tue, Aug 17, 1999 at 01:53:21PM -0400, Stephen Frost wrote:
> 
> 	From my understanding, most of the threading work is implemented in
> either glibc2 or linux-threads, w/ some kernel-level hooks (clone() I think?).
> 	Now, from my experiance linux handles threads pretty nicely, and from
> what I've seen according to POSIX semantics to boot.  Linux, and unix, already
> handles multiple processes at a time, so the idea is, what's a thread but
> another process? (I know I'm going to get flamed for this by SOMEONE), so
> that's the way Linux handles it.  Two threads in a running program are just
> simply two processes that share some info, similar to fork'ed processes, but
> not quite. ;)
> 	Anyhow, that's how I understand it, and I've yet to run into any
> problems or drawbacks in the linux thread implementation compared to other
> OS's (Solaris being one, NT another) that have threads at 'kernel-level'.
  yes, linux has processes you can create with fork() or more general with
  clone() - it appeared later.
  Thread is process again - and on NT (according to the original question)
  there's special API to create thread. By the M$oft definition is thread
  separate process sharing the same data space with parent process. fork()
  gets his own copy, you have to use clone() with the right parameter to
  achive this functionality.
  NT has no fork() or clone(), M$soft developed API similar to POSIX
  threads.
  According to POSIX threads: it's a library encapsulating process creation
  (process == thread). You don't need to learn process stuff on every OS,
  you must get POSIX thread library implementation for your OS. On linux
  it uses clone() on NT CreateThread() and so on.
  Comparison and summary:
  exec(), spawn() - creates process with its own data space and you can
                    add some params about environment inheritation etc.
    * Linux + NT
  fork() - creates process with its own data space and the same env. etc.
    * Linux, NT not
  clone() - creates process with its own data space or not - it depends on
            params - and the same env. etc.
    * Linux, NT has similar way to do it only with shared data space
      via CreateThread()
  using of POSIX threads implies:
    on Linux calling clone() and process API
    on NT calling CreateThread() and the rest of API
  Now you can see that linux is more powerful (encapsulates NT features)
  Another thing is OS process implementation. Is clone() faster than
  CreateThread() ? I don't know and to confuse you and me myself - 
  there are linux kernel-threads (I only heard it) ;-).
  To be more confused - NT has fibers too ... ;-)).
  I worked on multi-threaded (or multi-processed if you want) application
  for linux and win32 and I tested it on DEC Alpha UNIX too. I used clone()
  or CreateThread() API (M$soft gives you no POSIX threads syntax compatible
  library, grr.) Then I wrote essential things from POSIX threads from
  scratch. At last I found cygwin project - UNIX env. on win32 and POSIX
  threads for cygwin - finally the same threaded source.
  As I said above, the question is not in process/threads API but
  which implementation of process creating/handling is faster ?
> 		Stephen
> 
  Ferda Prantl
----------------------------------
Ferdinand Prantl
LVT FF UK
e-mail: prantl@ff.cuni.cz
www: 
http://www.ff.cuni.cz/~prantl
ICQ: 36302930
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/