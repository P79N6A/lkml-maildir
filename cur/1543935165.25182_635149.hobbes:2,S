Date: Mon, 7 Jan 2008 14:28:10 +0200 (EET)
From: Pekka J Enberg <>
Subject: [PATCH] slub: provide /proc/slabinfo
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/1/7/105

From: Pekka Enberg <penberg@cs.helsinki.fi>
[ Upstream commits: 57ed3eda977a215f054102b460ab0eb5d8d112e6,
  6b6adc22a01941165d5af9a3e69e28e948b28f47, and
  158a962422e4a54dc256b6a9b9562f3d30d34d9c ]
This adds a read-only /proc/slabinfo file on SLUB, that makes slabtop work.
[ mingo@elte.hu: build fix. ]
[ torvalds@linux-foundation.org: config unification. ]    
Cc: Andi Kleen <andi@firstfloor.org>
Cc: Christoph Lameter <clameter@sgi.com>
Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Cc: Ingo Molnar <mingo@elte.hu>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
---
 fs/proc/proc_misc.c      |    4 -
 include/linux/slab.h     |    5 ++
 include/linux/slab_def.h |    3 -
 init/Kconfig             |    6 ++
 mm/slab.c                |    2 
 mm/slub.c                |  112 +++++++++++++++++++++++++++++++++++++++++------
 6 files changed, 113 insertions(+), 19 deletions(-)
Index: linux-2.6.23.y/fs/proc/proc_misc.c
===================================================================
--- linux-2.6.23.y.orig/fs/proc/proc_misc.c	2008-01-07 14:07:50.000000000 +0200
+++ linux-2.6.23.y/fs/proc/proc_misc.c	2008-01-07 14:14:17.000000000 +0200
@@ -397,7 +397,7 @@
 };
 #endif
 
-#ifdef CONFIG_SLAB
+#ifdef CONFIG_SLABINFO
 static int slabinfo_open(struct inode *inode, struct file *file)
 {
 	return seq_open(file, &slabinfo_op);
@@ -709,7 +709,7 @@
 #endif
 	create_seq_entry("stat", 0, &proc_stat_operations);
 	create_seq_entry("interrupts", 0, &proc_interrupts_operations);
-#ifdef CONFIG_SLAB
+#ifdef CONFIG_SLABINFO
 	create_seq_entry("slabinfo",S_IWUSR|S_IRUGO,&proc_slabinfo_operations);
 #ifdef CONFIG_DEBUG_SLAB_LEAK
 	create_seq_entry("slab_allocators", 0 ,&proc_slabstats_operations);
Index: linux-2.6.23.y/include/linux/slab.h
===================================================================
--- linux-2.6.23.y.orig/include/linux/slab.h	2008-01-07 14:07:55.000000000 +0200
+++ linux-2.6.23.y/include/linux/slab.h	2008-01-07 14:14:17.000000000 +0200
@@ -269,5 +269,10 @@
 	return kmalloc(size, flags | __GFP_ZERO);
 }
 
+#ifdef CONFIG_SLABINFO
+extern const struct seq_operations slabinfo_op;
+ssize_t slabinfo_write(struct file *, const char __user *, size_t, loff_t *);
+#endif
+
 #endif	/* __KERNEL__ */
 #endif	/* _LINUX_SLAB_H */
Index: linux-2.6.23.y/include/linux/slab_def.h
===================================================================
--- linux-2.6.23.y.orig/include/linux/slab_def.h	2008-01-07 14:07:55.000000000 +0200
+++ linux-2.6.23.y/include/linux/slab_def.h	2008-01-07 14:14:17.000000000 +0200
@@ -95,7 +95,4 @@
 
 #endif	/* CONFIG_NUMA */
 
-extern const struct seq_operations slabinfo_op;
-ssize_t slabinfo_write(struct file *, const char __user *, size_t, loff_t *);
-
 #endif	/* _LINUX_SLAB_DEF_H */
Index: linux-2.6.23.y/init/Kconfig
===================================================================
--- linux-2.6.23.y.orig/init/Kconfig	2008-01-07 14:07:55.000000000 +0200
+++ linux-2.6.23.y/init/Kconfig	2008-01-07 14:14:17.000000000 +0200
@@ -573,6 +573,12 @@
 
 endmenu		# General setup
 
+config SLABINFO
+	bool
+	depends on PROC_FS
+	depends on SLAB || SLUB
+	default y
+
 config RT_MUTEXES
 	boolean
 	select PLIST
Index: linux-2.6.23.y/mm/slab.c
===================================================================
--- linux-2.6.23.y.orig/mm/slab.c	2008-01-07 14:07:55.000000000 +0200
+++ linux-2.6.23.y/mm/slab.c	2008-01-07 14:14:17.000000000 +0200
@@ -4082,7 +4082,7 @@
 	schedule_delayed_work(work, round_jiffies_relative(REAPTIMEOUT_CPUC));
 }
 
-#ifdef CONFIG_PROC_FS
+#ifdef CONFIG_SLABINFO
 
 static void print_slabinfo_header(struct seq_file *m)
 {
Index: linux-2.6.23.y/mm/slub.c
===================================================================
--- linux-2.6.23.y.orig/mm/slub.c	2008-01-07 14:07:55.000000000 +0200
+++ linux-2.6.23.y/mm/slub.c	2008-01-07 14:14:17.000000000 +0200
@@ -2789,6 +2789,19 @@
 	return slab_alloc(s, gfpflags, node, caller);
 }
 
+static unsigned long count_partial(struct kmem_cache_node *n)
+{
+	unsigned long flags;
+	unsigned long x = 0;
+	struct page *page;
+
+	spin_lock_irqsave(&n->list_lock, flags);
+	list_for_each_entry(page, &n->partial, lru)
+		x += page->inuse;
+	spin_unlock_irqrestore(&n->list_lock, flags);
+	return x;
+}
+
 #if defined(CONFIG_SYSFS) && defined(CONFIG_SLUB_DEBUG)
 static int validate_slab(struct kmem_cache *s, struct page *page,
 						unsigned long *map)
@@ -3171,19 +3184,6 @@
 	return n;
 }
 
-static unsigned long count_partial(struct kmem_cache_node *n)
-{
-	unsigned long flags;
-	unsigned long x = 0;
-	struct page *page;
-
-	spin_lock_irqsave(&n->list_lock, flags);
-	list_for_each_entry(page, &n->partial, lru)
-		x += page->inuse;
-	spin_unlock_irqrestore(&n->list_lock, flags);
-	return x;
-}
-
 enum slab_stat_type {
 	SL_FULL,
 	SL_PARTIAL,
@@ -3823,3 +3823,89 @@
 
 __initcall(slab_sysfs_init);
 #endif
+
+/*
+ * The /proc/slabinfo ABI
+ */
+#ifdef CONFIG_SLABINFO
+
+ssize_t slabinfo_write(struct file *file, const char __user * buffer,
+                       size_t count, loff_t *ppos)
+{
+	return -EINVAL;
+}
+
+
+static void print_slabinfo_header(struct seq_file *m)
+{
+	seq_puts(m, "slabinfo - version: 2.1\n");
+	seq_puts(m, "# name            <active_objs> <num_objs> <objsize> "
+		 "<objperslab> <pagesperslab>");
+	seq_puts(m, " : tunables <limit> <batchcount> <sharedfactor>");
+	seq_puts(m, " : slabdata <active_slabs> <num_slabs> <sharedavail>");
+	seq_putc(m, '\n');
+}
+
+static void *s_start(struct seq_file *m, loff_t *pos)
+{
+	loff_t n = *pos;
+
+	down_read(&slub_lock);
+	if (!n)
+		print_slabinfo_header(m);
+
+	return seq_list_start(&slab_caches, *pos);
+}
+
+static void *s_next(struct seq_file *m, void *p, loff_t *pos)
+{
+	return seq_list_next(p, &slab_caches, pos);
+}
+
+static void s_stop(struct seq_file *m, void *p)
+{
+	up_read(&slub_lock);
+}
+
+static int s_show(struct seq_file *m, void *p)
+{
+	unsigned long nr_partials = 0;
+	unsigned long nr_slabs = 0;
+	unsigned long nr_inuse = 0;
+	unsigned long nr_objs;
+	struct kmem_cache *s;
+	int node;
+
+	s = list_entry(p, struct kmem_cache, list);
+
+	for_each_online_node(node) {
+		struct kmem_cache_node *n = get_node(s, node);
+
+		if (!n)
+			continue;
+
+		nr_partials += n->nr_partial;
+		nr_slabs += atomic_long_read(&n->nr_slabs);
+		nr_inuse += count_partial(n);
+	}
+
+	nr_objs = nr_slabs * s->objects;
+	nr_inuse += (nr_slabs - nr_partials) * s->objects;
+
+	seq_printf(m, "%-17s %6lu %6lu %6u %4u %4d", s->name, nr_inuse,
+		   nr_objs, s->size, s->objects, (1 << s->order));
+	seq_printf(m, " : tunables %4u %4u %4u", 0, 0, 0);
+	seq_printf(m, " : slabdata %6lu %6lu %6lu", nr_slabs, nr_slabs,
+		   0UL);
+	seq_putc(m, '\n');
+	return 0;
+}
+
+const struct seq_operations slabinfo_op = {
+	.start = s_start,
+	.next = s_next,
+	.stop = s_stop,
+	.show = s_show,
+};
+
+#endif /* CONFIG_SLABINFO */