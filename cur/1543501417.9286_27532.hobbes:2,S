Date: Thu, 01 Jul 1999 21:48:05 -0700
From: Clemens Huebner <>
Subject: Re: Any documentation anywhere on the new wait.h?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/7/2/19

Unfortunately the changes break sysv ipc. I submitted the attached fix,
but it apparently
got lost...
Clemens
Ingo Molnar wrote:
> Changes/goals wrt. the waitqueues changes:
> 
> 1) waitqueue heads were separated from waitqueue entries, data-structure
> wise. Formerly the head was a pointer, which was not generic enough, see
> later.
> 
> 2) the waitqueue list has been changed to be a double-linked never-zero
> ringlist. This has obvious micro-speed and algorithmical scaling benefits,
> formerly remove_from_wait_queue() had to potentially traverse all the
> waitqueue to remove a single entry. Now it's all O(1).
> 
> 3) the generic datastructures enabled us to add per-waitqueue spinlocks
> which makes us scale better on SMP. Particularly __wake_up() tends to hold
> the waitqueue lock while doing other stuff (well, waking up processes), so
> this is a definit win. It was also easy and seemless due to the generic
> data structures. The spinlock architecture is atm. 'dual', which means
> that it can be switched between readwrite and 'simple' spinlocks via a
> define. The 'simple' version was benchmarked to perform better, that one
> will probably stick and the rw-version will be removed.
> 
> 4) all these changes enabled to implement the primary goal that triggered
> all these changes and cleanups: it was possible to add wake-one semantics
> for wakeup() in a clean way. (see the TASK_EXCLUSIVE stuff)
> 
> compiler_warning is there to make old code generate more warning messages
> when you old-style initialize waitqueues.
> 
> the debugging stuff will be removed before 2.4 - the frequency of
> waitqueue-related bugs is already very low. There is still some small
> benchmarking work to be done wrt. the wakeup order of exclusive tasks.
> 
> -- mingo
> 
> -
> To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
> the body of a message to majordomo@vger.rutgers.edu
> Please read the FAQ at 
http://www.tux.org/lkml/
diff -ur linux/include/linux/msg.h linux.new/include/linux/msg.h
--- linux/include/linux/msg.h	Sat May 15 16:34:43 1999
+++ linux.new/include/linux/msg.h	Sat May 29 21:03:42 1999
@@ -27,6 +27,25 @@
 	__kernel_ipc_pid_t msg_lspid;	/* pid of last msgsnd */
 	__kernel_ipc_pid_t msg_lrpid;	/* last receive pid */
 };
+/* to keep compatibility with ipc msgctl syscall, keep old msqid_ds
+   struct */
+struct msqid_u_ds
+{
+  struct ipc_perm msg_perm;      
+  struct msg *__msg_first;       
+  struct msg *__msg_last;        
+  __kernel_time_t msg_stime;            
+  __kernel_time_t msg_rtime;            
+  __kernel_time_t msg_ctime;            
+  void *__wwait;    	/* not transmitted to userland */
+  void *__rwait;    	/* not transmitted to userland */
+  unsigned short int msg_cbytes; 
+  unsigned short int msg_qnum;   
+  unsigned short int msg_qbytes; 
+  __kernel_ipc_pid_t msg_lspid;         
+  __kernel_ipc_pid_t msg_lrpid;         
+};
+
 
 /* message buffer for msgsnd and msgrcv calls */
 struct msgbuf {
@@ -73,7 +92,7 @@
 asmlinkage int sys_msgsnd (int msqid, struct msgbuf *msgp, size_t msgsz, int msgflg);
 asmlinkage int sys_msgrcv (int msqid, struct msgbuf *msgp, size_t msgsz, long msgtyp,
 		       int msgflg);
-asmlinkage int sys_msgctl (int msqid, int cmd, struct msqid_ds *buf);
+asmlinkage int sys_msgctl (int msqid, int cmd, struct msqid_u_ds *buf);
 
 #endif /* __KERNEL__ */
 
diff -ur linux/ipc/msg.c linux.new/ipc/msg.c
--- linux/ipc/msg.c	Sat May 29 16:50:49 1999
+++ linux.new/ipc/msg.c	Sat May 29 19:41:39 1999
@@ -352,11 +352,11 @@
 	kfree(msq);
 }
 
-asmlinkage int sys_msgctl (int msqid, int cmd, struct msqid_ds *buf)
+asmlinkage int sys_msgctl (int msqid, int cmd, struct msqid_u_ds *buf)
 {
 	int id, err = -EINVAL;
 	struct msqid_ds *msq;
-	struct msqid_ds tbuf;
+	struct msqid_u_ds tbuf;
 	struct ipc_perm *ipcp;
 
 	printk("msgctl: %d %d %p\n",msqid,cmd,buf);