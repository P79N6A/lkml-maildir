Date: Tue, 9 Nov 1999 23:15:25 +0000 (GMT)
From: Alan Cox <>
Subject: Re: [NEW PATCH] POSIX timers for 2.3.26
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/11/9/204

> 
> +		memset (&tes, 0, sizeof(tes));
> +		if (get_user (tes.sigev_value.sival_int, &timer_event_spec->sigev_value.sival_int) ||
> +		    __get_user (tes.sigev_signo, &timer_event_spec->sigev_signo) ||
You cant do that one. Suppose the object is across a page boundary. You need
to check the address range first then use __get_user. In fact its probably
faster to memcpy the object from user into L1 cache then use it
> +asmlinkage int sys_timer_create(clockid_t which_clock,
> +				struct sigevent *timer_event_spec,
> +				timer_t *created_timer_id)
This one has races I think
> +		timers = current->posix_timers = itimer_struct_new();
What if two threads sharing timers execute this at the same time. I suspect
you need to guard this with the tasklist lock perhaps ?
Also consider exec and a setuid program getting started with suprise signals
pending. I suspect execve needs to kill these timers ?
Alan
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/