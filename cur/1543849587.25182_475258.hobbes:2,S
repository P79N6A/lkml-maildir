Date: Fri, 20 Oct 2006 18:33:10 +0100
From: "Alex Owen" <>
Subject: Re: forcedeth net driver: reverse mac address after pxe boot
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/10/20/370

This is a patch against the RHEL4_U3 forcedeth.c source as distributed
by nvidia in the package
http://download.nvidia.com/XFree86/nforce/1.11/NFORCE-Linux-x86-1.11.zip
It performs the test suggested by Alan Cox and reveses the MAC address
as needed.
It is not pretty but is solves my issue while I am waiting for my PC
vendor to get a new BIOS sorted with the upgraded bootagent that fixes
the problem.
As it may help others I'm posting it here!!!
Alex Owen
On 04/10/06, Alan Cox <alan@lxorguk.ukuu.org.uk> wrote:
> Ar Mer, 2006-10-04 am 17:19 +0100, ysgrifennodd Alex Owen:
> > The obvious fix for this is to try and read the MAC address from the
> > canonical location... ie where is the source of the address writen
> > into the controlers registers at power on? But do we know where that
> > may be?
>
> Why not check if the first or last 3 bytes are the Nvidia owner bits.
> The only card that will misdetect is
>
> 00:16:17:17:16:00
>
> which doesn't matter anyway
>
> Alan
>
>
--- forcedeth.c.orig	2006-06-19 13:10:32.000000000 +0100
+++ forcedeth.c	2006-10-20 17:52:33.000000000 +0100
@@ -4784,12 +4784,39 @@
 	np->orig_mac[0] = readl(base + NvRegMacAddrA);
 	np->orig_mac[1] = readl(base + NvRegMacAddrB);
 
+/* RAO FIXME - if mac address is reversed (test oid) then flip into dev_addr then strait copy to orig mac... THEN continue */
+
+        if ( ( (np->orig_mac[0] >> 16) & 0xff ) == 0x17 &&
+             ( (np->orig_mac[0] >>  8) & 0xff ) == 0x16 &&
+             ( (np->orig_mac[0] >>  0) & 0xff ) == 0x00 )
+                { /* mac address is reveresed (PXE bug) so copy into dev_addr */
+                        dev->dev_addr[0] = (np->orig_mac[1] >>  8) & 0xff;
+                        dev->dev_addr[1] = (np->orig_mac[1] >>  0) & 0xff;
+                        dev->dev_addr[2] = (np->orig_mac[0] >> 24) & 0xff;
+                        dev->dev_addr[3] = (np->orig_mac[0] >> 16) & 0xff;
+                        dev->dev_addr[4] = (np->orig_mac[0] >>  8) & 0xff;
+                        dev->dev_addr[5] = (np->orig_mac[0] >>  0) & 0xff;
+                  /* Now copy "reveresed" into orig_mac */
+                        np->orig_mac[0] = (dev->dev_addr[0] << 0) + (dev->dev_addr[1] << 8) +
+                                          (dev->dev_addr[2] << 16) + (dev->dev_addr[3] << 24);
+                        np->orig_mac[1] = (dev->dev_addr[4] << 0) + (dev->dev_addr[5] << 8);
+
+                        printk(KERN_ERR "forcedeth: REVERSED Mac address detected: %02x:%02x:%02x:%02x:%02x:%02x\n",
+                        dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+                        dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+	                printk(KERN_ERR "Fixing MAC address.\n");
+                }
+
 	dev->dev_addr[0] = (np->orig_mac[1] >>  8) & 0xff;
 	dev->dev_addr[1] = (np->orig_mac[1] >>  0) & 0xff;
 	dev->dev_addr[2] = (np->orig_mac[0] >> 24) & 0xff;
 	dev->dev_addr[3] = (np->orig_mac[0] >> 16) & 0xff;
 	dev->dev_addr[4] = (np->orig_mac[0] >>  8) & 0xff;
 	dev->dev_addr[5] = (np->orig_mac[0] >>  0) & 0xff;
+       	printk(KERN_ERR "forcedeth: using Mac address: %02x:%02x:%02x:%02x:%02x:%02x\n",
+			dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+			dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13)
 	memcpy(dev->perm_addr, dev->dev_addr, dev->addr_len);
 