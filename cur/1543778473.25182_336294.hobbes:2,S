Date: Tue, 26 Jul 2005 12:17:52 -0600
From: (Eric W. Biederman)
Subject: [PATCH 23/23] acpi: Don't call acpi_sleep_prepare from acpi_power_off
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/7/26/199

Now that all of the code paths that call acpi_power_off
have been modified to call either call kernel_power_off
(which calls apci_sleep_prepare by way of acpi_shutdown)
or to call acpi_sleep_prepare directly it is redundant to call
acpi_sleep_prepare from acpi_power_off.
So simplify the code and simply don't call acpi_sleep_prepare.
In addition there is a little error handling done so if we
can't register the acpi class we don't hook pm_power_off.
I think I have done the right thing with the CONFIG_PM define
but I'm not certain.  Can this code even be compiled if
CONFIG_PM is false?
Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
---
 drivers/acpi/sleep/poweroff.c |   33 ++++++++++++---------------------
 1 files changed, 12 insertions(+), 21 deletions(-)
415ee58560128bb4f90f8252c189bdf489d1f0d3
diff --git a/drivers/acpi/sleep/poweroff.c b/drivers/acpi/sleep/poweroff.c
--- a/drivers/acpi/sleep/poweroff.c
+++ b/drivers/acpi/sleep/poweroff.c
@@ -19,8 +19,6 @@
 
 int acpi_sleep_prepare(u32 acpi_state)
 {
-	/* Flag to do not allow second time invocation for S5 state */
-	static int shutdown_prepared = 0;
 #ifdef CONFIG_ACPI_SLEEP
 	/* do we have a wakeup address for S2 and S3? */
 	/* Here, we support only S4BIOS, those we set the wakeup address */
@@ -38,27 +36,23 @@ int acpi_sleep_prepare(u32 acpi_state)
 	acpi_enable_wakeup_device_prep(acpi_state);
 #endif
 	if (acpi_state == ACPI_STATE_S5) {
-		/* Check if we were already called */
-		if (shutdown_prepared)
-			return 0;
 		acpi_wakeup_gpe_poweroff_prepare();
-		shutdown_prepared = 1;
 	}
 	acpi_enter_sleep_state_prep(acpi_state);
 	return 0;
 }
 
+#ifdef CONFIG_PM
+
 void acpi_power_off(void)
 {
+	/* acpi_sleep_prepare(ACPI_STATE_S5) should have already been called */
 	printk("%s called\n", __FUNCTION__);
-	acpi_sleep_prepare(ACPI_STATE_S5);
 	local_irq_disable();
 	/* Some SMP machines only can poweroff in boot CPU */
 	acpi_enter_sleep_state(ACPI_STATE_S5);
 }
 
-#ifdef CONFIG_PM
-
 static int acpi_shutdown(struct sys_device *x)
 {
 	return acpi_sleep_prepare(ACPI_STATE_S5);
@@ -74,8 +68,6 @@ static struct sys_device device_acpi = {
 	.cls = &acpi_sysclass,
 };
 
-#endif
-
 static int acpi_poweroff_init(void)
 {
 	if (!acpi_disabled) {
@@ -85,19 +77,18 @@ static int acpi_poweroff_init(void)
 		status =
 		    acpi_get_sleep_type_data(ACPI_STATE_S5, &type_a, &type_b);
 		if (ACPI_SUCCESS(status)) {
-			pm_power_off = acpi_power_off;
-#ifdef CONFIG_PM
-			{
-				int error;
-				error = sysdev_class_register(&acpi_sysclass);
-				if (!error)
-					error = sysdev_register(&device_acpi);
-				return error;
-			}
-#endif
+			int error;
+			error = sysdev_class_register(&acpi_sysclass);
+			if (!error)
+				error = sysdev_register(&device_acpi);
+			if (!error)
+				pm_power_off = acpi_power_off;
+			return error;
 		}
 	}
 	return 0;
 }
 
 late_initcall(acpi_poweroff_init);
+
+#endif /* CONFIG_PM */
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/