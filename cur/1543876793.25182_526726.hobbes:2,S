Date: Tue, 3 Apr 2007 11:52:19 -0700
From: "Siddha, Suresh B" <>
Subject: Re: [PATCH] msi: Immediately mask and unmask msi-x irqs.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/4/3/216

On Tue, Apr 03, 2007 at 01:41:49AM -0600, Eric W. Biederman wrote:
> When we mask or unmask a msi-x irqs the writes may be posted because
> we are writing to memory mapped region.  This means the mask and
> unmask don't happen immediately but at some unspecified time in the
> future.  Which is out of sync with how the mask/unmask logic work
> for ioapic irqs.
> 
> The practical result is that we get very subtle and hard to track down
> irq migration bugs.
> 
> This patch performs a read flush after writes to the MSI-X table for mask
> and unmask operations.  Since the SMP affinity is set while the interrupt
> is masked, and since it's unmasked immediately after, no additional flushes
> are required in the various affinity setting routines.
set_msi_irq_affinity() is already doing read_msi_msg(). So the mask operation
before this should atleast get flushed before we modify the irq destination
information.
With this patch however, unmask happens immediately.
> diff --git a/drivers/pci/msi.c b/drivers/pci/msi.c
> index ad33e01..435c195 100644
> --- a/drivers/pci/msi.c
> +++ b/drivers/pci/msi.c
> @@ -94,6 +94,7 @@ static void msi_set_mask_bit(unsigned int irq, int flag)
>  		int offset = entry->msi_attrib.entry_nr * PCI_MSIX_ENTRY_SIZE +
>  			PCI_MSIX_ENTRY_VECTOR_CTRL_OFFSET;
>  		writel(flag, entry->mask_base + offset);
> +		readl(entry->mask_base + offset);
Don't we need the flush for the PCI_CAP_ID_MSI case aswell.
thanks,
suresh
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/