Date: Sun, 23 Jan 2000 01:11:22 +0100
From: Martin Vogt <>
Subject: select bug after 12 hours?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/1/23/95

Hello,
this bug is hard to describe, I´m using RH 6.1 (standard kernel)
Kernel 2.2.12-20 on an i586
It seems to me, that after 12 hours, or at least after many hours (> 10)
the kernel does not wait correct on a select call.
My program displays mpeg videos and after each video I must
wait for some time.
I have just rebooted (after 12 hours uptime) 
and now the wait routine works again.
Before it, the select call returned too fast, which results
in a too fast played video.
Heres a code sample to give you an idea what I´m doing:
  waitTime->set(0,oneFrameTime);
  startTime->gettimeofday();
  startTime->addOffset(waitTime);
  startTime stores currentTime and adds an offset. oneFrameTime 
  is 40000 u_sec (for 25 frames/s video)
  
  now I dither the picture.This usually takes 15000 u_sec.
  endTime->gettimeofday();
  startTime->minus(endTime,endTime);
 
  here I store in endTime the differenc between starttime and
  the current time.
  endTime->waitForIt();
  ^^^^^^^^^^^^^^^^^^^^^^^^^
this calls select and select returns too fast.
(But after a reboot it works for 12 hours as expected.
I have no SMP system. I have an AMD K 6 III 400 MHz.
Is it possible that an internal kernel variable "overflows"
after 12 hours and the select returns too fast?
This is the select call:
void TimeStamp::waitForIt() {
  struct timeval waitTime;
  waitTime.tv_sec=time.tv_sec;
  waitTime.tv_usec=time.tv_usec;
  if (vorzeichen == 1) {
    //    cout << "wait:"<<waitTime.tv_sec<<" usec:"<<waitTime.tv_usec<<endl;
    select(0,NULL,NULL,NULL,&waitTime);
  }
}
regards,
Martin
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/