Date: Fri, 31 Oct 2003 01:58:18 -0800
From: Andrew Morton <>
Subject: Re: [PATCH] remove useless highmem bounce from loop/cryptoloop
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2003/10/31/29

Andrew Morton <akpm@osdl.org> wrote:
>
>  Andrew Morton <akpm@osdl.org> wrote:
>  >
>  > Here's the patch;
> 
>  And here's your cleanup patch on top of that.
And here are some fixes against your patch.  kunmap_atomic() takes a kernel
virtual address, not a pageframe pointer.  And there were a couple of stray
kunmap()s left over.
--- 25/drivers/block/loop.c~loop-highmem-fixes	2003-10-31 00:55:17.000000000 -0800
+++ 25-akpm/drivers/block/loop.c	2003-10-31 01:01:32.000000000 -0800
@@ -81,18 +81,16 @@ static int transfer_none(struct loop_dev
 			 struct page *loop_page, unsigned loop_off,
 			 int size, sector_t real_block)
 {
-	char	*raw_buf = kmap_atomic(raw_page, KM_USER0) + raw_off;
-	char	*loop_buf = kmap_atomic(loop_page, KM_USER1) + loop_off;
+	char *raw_buf = kmap_atomic(raw_page, KM_USER0) + raw_off;
+	char *loop_buf = kmap_atomic(loop_page, KM_USER1) + loop_off;
 
-	if (raw_buf != loop_buf) {
-		if (cmd == READ)
-			memcpy(loop_buf, raw_buf, size);
-		else
-			memcpy(raw_buf, loop_buf, size);
-	}
+	if (cmd == READ)
+		memcpy(loop_buf, raw_buf, size);
+	else
+		memcpy(raw_buf, loop_buf, size);
 
-	kunmap_atomic(raw_page, KM_USER0);
-	kunmap_atomic(loop_page, KM_USER1);
+	kunmap_atomic(raw_buf, KM_USER0);
+	kunmap_atomic(loop_buf, KM_USER1);
 	cond_resched();
 	return 0;
 }
@@ -102,10 +100,10 @@ static int transfer_xor(struct loop_devi
 			struct page *loop_page, unsigned loop_off,
 			int size, sector_t real_block)
 {
-	char	*raw_buf = kmap_atomic(raw_page, KM_USER0) + raw_off;
-	char	*loop_buf = kmap_atomic(loop_page, KM_USER1) + loop_off;
-	char	*in, *out, *key;
-	int	i, keysize;
+	char *raw_buf = kmap_atomic(raw_page, KM_USER0) + raw_off;
+	char *loop_buf = kmap_atomic(loop_page, KM_USER1) + loop_off;
+	char *in, *out, *key;
+	int i, keysize;
 
 	if (cmd == READ) {
 		in = raw_buf;
@@ -120,8 +118,8 @@ static int transfer_xor(struct loop_devi
 	for (i = 0; i < size; i++)
 		*out++ = *in++ ^ key[(i & 511) % keysize];
 
-	kunmap_atomic(raw_page, KM_USER0);
-	kunmap_atomic(loop_page, KM_USER1);
+	kunmap_atomic(raw_buf, KM_USER0);
+	kunmap_atomic(loop_buf, KM_USER1);
 	cond_resched();
 	return 0;
 }
@@ -225,17 +223,19 @@ do_lo_send(struct loop_device *lo, struc
 						 bvec->bv_page, bv_offs,
 						 size, IV);
 		if (transfer_result) {
+			char *kaddr;
+
 			/*
 			 * The transfer failed, but we still write the data to
 			 * keep prepare/commit calls balanced.
 			 */
 			printk(KERN_ERR "loop: transfer error block %llu\n",
 			       (unsigned long long)index);
-			memset(kmap_atomic(page, KM_USER0) + offset, 0, size);
-			kunmap_atomic(page, KM_USER0);
+			kaddr = kmap_atomic(page, KM_USER0);
+			memset(kaddr + offset, 0, size);
+			kunmap_atomic(kaddr, KM_USER0);
 		}
 		flush_dcache_page(page);
-		kunmap(page);
 		if (aops->commit_write(file, page, offset, offset+size))
 			goto unlock;
 		if (transfer_result)
@@ -250,7 +250,6 @@ do_lo_send(struct loop_device *lo, struc
 	}
 	up(&mapping->host->i_sem);
 out:
-	kunmap(bvec->bv_page);
 	return ret;
 
 unlock:
_
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/