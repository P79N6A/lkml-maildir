Date: Sat, 17 Apr 1999 23:51:00 +0200
From: Pavel Machek <>
Subject: ANNOUNCE: podfuk - userfs replacement in 300 lines
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/4/18/8

Hi!
I'd like to announce podfuk - userfs replacement which can currently
decompress files (gz, bz2), work with compressed archives (just cd to
them, tar, zip, arj, deb, rpm), and work with anonymous ftp (would not
you _love_ to cat /#ftp:ftp.kernel.org/pub/linux/kernel/v2.2/patch
2.2.6.gz#ugz | patch -Esp1?). And that all in 400 lines (well, it
links against midnight commander :-).
Podfuk v2, unlike userfs which required kernel patch, and unlike
podfuk-old which used nfs, uses coda client, present in 2.2.x linux
kernels. Attached code can be used to redirect requests for all
non-existent files into /overlay tree. [Can someone comment on quality
of attached kernel patch? Is there smarter way? Is it usefull for
something other than podfuk?]
								Pavel
PS: Aha, you want to look at
http://atrey.karlin.mff.cuni.cz/~pavel/podfuk/podfuk.html.
--- clean//fs/namei.c	Tue Feb  9 14:00:56 1999
+++ linux/fs/namei.c	Wed Apr  7 22:36:24 1999
@@ -39,7 +39,7 @@
 
 /* This can be removed after the beta phase. */
 #define CACHE_SUPERVISE	/* debug the correctness of dcache entries */
-#undef DEBUG		/* some other debugging */
+#define DEBUG		/* some other debugging */
 
 
 #define ACC_MODE(x) ("\000\004\002\006"[(x)&O_ACCMODE])
@@ -309,6 +309,38 @@
 	return dentry;
 }
 
+struct dentry *
+no_file( struct dentry *base, int lookup_flags )
+{
+	char *tmp = (char *) __get_free_page(GFP_KERNEL);
+	char *path = d_path(base, tmp, PAGE_SIZE);
+	struct dentry *res;
+	char *s = "yalrevo/";
+
+	if (strlen(path) > PAGE_SIZE-30) {
+		printk( "Namei: path much too long\n" );
+		res = ERR_PTR(-ENOENT);
+		goto done;
+	}
+
+	if (!strncmp( path, "/overlay", 8 )) {
+		printk( "[loop]" );
+		res = ERR_PTR(-ENOENT);
+		goto done;
+	}
+
+	printk( "No file %s / ???...", path );
+	while (*s) *--path = *s++;
+	printk( "looking %s...", path );
+
+	res = lookup_dentry( path, NULL, lookup_flags );
+	printk( "done (%x)\n", res );
+
+done:
+	free_page((unsigned long) tmp);
+	return res;
+} 
+
 /*
  * Name resolution.
  *
@@ -376,6 +408,7 @@
 				flags |= LOOKUP_CONTINUE;
 		}
 
+//printk( "(L: %s, %d)", this.name, follow );
 		/*
 		 * See if the low-level filesystem might want
 		 * to use its own hash..
@@ -399,6 +432,48 @@
 					break;
 			}
 		}
+#ifndef CLEAN
+		if (strchr( this.name, '#' ))
+#endif
+		if (!dentry->d_inode) {
+			struct dentry *tbase, *tdentry = NULL;
+			tbase = no_file( base, lookup_flags );
+			if (!IS_ERR(tbase) && (tbase->d_inode)) {
+				/* We need to do lookup once again. */
+
+				/* FIXME: We should save original hash... 
+				 *        [what if fs wanted _normal_ hash?]
+				 * See if the low-level filesystem might want
+				 * to use its own hash..
+				 */
+				if (tbase->d_op && tbase->d_op->d_hash) {
+					int error;
+					error = tbase->d_op->d_hash(base, &this);
+					if (error < 0) {
+						dentry = ERR_PTR(error);
+						break;
+					}
+				}
+
+				/* This does the actual lookups.. */
+				tdentry = reserved_lookup(tbase, &this);
+				if (!tdentry) {
+					tdentry = cached_lookup(tbase, &this);
+					if (!tdentry) {
+						tdentry = real_lookup(tbase, &this);
+						if (IS_ERR(dentry))
+							break;
+					}
+				}
+				if (!IS_ERR(tdentry) && (tdentry->d_inode)) {
+					base = tbase;
+					dentry = tdentry;
+				}
+			}
+		}
+
+		if (IS_ERR(dentry))
+			break;
 
 		/* Check mountpoints.. */
 		dentry = follow_mount(dentry);
-- 
I'm really pavel@atrey.karlin.mff.cuni.cz. 	   Pavel
Look at 
http://atrey.karlin.mff.cuni.cz/~pavel/
 ;-).[unhandled content-type:application/octet-stream]