Date: Thu, 1 Feb 2007 12:17:42 +0100
From: Andi Kleen <>
Subject: Re: [patch 5/9] Add all the necessary structures to the vsyscall page
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/2/1/102

On Thursday 01 February 2007 10:59, jbohac@suse.cz wrote:
>  struct vxtime_data {
> +	union {
> +		struct {
> +			u64 tsc_slope;		/* TSC to MT coefficient */
> +			u64 tsc_slope_avg;	/* average tsc_slope */
> +			u64 mt_base;		/* approximated MT at the last LAPIC tick */
> +			u64 mt_last;		/* MT at the last LAPIC tick */
> +			u64 tsc_last;		/* TSC at the last LAPIC tick */
> +			u64 last_mt_guess;	/* ensures monotonicity in temporary MT mode */
> +			char tsc_invalid;	/* don't trust the TSC now (frequency changing) */
> +		};
> +		char pad[64];	/* cacheline alignment */
Use some variant of __cacheline_aligned_in_smp
There are far better ways than to hardcode
> +	} cpu[NR_CPUS];
This can become very large with default NR_CPUS==128. I would prefer
a way that waste less space on smaller machines by only sizing the array
num_possible_cpus()
>  	long hpet_address;	/* HPET base address */
> -	int last;
> -	unsigned long last_tsc;
> -	long quot;
> -	long tsc_quot;
> +	u64 mt_q;		/* master timer to nsec quotient */
> +	u64 mt_wall;		/* MT ticks already covered by the jiffies */
> +	s64 ns_drift;		/* MT - xtime drift in the last tick in ns */
Might make sense to duplicate those to all per cpu datas, then they 
only need to acce
-Andi
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/