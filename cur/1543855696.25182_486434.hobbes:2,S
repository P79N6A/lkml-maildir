Date: Wed, 29 Nov 2006 08:10:23 +0100
From: Ingo Molnar <>
Subject: Re: [patch] genapic: default to physical mode on hotplug CPU kernels
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/11/29/21

* Siddha, Suresh B <suresh.b.siddha@intel.com> wrote:
> On Tue, Nov 28, 2006 at 09:23:22PM +0100, Ingo Molnar wrote:
> > 
> > * Siddha, Suresh B <suresh.b.siddha@intel.com> wrote:
> > 
> > > On Tue, Nov 28, 2006 at 07:33:46AM +0100, Ingo Molnar wrote:
> > > > -	if (clusters <= 1 && max_cluster <= 8 && cluster_cnt[0] == max_cluster)
> > > > +	if (max_apic < 8)
> > > 
> > > Patch mostly looks good.  Instead of checking for max_apic, can we use
> > > 	cpus_weight(cpu_possible_map) <= 8
> > 
> > ok - but i think it's still possible the BIOS tells us APIC IDs that are 
> > larger than 7, even if there are fewer CPUs. So i think the patch below 
> > should cover it. Agreed?
> > 
> 
> I think it is ok to use flat mode even when APIC IDs are larger than 
> 7, as we rely on LDR's which are programmed using smp_processor_id().
> 
> IMO, cpus_weight check should be fine.
hm - indeed. Then we can indeed do the patch below. Nice simplification!
	Ingo
-------------------->
From: Ingo Molnar <mingo@elte.hu>
Subject: [patch] genapic: default to physical mode on hotplug CPU kernels
default to physical mode on hotplug CPU kernels. Furher simplify and
clean up the APIC initialization code.
Signed-off-by: Ingo Molnar <mingo@elte.hu>
---
 arch/x86_64/kernel/genapic.c |   20 +++-----------------
 arch/x86_64/kernel/mpparse.c |    2 +-
 include/asm-x86_64/apic.h    |    2 +-
 3 files changed, 5 insertions(+), 19 deletions(-)
Index: linux/arch/x86_64/kernel/genapic.c
===================================================================
--- linux.orig/arch/x86_64/kernel/genapic.c
+++ linux/arch/x86_64/kernel/genapic.c
@@ -33,25 +33,11 @@ u8 x86_cpu_to_log_apicid[NR_CPUS]	= { [0
 struct genapic __read_mostly *genapic = &apic_flat;
 
 /*
- * Check the APIC IDs in bios_cpu_apicid and choose the APIC mode.
+ * Choose the APIC routing mode:
  */
-void __init clustered_apic_check(void)
+void __init setup_apic_routing(void)
 {
-	unsigned int i, max_apic = 0;
-	u8 id;
-
-	/*
-	 * Determine the maximum APIC ID in use:
-	 */
-	for (i = 0; i < NR_CPUS; i++) {
-		id = bios_cpu_apicid[i];
-		if (id == BAD_APICID)
-			continue;
-		if (id > max_apic)
-			max_apic = id;
-	}
-
-	if (max_apic < 8)
+	if (cpus_weight(cpu_possible_map) <= 8)
 		genapic = &apic_flat;
 	else
 		genapic = &apic_physflat;
Index: linux/arch/x86_64/kernel/mpparse.c
===================================================================
--- linux.orig/arch/x86_64/kernel/mpparse.c
+++ linux/arch/x86_64/kernel/mpparse.c
@@ -302,7 +302,7 @@ static int __init smp_read_mpc(struct mp
 			}
 		}
 	}
-	clustered_apic_check();
+	setup_apic_routing();
 	if (!num_processors)
 		printk(KERN_ERR "MPTABLE: no processors registered!\n");
 	return num_processors;
Index: linux/include/asm-x86_64/apic.h
===================================================================
--- linux.orig/include/asm-x86_64/apic.h
+++ linux/include/asm-x86_64/apic.h
@@ -82,7 +82,7 @@ extern void setup_secondary_APIC_clock (
 extern int APIC_init_uniprocessor (void);
 extern void disable_APIC_timer(void);
 extern void enable_APIC_timer(void);
-extern void clustered_apic_check(void);
+extern void setup_apic_routing(void);
 static inline void lapic_timer_idle_broadcast(int broadcast) { }
 
 extern void setup_APIC_extened_lvt(unsigned char lvt_off, unsigned char vector,
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/