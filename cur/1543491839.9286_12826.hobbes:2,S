Date: Sun, 4 Apr 1999 04:21:12 +0400 (MSD)
From: Sergei Ivanov <>
Subject: a modem problem introduced in 2.2.4
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/4/3/73

Hello
The changes to drivers/char/serial.c made between 2.2.3 and 2.2.4
introduced a problem with my modem and uucp. It remains there
under 2.2.5.
The system is a Pentium-75 and a fairly generic PCI board. The modem
is on ttyS1. It's a 5 years old internal USR Sportster 14400.
Nothing special about the serial port. This stuff works fine
under earlier kernels, including 2.2.3.
In short, the problem is that uucp can dial out only once after boot.
The next time it tries, it fails to place a call. This is 100%
reproducible. But I could not obtain this effect from other programs
and I don't know what exactly uucp does to the serial port.
This is how it looks in logs: uucico sends "AT\r", waits for "OK",
then sends "ATZ\r", waits for "OK", places the call, talks to the other
system, and finally sends "+++ ATH\r" to hang up. This works for the
first time. But the next time, it does not get the OK for its ATZ.
It receives some garbage instead. Any further attempts don't bring
any response from the modem. Sometimes the port (modem?) can be
recovered by other means, and sometimes it appears badly locked.
The thing returns to its normal behavior if drivers/char/serial.c
is replaced by the copy from 2.2.3. It fact, it is sufficient to undo
only a part of patch-2.2.4:
--- v2.2.3/linux/drivers/char/serial.c	Tue Jan 19 11:32:51 1999
+++ linux/drivers/char/serial.c	Tue Mar 23 13:13:58 1999
@@ -1274,6 +1274,8 @@
 
 	/* Determine divisor based on baud rate */
 	baud = tty_get_baud_rate(info->tty);
+	if (!baud)
+		baud = 9600;	/* B0 transition handled in rs_set_termios */
 	baud_base = info->state->baud_base;
 	if (baud == 38400 &&
 	    ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST))
@@ -2162,8 +2164,9 @@
 {
 	struct async_struct *info = (struct async_struct *)tty->driver_data;
 	unsigned long flags;
+	unsigned int cflag = tty->termios->c_cflag;
 	
-	if (   (tty->termios->c_cflag == old_termios->c_cflag)
+	if (   (cflag == old_termios->c_cflag)
 	    && (   RELEVANT_IFLAG(tty->termios->c_iflag) 
 		== RELEVANT_IFLAG(old_termios->c_iflag)))
 	  return;
@@ -2172,7 +2175,7 @@
 
 	/* Handle transition to B0 status */
 	if ((old_termios->c_cflag & CBAUD) &&
-	    !(tty->termios->c_cflag & CBAUD)) {
+	    !(cflag & CBAUD)) {
 		info->MCR &= ~(UART_MCR_DTR|UART_MCR_RTS);
 		save_flags(flags); cli();
 		serial_out(info, UART_MCR, info->MCR);
@@ -2181,7 +2184,7 @@
 	
 	/* Handle transition away from B0 status */
 	if (!(old_termios->c_cflag & CBAUD) &&
-	    (tty->termios->c_cflag & CBAUD)) {
+	    (cflag & CBAUD)) {
 		info->MCR |= UART_MCR_DTR;
 		if (!(tty->termios->c_cflag & CRTSCTS) || 
 		    !test_bit(TTY_THROTTLED, &tty->flags)) {
BTW, in linux-kernel archives I found another patch to serial.c,
by Richard Johnson. The effect of that patch is the same as that of
kernel 2.2.4.
System details: uucp-1.06.1, glibc 2.1, egcs 1.1.2 (but gcc 2.7.2.3
does not make any difference), binutils-2.9.1.0.22b.
Serial is not a module, setserial is not used.
Thanks for any info.
Sergei
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/