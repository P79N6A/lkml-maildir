Date: Fri, 20 Aug 1999 17:41:13 +0800
From: Tseng Chou Ming (Soft Eng) <>
Subject: modified rd.c from v2.2.1(4):diff patch file
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/8/20/31

--- rd.c.221	Fri Aug 20 17:34:48 1999
+++ rd.c.jmt	Fri Aug 20 17:23:53 1999
@@ -62,6 +62,8 @@
 
 extern void wait_for_keypress(void);
 
+#define JMT_RD
+
 /*
  * 35 has been officially registered as the RAMDISK major number, but
  * so is the original MAJOR number of 1.  We're using 1 in
@@ -71,7 +73,7 @@
 #include <linux/blk.h>
 
 /* The RAM disk size is now a parameter */
-#define NUM_RAMDISKS 16		/* This cannot be overridden (yet) */ 
+#define NUM_RAMDISKS 1		/* (16) This cannot be overridden (yet) */ 
 
 #ifndef MODULE
 /* We don't have to load RAM disks or gunzip them in a module. */
@@ -98,10 +100,10 @@
  * architecture-specific setup routine (from the stored boot sector
  * information). 
  */
-int rd_size = 4096;		/* Size of the RAM disks */
+int rd_size = 4567; /*4872;*/ /*4096;*/		/* Size of the RAM disks */
 
 #ifndef MODULE
-int rd_doload = 0;		/* 1 = load RAM disk, 0 = don't load */
+int rd_doload = 0;		/* "1" = load RAM disk, 0 = don't load */
 int rd_prompt = 1;		/* 1 = prompt for RAM disk, 0 = don't prompt */
 int rd_image_start = 0;		/* starting block # of image */
 #ifdef CONFIG_BLK_DEV_INITRD
@@ -122,6 +124,11 @@
 	unsigned int minor;
 	int offset, len;
 
+	loff_t pos;
+#if 0
+	printk("[.]in rd_request\n");
+#endif
+
 repeat:
 	INIT_REQUEST;
 	
@@ -133,6 +140,9 @@
 	}
 	
 	offset = CURRENT->sector << 9;
+
+	pos=offset;	
+
 	len = CURRENT->current_nr_sectors << 9;
 
 	if ((offset + len) > rd_length[minor]) {
@@ -148,7 +158,12 @@
   	 */
 
 	if (CURRENT->cmd == READ) 
+	{
 		memset(CURRENT->buffer, 0, len); 
+#ifdef JMT_RD
+		initrd_read(NULL,CURRENT->buffer,len,&pos);
+#endif
+	}
 	else	
 		set_bit(BH_Protected, &CURRENT->bh->b_state);
 
@@ -159,6 +174,8 @@
 static int rd_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
 {
 	int err;
+
+	printk("[.]in rd_ioctl\n");
 	
 	if (!inode || !inode->i_rdev) 	
 		return -EINVAL;
@@ -170,10 +187,12 @@
 			break;
          	case BLKGETSIZE:   /* Return device size */
 			if (!arg)  return -EINVAL;
+#ifndef JMT_RD
 			err = verify_area(VERIFY_WRITE, (long *) arg,
 					  sizeof(long));
 			if (err)
 				return err;
+#endif
 			put_user(rd_length[MINOR(inode->i_rdev)] / 512, 
 				 (long *) arg);
 			return 0;
@@ -198,6 +217,9 @@
 	if (count == 0) return 0;
 	copy_to_user(buf, (char *)initrd_start + *ppos, count);
 	*ppos += count;
+#if 0
+	printk("[?]initrd_read(~,%d,%d)\n",count,*ppos);
+#endif
 	return count;
 }
 
@@ -207,6 +229,11 @@
 	unsigned long i;
 
 	if (--initrd_users) return 0;
+
+#ifdef JMT_RD
+	return 0;
+#endif
+
 	for (i = initrd_start; i < initrd_end; i += PAGE_SIZE)
 		free_page(i);
 	initrd_start = 0;
@@ -230,9 +257,55 @@
 
 #endif
 
+#ifdef JMT_RD
+static int jmtrd_open(struct inode * inode, struct file * filp)
+{
+	printk("[*]jmtrd_open(%s)\n",kdevname(inode->i_rdev));
+
+	if (DEVICE_NR(inode->i_rdev) >= NUM_RAMDISKS)
+		return -ENXIO;
+
+	MOD_INC_USE_COUNT;
+
+	return 0;
+}
+
+static int jmtrd_release(struct inode * inode, struct file * filp)
+{
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+static struct file_operations jmtrd_fops = {
+	NULL,		/* lseek - default */
+	initrd_read,	/* read - initrd dev read */
+	NULL, /*block_write,	 write - block dev write */
+	NULL,		/* readdir - not here! */
+	NULL,		/* poll */
+	rd_ioctl, 	/* ioctl */
+	NULL,		/* mmap */
+	jmtrd_open,	/* open */
+	NULL,		/* flush */
+	jmtrd_release,	/* module needs to decrement use count */
+	block_fsync		/* fsync */ 
+};
+#endif
+
 
 static int rd_open(struct inode * inode, struct file * filp)
 {
+#ifdef JMT_RD
+	printk("[*]jmtrd_open(%s)\n",kdevname(inode->i_rdev));
+	if (MAJOR(inode->i_rdev)==RAMDISK_MAJOR && MINOR(inode->i_rdev)==0)
+	{
+		if (!initrd_start) return -ENODEV;
+		MOD_INC_USE_COUNT;
+		filp->f_op = &jmtrd_fops;
+		printk("[.]in rd_open\n");
+		return 0;
+	}
+#endif
+
 #ifdef CONFIG_BLK_DEV_INITRD
 	if (DEVICE_NR(inode->i_rdev) == INITRD_MINOR) {
 		if (!initrd_start) return -ENODEV;
@@ -256,9 +329,10 @@
 	return 0;
 }
 
+
 static struct file_operations fd_fops = {
 	NULL,		/* lseek - default */
-	block_read,	/* read - block dev read */
+	initrd_read,/*block_read,	 read - block dev read */
 	block_write,	/* write - block dev write */
 	NULL,		/* readdir - not here! */
 	NULL,		/* poll */
@@ -275,7 +349,11 @@
 {
 	int		i;
 
+#ifdef JMT_RD
+	if (register_blkdev(MAJOR_NR, "ramdisk", &jmtrd_fops)) {
+#else
 	if (register_blkdev(MAJOR_NR, "ramdisk", &fd_fops)) {
+#endif
 		printk("RAMDISK: Could not get major %d", MAJOR_NR);
 		return -EIO;
 	}
@@ -336,6 +414,52 @@
  *	romfs
  * 	gzip
  */
+
+int
+identify_romfs_image(void)
+{
+	const int size = 512;
+	struct romfs_super_block *romfsb;
+	int nblocks = -1;
+	unsigned char *buf;
+
+	int start_block=0;
+	loff_t pos;
+	pos=0;
+
+	buf = kmalloc(size, GFP_KERNEL);
+	if (buf == 0)
+		return -1;
+
+	romfsb = (struct romfs_super_block *) buf;
+	memset(buf, 0xe5, size);
+
+	/*
+	 * Read block 0 to test for romfs image
+	 */
+
+	initrd_read(NULL,buf,size,&pos);
+
+	/* romfs is at block zero too */
+	if (romfsb->word0 == ROMSB_WORD0 &&
+	    romfsb->word1 == ROMSB_WORD1) {
+		printk(KERN_NOTICE
+		       "RAMDISK: romfs filesystem found at block %d\n",
+		       start_block);
+		nblocks = (ntohl(romfsb->size)+BLOCK_SIZE-1)>>BLOCK_SIZE_BITS;
+		goto done;
+	}
+
+	printk(KERN_NOTICE
+	       "JMTRD: Couldn't find valid ROMFS disk image starting at %d.\n",
+	       start_block);
+	
+done:
+
+	kfree(buf);
+	return nblocks;
+}
+
 __initfunc(int
 identify_ramdisk_image(kdev_t device, struct file *fp, int start_block))
 {
@@ -346,6 +470,7 @@
 	int nblocks = -1;
 	unsigned char *buf;
 
+
 	buf = kmalloc(size, GFP_KERNEL);
 	if (buf == 0)
 		return -1;
@@ -361,7 +486,7 @@
 	if (fp->f_op->llseek)
 		fp->f_op->llseek(fp, start_block * BLOCK_SIZE, 0);
 	fp->f_pos = start_block * BLOCK_SIZE;
-	
+
 	fp->f_op->read(fp, buf, size, &fp->f_pos);
 
 	/*
@@ -429,6 +554,17 @@
 /*
  * This routine loads in the RAM disk image.
  */
+#ifdef JMT_RD
+__initfunc(static void rd_load_image(kdev_t device,int offset))
+{	
+	int nblocks;
+
+	nblocks=identify_romfs_image();
+
+	ROOT_DEV = MKDEV(MAJOR_NR,0);
+	printk("[*]jmtrd loaded %d blocks\n",nblocks);
+}
+#else
 __initfunc(static void rd_load_image(kdev_t device,int offset))
 {
  	struct inode inode, out_inode;
@@ -461,12 +597,18 @@
 	out_dentry.d_inode = &out_inode;
 
 	if (blkdev_open(&inode, &infile) != 0) return;
+
 	if (blkdev_open(&out_inode, &outfile) != 0) return;
 
 	fs = get_fs();
 	set_fs(KERNEL_DS);
-	
+#if 0
+	printk("identify_ramdisk_image\n");
+#endif
 	nblocks = identify_ramdisk_image(device, &infile, offset);
+#if 0
+	printk("#nblocks:#%d\n",nblocks);
+#endif
 	if (nblocks < 0)
 		goto done;
 
@@ -540,6 +682,9 @@
 
 successful_load:
 	invalidate_buffers(device);
+
+	printk("[*]old ROOT_DEV=%s\n",kdevname(ROOT_DEV));
+
 	ROOT_DEV = MKDEV(MAJOR_NR,0);
 
 done:
@@ -547,10 +692,11 @@
 		infile.f_op->release(&inode, &infile);
 	set_fs(fs);
 }
-
+#endif
 
 __initfunc(void rd_load(void))
 {
+
 	if (rd_doload == 0)
 		return;
 	
@@ -573,6 +719,9 @@
 #ifdef CONFIG_BLK_DEV_INITRD
 __initfunc(void initrd_load(void))
 {
+#if 0
+	printk("[+]rd_load_image()\n");
+#endif
 	rd_load_image(MKDEV(MAJOR_NR, INITRD_MINOR),0);
 }
 #endif
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/