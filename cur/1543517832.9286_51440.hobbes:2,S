Date: 04 Dec 1999 00:59:41 -0800
From: Dimitris Michailidis <>
Subject: Re: [patch] new spinlock variant, spinlock-2.3.30-A4
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/12/4/13

Andrea Arcangeli <andrea@suse.de> writes:
> On Sat, 4 Dec 1999, Manfred wrote:
> 
> >This means that the following could happen:
> >
> >cpu1           memory                         cpu2
> >                       A=0
> > A=1
>   XXX
> >* into buffer
> >*                                                  A=0
> >*                                                  * cpu2 is a snob
> >*                                                  * with a short buffer ;)
> >*                                                  * my test program
> >*                                                  *uses a rmb()
> >*                                                  * to trigger that.
> >*                       A=0 <--------
> >*
> >* cpu1 is lazy
> >*
> >*
> >------> A=1
>          YYY
> >
> >As you see, although cpu2 has executed it's instruction after
> >cpu1, the value from cpu1 'wins'.
> 
> That's not a problem. You have no garantee that the instruction will
> happen at line XXX. So if it happens at XXX and you see it at YYY, you can
> just assume the CPU executed the instruction at line YYY and you can as
> well ignore the write buffer.
It is a problem because cpu1 sees it as if it has happened at XXX while cpu2
sees it at YYY.  Manfred is right in saying that Ingo's locks do not
guarantee mutual exclusion (I've mentioned it to Ingo in private email).  Any 
number of CPUs may acquire his lock just because they see only their own
writes.
> But if a read happens between XXX and YYY, then - to preserve processor
> ordering - the hardware should invalidate such a speculative read if
> another CPU changed the value that we read in speculative mode before YYY.
> It seems to me the speculative read is not invalidated.
> 
> The point is that a read should be considered speculative (waiting to be
> invalidated) until the write is _visible_ to all the other CPUs.
It doesn't work this way.  Stores can be forwarded to reads within a CPU
before they become externally visible.  Your suggestion would considerably
hurt SMP performance.
-- 
Dimitris Michailidis                    dimitris@engr.sgi.com
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/