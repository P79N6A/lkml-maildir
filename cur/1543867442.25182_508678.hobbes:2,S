Date: Wed, 14 Feb 2007 09:17:50 -0800 (PST)
From: Davide Libenzi <>
Subject: Re: [patch 00/11] ANNOUNCE: "Syslets", generic asynchronous system call support
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/2/14/139

On Wed, 14 Feb 2007, Ingo Molnar wrote:
> 
> * Evgeniy Polyakov <johnpol@2ka.mipt.ru> wrote:
> 
> > Let me clarify what I meant. There is only limited number of threads, 
> > which are supposed to execute blocking context, so when all they are 
> > used, main one will block too - I asked about possibility to reuse the 
> > same thread to execute queue of requests attached to it, each request 
> > can block, but if blocking issue is removed, it would be possible to 
> > return.
> 
> ah, ok, i understand your point. This is not quite possible: the 
> cachemisses are driven from schedule(), which can be arbitraily deep 
> inside arbitrary system calls. It can be in a mutex_lock() deep inside a 
> driver. It can be due to a alloc_pages() call done by a kmalloc() call 
> done from within ext3, which was called from the loopback block driver, 
> which was called from XFS, which was called from a VFS syscall.
> 
> Even if it were possible to backtrack i'm quite sure we dont want to do 
> this, for three main reasons:
IMO it'd be quite simple. We detect the service-thread full condition, 
*before* entering exec_atom and we queue the atom in an async_head request 
list. Yes, there is the chance that from the test time in sys_async_exec, 
to the time we'll end up entering exec_atom and down to schedule, one 
of the threads would become free, but IMO better that blocking 
sys_async_exec.
- Davide
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/