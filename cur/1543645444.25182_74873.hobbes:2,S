Date: Mon, 30 Sep 2002 12:26:48 +0400
From: Oleg Drokin <>
Subject: Re: make UML to compile in 2.5 bk-curr
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2002/9/30/38

Hello!
On Mon, Sep 30, 2002 at 12:12:48PM +0400, Oleg Drokin wrote:
>    After MIngo's patches named "atomic-thread-signals" and "tq_struct removal
>    fixups.." were merged into bk current, patch below is necessary for
>    UML to compile.
And here is forgotten patch.
===== arch/um/drivers/chan_kern.c 1.1 vs edited =====
--- 1.1/arch/um/drivers/chan_kern.c	Fri Sep  6 21:29:28 2002
+++ edited/arch/um/drivers/chan_kern.c	Mon Sep 30 11:49:05 2002
@@ -409,7 +409,7 @@
 		do {
 			if((tty != NULL) && 
 			   (tty->flip.count >= TTY_FLIPBUF_SIZE)){
-				queue_task(task, &tq_timer);
+				schedule_task(task);
 				goto out;
 			}
 			err = chan->ops->read(chan->fd, &c, chan->data);
===== arch/um/kernel/signal_kern.c 1.1 vs edited =====
--- 1.1/arch/um/kernel/signal_kern.c	Thu Sep 12 16:22:53 2002
+++ edited/arch/um/kernel/signal_kern.c	Mon Sep 30 11:56:06 2002
@@ -101,12 +101,12 @@
 		ka->sa.sa_handler = SIG_DFL;
 
 	if (!(ka->sa.sa_flags & SA_NODEFER)) {
-		spin_lock_irq(&current->sigmask_lock);
+		spin_lock_irq(&current->sig->siglock);
 		sigorsets(&current->blocked, &current->blocked, 
 			  &ka->sa.sa_mask);
 		sigaddset(&current->blocked, signr);
 		recalc_sigpending();
-		spin_unlock_irq(&current->sigmask_lock);
+		spin_unlock_irq(&current->sig->siglock);
 	}
 
 	sp = PT_REGS_SP(regs);
@@ -188,11 +188,11 @@
 	sigset_t saveset;
 
 	mask &= _BLOCKABLE;
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sig->siglock);
 	saveset = current->blocked;
 	siginitset(&current->blocked, mask);
 	recalc_sigpending();
-	spin_unlock_irq(&current->sigmask_lock);
+	spin_unlock_irq(&current->sig->siglock);
 
 	while (1) {
 		current->state = TASK_INTERRUPTIBLE;
@@ -214,11 +214,11 @@
 		return -EFAULT;
 	sigdelsetmask(&newset, ~_BLOCKABLE);
 
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sig->siglock);
 	saveset = current->blocked;
 	current->blocked = newset;
 	recalc_sigpending();
-	spin_unlock_irq(&current->sigmask_lock);
+	spin_unlock_irq(&current->sig->siglock);
 
 	while (1) {
 		current->state = TASK_INTERRUPTIBLE;
@@ -234,13 +234,13 @@
 	void *mask = sp_to_mask(PT_REGS_SP(&regs));
 	int sig_size = (_NSIG_WORDS - 1) * sizeof(unsigned long);
 
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sig->siglock);
 	copy_from_user(&current->blocked.sig[0], sc_sigmask(sc), 
 		       sizeof(current->blocked.sig[0]));
 	copy_from_user(&current->blocked.sig[1], mask, sig_size);
 	sigdelsetmask(&current->blocked, ~_BLOCKABLE);
 	recalc_sigpending();
-	spin_unlock_irq(&current->sigmask_lock);
+	spin_unlock_irq(&current->sig->siglock);
 	copy_sc_from_user(current->thread.regs.regs.sc, sc,
 			  &signal_frame_sc.arch);
 	return(PT_REGS_SYSCALL_RET(&current->thread.regs));
@@ -252,11 +252,11 @@
 	void *mask = sp_to_rt_mask(PT_REGS_SP(&regs));
 	int sig_size = _NSIG_WORDS * sizeof(unsigned long);
 
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sig->siglock);
 	copy_from_user(&current->blocked, mask, sig_size);
 	sigdelsetmask(&current->blocked, ~_BLOCKABLE);
 	recalc_sigpending();
-	spin_unlock_irq(&current->sigmask_lock);
+	spin_unlock_irq(&current->sig->siglock);
 	copy_sc_from_user(current->thread.regs.regs.sc, sc,
 			  &signal_frame_sc.arch);
 	return(PT_REGS_SYSCALL_RET(&current->thread.regs));
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/