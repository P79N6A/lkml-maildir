Date: Sun, 08 Jul 2007 21:46:02 +1000
From: Rusty Russell <>
Subject: maps2-add-proc-kpagemap-interface.patch
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/7/8/49

> + * Each entry is a pair of unsigned longs representing the
> + * corresponding physical page, the first containing the page flags
> + * and the second containing the page use count.
> + *
> + * The first 4 bytes of this file form a simple header:
> + *
> + * first byte:   0 for big endian, 1 for little
> + * second byte:  page shift (eg 12 for 4096 byte pages)
> + * third byte:   entry size in bytes (currently either 4 or 8)
> + * fourth byte:  header size
Hi Matt,
	This comment is worded badly: if the "entry is a pair" then "entry size
in bytes" would be 8 or 16.
> +	pfn = src / KPMSIZE - 1;
> +	count = min_t(size_t, count, ((max_pfn + 1) * KPMSIZE) - src);
Is min_t required here?  KPMSIZE is a sizeof() expression, so I'd expect
both sides to be type-compatible...
> +	page = (unsigned long *)__get_free_page(GFP_USER);
> +	if (!page)
> +		return -ENOMEM;
An explicit "struct kpagemap { unsigned long flags, count; };" would
simplify your iteration, clear up the code and get rid of the KPMSIZE &
KPMMASK macros.
But again I'd query the necessity of this cache page at all.
> +		if (copy_to_user(buf, page, chunk)) {
> +			ret = -EFAULT;
> +			break;
> +		}
> +		ret += chunk;
> +		src += chunk;
> +		buf += chunk;
> +		count -= chunk;
> +		cond_resched();
No cond_resched() needed here, either.
Cheers,
Rusty.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/