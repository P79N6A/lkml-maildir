Date: Sat, 13 Mar 2004 18:14:01 +0100
From: <>
Subject: Re: RE: Kernel 2.6.3 patch for Intel Compiler 8.0
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2004/3/13/54

Hi Jun,
thanks for the script, I'll check it out.
First of all, I am using icc 8.0 (Build 20031016Z Package ID:
l_cc_p_8.0.055) and encountered several problems with the compiler and
Linux kernel 2.6.3.
1.) icc sometimes interprets assembler constraints for inline assembly
in the wrong way (I will check my disk for a sample to prove it).
2.) is it right that the "-fno-common" switch of icc is incompatible to
that of gcc and generates common variables, e.g. in modules?
3.) arch/i386/lib/dec_and_lock.c: I attached the wrong assembler version
generated by icc (with comments).
btw: Could you supply me with the PGO kernel driver for icc, or: where
can I find it?
Rgs, Ingo.
"Nakajima, Jun" <jun.nakajima@intel.com> schrieb am 12.03.2004,
23:31:02:
> Ingo, Hi
> 
> We tried it (2.6.4) our side. As long as we tested, we did not need _any
> changes_ to the kernel tree, and I guess what you are missing is a shell
> script that calls icc converting the GCC specific options to Intel
> compiler.
> 
> Attached is the script. Just type "make CC=kicc" for example.
> 
> Can you be more specific about the issue with dec_and_lock.c?
> 
> Jun
>
        .globl atomic_dec_and_lock
atomic_dec_and_lock:
# parameter 1: 28 + %esp (atomic)
# parameter 2: 32 + %esp (lock)
..B1.1:
  pushl     %esi
  pushl     %ebx
  subl      $16, %esp
  movl      28(%esp), %ebx      # %ebx = atomic
..B1.2:
  movl      (%ebx), %esi        # %esi = atomic->counter
  movl      %esi, (%esp)        # (%esp) = counter
  addl      $-1, %esi           # %esi = newcount
  je        ..B1.5
..B1.3:
  movl      (%ebx), %ecx        # %ecx = atomic->counter
  movl      (%esp), %edx        # %edx = counter
  movl      %ecx, 12(%esp)      # 12(%esp) = DUPLICATE OF
                                # atomic->counter (BUG!)
  movl      %edx, %eax          # %eax = counter
                                # inline param: "0" (counter)
# Begin ASM
  lock; cmpxchgl %esi,12(%esp)  # %1 = %esi = newcount
                                # %2 = 12(%esp) = DUPLCATE OF
                                # atomic->counter (BUG!)
# End ASM
  cmpl      %edx, %eax
  jne       ..B1.2
..B1.4:
  xorl      %eax, %eax
  addl      $16, %esp
  popl      %ebx
  popl      %esi
  ret
..B1.5: