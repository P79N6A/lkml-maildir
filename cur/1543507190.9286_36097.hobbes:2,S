Date: Fri, 27 Aug 1999 14:55:08 +0100
From: "Stephen Creswell" <>
Subject: Module use count problems with forked processes
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/8/27/41

Hi,
I have written a char-device driver module for a data-acquisition card
(based heavily on examples courtesy of A. Rubini's excellent book).
I am running RedHat 6.0 (2.2.5-15 kernel) and manually loading and
unloading the driver module from the kernel.
The problem I am experiencing is in a small application which spawns
child processes to handle network socket based access to the
data-acquisition file interface.  The /dev/* files are opened by the
parent process prior to any child process being forked which increments
the use count (n) seen in /proc/modules - OK so far.  When the child
process completes, it decrements the module use count back down to 0
which means that the use count goes down to -n when the parent process
exits!  I am then left unable to unload the module.
According to documentation in A. Rubini's book and elsewhere, the
forking of the child process does not "open" the device driver files
(they are "dup"ed) and should increment the shared file struct use
count.  The child process (when exiting) "closes" the file descriptors
which it inherited but does not call the the module "release" function
as the file struct use count will not be 0.
This all seems logical but would not appear to be happening.
Has anyone got any ideas, information sources they could recommend?
Thanks in advance,
Stephen Creswell
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/