Date: Tue, 17 Oct 2006 08:34:47 -0700
From: "Yinghai Lu" <>
Subject: Re: [PATCH] x86_64: store Socket ID in phys_proc_id
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/10/17/147

Current code store phys_proc_id with init APIC ID, and later will change
to apicid>>bits.
So for the apic id lifted system, for example BSP with apicid 0x10, the
phys_proc_id will be 8.
This patch use initial APIC ID to get Socket ID.
It also removed ht_nodeid calculating, because We already have correct
socket id for sure.
Signed-off-by: Yinghai Lu <yinghai.lu@amd.com>
diff --git a/arch/x86_64/kernel/setup.c b/arch/x86_64/kernel/setup.c
index fc944b5..d30f78a 100644
--- a/arch/x86_64/kernel/setup.c
+++ b/arch/x86_64/kernel/setup.c
@@ -643,34 +643,20 @@ #endif
 
 	/* Low order bits define the core id (index of core in socket) */
 	c->cpu_core_id = c->phys_proc_id & ((1 << bits)-1);
-	/* Convert the APIC ID into the socket ID */
-	c->phys_proc_id = phys_pkg_id(bits);
+	/* Convert the initial APIC ID into the socket ID */
+	c->phys_proc_id >>= bits; 
 
 #ifdef CONFIG_NUMA
   	node = c->phys_proc_id;
  	if (apicid_to_node[apicid] != NUMA_NO_NODE)
  		node = apicid_to_node[apicid];
  	if (!node_online(node)) {
- 		/* Two possibilities here:
- 		   - The CPU is missing memory and no node was created.
- 		   In that case try picking one from a nearby CPU
- 		   - The APIC IDs differ from the HyperTransport node IDs
- 		   which the K8 northbridge parsing fills in.
- 		   Assume they are all increased by a constant offset,
- 		   but in the same order as the HT nodeids.
- 		   If that doesn't result in a usable node fall back to the
- 		   path for the previous case.  */
- 		int ht_nodeid = apicid - (cpu_data[0].phys_proc_id << bits);
- 		if (ht_nodeid >= 0 &&
- 		    apicid_to_node[ht_nodeid] != NUMA_NO_NODE)
- 			node = apicid_to_node[ht_nodeid];
  		/* Pick a nearby node */
- 		if (!node_online(node))
- 			node = nearby_node(apicid);
+		node = nearby_node(apicid);
  	}
 	numa_set_node(cpu, node);
 
-	printk(KERN_INFO "CPU %d/%x -> Node %d\n", cpu, apicid, node);
+	printk(KERN_INFO "CPU %d/0x%02x -> Node %d\n", cpu, apicid, node);
 #endif
 #endif
 }
@@ -928,7 +914,7 @@ void __cpuinit early_identify_cpu(struct
 	}
 
 #ifdef CONFIG_SMP
-	c->phys_proc_id = (cpuid_ebx(1) >> 24) & 0xff;
+	c->phys_proc_id = (cpuid_ebx(1) >> 24) & 0xff; /* initial APIC ID */
 #endif
 }
 
@@ -1136,6 +1122,7 @@ #endif
 #ifdef CONFIG_SMP
 	if (smp_num_siblings * c->x86_max_cores > 1) {
 		int cpu = c - cpu_data;
+		seq_printf(m, "apic id\t\t: 0x%02x\n", x86_cpu_to_apicid[cpu]);
 		seq_printf(m, "physical id\t: %d\n", c->phys_proc_id);
 		seq_printf(m, "siblings\t: %d\n", cpus_weight(cpu_core_map[cpu]));
 		seq_printf(m, "core id\t\t: %d\n", c->cpu_core_id);