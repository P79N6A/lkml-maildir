Date: 11 Jul 1999 19:50:11 +0200
From: Jes Sorensen <>
Subject: Re: interrupt handling w/o handler?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/7/12/13

>>>>> "Mark" == Mark Lord <mlord@pobox.com> writes:
Mark> Jes Sorensen wrote:
>> You have to register a handler for thaat, otherwise how are you
>> guaranteed that the interrupt is handled and the hardware doesn't
>> keep reasserting the same interrupt over and over again.
Mark> I think Jeff might be looking for a function such as:
Mark> interruptable_sleep_on_irq(n): -- allocate unused irq(n), bind
Mark> in generic_irqhandler(n) -- save PID in wakeuptable(n) -- unmask
Mark> irq(n) -- sleep until woken up by generic_irqhandler(n) --
Mark> deallocate irq(n) -- exit
Which is generally not a good solution because you will have to call
disable_irq(source) to do it in a generic way. That would of course be
a problem in itself if the irq is shared, which easily happens with
the lack of interrupts on the x86, and which is the normal case on
some architectures. The real problem however is the disable_irq()
sucks as it has to go across all processors on SMP.
The only decent way to do this is to register an irq handler that can
shut up the interrupt source by acknowledging it properly instead of
calling disable_irq().
Jes
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/