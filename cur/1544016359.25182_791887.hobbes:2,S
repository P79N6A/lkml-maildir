Date: Wed, 14 Jan 2009 11:17:57 +0100
From: Eric Dumazet <>
Subject: Re: maximum buffer size for splice(2) tcp->pipe?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2009/1/14/128

Volker Lendecke a Ã©crit :
> On Wed, Jan 14, 2009 at 10:13:34AM +0100, Eric Dumazet wrote:
>> for (;;) {
>> 	struct pollfd pfd;
>> 	pfd.fd = socket;
>> 	pfd.events = POLLIN;
>> 	if (poll(&pfd, 1, -1) != 1)
>> 		continue;
>> 	res = splice(socket, NULL, pipefds[1], NULL, 65536, SPLICE_F_MOVE|SPLICE_F_NONBLOCK);
>> 	if (res > 0)
>> 		nwritten = splice(pipefds[0], NULL, file_fd, NULL, res, SPLICE_F_MOVE|SPLICE_F_MORE);
>> }
> 
> Doesn't this reduce performance again? I thought the whole
> point of splice() was to increase performance by avoiding
> memory copies. If I have to do a poll syscall for each call
> to splice, doesn't the context switch eat that performance
> advantage again?
> 
> Or was splice designed only for multi-threaded applications
> (which at least Samba is not)?
> 
> Volker
splice() avoids memory copies yes, but on typical 1460 bytes
frames its a small gain.
But if no data is available on socket,
you still have to wait (and have a context switch later).
Waiting in poll() or splice() has same context switch cost.
Only cost is the extra syscall of course, but it is mandatory
if you want to avoid a possible deadlock in current splice()
implementation.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/