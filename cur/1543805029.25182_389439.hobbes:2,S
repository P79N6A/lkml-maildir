Date: Mon, 23 Jan 2006 15:54:01 -0800
From: Andrew Morton <>
Subject: Re: [patch] fix O_DIRECT read of last block in a sparse file
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/1/23/310

Jeff Moyer <jmoyer@redhat.com> wrote:
>
> Currently, if you open a file O_DIRECT, truncate it to a size that is not a
>  multiple of the disk block size, and then try to read the last block in the
>  file, the read will return 0.  The problem is in do_direct_IO, here:
> 
>          /* Handle holes */
>          if (!buffer_mapped(map_bh)) {
>                  char *kaddr;
> 
>  		...
> 
>                  if (dio->block_in_file >=
>                          i_size_read(dio->inode)>>blkbits) {
>                          /* We hit eof */
>                          page_cache_release(page);
>                          goto out;
>                  }
> 
>  We shift off any remaining bytes in the final block of the I/O, resulting
>  in a 0-sized read.  I've attached a patch that fixes this.  I'm not happy
>  about how ugly the math is getting, so suggestions are more than welcome.
> 
>  I've tested this with a simple program that performs the steps outlined for
>  reproducing the problem above.  Without the patch, we get a 0-sized result
>  from read.  With the patch, we get the correct return value from the short
>  read.
OK.  We do have some helper functions to make the math a little clearer. 
How does this look?
--- devel/fs/direct-io.c~fix-o_direct-read-of-last-block-in-a-sparse-file	2006-01-23 15:42:31.000000000 -0800
+++ devel-akpm/fs/direct-io.c	2006-01-23 15:51:14.000000000 -0800
@@ -857,6 +857,7 @@ do_holes:
 			/* Handle holes */
 			if (!buffer_mapped(map_bh)) {
 				char *kaddr;
+				loff_t i_size_aligned;
 
 				/* AKPM: eargh, -ENOTBLK is a hack */
 				if (dio->rw == WRITE) {
@@ -864,8 +865,14 @@ do_holes:
 					return -ENOTBLK;
 				}
 
+				/*
+				 * Be sure to account for a partial block as the
+				 * last block in the file
+				 */
+				i_size_aligned = ALIGN(i_size_read(dio->inode),
+							1 << blkbits);
 				if (dio->block_in_file >=
-					i_size_read(dio->inode)>>blkbits) {
+						i_size_aligned >> blkbits) {
 					/* We hit eof */
 					page_cache_release(page);
 					goto out;
_
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/