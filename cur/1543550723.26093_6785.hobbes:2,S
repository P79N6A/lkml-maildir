Date: Thu, 5 Oct 2000 18:10:37 +0200
From: Torben Mathiasen <>
Subject: [PATCH] Link order of drivers outside drivers/scsi
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/10/5/27

Linus,
This patch is a resend of my other link fix patch that didn't get
in test9-pre9. I assume this is because of some other changes
to upper layer scsi drivers.
This patch is a lot smaller because the "moving files around" part
has been omittet.
So please apply this patch and do the following:
	copy sd.c sg.c sr.c sr_ioctl.c sr_vendor st.c to
	drivers/scsi/upper
I really hope you don't mind this way of applying a patch, so if
you do please let me know. The patch still includes the I2O
fixes (verified by Alan).
BTW. To fix other drivers outside drivers/scsi to link corretly
they need the same changes as I2O: 
	convert to initcalls
	move them in top makefile.
I just need to identify which drivers needs this.
-- 
Torben Mathiasen <tmm@kernel.dk>
Linux ThunderLAN maintainer 
http://tlan.kernel.dk
diff -urN linux-test9/Makefile linux/Makefile
--- linux-test9/Makefile	Tue Oct  3 23:39:53 2000
+++ linux/Makefile	Tue Oct  3 23:38:41 2000
@@ -144,7 +144,13 @@
 DRIVERS-$(CONFIG_ARCNET) += drivers/net/arcnet/arcnet.a
 DRIVERS-$(CONFIG_ATM) += drivers/atm/atm.o
 DRIVERS-$(CONFIG_IDE) += drivers/ide/idedriver.o
+
+# Init ordering constraint:
+# scsidrv.o < !drivers/scsi < scsi_upper.o
 DRIVERS-$(CONFIG_SCSI) += drivers/scsi/scsidrv.o
+DRIVERS-$(CONFIG_I2O) += drivers/i2o/i2o.o
+DRIVERS-$(CONFIG_SCSI) += drivers/scsi/upper/scsi_upper.o
+
 DRIVERS-$(CONFIG_IEEE1394) += drivers/ieee1394/ieee1394.a
 
 ifneq ($(CONFIG_CD_NO_IDESCSI)$(CONFIG_BLK_DEV_IDECD)$(CONFIG_BLK_DEV_SR)$(CONFIG_PARIDE_PCD),)
@@ -171,7 +177,6 @@
 DRIVERS-$(CONFIG_TC) += drivers/tc/tc.a
 DRIVERS-$(CONFIG_USB) += drivers/usb/usbdrv.o
 DRIVERS-$(CONFIG_INPUT) += drivers/input/inputdrv.o
-DRIVERS-$(CONFIG_I2O) += drivers/i2o/i2o.o
 DRIVERS-$(CONFIG_IRDA) += drivers/net/irda/irda.o
 DRIVERS-$(CONFIG_I2C) += drivers/i2c/i2c.o
 DRIVERS-$(CONFIG_PHONE) += drivers/telephony/telephony.o
diff -urN linux-test9/drivers/block/genhd.c linux/drivers/block/genhd.c
--- linux-test9/drivers/block/genhd.c	Tue Oct  3 23:39:58 2000
+++ linux/drivers/block/genhd.c	Tue Oct  3 23:38:41 2000
@@ -27,7 +27,6 @@
 extern void console_map_init(void);
 extern int soc_probe(void);
 extern int atmdev_init(void);
-extern int i2o_init(void);
 extern int cpqarray_init(void);
 extern void ieee1394_init(void);
 
@@ -39,9 +38,6 @@
 	chr_dev_init();
 	blk_dev_init();
 	sti();
-#ifdef CONFIG_I2O
-	i2o_init();
-#endif
 #ifdef CONFIG_BLK_DEV_DAC960
 	DAC960_Initialize();
 #endif
diff -urN linux-test9/drivers/i2o/i2o_block.c linux/drivers/i2o/i2o_block.c
--- linux-test9/drivers/i2o/i2o_block.c	Tue Oct  3 23:40:13 2000
+++ linux/drivers/i2o/i2o_block.c	Tue Oct  3 23:38:41 2000
@@ -46,6 +46,7 @@
 #include <linux/fs.h>
 #include <linux/stat.h>
 #include <linux/errno.h>
+#include <linux/init.h>
 #include <linux/file.h>
 #include <linux/ioctl.h>
 #include <linux/i2o.h>
@@ -108,6 +109,7 @@
 #define I2O_BSA_DSC_VOLUME_CHANGED      0x000D
 #define I2O_BSA_DSC_TIMEOUT             0x000E
 
+
 /*
  *	Some of these can be made smaller later
  */
@@ -1591,11 +1593,7 @@
  *  (Just smiley confuses emacs :-)
  */
 
-#ifdef MODULE
-#define i2o_block_init init_module
-#endif
-
-int i2o_block_init(void)
+static int __init i2o_block_init(void)
 {
 	int i;
 
@@ -1611,9 +1609,8 @@
 		       MAJOR_NR);
 		return -EIO;
 	}
-#ifdef MODULE
+	
 	printk(KERN_INFO "i2o_block: registered device at major %d\n", MAJOR_NR);
-#endif
 
 	/*
 	 *	Now fill in the boiler plate
@@ -1694,13 +1691,7 @@
 	return 0;
 }
 
-#ifdef MODULE
-
-EXPORT_NO_SYMBOLS;
-MODULE_AUTHOR("Red Hat Software");
-MODULE_DESCRIPTION("I2O Block Device OSM");
-
-void cleanup_module(void)
+static void __exit i2o_block_exit(void)
 {
 	struct gendisk **gdp;
 	int i;
@@ -1760,4 +1751,11 @@
 			break;
 
 }
-#endif
+
+EXPORT_NO_SYMBOLS;
+MODULE_AUTHOR("Red Hat Software");
+MODULE_DESCRIPTION("I2O Block Device OSM");
+
+module_init(i2o_block_init);
+module_exit(i2o_block_exit);
+
diff -urN linux-test9/drivers/i2o/i2o_config.c linux/drivers/i2o/i2o_config.c
--- linux-test9/drivers/i2o/i2o_config.c	Tue Oct  3 23:40:13 2000
+++ linux/drivers/i2o/i2o_config.c	Tue Oct  3 23:38:41 2000
@@ -910,11 +910,7 @@
 	&config_fops
 };	
 
-#ifdef MODULE
-int init_module(void)
-#else
-int __init i2o_config_init(void)
-#endif
+static int __init i2o_config_init(void)
 {
 	printk(KERN_INFO "I2O configuration manager v 0.04.\n");
 	printk(KERN_INFO "  (C) Copyright 1999 Red Hat Software\n");
@@ -948,9 +944,7 @@
 	return 0;
 }
 
-#ifdef MODULE
-
-void cleanup_module(void)
+void __exit i2o_config_exit(void)
 {
 	misc_deregister(&i2o_miscdev);
 	
@@ -961,9 +955,11 @@
 	if(i2o_buffer)
 		kfree(i2o_buffer);
 }
+
+module_init(i2o_config_init);
+module_exit(i2o_config_exit);
  
 EXPORT_NO_SYMBOLS;
 MODULE_AUTHOR("Red Hat Software");
 MODULE_DESCRIPTION("I2O Configuration");
 
-#endif
diff -urN linux-test9/drivers/i2o/i2o_core.c linux/drivers/i2o/i2o_core.c
--- linux-test9/drivers/i2o/i2o_core.c	Tue Oct  3 23:40:13 2000
+++ linux/drivers/i2o/i2o_core.c	Tue Oct  3 23:38:41 2000
@@ -19,7 +19,7 @@
  *		Auvo HÃ¤kkinen <Auvo.Hakkinen@cs.Helsinki.FI> 
  *		Deepak Saxena <deepak@plexity.net> 
  *		Boji T Kannanthanam <boji.t.kannanthanam@intel.com>
- * 
+ *		Torben Mathiasen <torben@kernel.dk> 
  */
 
 #include <linux/config.h>
@@ -119,7 +119,6 @@
  */
 static spinlock_t i2o_dev_lock = SPIN_LOCK_UNLOCKED;
 
-#ifdef MODULE
 /* 
  * Function table to send to bus specific layers
  * See <include/linux/i2o.h> for explanation of this
@@ -134,12 +133,9 @@
 	i2o_delete_controller
 };
 
-#ifdef CONFIG_I2O_PCI_MODULE
 extern int i2o_pci_core_attach(struct i2o_core_func_table *);
 extern void i2o_pci_core_detach(void);
-#endif /* CONFIG_I2O_PCI_MODULE */
 
-#endif /* MODULE */
 
 /*
  * Structures and definitions for synchronous message posting.
@@ -3115,8 +3111,6 @@
 }
 
 
-#ifdef MODULE
-
 EXPORT_SYMBOL(i2o_controller_chain);
 EXPORT_SYMBOL(i2o_num_controllers);
 EXPORT_SYMBOL(i2o_find_controller);
@@ -3152,8 +3146,7 @@
 MODULE_AUTHOR("Red Hat Software");
 MODULE_DESCRIPTION("I2O Core");
 
-
-int init_module(void)
+static int __init init_i2o(void)
 {
 	printk(KERN_INFO "I2O Core - (C) Copyright 1999 Red Hat Software\n");
 	if (i2o_install_handler(&i2o_core_handler) < 0)
@@ -3168,10 +3161,8 @@
 	/*
 	 * Attach core to I2O PCI transport (and others as they are developed)
 	 */
-#ifdef CONFIG_I2O_PCI_MODULE
 	if(i2o_pci_core_attach(&i2o_core_functions) < 0)
 		printk(KERN_INFO "i2o: No PCI I2O controllers found\n");
-#endif
 
 	/*
 	 * Initialize event handling thread
@@ -3195,7 +3186,7 @@
 	return 0;
 }
 
-void cleanup_module(void)
+static void __exit exit_i2o(void)
 {
 	int stat;
 
@@ -3221,72 +3212,14 @@
 		}
 	}
 
-#ifdef CONFIG_I2O_PCI_MODULE
 	i2o_pci_core_detach();
-#endif
 
 	i2o_remove_handler(&i2o_core_handler);
 
 	unregister_reboot_notifier(&i2o_reboot_notifier);
 }
 
-#else
-
-extern int i2o_block_init(void);
-extern int i2o_config_init(void);
-extern int i2o_lan_init(void);
-extern int i2o_pci_init(void);
-extern int i2o_proc_init(void);
-extern int i2o_scsi_init(void);
-
-int __init i2o_init(void)
-{
-	printk(KERN_INFO "Loading I2O Core - (c) Copyright 1999 Red Hat Software\n");
-	
-	if (i2o_install_handler(&i2o_core_handler) < 0)
-	{
-		printk(KERN_ERR 
-			"i2o_core: Unable to install core handler.\nI2O stack not loaded!");
-		return 0;
-	}
-
-	core_context = i2o_core_handler.context;
-
-	/*
-	 * Initialize event handling thread
-	 * We may not find any controllers, but still want this as 
-	 * down the road we may have hot pluggable controllers that
-	 * need to be dealt with.
-	 */	
-	init_MUTEX_LOCKED(&evt_sem);
-	if((evt_pid = kernel_thread(i2o_core_evt, &evt_reply, CLONE_SIGHAND)) < 0)
-	{
-		printk(KERN_ERR "I2O: Could not create event handler kernel thread\n");
-		i2o_remove_handler(&i2o_core_handler);
-		return 0;
-	}
-
+module_init(init_i2o);
+module_exit(exit_i2o);
 
-#ifdef CONFIG_I2O_PCI
-	i2o_pci_init();
-#endif
 
-	if(i2o_num_controllers)
-		i2o_sys_init();
-
-	register_reboot_notifier(&i2o_reboot_notifier);
-
-	i2o_config_init();
-#ifdef CONFIG_I2O_BLOCK
-	i2o_block_init();
-#endif
-#ifdef CONFIG_I2O_LAN
-	i2o_lan_init();
-#endif
-#ifdef CONFIG_I2O_PROC
-	i2o_proc_init();
-#endif
-	return 0;
-}
-
-#endif
diff -urN linux-test9/drivers/i2o/i2o_lan.c linux/drivers/i2o/i2o_lan.c
--- linux-test9/drivers/i2o/i2o_lan.c	Tue Oct  3 23:40:13 2000
+++ linux/drivers/i2o/i2o_lan.c	Tue Oct  3 23:38:41 2000
@@ -1421,11 +1421,8 @@
 	return dev;
 }
 
-#ifdef MODULE
-#define i2o_lan_init	init_module
-#endif
 
-int __init i2o_lan_init(void)
+static int __init i2o_lan_init(void)
 {
 	struct net_device *dev;
 	int i;
@@ -1506,9 +1503,8 @@
 	return 0;
 }
 
-#ifdef MODULE
 
-void cleanup_module(void)
+static void __exit i2o_lan_exit(void)
 {
 	int i;
 
@@ -1565,4 +1561,5 @@
 MODULE_PARM(tx_batch_mode, "0-2" "i");
 MODULE_PARM_DESC(tx_batch_mode, "0=Send immediatelly, 1=Send in batches, 2=Switch automatically");
 
-#endif
+module_init(i2o_lan_init);
+module_exit(i2o_lan_exit);
diff -urN linux-test9/drivers/i2o/i2o_pci.c linux/drivers/i2o/i2o_pci.c
--- linux-test9/drivers/i2o/i2o_pci.c	Tue Oct  3 23:40:13 2000
+++ linux/drivers/i2o/i2o_pci.c	Tue Oct  3 23:38:41 2000
@@ -31,7 +31,6 @@
 #include <asm/mtrr.h>
 #endif // CONFIG_MTRR
 
-#ifdef MODULE
 /*
  * Core function table
  * See <include/linux/i2o.h> for an explanation
@@ -41,7 +40,6 @@
 /* Core attach function */
 extern int i2o_pci_core_attach(struct i2o_core_func_table *);
 extern void i2o_pci_core_detach(void);
-#endif /* MODULE */
 
 /*
  *	Free bus specific resources
@@ -304,8 +302,6 @@
 }
 #endif // I2O_HOTPLUG_SUPPORT
 
-#ifdef MODULE
-
 int i2o_pci_core_attach(struct i2o_core_func_table *table)
 {
 	MOD_INC_USE_COUNT;
@@ -322,7 +318,7 @@
 	MOD_DEC_USE_COUNT;
 }
 
-int init_module(void)
+static int __init i2o_pci_init(void)
 {
 	printk(KERN_INFO "Linux I2O PCI support (c) 1999 Red Hat Software.\n");
 	
@@ -332,20 +328,16 @@
  
 }
 
-void cleanup_module(void)
+static void __exit i2o_pci_exit(void)
 {
 }
 
+module_init(i2o_pci_init);
+module_exit(i2o_pci_exit);
+
 EXPORT_SYMBOL(i2o_pci_core_attach);
 EXPORT_SYMBOL(i2o_pci_core_detach);
 
 MODULE_AUTHOR("Red Hat Software");
 MODULE_DESCRIPTION("I2O PCI Interface");
 
-#else
-void __init i2o_pci_init(void)
-{
-	printk(KERN_INFO "Linux I2O PCI support (c) 1999 Red Hat Software.\n");
-	i2o_pci_scan();
-}
-#endif
diff -urN linux-test9/drivers/i2o/i2o_proc.c linux/drivers/i2o/i2o_proc.c
--- linux-test9/drivers/i2o/i2o_proc.c	Tue Oct  3 23:40:13 2000
+++ linux/drivers/i2o/i2o_proc.c	Tue Oct  3 23:38:41 2000
@@ -3365,8 +3365,6 @@
 	i2o_remove_handler(&i2o_proc_handler);
 }
 
-#ifdef MODULE
 module_init(i2o_proc_init);
-#endif
 module_exit(i2o_proc_exit);
 
diff -urN linux-test9/drivers/i2o/i2o_scsi.c linux/drivers/i2o/i2o_scsi.c
--- linux-test9/drivers/i2o/i2o_scsi.c	Tue Oct  3 23:40:13 2000
+++ linux/drivers/i2o/i2o_scsi.c	Tue Oct  3 23:38:41 2000
@@ -902,12 +902,8 @@
 	return 0;
 }
 
-/* Loadable module support */
-#ifdef MODULE
-
 MODULE_AUTHOR("Red Hat Software");
 
 Scsi_Host_Template driver_template = I2OSCSI;
 
 #include "../scsi/scsi_module.c"
-#endif
diff -urN linux-test9/drivers/scsi/Makefile linux/drivers/scsi/Makefile
--- linux-test9/drivers/scsi/Makefile	Tue Oct  3 23:39:58 2000
+++ linux/drivers/scsi/Makefile	Tue Oct  3 23:38:41 2000
@@ -6,12 +6,14 @@
 #
 # 20 Sep 2000, Torben Mathiasen <tmm@image.dk>
 # Changed link order to reflect new scsi initialization.
+#
+# 21 Sep 2000, Michael Elizabeth Chastain <mec@shout.net>
+# Moved upper level drivers to drivers/scsi/upper.
 
 O_TARGET := scsidrv.o
 
-SUB_DIRS	:=
-MOD_SUB_DIRS	:=
-MOD_IN_SUB_DIRS	:=
+SUB_DIRS	:= upper
+MOD_IN_SUB_DIRS	:= $(SUB_DIRS)
 ALL_SUB_DIRS	:= $(SUB_DIRS) pcmcia
 
 ifeq ($(CONFIG_PCMCIA),y)
@@ -111,11 +113,6 @@
 obj-$(CONFIG_SCSI_DEBUG)	+= scsi_debug.o
 obj-$(CONFIG_SCSI_FCAL)		+= fcal.o
 
-obj-$(CONFIG_CHR_DEV_ST)	+= st.o
-obj-$(CONFIG_BLK_DEV_SD)	+= sd_mod.o
-obj-$(CONFIG_BLK_DEV_SR)	+= sr_mod.o
-obj-$(CONFIG_CHR_DEV_SG)	+= sg.o
-
 
 
 scsi_mod-objs	:= scsi.o hosts.o scsi_ioctl.o constants.o \
@@ -123,7 +120,6 @@
 			scsi_obsolete.o scsi_queue.o scsi_lib.o \
 			scsi_merge.o scsi_dma.o scsi_scan.o \
 			
-sr_mod-objs	:= sr.o sr_ioctl.o sr_vendor.o
 initio-objs	:= ini9100u.o i91uscsi.o
 a100u2w-objs	:= inia100.o i60uscsi.o
 
@@ -150,12 +146,6 @@
 
 scsi_mod.o: $(scsi_mod-objs)
 	$(LD) -r -o $@ $(scsi_mod-objs)
-
-sd_mod.o: sd.o
-	$(LD) -r -o $@ sd.o
-
-sr_mod.o: $(sr_mod-objs)
-	$(LD) -r -o $@ $(sr_mod-objs)
 
 initio.o: $(initio-objs)
 	$(LD) -r -o $@ $(initio-objs)
diff -urN linux-test9/drivers/scsi/sd.c linux/drivers/scsi/sd.c
--- linux-test9/drivers/scsi/sd.c	Tue Oct  3 23:39:59 2000
+++ linux/drivers/scsi/sd.c	Tue Oct  3 23:38:43 2000
@@ -81,6 +81,7 @@
 struct hd_struct *sd;
 
 static Scsi_Disk *rscsi_disks;
+EXPORT_SYMBOL(rscsi_disks);
 static int *sd_sizes;
 static int *sd_blocksizes;
 static int *sd_hardsizes;	/* Hardware sector size */
diff -urN linux-test9/drivers/scsi/sd.h linux/drivers/scsi/sd.h
--- linux-test9/drivers/scsi/sd.h	Tue Oct  3 23:39:59 2000
+++ linux/drivers/scsi/sd.h	Tue Oct  3 23:38:41 2000
@@ -23,6 +23,7 @@
 #include <linux/genhd.h>
 #endif
 
+
 extern struct hd_struct *sd;
 
 typedef struct scsi_disk {
@@ -34,6 +35,7 @@
 	unsigned char sector_bit_shift;		/* power of 2 sectors per FS block */
 	unsigned has_part_table:1;	/* has partition table */
 } Scsi_Disk;
+
 
 extern int revalidate_scsidisk(kdev_t dev, int maxusage);
 
diff -urN linux-test9/drivers/scsi/sg.c linux/drivers/scsi/sg.c
--- linux-test9/drivers/scsi/sg.c	Tue Oct  3 23:39:59 2000
+++ linux/drivers/scsi/sg.c	Tue Oct  3 23:38:43 2000
@@ -19,7 +19,7 @@
  */
 #include <linux/config.h>
 #ifdef CONFIG_PROC_FS
- static char * sg_version_str = "Version: 3.1.17 (20001002)";
+ static char * sg_version_str = "Version: 3.1.17 (20000921)";
 #endif
  static int sg_version_num = 30117; /* 2 digits for each component */
 /*
@@ -69,8 +69,10 @@
 #ifdef CONFIG_PROC_FS
 #include <linux/proc_fs.h>
 static int sg_proc_init(void);
+#ifdef MODULE
 static void sg_proc_cleanup(void);
 #endif
+#endif
 
 #ifndef LINUX_VERSION_CODE
 #include <linux/version.h>
@@ -269,8 +271,7 @@
      * else try and use this device.  Also, if error recovery fails, it
      * may try and take the device offline, in which case all further
      * access to the device is prohibited.  */
-    if (! ((flags & O_NONBLOCK) || 
-	   scsi_block_when_processing_errors(sdp->device)))
+    if(! scsi_block_when_processing_errors(sdp->device))
         return -ENXIO;
 
     SCSI_LOG_TIMEOUT(3, printk("sg_open: dev=%d, flags=0x%x\n", dev, flags));
@@ -278,7 +279,7 @@
     if (flags & O_EXCL) {
         if (O_RDONLY == (flags & O_ACCMODE))
             return -EACCES;   /* Can't lock it with read only access */
-        if (sdp->headfp && (flags & O_NONBLOCK))
+        if (sdp->headfp && (filp->f_flags & O_NONBLOCK))
             return -EBUSY;
         res = 0;  /* following is a macro that beats race condition */
 	__wait_event_interruptible(sdp->o_excl_wait,
@@ -288,7 +289,7 @@
             return res; /* -ERESTARTSYS because signal hit process */
     }
     else if (sdp->exclude) { /* some other fd has an exclusive lock on dev */
-        if (flags & O_NONBLOCK)
+        if (filp->f_flags & O_NONBLOCK)
             return -EBUSY;
         res = 0;  /* following is a macro that beats race condition */
         __wait_event_interruptible(sdp->o_excl_wait, (! sdp->exclude), res);
@@ -352,6 +353,9 @@
         return -ENXIO;
     SCSI_LOG_TIMEOUT(3, printk("sg_read: dev=%d, count=%d\n",
                                MINOR(sdp->i_rdev), (int)count));
+
+    if(! scsi_block_when_processing_errors(sdp->device))
+        return -ENXIO;
     if (ppos != &filp->f_pos)
         ; /* FIXME: Hmm.  Seek to the right place, or fail?  */
     if ((k = verify_area(VERIFY_WRITE, buf, count)))
@@ -447,11 +451,15 @@
 static ssize_t sg_new_read(Sg_fd * sfp, char * buf, size_t count,
 			   Sg_request * srp)
 {
+    Sg_device           * sdp = sfp->parentdp;
     sg_io_hdr_t         * hp = &srp->header;
     int                   k, len;
 
+    if(! scsi_block_when_processing_errors(sdp->device) )
+	return -ENXIO;
     if (count < size_sg_io_hdr)
 	return -EINVAL;
+
     hp->sb_len_wr = 0;
     if ((hp->mx_sb_len > 0) && hp->sbp) {
 	if ((CHECK_CONDITION & hp->masked_status) ||
@@ -495,8 +503,7 @@
     SCSI_LOG_TIMEOUT(3, printk("sg_write: dev=%d, count=%d\n",
                                MINOR(sdp->i_rdev), (int)count));
 
-    if (! ((filp->f_flags & O_NONBLOCK) ||
-           scsi_block_when_processing_errors(sdp->device)))
+    if(! scsi_block_when_processing_errors(sdp->device) )
         return -ENXIO;
     if (ppos != &filp->f_pos)
         ; /* FIXME: Hmm.  Seek to the right place, or fail?  */
@@ -705,6 +712,8 @@
         return -ENXIO;
     SCSI_LOG_TIMEOUT(3, printk("sg_ioctl: dev=%d, cmd=0x%x\n",
                                MINOR(sdp->i_rdev), (int)cmd_in));
+    if(! scsi_block_when_processing_errors(sdp->device) )
+        return -ENXIO;
     read_only = (O_RDWR != (filp->f_flags & O_ACCMODE));
 
     switch(cmd_in)
@@ -876,11 +885,7 @@
     case SG_EMULATED_HOST:
         return put_user(sdp->device->host->hostt->emulated, (int *)arg);
     case SG_SCSI_RESET:
-        if (filp->f_flags & O_NONBLOCK) {
-	    if (sdp->device->host->in_recovery)
-		return -EBUSY;
-	}
-	else if (! scsi_block_when_processing_errors(sdp->device))
+        if (! scsi_block_when_processing_errors(sdp->device))
             return -EBUSY;
         result = get_user(val, (int *)arg);
         if (result) return result;
@@ -1296,14 +1301,16 @@
     return;
 }
 
-MODULE_AUTHOR("Douglas Gilbert");
-MODULE_DESCRIPTION("SCSI generic (sg) driver");
+#ifdef MODULE
 MODULE_PARM(def_reserved_size, "i");
 MODULE_PARM_DESC(def_reserved_size, "size of buffer reserved for each fd");
+#endif /* MODULE */
 
 static int __init init_sg(void) {
+#ifdef MODULE
     if (def_reserved_size >= 0)
 	sg_big_buff = def_reserved_size;
+#endif /* MODULE */
     sg_template.module = THIS_MODULE;
     return scsi_register_module(MODULE_SCSI_DEV, &sg_template);
 }
@@ -2544,6 +2551,7 @@
     return 0;
 }
 
+#ifdef MODULE
 static void sg_proc_cleanup()
 {
     int k;
@@ -2555,6 +2563,7 @@
 	remove_proc_entry(sg_proc_leaf_names[k], sg_proc_sgp);
     remove_proc_entry(sg_proc_sg_dirname, proc_scsi);
 }
+#endif
 
 static int sg_proc_dressz_read(char * buffer, char ** start, off_t offset,
 			       int size, int * eof, void * data)
diff -urN linux-test9/drivers/scsi/upper/Makefile linux/drivers/scsi/upper/Makefile
--- linux-test9/drivers/scsi/upper/Makefile	Thu Jan  1 01:00:00 1970
+++ linux/drivers/scsi/upper/Makefile	Tue Oct  3 23:38:43 2000
@@ -0,0 +1,63 @@
+#
+# Makefile for linux/drivers/scsi/upper
+#
+# 21 Sep 2000, Michael Elizabeth Chastain <mec@shout.net>
+# Created subdirectory drivers/scsi/upper for upper level drivers.
+# They need their own subdirectory for the benefit of init call ordering.
+
+O_TARGET	:= scsi_upper.o
+
+SUB_DIRS	:= 
+MOD_SUB_DIRS	:= 
+ALL_SUB_DIRS	:= 
+
+export-objs	:=
+
+# sd.h sr.h st.h still live in the main SCSI directory.
+EXTRA_CFLAGS	+= -I ..
+
+obj-$(CONFIG_CHR_DEV_ST)	+= st.o
+obj-$(CONFIG_BLK_DEV_SD)	+= sd_mod.o
+obj-$(CONFIG_BLK_DEV_SR)	+= sr_mod.o
+obj-$(CONFIG_CHR_DEV_SG)	+= sg_mod.o
+
+sd_mod-objs	:= sd.o
+sr_mod-objs	:= sr.o sr_ioctl.o sr_vendor.o
+sg_mod-objs	:= sg.o
+
+# Extract lists of the multi-part drivers.
+# The 'int-*' lists are the intermediate files used to build the multi's.
+
+multi-y		:= $(filter $(list-multi), $(obj-y))
+multi-m		:= $(filter $(list-multi), $(obj-m))
+int-y		:= $(sort $(foreach m, $(multi-y), $($(basename $(m))-objs)))
+int-m		:= $(sort $(foreach m, $(multi-m), $($(basename $(m))-objs)))
+
+# Files that are both resident and modular: remove from modular.
+
+obj-m		:= $(filter-out $(obj-y), $(obj-m))
+int-m		:= $(filter-out $(int-y), $(int-m))
+
+# Take multi-part drivers out of obj-y and put components in.
+
+obj-y		:= $(filter-out $(list-multi), $(obj-y)) $(int-y)
+
+# Translate to Rules.make lists.
+
+O_OBJS		:= $(filter-out $(export-objs), $(obj-y))
+OX_OBJS		:= $(filter     $(export-objs), $(obj-y))
+M_OBJS		:= $(sort $(filter-out $(export-objs), $(obj-m)))
+MX_OBJS		:= $(sort $(filter     $(export-objs), $(obj-m)))
+MI_OBJS		:= $(sort $(filter-out $(export-objs), $(int-m)))
+MIX_OBJS	:= $(sort $(filter     $(export-objs), $(int-m)))
+
+include $(TOPDIR)/Rules.make
+
+sd_mod.o: $(sd_mod-objs)
+	$(LD) -r -o $@ $(sd_mod-objs)
+
+sr_mod.o: $(sr_mod-objs)
+	$(LD) -r -o $@ $(sr_mod-objs)
+
+sg_mod.o: $(sg_mod-objs)
+	$(LD) -r -o $@ $(sg_mod-objs)
diff -urN linux-test9/include/linux/i2o.h linux/include/linux/i2o.h
--- linux-test9/include/linux/i2o.h	Tue Oct  3 23:39:54 2000
+++ linux/include/linux/i2o.h	Tue Oct  3 23:38:43 2000
@@ -173,7 +173,6 @@
 	/* User data follows */
 };
 
-#ifdef MODULE
 /*
  * Used by bus specific modules to communicate with the core
  *
@@ -193,7 +192,6 @@
 	void	(*run_queue)(struct i2o_controller *c);
 	int	(*delete)(struct i2o_controller *);
 };
-#endif // MODULE
 
 /*
  * I2O System table entry