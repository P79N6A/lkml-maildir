Date: Wed, 15 Mar 2000 09:16:31 -0500
From: Tim Coleman <>
Subject: Re: ver_linux script
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/3/15/144

Hi Riley
The changes you suggested seem to make sense and the output
looks very nice on the machine at work that I tested it on.
(except for the fact that /proc/modules doesn't exist, so
I get an error from cat).
At home, however, I have a few problems.  One of them is
caused by the removal of the 'PATH' line.  Although when
I am root /sbin/insmod is in my path, when I'm a user it is 
not.  This causes output like this:
"Kernel modules         found"
because insmod is not found.  
The script looks like line noise, but that's to be expected.
I don't know if you care to make it more robust or not, but
I think this thread has gone on for just about long enough :)
By robust, I mean checking to make sure files exist before
cat-ing them, and so on.  I don't think that that level of
checking is really necessary though, because the error messages
are just as informative and don't stop the script from running.
I've attached a slightly modified version here, which includes
the PATH statement so that it finds stuff in /sbin, as well
as checking that /proc/modules and /proc/version exist before
doing stuff with them.  
I noticed that you didn't include some backslashes, so for
completeness I added them in.
Tim
#!/bin/sh
# Note the liberal use of the \ character.  This is useful for 
# ignoring aliased versions of particular commands such as ls
# and the like, without specifying the path.
PATH=/sbin:/usr/sbin:/bin:/usr/bin:$PATH
cat <<.EOF
NOTE: This script expects to be run with the same PATH that you use when
      compiling the kernel or application you are having problems with.
      If such is not the case, please disregard the following, set your
      PATH to the one you use, and rerun this script.
==} The following software versions appear to be installed:
.EOF
if [ -f "/proc/version" ]; then
  \echo "/proc/version :-"
  \cat /proc/version | \sed 's/) /)£/g' | \tr '£' '\n' | \sed 's/^/    /'
fi
\echo "uname -a :-"
\uname -a | \sed 's/\(#[0-9]*\) /\1£/' | \tr '£' '\n' | \sed 's/^/    /'
\echo
\insmod -V  2>&1 | \awk 'NR==1 {print "Kernel modules        ",$NF}'
\echo "Gnu C                 " `\gcc --version 2> /dev/null || \echo '<None>'`
\ld -v 2>&1 | \awk -F\) '{print $1}' | \awk \
        '/BFD/{print "Binutils              ",$NF}'
\ls -l `\ldd /bin/sh | \awk '/libc/{print $3}'` | \sed -e 's/\.so$//' \
        | \awk -F'[.-]'   '{print "Linux C Library        " $(NF-2)"."$(NF-1)"."$NF}'
\echo -n "Dynamic linker         "
\ldd -v > /dev/null 2>&1 && \ldd -v || \ldd --version | \head -1
\ls -l /usr/lib/lib{g,stdc}++.so  2>/dev/null | \awk -F. \
        '{print "Linux C++ Library      " $4"."$5"."$6}'
\ps --version 2>&1 | \awk 'NR==1{print "Procps                ", $NF}'
\mount --version | \awk -F\- '{print "Mount                 ", $NF}'
\hostname -V 2>&1 | \awk 'NR==1{print "Net-tools             ", $NF}'
# Kbd needs 'loadkeys -h',
\loadkeys -h 2>&1 | \awk \
        '(NR==1 && ($3 !~ /option/)) {print "Kbd                   ", $3}'
# while console-tools needs 'loadkeys -V'.
\loadkeys -V 2>&1 | \awk \
        '(NR==1 && ($2 ~ /console-tools/)) {print "Console-tools         ",
$3}'
\expr --v 2>&1 | \awk 'NR==1{print "Sh-utils              ", $NF}'
\echo
if [ -f "/proc/modules" ]; then
  \echo "Modules Loaded :-"
  \cat /proc/modules | \sed -e "s/ .*$//" | \sort -f | \tr '\n' ' ' \
          | \sed 's/^/    /'
else
  if [ -d "/proc" ]; then
    \echo "No modules loaded"
  else
    \echo "Module information could not be found in /proc/modules"
  fi
fi
\cat <<.EOF
==} If some fields are empty or look unusual, then it is possible that
==} you have very old versions thereof.
.EOF
[unhandled content-type:application/pgp-signature]