Date: Tue, 20 Nov 2001 22:29:20 -0800 (PST)
From: "David S. Miller" <>
Subject: Re: 2.4.14 + Bug in swap_out.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2001/11/21/12

   From: ebiederm@xmission.com (Eric W. Biederman)
   Date: 20 Nov 2001 23:01:06 -0700
   And looking in fork.c mmput under with right circumstances becomes.
   kmem_cache_free(mm_cachep, (mm)))
   So it appears that there is nothing that keeps the mm_struct that
   swap_mm points to as being valid. 
I do not agree with your analysis.
If we hold the mmlist lock and we find the mm on the swap mm list, by
definition it must have a non-zero user count already.  (put an assert
there if you don't believe me :-)
Only when the user count drops to zero will mmput() free up the mm.
It simultaneously grabs the mmlist lock when it drops the user count
to zero, this is how it synchronizes with the rest of the world.
Perhaps you aren't noticing that it is using "atomic_dec_and_lock()"
or you don't understand how that primitive works?
We increment the mm user count before dropping the mmlist lock in the
swapper, so even if the user does a mmput() we still hold a reference.
ie. mmput won't put the user count to zero.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/