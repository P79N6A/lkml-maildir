Date: Fri, 3 Mar 2006 16:43:12 +0100
From: Ingo Molnar <>
Subject: Re: [PATCH 7/5] Optimise d_find_alias()
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/3/3/122

* David Howells <dhowells@redhat.com> wrote:
> Andrew Morton <akpm@osdl.org> wrote:
> 
> > How can we get away without a barrier?
> 
> Is this what you're thinking of:
> 
> 	struct dentry * d_find_alias(struct inode *inode)
> 	{
> 		struct dentry *de = NULL;
> 
> 		smp_rmb();
> 		if (!list_empty(&inode->i_dentry)) {
> 			spin_lock(&dcache_lock);
no barrier is needed i think. This code just picks an alias, with no 
guarantee of any ordering wrt. add/removal ops from the alias list. In 
other words, d_find_alias() depends on external serialization - when 
used standalone it is fundamentally nondeterministic anyway.
it is true that the list_empty() might observe an intermediate state of 
the list [e.g. backlink not modified yet but forward link modified - or 
the other way around], but that's not a problem: it either returns true 
or false, both of which are correct results when the modification is 
underway in parallel on another CPU. When d_find_alias() returns 
non-NULL it will only do it by taking dcache_lock, so the correct use of 
the list is always guaranteed.
[ a barrier would have no useful effect here anyway - it only guarantees
  instruction ordering locally, and has no deterministic effect on the
  order of memory values being written from another CPU. A barrier makes
  sense when ordering of writes to two different memory values is
  deterministic - e.g. a flag and a resource pointer. But in the case of
  list_empty(), the order of modifications to the two pointers in the
  list is not guaranteed. ]
	Ingo
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/