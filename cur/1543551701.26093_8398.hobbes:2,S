Date: Mon, 16 Oct 2000 03:28:27 -0600
From: "Jeff V. Merkey" <>
Subject: Re: [Criticism] On the discussion about C++ modules
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/10/16/34

Actually, I spent four months at Novell profiling Chorus, MACH and TMOK
(Trusted Modular Object Kernel -- a very nice piece of work) with EMON
and an AArium profiling bus footprints -- the result.  C++ kernels are
slightly slower, and hit the wall on I/O performance due to excessive
memory read/write activity.  
Chorus, TMOK, and MACH on a PPro X 4 has bus utilizations WHILE IDLE of
@ 60,000,000 clocks (there were only 219,000,000 total per second). 
NetWare on the other hand was right around 75,000 and NT was at
2,000,000 for just background memory reads/writes.   As soon as I/O
loading  tests started, they all sucked wind.  The whole idea of a
kernel is to squeeze every clock you can to increase the capcity the OS
can support for both I/O and app loading.  NetWare is more optimized
than most and has the greatest capacity, but it's because we got rid of
every useless code path and C++ construct in the kernel, then hand
optimized the fast paths in assembler.  
C++ makes it tough to achieve this level of optimization.
Jeff
"J . A . Magallon" wrote:
> 
> Firs of all, as someone said, is there any other list where we can discuss this
> ?
> It is ver off-topic here...
> 
> I messed in the discussion because I'm tired of seein people say that they don't
> use
> C++ because their big overheads, being slow, messed, out of programmer's control
> for
> low level tasks and so on. They seem to not have read anything about compilers
> or
> the design of C++. One of the premises of C++ was tat ANYTHING that could be
> done in
> C was not slower or used more resources for being done with a c++ feature.
> 
> In the kernel you say in C:
> 
> generic_driver_init(&my_driver,Ã±params);
> my_driver->specific_init(&my_driver,params);
> 
> and in C++
> my_driver.init(params), that could be automatically configured to call the
> generic init also.
> 
> and THAT IS NO OVERHEAD, no address fetching to call a simple member, and just
> the same as
> in C for a inherited member.
> 
> My point of view is that there's many code in the kernel to implement generic to
> specific inits,
> functions for drivers and so on that could be generated by a C++ compiler, with
> no overhead
> at runtime. Load a module and find the init proc, the io proc, store them in
> pointers and
> use pointers to functions to use the driver. Thats hand-writen C++.
> 
> --
> Juan Antonio Magallon Lacarta                          mailto:jamagallon@able.es
> 
> -
> To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
> the body of a message to majordomo@vger.kernel.org
> Please read the FAQ at 
http://www.tux.org/lkml/
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
Please read the FAQ at 
http://www.tux.org/lkml/