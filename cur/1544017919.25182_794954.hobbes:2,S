Date: Tue, 20 Jan 2009 13:19:44 +0000
From: Jonathan Cameron <>
Subject: regulator: Add disable_on_boot flag to constraints.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2009/1/20/143

From: Jonathan Cameron <jic23@cam.ac.uk>
regulator: Add disable_on_boot flag to constraints.
Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
---
Changes in response to Mark Browns comments.
Patch changed to disable_on_boot for more flexibility.
This only really involved removing the check in the enable code
found in the previous patch.
This is intended to allow the disabling of regulators during
registration.  Typical use case is regulators that aren't
actually connected to anything.
This is against a clean 2.6.29-rc2-git1 tree.
 drivers/regulator/core.c          |   19 ++++++++++++++++++-
 include/linux/regulator/machine.h |    7 ++++---
 2 files changed, 22 insertions(+), 4 deletions(-)
diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index f511a40..7d57338 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -709,7 +709,14 @@ static int set_machine_constraints(struct
regulator_dev *rdev,
             goto out;
         }
     }
-
+    /* Sanity check */
+    if (constraints->always_on && constraints->disable_on_boot) {
+        printk(KERN_ERR "%s: always on and disable at boot both set for
%s\n",
+               __func__, name);
+        rdev->constraints = NULL;
+        ret = -EINVAL;
+        goto out;
+    }
     /* if always_on is set then turn the regulator on if it's not
      * already on. */
     if (constraints->always_on && ops->enable &&
@@ -722,6 +729,16 @@ static int set_machine_constraints(struct
regulator_dev *rdev,
             rdev->constraints = NULL;
             goto out;
         }
+    } else if (constraints->disable_on_boot && ops->disable &&
+           ((ops->is_enabled && ops->is_enabled(rdev)) ||
+            (!ops->is_enabled && constraints->boot_on))) {
+        ret = ops->disable(rdev);
+        if (ret < 0) {
+            printk(KERN_ERR "%s: failed to disable %s\n",
+                   __func__, name);
+            rdev->constraints = NULL;
+            goto out;
+        }
     }
 
     print_constraints(rdev);
diff --git a/include/linux/regulator/machine.h
b/include/linux/regulator/machine.h
index 3794773..fc0a641 100644
--- a/include/linux/regulator/machine.h
+++ b/include/linux/regulator/machine.h
@@ -112,10 +112,10 @@ struct regulation_constraints {
     suspend_state_t initial_state; /* suspend state to set at init */
 
     /* constriant flags */
-    unsigned always_on:1;    /* regulator never off when system is on */
-    unsigned boot_on:1;    /* bootloader/firmware enabled regulator */
-    unsigned apply_uV:1;    /* apply uV constraint iff min == max */
+    unsigned always_on:1;        /* regulator never off when system on */
+    unsigned boot_on:1;        /* bootloader/firmware enabled reg */
+    unsigned disable_on_boot:1;    /* regulator to be disabled at boot */
+    unsigned apply_uV:1;        /* apply uV constraint iff min == max */
 };
 
 /**