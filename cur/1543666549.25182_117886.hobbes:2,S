Date: Mon, 17 Mar 2003 10:28:59 -0500 (Eastern Standard Time)
From: "Sparks, Jamie" <>
Subject: select() stress
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2003/3/17/74

Hello,
  I'm running some code ported from an sgi running Irix 6.5 on a
  redhat 7.1 box: 2.4.7-10, i686.  Control hangs on a select()
  statement forever.  The select is never completed, so I can't
  check errno.
  Please reply to me personally as I'm not currently subscribed:
  jamie.sparks@cubic.com
  on sgi, the call is:
  select(getdtablehi(), &socklist, NULL, NULL, NULL);
  where socklist is declared as:  FD_SET socklist;
  on linux, there is no getdtablehi() equivalent, so I use
  getdtablesize() in its place.  getdtablehi() returns the
  number of fd's currently open and getdtablesize() returns
  the number of fd's that *can* be open.
  here's the code:
  for (;;)
  {
    printf("CLEARING sockets\n");
    FD_ZERO(&socklist); /* Always clear the structure first. */
    FD_SET(Sockfd[0], &socklist);
    FD_SET(Sockfd[1], &socklist);
    int len = -1;
    bool wasDequeued =false;
    if (!StateManager::getSaveInProgress()&& StateManager::hasQueuedPdus())
    {
      FD_ZERO(&socklist); /* Always clear the structure first. */
      pdu = StateManager::dequeuePostPduProcess();
      len = sizeof(pdu);
      wasDequeued = true;
      printf("PDU DEqueued from StateManager since Save has completed\n");
    }
    else
    {
      printf("prior to select\n");
      // orig sgi if (select(getdtablehi(), &socklist, NULL, NULL, NULL) < 0)
      /*  ****************************** */
      /*  THIS select() STATEMENT NEVER COMPLETES */
      /*  ****************************** */
      if (select(getdtablesize(), &socklist, NULL, NULL, NULL) < 0)
      {
        if (errno != EINTR) perror("WeapTerrain");
	continue;
      }
      printf("after select\n");
			}
      printf("Prior to finding which socket\n");
      for (ii=0;ii<2;ii++)
      {
        len = -1;
        if (FD_ISSET(Sockfd[ii],&socklist))
	{
          if (!ii)
	  {
            len = waitForSocketMessage(Sockfd[ii],&pdu,
	    sizeof(pdu));
	  } else if (ii)
	  {
	    len = 0;
	  }
	}
	if (wasDequeued){len = sizeof(pdu);wasDequeued=false;}
        if (len == sizeof(pdu) && StateManager::getSaveInProgress())
	{
          StateManager::queuePostPduProcess(pdu);
          printf("incoming PDU queued in StateManager since SaveInProgress\n");
	  continue;
        }
        if (len >= 0)
	{
	  printf("LEN?TYPE = %d %d\n",len, pdu.dpdu.detonation_header.type);
        }
        .
        .
        .
  Please reply to me personally as I'm not currently subscribed:
  jamie.sparks@cubic.com
  thanks,
  Jamie
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/