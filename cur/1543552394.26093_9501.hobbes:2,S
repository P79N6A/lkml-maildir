Date: Mon, 23 Oct 2000 16:32:22 -0400
From: Brian Gerst <>
Subject: Re: mount: Unable to handle kernel paging request at virtual address
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/10/23/162

David Dyck wrote:
> 
> I am getting a repeatable oops during the boot up phase,
> with linux 2.4.0  test10-pre4
> 
> Even a simple "mount /proc" command yields an oops.
> I believe I have the latest mount program.
> 
> Unable to handle kernel paging request at virtual address 08067000
> c01f90d0
> *pde = 07f42067
> Oops: 0000
> CPU:    0
> EIP:    0010:[<c01f90d0>]
> Using defaults from ksymoops -t elf32-i386 -a i386
> EFLAGS: 00010206
> eax: 00000000   ebx: 00000000   ecx: 000000a0   edx: 08067280
> esi: 08067000   edi: c7ec3d80   ebp: c7f3ffbc   esp: c7f3ff64
> ds: 0018   es: 0018   ss: 0018
> Process mount (pid: 18, stackpage=c7f3f000)
> Stack: c7f3e000 08066280 00001000 c0134610 c7ec3000 08066280 00001000 c7f3e000
>        08066270 08066260 080662b0 c7ec3000 00000009 c01349b2 08066280 c7f3ffbc
>        c7f3e000 c0ed0000 080662b0 bffffb84 c7f3e000 00000000 00000000 c010906b
> Call Trace: [<c0134610>] [<c01349b2>] [<c010906b>]
> Code: f3 a5 89 c1 f3 a4 89 c8 5b 5e 5f c3 8d 74 26 00 57 56 8b 7c
> 
> >>EIP; c01f90d0 <__generic_copy_from_user+30/40>   <=====
> Trace; c0134610 <copy_mount_options+80/100>
> Trace; c01349b2 <sys_mount+22/d0>
> Trace; c010906b <system_call+33/38>
> Code;  c01f90d0 <__generic_copy_from_user+30/40> 00000000 <_EIP>:
> Code;  c01f90d0 <__generic_copy_from_user+30/40>    0:   f3 a5                     repz movsl %ds:(%esi),%es:(%edi)   <=====
> Code;  c01f90d2 <__generic_copy_from_user+32/40>    2:   89 c1                     mov    %eax,%ecx
> Code;  c01f90d4 <__generic_copy_from_user+34/40>    4:   f3 a4                     repz movsb %ds:(%esi),%es:(%edi)
> Code;  c01f90d6 <__generic_copy_from_user+36/40>    6:   89 c8                     mov    %ecx,%eax
> Code;  c01f90d8 <__generic_copy_from_user+38/40>    8:   5b                        pop    %ebx
> Code;  c01f90d9 <__generic_copy_from_user+39/40>    9:   5e                        pop    %esi
> Code;  c01f90da <__generic_copy_from_user+3a/40>    a:   5f                        pop    %edi
> Code;  c01f90db <__generic_copy_from_user+3b/40>    b:   c3                        ret
> Code;  c01f90dc <__generic_copy_from_user+3c/40>    c:   8d 74 26 00               lea    0x0(%esi,1),%esi
> Code;  c01f90e0 <__strncpy_from_user+0/30>       10:   57                        push   %edi
> Code;  c01f90e1 <__strncpy_from_user+1/30>       11:   56                        push   %esi
> Code;  c01f90e2 <__strncpy_from_user+2/30>       12:   8b 7c 00 00               mov    0x0(%eax,%eax,1),%edi
This should have been trapped by the exception handling routines.  One
possible explanation is that the exception table is not sorted correctly
by the linker.  This can happen if an exception entry is made for an
address that is in another section than .text.  The exception handler
does a binary search which can be tripped up by an out of sequence
entry.
Hmm, I wonder if GCC inlined do_test_wp_bit().  That would put an
exception in the .text.init section.  Could you check to see if this
happened?
--
				Brian Gerst
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
Please read the FAQ at 
http://www.tux.org/lkml/