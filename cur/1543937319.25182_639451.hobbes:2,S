Date: Thu, 17 Jan 2008 14:09:39 +1100
From: Rusty Russell <>
Subject: Re: Is try_module_get buggy?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/1/16/475

On Saturday 12 January 2008 15:35:27 rmingming wrote:
> Hi,
>  I have a problem about the try_module_get function, I don't know if
> someone removed the module just AFTER line 372, then what happens? Because
> in this situation, the variable module will be incorrect, and
> module_is_live function will lead to unpredicatable behaviour.
>
> 368 static inline int try_module_get(struct module *module)
> 369 {
> 370         int ret = 1;
> 371
> 372         if (module) {
> 373                 unsigned int cpu = get_cpu();
> 374                 if (likely(module_is_live(module)))
> 375                         local_inc(&module->ref[cpu].count);
> 376                 else
> 377                         ret = 0;
> 378                 put_cpu();
> 379         }
> 380         return ret;
> 381 }
Hi rminming,
try_module_get is designed to ensure that you don't call a function inside a 
module without a reference.  Like any reference function, it cannot handle 
the case where the argument is invalid (or invalidated partway through the 
call).
In this case, the module pointer is usually inside a registered structure.  
The pointer will be valid until the structure is unregistered, which the 
calling code presumably prevents while it's doing a lookup.
Hope that clarifies,
Rusty.