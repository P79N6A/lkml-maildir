Date: Fri, 7 May 1999 17:07:18 +0300 (EEST)
From: Matti Aarnio <>
Subject: Re: mmap from 0xFFFF0000 -> 0xFFFFFFFF does not work, why?!
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/5/7/94

Bossek Raphael <raphael.bossek@solutions4linux.de> asked:
> Hi all,
> 
> 1st Question :
> 
> i'm working at a bios flash utility for some pc manufacture and have trouble
> in using the mmap function :(
> 
> I need access to the address space starting at 0xFFFE0000 to 0xFFFFFFFF
> where the flash chip copy its contents. I use the /dev/mem device driver
> to access the memory environment throw the mmap function but it does not
> work. So i decrease the size from 0x20000 to 0x20000 - getpagesize() and
> what happens, yes mmap exit without any error.
> 
> Why can i not mmap from 0xFFFE0000 with the size of 0x20000 bytes ?!
	Likely because 0xFFFE0000 + 0x00020000 exceeds value range
	presentable in 32-bit integer.
	You can map up to one page less than the top of the memory.
> More background information. I have to program the vendor specific PCI
> devices before i get the access to the flash contents. This PCI device
> handels the write/read operations to that flash chip and the region
> where its contents will be mirrored. I can NOT change the region where
> it will be :(
	*maybe* you can do it with   bus_to_virt()  within the
	kernel.  (I didn't check it all the way, but you are
	interested in bus space physical addresses mapped into
	kernel virtual address space.)
> 2nd Question :
> 
> Perhapps it will be a stuppid question but how can i access the mapped
> memory ?! Can i use simple cpu memory access or is it required to use
> the read/write function with the previous get file handle by
> open("/dev/mem", ..) ?!
> 
> 3rd Question :
> 
> The access to the flash chip is VERY time critical. I need a function that
> allows me to protect the current task from others. While accessing the
> flash memory mapped before, NO other task should/must get processor
> time. Which technique solve this problem ?!
	Loading the timing critical FLASH-writer code into the kernel
	as a module. Doing it as a character device would likely be
	the best way.
	A possible danger is that you must very likely disable all
	interrupts for the sensitive writer routine to be safe.
	IRQ disabling will also mean that you can't use jiffies
	as timing reference.  ( For the duration of flash full/block
	erase, and block write, that is. ) (I seem to recall that
	a couple milliseconds spent elsewere will timeout flash
	writing.)
	Copy the writable block to kernel buffer *before* you enter
	into the irq-disable section, do writes, and re-enable irq:s.
	Do this in as small blocks as the flash device allows.
> 4th Question :
> 
> Because the pentium processors have caches it is required to disable them
> before access the flash memory (you know, time critical access). So i include
> some assembler code that use the %cr0 pentium processor register but i get
> segfaults while executing this source line :( How can i disable the cpu cache
> withou using the assembler code within the user application ?! Of
> course, only root can do that.
	"root" isn't powerfull enough, those must be executed
	in the supervisor mode -- within the kernel, that is.
	Another reason to go via device driver kernel module.
> I hope this questions fits in the mailling list because it is the last chanse
> for me, no one else could help me...
> 
> I realy HOPE get hopeful answers, thx.
> -- 
> Raphal Bossek <raphael.bossek@solutions4linux.de>
/Matti Aarnio <matti.aarnio@sonera.fi>
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/