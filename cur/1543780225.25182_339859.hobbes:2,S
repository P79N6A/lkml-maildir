Date: Sun, 07 Aug 2005 04:03:43 -0700
From: Zachary Amsden <>
Subject: Re: [PATCH] 5/8 Move descriptor table management into the sub-arch layer
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/8/7/27

Chris Wright wrote:
>* Zachary Amsden (zach@vmware.com) wrote:
> 
>
>>This change encapsulates descriptor and task register management.
>> 
>>
>
>These will need some merging together, will take a stab tomorrow.
>
>
>--- linux-2.6.12-xen0-arch.orig/include/asm-i386/desc.h
>+++ linux-2.6.12-xen0-arch/include/asm-i386/desc.h
>@@ -14,9 +14,6 @@
>
> static inline void __set_tss_desc(unsigned int cpu, unsigned int entry, void *addr)
> {
>-	_set_tssldt_desc(&per_cpu(cpu_gdt_table, cpu)[entry], (int)addr,
>+	_set_tssldt_desc(&get_cpu_gdt_table(cpu)[entry], (int)addr,
> 
>
What is Xen doing for the GDT on SMP?  Does Xen have 16 pages of GDT per 
CPU?
>+++ linux-2.6.12-xen0-arch/include/asm-i386/mach-default/mach_desc.h
>@@ -0,0 +1,57 @@
>+#ifndef __ASM_MACH_DESC_H
>+#define __ASM_MACH_DESC_H
>+
>+extern struct desc_struct cpu_gdt_table[GDT_ENTRIES];
>+DECLARE_PER_CPU(struct desc_struct, cpu_gdt_table[GDT_ENTRIES]);
>+#define get_cpu_gdt_table(_cpu) per_cpu(cpu_gdt_table, cpu)
>+
>+#define _set_tssldt_desc(n,addr,limit,type) \
>+__asm__ __volatile__ ("movw %w3,0(%2)\n\t" \
>+	"movw %%ax,2(%2)\n\t" \
>+	"rorl $16,%%eax\n\t" \
>+	"movb %%al,4(%2)\n\t" \
>+	"movb %4,5(%2)\n\t" \
>+	"movb $0,6(%2)\n\t" \
>+	"movb %%ah,7(%2)\n\t" \
>+	"rorl $16,%%eax" \
>+	: "=m"(*(n)) : "a" (addr), "r"(n), "ir"(limit), "i"(type))
> 
>
This actually doesn't need to move into sub-arch.  You can redefine the 
call sites (set_ldt_desc / set_tss_desc) to operate on stack (implicit 
register) values instead and then notify the hypervisor about GDT 
updates.  Course, which way is cleaner looks still TBD.
>+static inline void clear_LDT(void)
>+{
>+	int cpu = get_cpu();
>+
>+	set_ldt_desc(cpu, &default_ldt[0], 5);
>+	load_LDT_desc();
>+	put_cpu();
>+}
>+
>+/*
>+ * load one particular LDT into the current CPU
>+ */
>+static inline void load_LDT_nolock(mm_context_t *pc, int cpu)
>+{
>+	void *segments = pc->ldt;
>+	int count = pc->size;
>+
>+	if (likely(!count)) {
>+		segments = &default_ldt[0];
>+		count = 5;
>+	}
>+		
>+	set_ldt_desc(cpu, segments, count);
>+	load_LDT_desc();
>+}
>+
>+#endif
> 
>
These two don't actually need to move into sub-arch ; they can call 
functions that have already moved.
So far looks like we are pretty much on the same page, with mostly 
cosmetic differences.
Zach
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/