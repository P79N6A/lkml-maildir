Date: Thu, 12 Sep 2002 14:52:44 +1000
From: Rusty Russell <>
Subject: Re: [RFC] Raceless module interface
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2002/9/12/3

On Thu, 12 Sep 2002 05:47:57 +0200
Daniel Phillips <phillips@arcor.de> wrote:
> On Thursday 12 September 2002 05:13, Rusty Russell wrote:
> > B) We do not handle the "half init problem" where a module fails to load, eg.
> > 	a = register_xxx();
> > 	b = register_yyy();
> > 	if (!b) {
> > 		unregister_xxx(a);
> > 		return -EBARF;
> > 	}
> >   Someone can start using "a", and we are in trouble when we remove
> >   the failed module.
> 
> No we are not.  The module remains in the 'stopped' state
> throughout the entire initialization process, as it should and
> does, in my model.
Um, so register_xxx interfaces all use try_inc_mod_count (ie. a
struct module *  extra arg to register_xxx)?  Or those entry points
are not protected by try_inc_mod_count, so it must bump the refcnt, so
you need to sleep in load until the module becomes unused again.
You have the same issue in the "wait for schedule" case on unload,
where someone jumps in while you are unregistering.  My implementation
decided to ignore this problem (ie. potentially wait forever with the
module half-loaded) but it is an issue.
Rusty.
-- 
   there are those who do and those who hang on and you don't see too
   many doers quoting their contemporaries.  -- Larry McVoy
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/