Date: Tue, 07 Aug 2007 16:32:23 -0400
From: Chris Snook <>
Subject: Re: why are some atomic_t's not volatile, while most are?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/8/7/321

Chris Friesen wrote:
> Chris Snook wrote:
> 
>> If your architecture doesn't support SMP, the volatile keyword doesn't 
>> do anything except add a useless memory fetch.
> 
> I was under the impression that there were other cases as well 
> (interrupt handlers, for instance) where the value could be modified 
> "behind the back" of the current code.
When you're accessing data that could be modified by an interrupt handler, you 
generally use a function that calls arch-specific inline assembler to explicitly 
fetch it from memory.
> It seems like this would fall more into the case of the arch providing 
> guarantees when using locked/atomic access rather than anything 
> SMP-related, no?.
But if you're not using SMP, the only way you get a race condition is if your 
compiler is reordering instructions that have side effects which are invisible 
to the compiler.  This can happen with MMIO registers, but it's not an issue 
with an atomic_t we're declaring in real memory.
	-- Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/