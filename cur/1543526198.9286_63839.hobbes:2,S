Date: Thu, 17 Feb 2000 11:33:37 +0200
From: Tuukka Toivonen <>
Subject: Re: success on 386 (was: Re: Does anybody try to compile...)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/2/17/58

So that this isn't completely offtopic, here's a bug report:
I got an oops when giving command "mdir a:" right after boot on the 386.
kmod inserted the floppy module, which detected floppy drive chip and
displayed it's normal message, and right after that an oops happened.
i tried to copy it down with gpm, but that caused more oopses.
After that floppy was visible in /proc/modules, but I couldn't use floppy
drive.
So sorry, no oops report this time. Maybe it was buggy hardware anyway...
It happened only once.
[offtopic starts]
On Tue, 15 Feb 2000, Alan Cox wrote:
> > assembly-optimized VGA drivers.
...
> Unrolled loops tuned for old era CPU's like the 386. So no I don't think that
> is why. X is just a bit heavier and without the RAM for it your machine
> thrashes.
If I only move a single Xterm window around, it doesn't trash, HD is dead.
When X is doing a block copy it is supposed to be in small tight loop
anyway.
I compared X and windoze a little and believe I know now the reason for
the speed difference. There are two reasons, the first being assembly
optimized video drivers. This affects clearly for eg. how fast the mouse
cursor is redrawn when I move mouse. The second and more important fact is
that windoze actually cheats. I explain this below.
When I move a window from position A to B, there are two different
cases: either the pixel positions are byte aligned, or then they are
not. The latter is usually (7 out of 8) true, but it is much slower way to
do the copy since X has to copy each bitplane separately (while it is
doing the copy, colors get "funny") and do a bit shift.
If the positions _are_ aligned, things are so much simpler. CPU can copy
all bitplanes with a single instruction, using VGA hardware latches. And X
really does this, and in this case is almost as fast as windoze.
Now, how windowz cheats? It simply aligns windows _always_ at integer byte
positions, so that it can do always a fast copy. It's impossible to move
just a few pixels the windows: either they move not at all or full 8
pixels.
Now, how to optimize X to take advantage of this cheat too? Clearly the
server can not align windows like windoze, to be compliant with X
standard. The trick would be to modify window manager to always do the
align.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/