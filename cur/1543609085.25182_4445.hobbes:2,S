Date: Thu, 8 Nov 2001 09:10:41 -0800 (PST)
From: Linus Torvalds <>
Subject: Re: [PATCH] net/ipv4/*, net/core/neighbour.c jiffies cleanup
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2001/11/8/83

On Thu, 8 Nov 2001, Krishna Kumar wrote:
> > >
> > > In short: It is wrong to do
> > >
> > >          if (jiffies <= start+HZ)
> > >
> > > and it is _right_ to do
> > >
> > >          if (jiffies - start <= HZ)
>
> I am sorry, but I still don't see the difference. I wrote a small
> program with different cases, but the values still come same
> irrespective of the input arguments to the checks. Could you tell
> under what conditions the checks wuold fail ? The 2's complement works
> the same for addition and subtraction. I have included the test
> program below.
Ok.
Let's give an example. HZ is 100, and we started just before jiffies
wrapped, and we want to check that we're within one second.
So "start" equals 0xfffffff0, and "jiffies" equals 0xfffffff5.
The first if-statement will say
	if (0xfffffff5 <= 0xfffffff0+100)
which is the same as
	if (0xfffffff5 <= 0x54)
which is
	if (0)
in short, the first statement will say that jiffies is _not_ within 100
ticks of "start", which is obviously wrong. Jiffies _is_ within 100 ticks,
it is in fact just 5 ticks after "start".
The second statement will say
	if (0xfffffff5 - 0xfffffff0 <= 100)
which is
	if (5 <= 100)
which is
	if (1)
which is _correct_. We _are_ within 100 ticks.
See?
Ok, that was wrap-around one way: the "+HZ" wrapped. Let's see the other
case, which is that "jiffies" has wrapped: start is still 0xfffffff0, but
jiffies has wrapped around and is 0x00000001.
The first if-statement will say
	if (0x00000001 <= 0xfffffff0+100)
which is
	if (0x00000001 <= 0x54)
which is
	if (1)
which is correct. The second one will say
	if (0x00000001 - 0xfffffff0 <= 100)
which is
	if (11 <= 100)
which is
	if (1)
which is correct.
In short, the _correct_ one ALWAYS gets the right answer. Even when the
subtraction overflows.
While the first (and incorrect one) gets the wrong answer when the
addition overflows.
Do you see the difference now?
		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/