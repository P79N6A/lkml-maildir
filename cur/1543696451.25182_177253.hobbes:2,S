Date: Sun, 9 Nov 2003 21:36:11 +0300
From: Andrey Borzenkov <>
Subject: [PATCH][2.6.0-test9] fix 32/64 bits for input events
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2003/11/9/76

Input bits are kept as array of unsigned long and when no bit is set the whole 
"unsigned long" is represented as single 0 in hotplug events and /proc files. 
It makes rather hard for user-level programs to guess which bits are set - 
programs need to know size of kernel long to correctly interpret output.
One possibility is attached patch. It makes sure every long is always output 
in full. Another possibility (I like it more frankly speaking) is to always 
use 32 bit type for arrays. But it needs more than two lines of trivial 
changes.
regards
-andrey
PS do I miss something or input /proc functions really never check for buffer 
overflow?
--- linux-2.6.0-test9/drivers/input/input.c	2003-11-09 21:17:59.000000000 +0300
+++ ../tmp/linux-2.6.0-test9/drivers/input/input.c	2003-10-25 22:21:42.000000000 +0400
@@ -330,8 +330,7 @@ static struct input_device_id *input_mat
 		for (j = NBITS(max) - 1; j >= 0; j--) \
 			if (dev->bit[j]) break; \
 		for (; j >= 0; j--) \
-			scratch += sprintf(scratch, "%0*lx ", \
-					BITS_PER_LONG/4, dev->bit[j]); \
+			scratch += sprintf(scratch, "%lx ", dev->bit[j]); \
 		scratch++; \
 	} while (0)
 
@@ -584,8 +583,7 @@ static struct file_operations input_fops
 		for (i = NBITS(max) - 1; i >= 0; i--) \
 			if (dev->bit[i]) break; \
 		for (; i >= 0; i--) \
-			len += sprintf(buf + len, "%0*lx ", \
-					BITS_PER_LONG/4, dev->bit[i]); \
+			len += sprintf(buf + len, "%lx ", dev->bit[i]); \
 		len += sprintf(buf + len, "\n"); \
 	} while (0)
 