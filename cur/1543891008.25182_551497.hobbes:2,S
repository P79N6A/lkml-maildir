Date: Thu, 31 May 2007 07:16:00 -0700
From: Stephane Eranian <>
Subject: Re: [PATCH 19/22] 2.6.22-rc3 perfmon2 : modified x86_64 files
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/5/31/167

Andi,
On Thu, May 31, 2007 at 05:05:04PM +0200, Andi Kleen wrote:
> Stephane Eranian <eranian@frankl.hpl.hp.com> writes:
> 
> > @@ -557,6 +561,10 @@ static inline void __switch_to_xtra(stru
> >  		 */
> >  		memset(tss->io_bitmap, 0xff, prev->io_bitmap_max);
> >  	}
> > +
> > +	if (test_tsk_thread_flag(next_p, TIF_PERFMON_CTXSW)
> > +	    || test_tsk_thread_flag(prev_p, TIF_PERFMON_CTXSW))
> > +		pfm_ctxsw(prev_p, next_p);
> >  }
> 
> I thought we had agreed earlier to put this into single "all uncommon
> bits" check first?
> 
This is it. the check for uncommon bits is below (_TIF_WORK_CTXSW). Then
we need to check each uncommon bits (done above). Did you have something else
in mind?
> > 
> >  /*
> > @@ -661,7 +669,7 @@ __switch_to(struct task_struct *prev_p, 
> >  	 * Now maybe reload the debug registers and handle I/O bitmaps
> >  	 */
> >  	if (unlikely((task_thread_info(next_p)->flags & _TIF_WORK_CTXSW))
> > -	    || test_tsk_thread_flag(prev_p, TIF_IO_BITMAP))
> > +  	    || (task_thread_info(prev_p)->flags & _TIF_WORK_CTXSW))
> 
> >  		__switch_to_xtra(prev_p, next_p, tss);
> > 
> >  	/* If the task has used fpu the last 5 timeslices, just do a full
> > diff --exclude=.git -urp linux-2.6.22.base/arch/x86_64/kernel/setup64.c linux-2.6.22/arch/x86_64/kernel/setup64.c
> > --- linux-2.6.22.base/arch/x86_64/kernel/setup64.c	2007-05-29 03:17:16.000000000 -0700
> > +++ linux-2.6.22/arch/x86_64/kernel/setup64.c	2007-05-29 03:24:14.000000000 -0700
> > @@ -11,6 +11,7 @@
> >  #include <linux/bootmem.h>
> >  #include <linux/bitops.h>
> >  #include <linux/module.h>
> > +#include <linux/perfmon.h>
> >  #include <asm/bootsetup.h>
> >  #include <asm/pda.h>
> >  #include <asm/pgtable.h>
> > @@ -283,4 +284,6 @@ void __cpuinit cpu_init (void)
> >  	fpu_init(); 
> > 
> >  	raw_local_save_flags(kernel_eflags);
> > +
> > + 	pfm_init_percpu();
> 
> Just use a cpu notifier instead. No need to add everybody's per cpu init code here.
The code must run on the CPU that is being initialized.
> > diff --exclude=.git -urp linux-2.6.22.base/arch/x86_64/kernel/smpboot.c linux-2.6.22/arch/x86_64/kernel/smpboot.c
> > --- linux-2.6.22.base/arch/x86_64/kernel/smpboot.c	2007-05-29 03:17:16.000000000 -0700
> > +++ linux-2.6.22/arch/x86_64/kernel/smpboot.c	2007-05-29 03:24:14.000000000 -0700
> > @@ -49,6 +49,7 @@
> >  #include <linux/mc146818rtc.h>
> >  #include <linux/smp.h>
> >  #include <linux/kdebug.h>
> > +#include <linux/perfmon.h>
> > 
> >  #include <asm/mtrr.h>
> >  #include <asm/pgalloc.h>
> > @@ -1043,6 +1044,7 @@ int __cpu_disable(void)
> >  	spin_unlock(&vector_lock);
> >  	remove_cpu_from_maps();
> >  	fixup_irqs(cpu_online_map);
> > +	pfm_cpu_disable();
> 
> Also cpu notifier.
> 
Same thing here. I need to run on the CPU that is being disabled.
> 
> No compat syscalls? 
> 
compat syscalls for what? I need to ensure backward compatiblity on IA-64 only.
-- 
-Stephane
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/