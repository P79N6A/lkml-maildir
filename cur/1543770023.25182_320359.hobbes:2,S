Date: Wed, 25 May 2005 01:35:29 +0900 (KST)
From: Tejun Heo <>
Subject: Re: [PATCH Linux 2.6.12-rc4-mm2 02/03] cfq: cfq_io_context leak fix
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/5/24/206

02_cfq_ioc_leak_fix.patch
	When a process has more than one cic's associated with it,
	only the first one was kmem_cache_free'd in the original code.
	This patch frees all cic's in cfq_free_io_context().
	While at it, remove unnecessary refcounting from cic's to ioc.
	This reference is created when each cic is created and removed
	altogether when the ioc is exited, and, thus, serves no
	purpose.
Signed-off-by: Tejun Heo <htejun@gmail.com>
 cfq-iosched.c |   19 ++++++++++---------
 1 files changed, 10 insertions(+), 9 deletions(-)
Index: blk-fixes/drivers/block/cfq-iosched.c
===================================================================
--- blk-fixes.orig/drivers/block/cfq-iosched.c	2005-05-25 01:35:16.000000000 +0900
+++ blk-fixes/drivers/block/cfq-iosched.c	2005-05-25 01:35:16.000000000 +0900
@@ -1238,6 +1238,14 @@ cfq_find_cfq_hash(struct cfq_data *cfqd,
 
 static void cfq_free_io_context(struct cfq_io_context *cic)
 {
+	struct cfq_io_context *__cic;
+	struct list_head *entry, *next;
+
+	list_for_each_safe(entry, next, &cic->list) {
+		__cic = list_entry(entry, struct cfq_io_context, list);
+		kmem_cache_free(cfq_ioc_pool, __cic);
+	}
+
 	kmem_cache_free(cfq_ioc_pool, cic);
 }
 
@@ -1260,7 +1268,6 @@ static void cfq_exit_single_io_context(s
 
 	cfq_put_queue(cic->cfqq);
 	cic->cfqq = NULL;
-	put_io_context(cic->ioc);
 	spin_unlock(q->queue_lock);
 }
 
@@ -1271,7 +1278,7 @@ static void cfq_exit_single_io_context(s
 static void cfq_exit_io_context(struct cfq_io_context *cic)
 {
 	struct cfq_io_context *__cic;
-	struct list_head *entry, *nxt;
+	struct list_head *entry;
 	unsigned long flags;
 
 	local_irq_save(flags);
@@ -1279,10 +1286,8 @@ static void cfq_exit_io_context(struct c
 	/*
 	 * put the reference this task is holding to the various queues
 	 */
-	list_for_each_safe(entry, nxt, &cic->list) {
+	list_for_each(entry, &cic->list) {
 		__cic = list_entry(entry, struct cfq_io_context, list);
-
-		list_del(&__cic->list);
 		cfq_exit_single_io_context(__cic);
 	}
 
@@ -1471,8 +1476,6 @@ cfq_get_io_context(struct cfq_data *cfqd
 		ioc->cic = cic;
 		ioc->set_ioprio = cfq_ioc_set_ioprio;
 		cic->ioc = ioc;
-		atomic_inc(&ioc->refcount);
-
 		cic->key = cfqd;
 		atomic_inc(&cfqd->ref);
 	} else {
@@ -1509,8 +1512,6 @@ cfq_get_io_context(struct cfq_data *cfqd
 			goto err;
 
 		__cic->ioc = ioc;
-		atomic_inc(&ioc->refcount);
-
 		__cic->key = cfqd;
 		atomic_inc(&cfqd->ref);
 		list_add(&__cic->list, &cic->list);
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/