Date: Sat, 13 Sep 2003 13:01:09 -0700 (PDT)
From: Andre Hedrick <>
Subject: Re: People, not GPL  [was: Re: Driver Model]
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2003/9/13/141

SYMBOL in question "dequeue_signal"
*************************************
pwd :: /usr/src/linux-2.4.18-27/kernel/signal.c
/*
 * Dequeue a signal and return the element to the caller, which is
 * expected to free it.
 *
 * All callers must be holding current->sigmask_lock.
 */
int
dequeue_signal(sigset_t *mask, siginfo_t *info)
{
        int sig = 0;
#if DEBUG_SIG
printk("SIG dequeue (%s:%d): %d ", current->comm, current->pid,
        signal_pending(current));
#endif
        sig = next_signal(current, mask);
        if (sig) {
                if (current->notifier) {
                        if (sigismember(current->notifier_mask, sig)) {
                                if (!(current->notifier)(current->notifier_data)) {
                                        current->sigpending = 0;
                                        return 0;
                                }
                        }
                }
                if (!collect_signal(sig, &current->pending, info))
                        sig = 0;
                /* XXX: Once POSIX.1b timers are in, if si_code == SI_TIMER,
                   we need to xchg out the timer overrun values.  */
        }
        recalc_sigpending(current);
#if DEBUG_SIG
printk(" %d -> %d\n", signal_pending(current), sig);
#endif
        return sig;
}
EXPORT_SYMBOL(dequeue_signal);
EXPORT_SYMBOL(flush_signals);
*************************************
pwd :: /usr/src/linux-2.4.20-18.9/kernel/signal.c
static int __dequeue_signal(struct sigpending *pending, sigset_t *mask,
                        siginfo_t *info)
{
        int sig = 0;
        sig = next_signal(pending, mask);
        if (sig) {
                if (current->notifier) {
                        if (sigismember(current->notifier_mask, sig)) {
                                if (!(current->notifier)(current->notifier_data)) {
                                        current->sigpending = 0;
                                        return 0;
                                }
                        }
                }
                if (!collect_signal(sig, pending, info))
                        sig = 0;
                /* XXX: Once POSIX.1b timers are in, if si_code == SI_TIMER,
                   we need to xchg out the timer overrun values.  */
        }
        recalc_sigpending();
        return sig;
}
/*
 * Dequeue a signal and return the element to the caller, which is
 * expected to free it.
 *
 * All callers have to hold the siglock.
 */
int dequeue_signal(sigset_t *mask, siginfo_t *info)
{
        int signr = __dequeue_signal(&current->pending, mask, info);
        if (!signr)
                signr = __dequeue_signal(&current->signal->shared_pending,
                                         mask, info);
        return signr;
}
EXPORT_SYMBOL(recalc_sigpending);
EXPORT_SYMBOL_GPL(dequeue_signal);
EXPORT_SYMBOL(flush_signals);
*************************************
Now it is totally clear this is an attempt to strip and remove
functionality of the API, period.
But this is to obvious to miss.
Regards,
Andre Hedrick
LAD Storage Consulting Group
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/