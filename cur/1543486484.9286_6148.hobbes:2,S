Date: Fri, 19 Feb 1999 09:36:28 +0100
From: "Ulrich Windl" <>
Subject: 2.2.1 (i386): announce: `nanokernel' (experimental, first snapshot) available
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/2/19/12

Hello,
I decided to make this available before the week-end: I have got my 
first running snapshot of the "nanokernel" for i386 architecture.
Locations to see are (as usual) 
master.kernel.org/pub/linux/daemons/ntp/PPS and 
ftp://pcphy4.physik.uni-regensburg.de/pub/wiu09524/PPS,
 and the file 
to look for is PPSkit-0.6-pre1.diff.gz
I haven't tested a lot (it was too late/early), but this version no 
longer adds two seconds every second as the first one did. a compiled 
xntpd might even run because the timex seems compatible enough, and I 
down-scaled "time_tick" to microseconds again in STA_NANO is clear.
Just have a look. The timeoffset still has a resolution of 1µs, but I 
have a 100MHz Pentium anyway. True nanoseconds are still to be done.
The code is highly experimental, of course, so don't use it on 
production machines. Also don't distribute any patches against NTP 
that you made for this version.
Even if you don't use NTP, you should have a look whether all your 
drivers still compile.
Specifically, is it correct, that these locks are added?:
 static void do_normal_gettime(struct timeval * tm)
 {
-        *tm=xtime;
+	read_lock(&xtime_lock);	/* UW thinks this is necessary and OK 
*/
+	tm->tv_sec = xtime.tv_sec;
+	tm->tv_usec = xtime.tv_nsec / 1000;
+	read_unlock(&xtime_lock);
 }
-asmlinkage int sys_stime(int * tptr)
+asmlinkage int sys_stime(int *tptr)
 {
 	int value;
 
@@ -91,15 +436,17 @@
 		return -EPERM;
 	if (get_user(value, tptr))
 		return -EFAULT;
-	cli();
+	write_lock_irq(&xtime_lock);	/* UW thinks we need it */
 	xtime.tv_sec = value;
-	xtime.tv_usec = 0;
+	xtime.tv_nsec = 0;
 	time_adjust = 0;	/* stop active adjtime() */
+#ifdef CONFIG_NTP
 	time_status |= STA_UNSYNC;
 	time_state = TIME_ERROR;	/* p. 24, (a) */
 	time_maxerror = NTP_PHASE_LIMIT;
 	time_esterror = NTP_PHASE_LIMIT;
-	sti();
+#endif
+	write_unlock_irq(&xtime_lock);
 	return 0;
 }
 inline static void warp_clock(void)
 {
-	cli();
+	write_lock_irq(&xtime_lock);	/* UW thinks we need it */
 	xtime.tv_sec += sys_tz.tz_minuteswest * 60;
-	sti();
+	write_unlock_irq(&xtime_lock);
 }
Another thing is: Is it worth to "hand-assembler" the macros from 
"kernel/l_fp.h"? Currently I'm using gcc´s "long long" for 64bith 
maths (see bug report). The C-grows 32bit solution from the same file 
seems slower to me. Any assembly guru that volunteers?
Regards,
Ulrich Windl
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/