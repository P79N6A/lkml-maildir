Date: Tue, 18 May 2004 22:45:07 -0700 (PDT)
From: Alex Davis <>
Subject: signal handling issue.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2004/5/19/10

There appears to be a change between linux 2.4 and 2.6
in how signals are handled. As a test, I wrote the program
below:
#include <stdio.h>
#include <signal.h>
#include <setjmp.h>
static jmp_buf env;
static void handler(int s) {
        printf("caught signal %d\n", s);
        longjmp(env, 1);
}
int main() {
        int * p = 0;
        printf("write\n");
        signal(SIGSEGV, handler);
        if ( ! setjmp(env) )
        {
                *p = 0;
        }
        printf("read\n");
        signal(SIGSEGV, handler);
        if ( ! setjmp(env) )
        {
                int a = *p;
        }
        return 0;
}
When run on 2.4.26, the program prints:
write
caught signal 11
read
caught signal 11
Which (I think) is expected, but when run on 2.6.5,
the program prints:
write
caught signal 11
read
Segmentation fault
It's as if the second call to signal is being ignored.
Is this a bug or a feature?
-Alex
=====
I code, therefore I am
	
		
__________________________________
Do you Yahoo!?
SBC Yahoo! - Internet access at a great low price.
http://promo.yahoo.com/sbc/
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/