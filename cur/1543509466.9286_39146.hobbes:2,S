Date: Wed, 15 Sep 1999 13:31:46 -0400
From: Jordan Mendelson <>
Subject: Re: High Performance I/O stuff (more)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/9/15/105

Jayson Nordwick wrote:
> If you find an available signal, set the handler for it, the block it,
> this signal number now effectively becomes the completion port.  You then
> can fcntl() a file descriptor with F_SETSIG and the signal number.  Then to
> fetch the blocked signals, use sigwaitinfo().  I guess you could also use
> aio_{read,write}() and set sigevent appropriately.  This actually seems
> preferable since you can then use aio_return() to find the return value
> out and use aio_cancel() to cancel the request if wanted.
You probably don't need the aio_*() interfaces to be honest. It's just as easy
to set the socket nonblocking and deal with the event system as it is.
> Basically, unless anybody can see anything wrong with this get to work
> implementing!
I really haven't seen any examples of how to work with the event system. 
Attached to this message is a basic example using sigwaitinfo() for linux
2.2.x and glibc 2.1. Once si_band information is integrated into the stable
tree, this will actually be an effective way to eliminate polling, although it
could use a bit of speeding up.
If I have made any mistakes, please email me. There wasn't that much
documentation on how to do it correctly.
Jordan
--
Jordan Mendelson     : 
http://jordy.wserv.com
Web Services, Inc.   : 
http://www.wserv.com
[unhandled content-type:application/x-unknown-content-type-cfile]