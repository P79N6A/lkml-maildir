Date: Fri, 17 May 2002 20:46:33 +0200
From: Manfred Spraul <>
Subject: Re: [PATCH] #2 VIA Rhine stalls: TxAbort handling
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2002/5/17/136

>> All the three conditions caused the TXON bit of CR1 went off. the
>> driver must wait  a little while until the bit go off, reset the pointer of
>> [...]
>> do {} while (BYTE_REG_BITS_IS_ON(CR0_TXON,&pMacRegs->byCR0));
> 
> The driver "waits a little" in the interrupt handler? How long can that
> take, worst case? I don't know of many places where the kernel stops to
> wait for an external device to change some value.
> 
It's not that uncommon: Most network drivers busy-wait after stopping 
the tx process during netif_close().
But I would add a maximum timeout and a printk - just to avoid 
unexplainable system hangs. One example would be natsemi_stop_rxtx() in 
drivers/net/natsemi.c.
IIRC all register reads from the addresses that belong to a pulled out 
PCMCIA card return 0xFFFFFFFF ;-)
Shing, I don't like the empty body of the while loop. It's not a bug, 
but doesn't that generate a large load on the pci bus?
I've always added an udelay(1), i.e. wait one microsecond, into such loops.
--
	Manfred
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/