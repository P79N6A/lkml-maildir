Date: Mon, 23 Sep 2002 01:32:30 +0200 (CEST)
From: Ingo Molnar <>
Subject: Re: [ltt-dev] Re: [PATCH] LTT for 2.5.38 1/9: Core infrastructure
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2002/9/22/167

this is that a trace point should do, at most:
--------------------->
task_t *tracer_task;
int curr_idx[NR_CPUS];
int curr_pending[NR_CPUS];
struct trace_event **trace_ring;
void trace(event, data1, data2, data3)
{
	int cpu = smp_processor_id();
	int idx, pending, *curr = curr_idx + cpu;
	struct trace_event *t;
	unsigned long flags;
	if (!event_wanted(current, event, data1, data2, data3))
		return;
	local_irq_save(flags);
        idx = ++curr_idx[cpu] & (NR_TRACE_ENTRIES - 1);
	pending = ++curr_pending[cpu];
        t = trace_ring[cpu] + idx;
        t->event = event;
        rdtscll(t->timestamp);
        t->data1 = data1;
        t->data2 = data2;
        t->data3 = data3;
	if (curr_pending == TRACE_LOW_WATERMARK && tracer_task)
		wake_up_process(tracer_task);
	local_irq_restore(flags);
}
this should cover most of what's needed. The event_wanted() filter
function should be made as fast as possible. Note that the irq-disabled
section is not strictly needed but nice and also makes it work on the
preemptible kernel. (It's not a big issue at all to run these few
instructions with irqs disabled.)
[there are also other details like putting curr_index and curr_pending
into the per-cpu area and similar stuff.]
	Ingo
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/