Date: Tue, 31 May 2005 16:53:52 +0200
From: "Serge Noiraud" <>
Subject: RT : 2.6.12rc5 + realtime-preempt-2.6.12-rc5-V0.7.47-15
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/5/31/101

I have a test program which made a loop in RT to mesure the system
perturbation.
It works finely in a tty environment.
When I run it in an X environment ( xterm ), I get something like if I
click the Enter key in the active window.
If I open a new xterm, this is the new active window which receive these
events.
These events stop when the program stop.
I tried with X in RT and no RT : I have the problem.
I send you the program in copy to reproduce.
I have this problem in all version of RT.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "fonctions.h"
#include <stdio.h>
#include <unistd.h>
#include <sys/mman.h> /* for mmap and MCL_CURRENT */
#include <stdlib.h> /* for atoi */
#include <asm/msr.h> /* for rdtsc */
#define __USE_GNU 
#include <sched.h> /* for sched_xxxx */
//#define NB_TEST 60000000000ULL
#define NB_TEST 60000000ULL
float get_cpu_clock_speed()
{
  FILE *fp;
  char buffer[1024];
  size_t bytes_read;
  char *match;
  float clock_speed;
  fp = fopen ("/proc/cpuinfo", "r");
  bytes_read = fread (buffer, 1, sizeof (buffer), fp);
  fclose (fp);
  if (bytes_read == 0 || bytes_read == sizeof (buffer))
    return 0;
  buffer[bytes_read] = '\0';
  match = strstr (buffer, "cpu MHz");
  if (match == NULL)
    return 0;
  sscanf (match, "cpu MHz : %f", &clock_speed);
  return clock_speed;
}
int main(int argc,char **argv)
{
 unsigned long long max,dt;
 float frequency;
 int cptr;
 long long i;
 struct sched_param sched_param;
 double duree;
 union {
   unsigned long long total;
   struct {
     unsigned long MSL;
     unsigned long LSL;
   };
 } tempsdeb,tempsfin,t1,t2,tmax1,tmax2;
 cpu_set_t new_mask;
 pid_t p = 0;
 int ret;
  if (argc!=2)
  {
     fprintf(stderr,"Usage:%s <NUM_CPU>\n",argv[0]);
     return -1;
  }
  CPU_ZERO(&new_mask);
  CPU_SET(atoi(argv[1]),&new_mask);
  ret = sched_setaffinity(p,sizeof(cpu_set_t) , &new_mask);
  rdtsc(tempsdeb.MSL,tempsdeb.LSL);
  printf(" Start time %Lx \n",tempsdeb.total);
  sched_param.sched_priority =99;
  cptr = sched_setscheduler(getpid(), SCHED_FIFO,&sched_param );
  cptr = mlockall(MCL_CURRENT);
  printf("mlockall cptr %d\n",cptr);
 
 max=0;
 rdtsc(t1.MSL,t1.LSL);
 for (i = 0; i < NB_TEST; i++)
   {
	 rdtsc(t2.MSL,t2.LSL);
	 dt = t2.total - t1.total;
	 if ( dt > max) 
	 { max = dt;
	  tmax1.total = t1.total;
	  tmax2.total = t2.total;
	  }
	 t1.total = t2.total;
   }
 rdtsc(tempsfin.MSL,tempsfin.LSL);
 printf(" End time  %Lx \n",tempsfin.total);
 printf(" Max time 1  %Lx \n",tmax1.total);
 printf(" Max time 2  %Lx \n",tmax2.total);
 frequency = get_cpu_clock_speed();
  if (frequency == 0)
	  return -1;
 duree =((double) (tempsfin.total - tempsdeb.total))/(frequency*1000000);
 printf("Test duration is %f s max detected %.0f Âµs\n",duree,((double)max)/(frequency));
 return 0;
}