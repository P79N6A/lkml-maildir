Date: Mon, 10 Mar 2008 18:53:38 +0000
From: "Will Newton" <>
Subject: Re: copy_page_range() with VM_LOCKED
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/3/10/220

On Mon, Mar 10, 2008 at 5:40 PM, Hugh Dickins <hugh@veritas.com> wrote:
>  > mmap with MAP_LOCKED only promises the page will not be paged out, not
>  > that the page will never fault but I would like to get that behaviour.
>  >
>  > Would it be possible to add VM_LOCKED to the above conditional so
>  > copy_page_range would always copy VM_LOCKED vma page tables or would
>  > that be considered insane and broken?
>
>  It would be possible, but I don't think it would be justified - for
>  everybody who wants your behaviour, there'll be others who want the
>  current behaviour (and that condition reflects those cases on which
>  correctness demands we do the copy).
>
>  If you really want that, I think you'll have to patch your own kernel.
>
>  But much much better, mlock that area in your child after the fork,
>  since it isn't actually locked at present: that mlock will bring in
>  the pages - not quite as efficiently as copy_page_range would have done,
>  but as or more efficiently than the original mlock in the parent.
The reason I want to do this is to work around a silicon bug so I'd
rather keep the whole workaround in the kernel rather than hacking the
C library etc. I wasn't aware that the VM_LOCKED flag would be lost in
the child, it looks like I'll have to come up with a more creative
solution...
Thanks for taking the time to explain how this stuff fits together,