Date: Tue, 18 Jan 2000 12:13:08 +0100
From: Jamie Lokier <>
Subject: Re: Recent change in tcp_output.c is surely wrong
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/1/18/114

Rogier Wolff wrote:
> Hmm. I'm not too familiar with the exact wording of ANSI. However,
> they usually take the road where "more accuracy in intermediates is
> allowed", as that can normally only reduce the amount of trouble that
> you get into when things near the limit of the size you're using.
For signed types there is some flexibility, but unsigned types behave
pretty much as N bits.
> Is a compiler allowed to optimize
> 
>     a + 4 - 4 
> 
> into "a"?
On a 2's complement machine that is always true anyway.
> If you're right that a compiler may not extend the size of the
> intermediates beyond the size of an unsiged int, the Alpha compiler
> is in trouble, as it has to explicitly cater for this. Ints on Alpha
> are 32 bits, but registers are 64 bits, so it will have to explicitly
> clip the intermediate on:
> 
> 	(a << 4) >> 4 
> 
> Usually, ANSI will take the road where the compiler writer is allowed
> to optimize for the common case: More accuracy usually doesn't matter.
For a signed int, that optimisation would be valid on an Alpha.  Even in
GCC's model.  Think about what signed right shifts do.  But for an
unsigned int, it would be equivalent to `a & 0x0fffffff'.
enjoy,
-- Jamie
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/