Date: 03 Dec 1999 18:00:53 -0800
From: (Tom M. Kroeger)
Subject: Strange problem in my structs
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/12/3/195

I've just run into a very strange problem with a copy of the 2.2.12
kernel that I've modified to add predictive file prefetching.
I've got a file prefetch.h that declares several data structures I use
to track the file access patterns and prefetch files.  When I add one
new member to a specific structure (shown below), the compiled kernel
doesn't even begin to boot.  Lilo says:
 Uncompressing Linux.... OK, booting the kernel.
and then everything hangs.  Before I added the field everything
worked fine. To install the new kernel I've copied the following to my
test machine: the bzImage, the System.map and all the modules.  Then
I did a lilo to update things and rebooted.  Is there another kernel
file I'm forgetting?
typedef struct prediction {
        FileID  *ident;
        float   level;
        int     order;   /* newly added member */
} Prediction;
The entire header file is included below.  Any thoughts, suggestions,
comments or puzzled looks are welcome.
-- 
                       tmk
-----------------------------------------------------------------------
Tom M. Kroeger                           Pray for wind
Graduate Student, UC Santa Cruz      \    Pray for waves
e-mail: tmk@cse.ucsc.edu             |\    and Pray it's your day off!
http://www.cse.ucsc.edu/~tmk
         |~\
(831) 459-4458                       |__\
(831) 426-9055 home                 ,----+--
/**
 * $Id: prefetch.h,v 1.3 1999/12/02 02:50:54 tmk Exp $
 *
 *  structures for basic statistics and histogram for keeping statistics
 *of filesystem performance.
 *
 *                                       tmk 
 */
#ifndef _LINUX_FS_PREFETCH_H
#define _LINUX_FS_PREFETCH_H
#define  PREF_LOCK 2
#define PREFSIZE 100
#define SLOW 1
extern int tmk_prefetch_on;
extern unsigned int max_prefetch;
/* predictive performance info  */
extern int  numb_predicted;
extern int  numb_correct;
extern unsigned long total_prefetched;
extern unsigned long disk_prefetched;
extern unsigned long disk_reads;
extern int buff_check;
extern int buff_found;
extern int buff_look;
extern int buff_copies;
/* time prefetch durations */
extern prefetch_t prefetchTable[PREFSIZE];
extern long prefetch_in;
extern long prefetch_out;
extern long prefetch_done;
/*==========================================================
**
**      assert ()
**
**      modified copy from 386bsd:/usr/include/sys/assert.h
**
**   copied to here from ./drivers/scsi/ncr53c8xx.c
**----------------------------------------------------------
*/
#define assert(expression) { \
         if (!(expression)) { \
                 (void)printk(KERN_ERR \
                         "assertion \"%s\" failed: file \"%s\", line %d\n", \
                         #expression, \
                         __FILE__, __LINE__); \
         } \
 }
/* indexs go 0 - 254   255 is the equivalent of NULL */
/*#define MAX_PARTITION 65536*/
#define MAX_PARTITION 255
#define NULL_INDEX (Index) MAX_PARTITION
#define emptyIndex(index)  (index==MAX_PARTITION)
#define clearIndex(index)  (index=MAX_PARTITION)
#define clearEntry(entry)  ((entry)->ident.num=0)
#define emptyEntry(entry)  ((entry)->ident.num==0)
typedef unsigned int Index;
typedef int Count;
#define EXEC_EVENT_TEST (current->doneDisk & 32768)
#define OPEN_EVENT 0
#define EXEC_EVENT 1 
typedef struct fileID {
	short type;                /* 0= open , 1 = exec */
	short dev;
	unsigned long  num;
	unsigned long  generation;
	
#if SLOW
	char * name;	/* name just for debugging */
#endif
} FileID;
/* a file entry */
typedef struct fileEntry {
	FileID   ident;
	Count    count;
	Index    next;     /* next cibling */
	Index    child;    /* first child */
	Index    parent;   /* who we follow Needed for reducing and accounting 
			      for  curr context = sum +1 counts */
} FileEntry;
typedef struct predPartition {
	int                numbEntries;
	struct predPartition*  next;
	FileEntry*         entries;
	int                numbNew;   /* used to limit the number of new
				       * entries for each instance */
} Partition;
typedef struct context {
	Partition     *part;
	Index         index;
	FileEntry     *entry;
} Context;
typedef struct prediction {
	FileID  *ident;
	float   level;
	int     order;
} Prediction;
Index observeEvent(Context* context,struct dentry * dentry);
void reducePart(Context* context);
void checkPartition(Partition* part);
void printPartition(Partition* part);
void removePartition(struct dentry * dentry);
int checkPredictions(Prediction* preds, int numb, Partition *part,int par);
extern void init_fs_prefetch(void);
extern void setup_part_table(struct dentry * );
extern int process_predictions(struct dentry *);
extern int  setupPageBuffers(struct page *,struct buffer_head **, int , 
			     struct inode * , int ) ;
extern int prefetch_file_data_pages(struct inode * inode, 
				    unsigned long prefetch, char * name);
extern int prefetch_file_page(struct inode * inode,  unsigned long offset,
		       struct page ** hash );
#endif
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/