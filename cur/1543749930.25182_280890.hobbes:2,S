Date: Thu, 23 Dec 2004 18:33:31 +0300
From: Vladimir Saveliev <>
Subject: reiserfs bug fix: do not clear MS_ACTIVE mount flag
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2004/12/23/56

Hello
Andrew, please apply this reiserfs bug fix.
When CONFIG_QUOTA is defined reiserfs's finish_unfinished sets and clears
MS_ACTIVE bit in s_flags field of super block. If that bit was set already
it should not be set.
 fs/reiserfs/super.c |   13 ++++++++++---
 1 files changed, 10 insertions(+), 3 deletions(-)
diff -puN fs/reiserfs/super.c~reiserfs-do-not-clear-MS_ACTIVE fs/reiserfs/super.c
--- linux-2.6.10-rc3-mm1/fs/reiserfs/super.c~reiserfs-do-not-clear-MS_ACTIVE	2004-12-23 18:22:06.568755520 +0300
+++ linux-2.6.10-rc3-mm1-vs/fs/reiserfs/super.c	2004-12-23 18:22:06.576756006 +0300
@@ -158,6 +158,7 @@ static int finish_unfinished (struct sup
     int truncate;
 #ifdef CONFIG_QUOTA
     int i;
+    int ms_active_set;
 #endif
  
  
@@ -168,7 +169,12 @@ static int finish_unfinished (struct sup
 
 #ifdef CONFIG_QUOTA
     /* Needed for iput() to work correctly and not trash data */
-    s->s_flags |= MS_ACTIVE;
+    if (s->s_flags & MS_ACTIVE) {
+	    ms_active_set = 0;
+    } else {
+	    ms_active_set = 1;
+	    s->s_flags |= MS_ACTIVE;
+    }
     /* Turn on quotas so that they are updated correctly */
     for (i = 0; i < MAXQUOTAS; i++) {
 	if (REISERFS_SB(s)->s_qf_names[i]) {
@@ -276,8 +282,9 @@ static int finish_unfinished (struct sup
             if (sb_dqopt(s)->files[i])
                     vfs_quota_off_mount(s, i);
     }
-    /* Restore the flag back */
-    s->s_flags &= ~MS_ACTIVE;
+    if (ms_active_set)
+	    /* Restore the flag back */
+	    s->s_flags &= ~MS_ACTIVE;
 #endif
     pathrelse (&path);
     if (done)
_