Date: Sat, 2 Sep 2000 17:36:24 +0100 (BST)
From: John Levon <>
Subject: Drivers needlessly setting TASK_RUNNING
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/9/2/124

The following drivers appear to set TASK_RUNNING needlessly.
Against test8pre1.
Sorry for the mass mailing !
thanks
john
--- drivers/net/wan/cosa.c	Sat Jul 15 21:11:56 2000
+++ drivers/net/wan/cosa.c.new	Fri Sep  1 04:13:44 2000
@@ -524,7 +524,6 @@
 		current->state = TASK_INTERRUPTIBLE;
 		cosa_putstatus(cosa, SR_TX_INT_ENA);
 		schedule_timeout(30);
-		current->state = TASK_RUNNING;
 		irq = probe_irq_off(irqs);
 		/* Disable all IRQs from the card */
 		cosa_putstatus(cosa, 0);
@@ -824,14 +823,12 @@
 		if (signal_pending(current) && chan->rx_status == 0) {
 			chan->rx_status = 1;
 			remove_wait_queue(&chan->rxwaitq, &wait);
-			current->state = TASK_RUNNING;
 			spin_unlock_irqrestore(&cosa->lock, flags);
 			up(&chan->rsem);
 			return -ERESTARTSYS;
 		}
 	}
 	remove_wait_queue(&chan->rxwaitq, &wait);
-	current->state = TASK_RUNNING;
 	kbuf = chan->rxdata;
 	count = chan->rxsize;
 	spin_unlock_irqrestore(&cosa->lock, flags);
@@ -909,14 +906,12 @@
 		if (signal_pending(current) && chan->tx_status == 0) {
 			chan->tx_status = 1;
 			remove_wait_queue(&chan->txwaitq, &wait);
-			current->state = TASK_RUNNING;
 			chan->tx_status = 1;
 			spin_unlock_irqrestore(&cosa->lock, flags);
 			return -ERESTARTSYS;
 		}
 	}
 	remove_wait_queue(&chan->txwaitq, &wait);
-	current->state = TASK_RUNNING;
 	up(&chan->wsem);
 	spin_unlock_irqrestore(&cosa->lock, flags);
 	kfree(kbuf);
@@ -1538,7 +1533,6 @@
 #ifdef MODULE
 	current->state = TASK_INTERRUPTIBLE;
 	schedule_timeout(HZ/2);
-	current->state = TASK_RUNNING;
 #else
 	udelay(5*100000);
 #endif
--- drivers/char/serial.c	Fri Sep  1 04:16:40 2000
+++ drivers/char/serial.c.new	Fri Sep  1 04:17:00 2000
@@ -2902,7 +2902,6 @@
 		if (timeout && time_after(jiffies, orig_jiffies + timeout))
 			break;
 	}
-	set_current_state(TASK_RUNNING);
 #ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT
 	printk("lsr = %d (jiff=%lu)...done\n", lsr, jiffies);
 #endif
--- drivers/char/cyclades.c	Sat Jul 15 21:11:46 2000
+++ drivers/char/cyclades.c.new	Fri Sep  1 04:19:13 2000
@@ -2789,14 +2789,12 @@
 	    if (timeout && time_after(jiffies, orig_jiffies + timeout))
 		break;
 	}
-	current->state = TASK_RUNNING;
     } else {
 	// Nothing to do!
     }
     /* Run one more char cycle */
     current->state = TASK_INTERRUPTIBLE;
     schedule_timeout(char_time * 5);
-    current->state = TASK_RUNNING;
 #ifdef CY_DEBUG_WAIT_UNTIL_SENT
     printk("Clean (jiff=%lu)...done\n", jiffies);
 #endif
--- drivers/char/rocket.c	Tue Jul 11 19:33:45 2000
+++ drivers/char/rocket.c.new	Fri Sep  1 04:20:48 2000
@@ -1650,7 +1650,6 @@
 		if (signal_pending(current))
 			break;
 	}
-	current->state = TASK_RUNNING;
 #ifdef ROCKET_DEBUG_WAIT_UNTIL_SENT
 	printk("txcnt = %d (jiff=%lu)...done\n", txcnt, jiffies);
 #endif
--- drivers/char/istallion.c	Wed Aug  2 20:38:26 2000
+++ drivers/char/istallion.c.new	Fri Sep  1 04:21:41 2000
@@ -1532,7 +1532,6 @@
 	if (len > 0) {
 		current->state = TASK_INTERRUPTIBLE;
 		schedule_timeout(len);
-		current->state = TASK_RUNNING;
 	}
 } 
--- drivers/char/sx.c	Sat Aug 26 16:26:25 2000
+++ drivers/char/sx.c.new	Fri Sep  1 04:22:49 2000
@@ -1561,7 +1561,6 @@
 		if (signal_pending (current))
 				break;
 	}
-	current->state = TASK_RUNNING;
 	if (sx_read_channel_byte (port, hi_hstat) != HS_IDLE_CLOSED) {
 		if (sx_send_command (port, HS_FORCE_CLOSED, -1, HS_IDLE_CLOSED) != 1) {
 			printk (KERN_ERR  
--- drivers/char/serial_21285.c	Sat Aug 26 16:26:24 2000
+++ drivers/char/serial_21285.c.new	Fri Sep  1 04:24:07 2000
@@ -256,7 +256,6 @@
 		if (timeout && time_after(jiffies, orig_jiffies + timeout))
 			break;
 	}
-	current->state = TASK_RUNNING;
 }
 
 static int rs285_open(struct tty_struct *tty, struct file *filp)
--- drivers/char/dtlk.c	Sat Jul 15 21:11:47 2000
+++ drivers/char/dtlk.c.new	Fri Sep  1 04:24:48 2000
@@ -392,7 +392,6 @@
 {
 	current->state = TASK_INTERRUPTIBLE;
 	schedule_timeout((ms * HZ + 1000 - HZ) / 1000);
-	current->state = TASK_RUNNING;
 }
 
 static int dtlk_readable(void)
--- drivers/char/synclink.c	Wed Aug  2 20:38:26 2000
+++ drivers/char/synclink.c.new	Fri Sep  1 04:26:26 2000
@@ -3354,7 +3354,6 @@
 		}
 	}
       
-	set_current_state(TASK_RUNNING);
 exit:
 	if (debug_level >= DEBUG_LEVEL_INFO)
 		printk("%s(%d):mgsl_wait_until_sent(%s) exit\n",
--- drivers/char/drm/gamma_dma.c	Wed Aug  2 20:38:25 2000
+++ drivers/char/drm/gamma_dma.c.new	Fri Sep  1 04:28:20 2000
@@ -797,7 +797,6 @@
 				break;
 			}
 		}
-		current->state = TASK_RUNNING;
 		remove_wait_queue(&dev->lock.lock_queue, &entry);
 	}
 
--- drivers/char/generic_serial.c	Sat Aug 26 16:26:19 2000
+++ drivers/char/generic_serial.c.new	Fri Sep  1 04:29:33 2000
@@ -428,7 +428,6 @@
 	}
 
 	gs_dprintk (GS_DEBUG_FLUSH, "charsleft = %d.\n", charsleft); 
-	set_current_state (TASK_RUNNING);
 
 	func_exit();
 	return rv;
--- drivers/char/rio/rio_linux.c	Sat Aug 26 16:26:22 2000
+++ drivers/char/rio/rio_linux.c.new	Fri Sep  1 04:30:10 2000
@@ -349,7 +349,6 @@
   rio_dprintk (RIO_DEBUG_DELAY, "delaying %d jiffies\n", njiffies);  
   current->state = TASK_INTERRUPTIBLE;
   schedule_timeout(njiffies);
-  current->state = TASK_RUNNING;
   func_exit();
 
   if (signal_pending(current))
@@ -367,7 +366,6 @@
   rio_dprintk (RIO_DEBUG_DELAY, "delaying %d jiffies (ni)\n", njiffies);  
   current->state = TASK_UNINTERRUPTIBLE;
   schedule_timeout(njiffies);
-  current->state = TASK_RUNNING;
   func_exit();
   return !RIO_FAIL;
 }
--- drivers/char/amiserial.c	Wed Aug  2 20:38:24 2000
+++ drivers/char/amiserial.c.new	Fri Sep  1 04:32:42 2000
@@ -1676,7 +1676,6 @@
 		if (timeout && time_after(jiffies, orig_jiffies + timeout))
 			break;
 	}
-	current->state = TASK_RUNNING;
 #ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT
 	printk("lsr = %d (jiff=%lu)...done\n", lsr, jiffies);
 #endif
--- drivers/sbus/char/sab82532.c	Sat Aug 26 16:26:43 2000
+++ drivers/sbus/char/sab82532.c.new	Fri Sep  1 04:33:47 2000
@@ -1722,7 +1722,6 @@
 		if (timeout && time_after(jiffies, orig_jiffies + timeout))
 			break;
 	}
-	current->state = TASK_RUNNING;
 #ifdef SERIAL_DEBUG_WAIT_UNTIL_SENT
 	printk("xmit_cnt = %d, alls = %d (jiff=%lu)...done\n", info->xmit_cnt, info->all_sent, jiffies);
 #endif
--- drivers/sbus/char/su.c	Mon Jul 10 03:08:10 2000
+++ drivers/sbus/char/su.c.new	Fri Sep  1 04:34:51 2000
@@ -1851,7 +1851,6 @@
 		if (timeout && time_after(jiffies, orig_jiffies + timeout))
 			break;
 	}
-	current->state = TASK_RUNNING;
 #ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT
 	printk("lsr = %d (jiff=%lu)...done\n", lsr, jiffies);
 #endif
--- drivers/macintosh/macserial.c	Mon Jul 10 03:15:20 2000
+++ drivers/macintosh/macserial.c.new	Fri Sep  1 04:36:04 2000
@@ -2020,7 +2020,6 @@
 		if (timeout && time_after(jiffies, orig_jiffies + timeout))
 			break;
 	}
-	current->state = TASK_RUNNING;
 }
 
 /*
--- drivers/usb/audio.c	Fri Aug 11 00:21:37 2000
+++ drivers/usb/audio.c.new	Fri Sep  1 04:37:13 2000
@@ -625,7 +625,6 @@
 			notkilled = 0;
 		}
 	}
-	set_current_state(TASK_RUNNING);
 	if (u->durb[0].urb.transfer_buffer)
 		kfree(u->durb[0].urb.transfer_buffer);
 	if (u->durb[1].urb.transfer_buffer)
@@ -1096,7 +1095,6 @@
 			notkilled = 0;
 		}
 	}
-	set_current_state(TASK_RUNNING);
 	if (u->durb[0].urb.transfer_buffer)
 		kfree(u->durb[0].urb.transfer_buffer);
 	if (u->durb[1].urb.transfer_buffer)
--- drivers/usb/serial/digi_acceleport.c	Sat Aug 26 16:26:56 2000
+++ drivers/usb/serial/digi_acceleport.c.new	Fri Sep  1 04:38:08 2000
@@ -547,8 +547,6 @@
 
 	timeout = schedule_timeout(timeout);
 
-	set_current_state( TASK_RUNNING );
-
 	remove_wait_queue( q, &wait );
 
 	return( timeout );
--- drivers/tc/zs.c	Tue Jul 11 19:34:18 2000
+++ drivers/tc/zs.c.new	Fri Sep  1 04:39:04 2000
@@ -1318,7 +1318,6 @@
 		if (timeout && ((orig_jiffies + timeout) < jiffies))
 			break;
 	}
-	current->state = TASK_RUNNING;
 }
 
 /*
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
Please read the FAQ at 
http://www.tux.org/lkml/