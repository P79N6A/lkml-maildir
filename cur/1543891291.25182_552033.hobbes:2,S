Date: Fri, 1 Jun 2007 22:20:10 +0400
From: Cyrill Gorcunov <>
Subject: Re: [PATCH 2/2] Fix possible leakage of blocks in UDF
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/6/1/238

[Eric Sandeen - Fri, Jun 01, 2007 at 12:51:34PM -0500]
| Cyrill Gorcunov wrote:
| >[Eric Sandeen - Fri, Jun 01, 2007 at 12:17:53PM -0500]
| >| Andrew Morton wrote:
| >| 
| >| >Recursive lock_kernel() is OK.
| >| 
| >| Oh, it is?  Clearly I am not well versed in the BKL... that's probably a 
| >| good thing.... :)
| >| 
| >| Ok, let me look into it further.  I changed lock_kernel to 
| >| udf_lock_kernel to complain & backtrace if we re-lock, and it always 
| >| immediately hung after that; I assumed that was it.  I'll investigate 
| >| further.
| >| 
| >| -Eric
| >| 
| >
| >Btw, Andrew is there any way to force kernel to use special UDF module
| >instead of compiled-in one? (Sorry for stupid question ;)
| 
| Not if it's  already built in (at least not with more hackery than it's 
| worth...) - just rebuild your kernel w/ udf as a module.
| 
| BTW my testcase before was bogus, that's not what's causing the lockup. 
|  I'll keep investigating now that I know what *not* to look for. ;-)
| 
| -Eric
| 
Eric, could you try this
		Cyrill
diff --git a/fs/udf/namei.c b/fs/udf/namei.c
index 51fe307..833c1b6 100644
--- a/fs/udf/namei.c
+++ b/fs/udf/namei.c
@@ -983,6 +983,8 @@ static int udf_symlink(struct inode * dir, struct dentry * dentry, const char *
 		block = udf_get_pblock(inode->i_sb, block,
 			UDF_I_LOCATION(inode).partitionReferenceNum, 0);
 		epos.bh = udf_tread(inode->i_sb, block);
+		if (!epos.bh)
+			BUG();
 		lock_buffer(epos.bh);
 		memset(epos.bh->b_data, 0x00, inode->i_sb->s_blocksize);
 		set_buffer_uptodate(epos.bh);