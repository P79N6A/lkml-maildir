Date: Fri, 9 Jul 1999 18:21:32 -0700 (PDT)
From: Linus Torvalds <>
Subject: New kernel/resource.c
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/7/9/133

I got tired of the problems with the resource management - lack of
hierarchy, and the stupid and utterly horrible static allocation.
So I rewrote it. The new one can generate resource trees: you can claim a
piece of the pie, and then within that piece you can continue to do
resource management. And the new one doesn't have any arbitrary limits or
magic constants (0 is IO, 1 is MEM is gone, gone, gone).
The basic operation is now:
	int request_resource(struct resource *root, struct resource *new);
and everything pretty much follows from that one.
You can generate a resource hierachy by doing
	struct resource pci_io_resource = { "PCI IO", 0x0000, 0xFFFF };
	struct resource keyboard_resource = { "keyboard", 0x60, 0x6f };
	struct resource kbd_status_resource = { "kbd status", 0x60, 0x60 };
	request_resource(&pci_io_resource, &keyboard_resource);
	request_resource(&keyboard_resource, &kbd_status_resource);
which will have the hierarchy:
 - we have a "PCI IO" resource, with the area being 0-0xffff.
 - within that PCI IO resource, we carve up 0x60-0x6f as being reserved
   for the keyboard.
 - within that keyboard resource, we reserve the port 0x60 for the status
   byte.
The thing is completely generic, and you can generate your own resources
if you want to. Resources have names and a "flag" value that they could
use if they cared to (I'd like to see the MTRR setup using resources, for
example, but that's up to Richard). The only thing you need is the initial
"anchor" resource, aka "root resource", and that can be completely
internal to your own use (ie no need to tell the resource manager about it
explicitly).
With this, PCMCIA can have it's sub-resources without the ugly stuff it
does now. The sparc people can have their own native resources without
having to add new magic constants. And you don't have any arbitrary limits
on the number of resources available.
The old "request_region()" thing still works, but not until after the
memory allocator has been initialized (because it uses kmalloc()). So
stuff that does resource allocation early during boot has to actually use
"struct resource" directly - normal device drivers can just ignore the
change.
		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/