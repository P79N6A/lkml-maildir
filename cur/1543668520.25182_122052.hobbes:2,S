Date: Wed, 2 Apr 2003 08:35:12 -0800
From: William Lee Irwin III <>
Subject: Re: fairsched + O(1) process scheduler
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2003/4/2/83

On Wed, Apr 02, 2003 at 02:46:43PM +0200, Antonio Vargas wrote:
+static inline void update_user_timeslices(void)
...
+	list_for_each(entry, &user_list) {
+		user = list_entry(entry, struct user_struct, uid_list);
+
+		if(!user) continue;
+
+		if(0){
+			user_time_slice = user->time_slice;
Hmm, this looks very O(n)... BTW, doesn't uidhash_lock lock user_list?
On Wed, Apr 02, 2003 at 02:46:43PM +0200, Antonio Vargas wrote:
> @@ -39,10 +42,12 @@ struct user_struct root_user = {
>  static inline void uid_hash_insert(struct user_struct *up, struct list_head *hashent)
>  {
>  	list_add(&up->uidhash_list, hashent);
> +	list_add(&up->uid_list, &user_list);
>  }
Okay, there are three or four problems:
(1) uidhash_lock can't be taken in interrupt context
(2) you aren't taking uidhash_lock at all in update_user_timeslices()
(3) you're not actually handing out user timeslices due to an if (0)
(4) walking user_list is O(n)
-- wli
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/