Date: 14 Sep 1999 15:46:57 -0400
From: Todd Sabin <>
Subject: Re: [PATCH] isofs may compute wrong size for large files
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/9/14/147

Todd Sabin <tastas@home.com> writes:
> Hi,
> 
> There's a bug in fs/isofs/inode.c which causes it to get the wrong
> size for some large files.  It's triggered by having the
> iso_directory_entrys describing a file go across more than one block,
> with a empty record at the end of the first block.  There's code to
> handle that case, but it's slightly wrong.
> 
> The CD in question contains mp3s, and was burned on NT.  I suspect
> that mkisofs doesn't lay out the dir entries the same way, or this
> would have been noticed earlier.
> 
> 
> Todd
> 
> p.s.  Is there an official maintainer of isofs who should get this?
> While tracking this down I noticed there have been a few isofs patches
> to lkml recently that didn't get into the kernel...
> 
There was a problem with the previous patch.  I had DEBUG defined and
the warning was lost in the noise.  Sorry.  While fixing it I noticed
another problem.  In the (different) case where a single
iso_directory_entry is on two different blocks, cpnt is malloced to
hold the pasted together entry, raw_inode points to it, cpnt is freed,
and then the loop condition uses raw_inode to test.  This patch fixes
both problems.  This should be backed into 2.2.x, IMO.  I'll make a
patch for that, if needed.  Let me know...
Todd
--- fs/isofs/inode.c.orig	Thu Aug 26 17:18:06 1999
+++ fs/isofs/inode.c	Tue Sep 14 15:23:22 1999
@@ -1042,6 +1042,7 @@
 	struct buffer_head * bh = NULL;
 	int block = 0;
 	int i = 0;
+	int more_entries = 0;
 	void *cpnt;
 	struct iso_directory_record * raw_inode;
 
@@ -1062,7 +1063,6 @@
 				goto out_noread;
 		}
 		pnt = ((unsigned char *) bh->b_data + offset);
-		raw_inode = ((struct iso_directory_record *) pnt);
 		/*
 		 * Note: this is invariant even if the record
 		 * spans buffers and must be copied ...
@@ -1074,6 +1074,7 @@
 			ino = (ino & ~(ISOFS_BLOCK_SIZE - 1)) + ISOFS_BLOCK_SIZE;
 			continue;
 		}
+		raw_inode = ((struct iso_directory_record *) pnt);
 
 		/* Check whether the raw inode spans the buffer ... */	
 		if (offset + reclen > bufsize){
@@ -1095,13 +1096,15 @@
 		inode->i_size += isonum_733 (raw_inode->size);
 		if(i == 1) inode->u.isofs_i.i_next_section_ino = ino;
 
+		more_entries = raw_inode->flags[-high_sierra] & 0x80;
+
 		ino += reclen;
 		if (cpnt)
 			kfree (cpnt);
 		i++;
 		if(i > 100)
 			goto out_toomany;
-	} while(raw_inode->flags[-high_sierra] & 0x80);
+	} while(more_entries);
 out:
 	brelse(bh);
 	return 0;
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/