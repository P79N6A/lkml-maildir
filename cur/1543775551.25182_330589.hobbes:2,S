Date: Fri, 1 Jul 2005 19:06:44 -0400
From: Jeff Moyer <>
Subject: Re: [rfc | patch 0/6] netpoll: add support for the bonding driver
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/7/1/219

Move the poll_lock and poll_owner to the struct net_device.  This change is
important for the bonding driver support, as multiple real devices will
point at the same netpoll_info.  In such cases, we would be artificially
limiting ourselves to calling the polling routine of only one member of a
bond at a time.
To understand how this benefits the bonding driver, let's consider a
netpoll client that sends packets in response to receiving packets.  Let's
assume a packet comes in on eth0, and the response is to be delivered over
eth1.  If the poll_lock lived in the npinfo (and hence, there was only one
per bond), then we would have to queue the packet.  With this patch in
place, we can send the outbound packet immediately.
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
---
--- linux-2.6.12/net/core/netpoll.c.orig	2005-07-01 14:52:11.932101811 -0400
+++ linux-2.6.12/net/core/netpoll.c	2005-07-01 14:53:59.322183590 -0400
@@ -131,19 +131,20 @@ static int checksum_udp(struct sk_buff *
 static void poll_napi(struct netpoll *np)
 {
 	struct netpoll_info *npinfo = np->dev->npinfo;
+	struct net_device *dev = np->dev;
 	int budget = 16;
 
-	if (test_bit(__LINK_STATE_RX_SCHED, &np->dev->state) &&
-	    npinfo->poll_owner != smp_processor_id() &&
-	    spin_trylock(&npinfo->poll_lock)) {
+	if (test_bit(__LINK_STATE_RX_SCHED, &dev->state) &&
+	    dev->poll_owner != smp_processor_id() &&
+	    spin_trylock(&dev->poll_lock)) {
 		npinfo->rx_flags |= NETPOLL_RX_DROP;
 		atomic_inc(&trapped);
 
-		np->dev->poll(np->dev, &budget);
+		dev->poll(dev, &budget);
 
 		atomic_dec(&trapped);
 		npinfo->rx_flags &= ~NETPOLL_RX_DROP;
-		spin_unlock(&npinfo->poll_lock);
+		spin_unlock(&dev->poll_lock);
 	}
 }
 
@@ -246,7 +247,6 @@ repeat:
 static void netpoll_send_skb(struct netpoll *np, struct sk_buff *skb)
 {
 	int status;
-	struct netpoll_info *npinfo;
 
 repeat:
 	if(!np || !np->dev || !netif_running(np->dev)) {
@@ -255,8 +255,7 @@ repeat:
 	}
 
 	/* avoid recursion */
-	npinfo = np->dev->npinfo;
-	if (npinfo->poll_owner == smp_processor_id() ||
+	if (dev->poll_owner == smp_processor_id() ||
 	    np->dev->xmit_lock_owner == smp_processor_id()) {
 		if (np->drop)
 			np->drop(skb);
@@ -641,8 +640,6 @@ int netpoll_setup(struct netpoll *np)
 
 		npinfo->rx_flags = 0;
 		npinfo->rx_np = NULL;
-		npinfo->poll_lock = SPIN_LOCK_UNLOCKED;
-		npinfo->poll_owner = -1;
 		npinfo->rx_lock = SPIN_LOCK_UNLOCKED;
 	} else
 		npinfo = ndev->npinfo;
--- linux-2.6.12/net/core/dev.c.orig	2005-07-01 14:52:08.613655521 -0400
+++ linux-2.6.12/net/core/dev.c	2005-07-01 14:52:38.495669512 -0400
@@ -3069,6 +3069,10 @@ struct net_device *alloc_netdev(int size
 
 	setup(dev);
 	strcpy(dev->name, name);
+#ifdef CONFIG_NETPOLL
+	dev->poll_owner = -1;
+	dev->poll_lock = SPIN_LOCK_UNLOCKED;
+#endif
 	return dev;
 }
 EXPORT_SYMBOL(alloc_netdev);
--- linux-2.6.12/include/linux/netpoll.h.orig	2005-07-01 14:52:16.016420312 -0400
+++ linux-2.6.12/include/linux/netpoll.h	2005-07-01 14:52:38.495669512 -0400
@@ -24,8 +24,6 @@ struct netpoll {
 };
 
 struct netpoll_info {
-	spinlock_t poll_lock;
-	int poll_owner;
 	int rx_flags;
 	spinlock_t rx_lock;
 	struct netpoll *rx_np; /* netpoll that registered an rx_hook */
@@ -63,16 +61,16 @@ static inline int netpoll_rx(struct sk_b
 static inline void netpoll_poll_lock(struct net_device *dev)
 {
 	if (dev->npinfo) {
-		spin_lock(&dev->npinfo->poll_lock);
-		dev->npinfo->poll_owner = smp_processor_id();
+		spin_lock(&dev->poll_lock);
+		dev->poll_owner = smp_processor_id();
 	}
 }
 
 static inline void netpoll_poll_unlock(struct net_device *dev)
 {
 	if (dev->npinfo) {
-		dev->npinfo->poll_owner = -1;
-		spin_unlock(&dev->npinfo->poll_lock);
+		dev->poll_owner = -1;
+		spin_unlock(&dev->poll_lock);
 	}
 }
 
--- linux-2.6.12/include/linux/netdevice.h.orig	2005-07-01 14:52:22.666310731 -0400
+++ linux-2.6.12/include/linux/netdevice.h	2005-07-01 14:52:38.496669345 -0400
@@ -469,6 +469,8 @@ struct net_device
 	int			(*neigh_setup)(struct net_device *dev, struct neigh_parms *);
 #ifdef CONFIG_NETPOLL
 	struct netpoll_info	*npinfo;
+	spinlock_t		poll_lock;
+	int			poll_owner;
 #endif
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	void                    (*poll_controller)(struct net_device *dev);
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/