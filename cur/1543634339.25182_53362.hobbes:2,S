Date: Wed, 19 Jun 2002 23:45:33 +0200 (MET DST)
From: Bartlomiej Zolnierkiewicz <>
Subject: [PATCH 2.5.22] simple ide-tape.c and ide-floppy.c cleanup
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2002/6/19/135

Hi!
generic ATAPI hit #1 (rather trivial cleanup) against 2.5.22:
	- move generic ATAPI structs from ide/ide-floppy.c
	  and ide/ide-tape.c to include/atapi.h
	  (this has a nice side effect of making ide-tape
	   a bit more endianness aware)
	- also move generic ATAPI command's defines to atapi.h
	- remove IDEFLOPPY_MIN/MAX() macros, use generic ones
	- add #ifndef __LINUX_ATAPI_H_ blabla to atapi.h
	  to prevent including it more than once
should apply cleanly to 2.5.23
--
Bartlomiej Zolnierkiewicz
--- linux-2.5.22/include/linux/atapi.h	Tue Jun 18 00:27:38 2002
+++ linux/include/linux/atapi.h	Wed Jun 19 00:07:26 2002
@@ -1,3 +1,7 @@
+
+#ifndef __LINUX_ATAPI_H
+#define __LINUX_ATAPI_H
+
 /**** vi:set ts=8 sts=8 sw=8:************************************************
  *
  * Copyright (C) 2002 Marcin Dalecki <martin@dalecki.de>
@@ -12,6 +16,9 @@
  * more details.
  */
 
+#include <linux/types.h>
+#include <asm/byteorder.h>
+
 /*
  * With each packet command, we allocate a buffer.
  * This is used for several packet
@@ -79,3 +86,313 @@
 extern void atapi_read(struct ata_device *, u8 *, unsigned int);
 extern void atapi_write(struct ata_device *, u8 *, unsigned int);
 
+
+/*
+ *	ATAPI packet commands.
+ */
+#define ATAPI_FORMAT_UNIT_CMD		0x04
+#define ATAPI_INQUIRY_CMD		0x12
+#define ATAPI_MODE_SELECT10_CMD		0x55
+#define ATAPI_MODE_SENSE10_CMD		0x5a
+#define ATAPI_ALLOW_PREVENT_REMOVAL_CMD 0x1e
+#define ATAPI_READ10_CMD		0x28
+#define ATAPI_READ12_CMD		0xa8
+#define ATAPI_READ_CAPACITY_CMD		0x25
+#define ATAPI_READ_CAPACITIES_CMD	0x23
+#define ATAPI_REQUEST_SENSE_CMD		0x03
+#define ATAPI_SEEK_CMD			0x2b
+#define ATAPI_START_STOP_CMD		0x1b
+#define ATAPI_TEST_UNIT_READY_CMD	0x00
+#define ATAPI_VERIFY10_CMD		0x2f
+#define ATAPI_WRITE10_CMD		0x2a
+#define ATAPI_WRITE12_CMD		0xaa
+#define ATAPI_WRITE_VERIFY10_CMD	0x2e
+
+/*
+ *	Defines for the MODE SENSE command.
+ */
+#define MODE_SENSE_CURRENT		0x00
+#define MODE_SENSE_CHANGEABLE		0x01
+#define MODE_SENSE_DEFAULT		0x02 
+#define MODE_SENSE_SAVED		0x03
+
+
+/*
+ *	ATAPI Status Register.
+ */
+typedef union {
+	u8 all			: 8;
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		u8 check	: 1;	/* Error occurred */
+		u8 idx		: 1;	/* Reserved */
+		u8 corr		: 1;	/* Correctable error occurred */
+		u8 drq		: 1;	/* Data is request by the device */
+		u8 dsc		: 1;	/* Media access command finished / Buffer availability */
+		u8 reserved5	: 1;	/* Reserved */
+		u8 drdy		: 1;	/* Ignored for ATAPI commands (ready to accept ATA command) */
+		u8 bsy		: 1;	/* The device has access to the command block */
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		u8 bsy		: 1;
+		u8 drdy		: 1;
+		u8 reserved5	: 1;
+		u8 dsc		: 1;
+		u8 drq		: 1;
+		u8 corr		: 1;
+		u8 idx		: 1;
+		u8 check	: 1;
+#else
+#error "Please fix <asm/byteorder.h>"
+#endif
+	} b;
+} atapi_status_reg_t;
+
+/*
+ *	ATAPI error register.
+ */
+typedef union {
+	u8 all			: 8;
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		u8 ili		: 1;	/* Illegal Length Indication */
+		u8 eom		: 1;	/* End Of Media Detected */
+		u8 abrt		: 1;	/* Aborted command - As defined by ATA */
+		u8 mcr		: 1;	/* Media Change Requested - As defined by ATA */
+		u8 sense_key	: 4;	/* Sense key of the last failed packet command */
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		u8 sense_key	: 4;
+		u8 mcr		: 1;
+		u8 abrt		: 1;
+		u8 eom		: 1;
+		u8 ili		: 1;
+#else
+#error "Please fix <asm/byteorder.h>"
+#endif
+	} b;
+} atapi_error_reg_t;
+
+/* Currently unused, but please do not remove.  --bkz */
+/*
+ *	ATAPI Feature Register.
+ */
+typedef union {
+	u8 all			: 8;
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		u8 dma		: 1;	/* Using DMA or PIO */
+		u8 reserved321	: 3;	/* Reserved */
+		u8 reserved654	: 3;	/* Reserved (Tag Type) */
+		u8 reserved7	: 1;	/* Reserved */
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		u8 reserved7	: 1;
+		u8 reserved654	: 3;
+		u8 reserved321	: 3;
+		u8 dma		: 1;
+#else
+#error "Please fix <asm/byteorder.h>"
+#endif
+	} b;
+} atapi_feature_reg_t;
+
+/*
+ *	ATAPI Byte Count Register.
+ */
+typedef union {
+	u16 all			: 16;
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		u8 low;			/* LSB */
+		u8 high;		/* MSB */
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		u8 high;
+		u8 low;
+#else
+#error "Please fix <asm/byteorder.h>"
+#endif
+	} b;
+} atapi_bcount_reg_t;
+
+/*
+ *	ATAPI Interrupt Reason Register.
+ */
+typedef union {
+	u8 all			: 8;
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		u8 cod		: 1;	/* Information transferred is command (1) or data (0) */
+		u8 io		: 1;	/* The device requests us to read (1) or write (0) */
+		u8 reserved	: 6;	/* Reserved */
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		u8 reserved	: 6;
+		u8 io		: 1;
+		u8 cod		: 1;
+#else
+#error "Please fix <asm/byteorder.h>"
+#endif
+	} b;
+} atapi_ireason_reg_t;
+
+/* Currently unused, but please do not remove.  --bkz */
+/*
+ *	ATAPI Drive Select Register.
+ */
+typedef union {	
+	u8 all			:8;
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		u8 sam_lun	:3;	/* Logical unit number */
+		u8 reserved3	:1;	/* Reserved */
+		u8 drv		:1;	/* The responding drive will be drive 0 (0) or drive 1 (1) */
+		u8 one5		:1;	/* Should be set to 1 */
+		u8 reserved6	:1;	/* Reserved */
+		u8 one7		:1;	/* Should be set to 1 */
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		u8 one7		:1;
+		u8 reserved6	:1;
+		u8 one5		:1;
+		u8 drv		:1;
+		u8 reserved3	:1;
+		u8 sam_lun	:3;
+#else
+#error "Please fix <asm/byteorder.h>"
+#endif
+	} b;
+} atapi_drivesel_reg_t;
+
+/* Currently unused, but please do not remove.  --bkz */
+/*
+ *	ATAPI Device Control Register.
+ */
+typedef union {
+	u8 all			: 8;
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		u8 zero0	: 1;	/* Should be set to zero */
+		u8 nien		: 1;	/* Device interrupt is disabled (1) or enabled (0) */
+		u8 srst		: 1;	/* ATA software reset. ATAPI devices should use the new ATAPI srst. */
+		u8 one3		: 1;	/* Should be set to 1 */
+		u8 reserved4567	: 4;	/* Reserved */
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		u8 reserved4567	: 4;
+		u8 one3		: 1;
+		u8 srst		: 1;
+		u8 nien		: 1;
+		u8 zero0	: 1;
+#else
+#error "Please fix <asm/byteorder.h>"
+#endif
+	} b;
+} atapi_control_reg_t;
+
+/*
+ *	The following is used to format the general configuration word
+ *	of the ATAPI IDENTIFY DEVICE command.
+ */
+struct atapi_id_gcw {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	u8 packet_size		: 2;	/* Packet Size */
+	u8 reserved234		: 3;	/* Reserved */
+	u8 drq_type		: 2;	/* Command packet DRQ type */
+	u8 removable		: 1;	/* Removable media */
+	u8 device_type		: 5;	/* Device type */
+	u8 reserved13		: 1;	/* Reserved */
+	u8 protocol		: 2;	/* Protocol type */
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	u8 protocol		: 2;
+	u8 reserved13		: 1;
+	u8 device_type		: 5;
+	u8 removable		: 1;
+	u8 drq_type		: 2;
+	u8 reserved234		: 3;
+	u8 packet_size		: 2;
+#else	
+#error "Please fix <asm/byteorder.h>"
+#endif
+};
+
+/*
+ *	INQUIRY packet command - Data Format.
+ */
+typedef struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	u8	device_type	: 5;	/* Peripheral Device Type */
+	u8	reserved0_765	: 3;	/* Peripheral Qualifier - Reserved */
+	u8	reserved1_6t0	: 7;	/* Reserved */
+	u8	rmb		: 1;	/* Removable Medium Bit */
+	u8	ansi_version	: 3;	/* ANSI Version */
+	u8	ecma_version	: 3;	/* ECMA Version */
+	u8	iso_version	: 2;	/* ISO Version */
+	u8	response_format : 4;	/* Response Data Format */
+	u8	reserved3_45	: 2;	/* Reserved */
+	u8	reserved3_6	: 1;	/* TrmIOP - Reserved */
+	u8	reserved3_7	: 1;	/* AENC - Reserved */
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	u8	reserved0_765	: 3;
+	u8	device_type	: 5;
+	u8	rmb		: 1;
+	u8	reserved1_6t0	: 7;
+	u8	iso_version	: 2;
+	u8	ecma_version	: 3;
+	u8	ansi_version	: 3;
+	u8	reserved3_7	: 1;
+	u8	reserved3_6	: 1;
+	u8	reserved3_45	: 2;
+	u8	response_format : 4;
+#else
+#error "Please fix <asm/byteorder.h>"
+#endif
+	u8	additional_length;	/* Additional Length (total_length-4) */
+	u8	rsv5, rsv6, rsv7;	/* Reserved */
+	u8	vendor_id[8];		/* Vendor Identification */
+	u8	product_id[16];		/* Product Identification */
+	u8	revision_level[4];	/* Revision Level */
+	u8	vendor_specific[20];	/* Vendor Specific - Optional */
+	u8	reserved56t95[40];	/* Reserved - Optional */
+					/* Additional information may be returned */
+} atapi_inquiry_result_t;
+
+/*
+ *	REQUEST SENSE packet command result - Data Format.
+ */
+typedef struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	u8	error_code	: 7;	/* Error Code (0x70 - current or 0x71 - deferred) */
+	u8	valid		: 1;	/* The information field conforms to standard */
+	u8	reserved1	: 8;	/* Reserved (Segment Number) */
+	u8	sense_key	: 4;	/* Sense Key */
+	u8	reserved2_4	: 1;	/* Reserved */
+	u8	ili		: 1;	/* Incorrect Length Indicator */
+	u8	eom		: 1;	/* End Of Medium */
+	u8	filemark	: 1;	/* Filemark */
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	u8	valid		: 1;
+	u8	error_code	: 7;
+	u8	reserved1	: 8;
+	u8	filemark	: 1;
+	u8	eom		: 1;
+	u8	ili		: 1;
+	u8	reserved2_4	: 1;
+	u8	sense_key	: 4;
+#else
+#error "Please fix <asm/byteorder.h>"
+#endif
+	u32	information __attribute__ ((packed));
+	u8	asl;			/* Additional sense length (n-7) */
+	u32	command_specific;	/* Additional command specific information */
+	u8	asc;			/* Additional Sense Code */
+	u8	ascq;			/* Additional Sense Code Qualifier */
+	u8	replaceable_unit_code;	/* Field Replaceable Unit Code */
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	u8	sk_specific1	: 7;	/* Sense Key Specific */
+	u8	sksv		: 1;	/* Sense Key Specific information is valid */
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	u8	sksv		: 1;	/* Sense Key Specific information is valid */
+	u8	sk_specific1	: 7;	/* Sense Key Specific */
+#else
+#error "Please fix <asm/byteorder.h>"
+#endif
+	u8	sk_specific[2];		/* Sense Key Specific */
+	u8	pad[2];			/* Padding to 20 bytes */
+} atapi_request_sense_result_t;
+
+#endif __LINUX_ATAPI_H
--- linux-2.5.22/drivers/ide/ide-floppy.c	Tue Jun 18 00:29:02 2002
+++ linux/drivers/ide/ide-floppy.c	Tue Jun 18 23:50:06 2002
@@ -272,34 +272,6 @@
 #define IDEFLOPPY_ZIP_DRIVE		5	/* Requires BH algorithm for packets */
 
 /*
- *	ATAPI floppy drive packet commands
- */
-#define IDEFLOPPY_FORMAT_UNIT_CMD	0x04
-#define IDEFLOPPY_INQUIRY_CMD		0x12
-#define IDEFLOPPY_MODE_SELECT_CMD	0x55
-#define IDEFLOPPY_MODE_SENSE_CMD	0x5a
-#define IDEFLOPPY_READ10_CMD		0x28
-#define IDEFLOPPY_READ12_CMD		0xa8
-#define IDEFLOPPY_READ_CAPACITY_CMD	0x23
-#define IDEFLOPPY_REQUEST_SENSE_CMD	0x03
-#define IDEFLOPPY_PREVENT_REMOVAL_CMD	0x1e
-#define IDEFLOPPY_SEEK_CMD		0x2b
-#define IDEFLOPPY_START_STOP_CMD	0x1b
-#define IDEFLOPPY_TEST_UNIT_READY_CMD	0x00
-#define IDEFLOPPY_VERIFY_CMD		0x2f
-#define IDEFLOPPY_WRITE10_CMD		0x2a
-#define IDEFLOPPY_WRITE12_CMD		0xaa
-#define IDEFLOPPY_WRITE_VERIFY_CMD	0x2e
-
-/*
- *	Defines for the mode sense command
- */
-#define MODE_SENSE_CURRENT		0x00
-#define MODE_SENSE_CHANGEABLE		0x01
-#define MODE_SENSE_DEFAULT		0x02 
-#define MODE_SENSE_SAVED		0x03
-
-/*
  *	IOCTLs used in low-level formatting.
  */
 
@@ -315,270 +287,6 @@
 #define	IDEFLOPPY_ERROR_GENERAL		101
 
 /*
- *	The ATAPI Status Register.
- */
-typedef union {
-	unsigned all			:8;
-	struct {
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-		unsigned check		:1;	/* Error occurred */
-		unsigned idx		:1;	/* Reserved */
-		unsigned corr		:1;	/* Correctable error occurred */
-		unsigned drq		:1;	/* Data is request by the device */
-		unsigned dsc		:1;	/* Media access command finished */
-		unsigned reserved5	:1;	/* Reserved */
-		unsigned drdy		:1;	/* Ignored for ATAPI commands (ready to accept ATA command) */
-		unsigned bsy		:1;	/* The device has access to the command block */
-#elif defined(__BIG_ENDIAN_BITFIELD)
-		unsigned bsy		:1;	/* The device has access to the command block */
-		unsigned drdy		:1;	/* Ignored for ATAPI commands (ready to accept ATA command) */
-		unsigned reserved5	:1;	/* Reserved */
-		unsigned dsc		:1;	/* Media access command finished */
-		unsigned drq		:1;	/* Data is request by the device */
-		unsigned corr		:1;	/* Correctable error occurred */
-		unsigned idx		:1;	/* Reserved */
-		unsigned check		:1;	/* Error occurred */
-#else
-#error "Bitfield endianness not defined! Check your byteorder.h"
-#endif
-	} b;
-} idefloppy_status_reg_t;
-
-/*
- *	The ATAPI error register.
- */
-typedef union {
-	unsigned all			:8;
-	struct {
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-		unsigned ili		:1;	/* Illegal Length Indication */
-		unsigned eom		:1;	/* End Of Media Detected */
-		unsigned abrt		:1;	/* Aborted command - As defined by ATA */
-		unsigned mcr		:1;	/* Media Change Requested - As defined by ATA */
-		unsigned sense_key	:4;	/* Sense key of the last failed packet command */
-#elif defined(__BIG_ENDIAN_BITFIELD)
-		unsigned sense_key	:4;	/* Sense key of the last failed packet command */
-		unsigned mcr		:1;	/* Media Change Requested - As defined by ATA */
-		unsigned abrt		:1;	/* Aborted command - As defined by ATA */
-		unsigned eom		:1;	/* End Of Media Detected */
-		unsigned ili		:1;	/* Illegal Length Indication */
-#else
-#error "Bitfield endianness not defined! Check your byteorder.h"
-#endif
-	} b;
-} idefloppy_error_reg_t;
-
-/*
- *	ATAPI Feature Register
- */
-typedef union {
-	unsigned all			:8;
-	struct {
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-		unsigned dma		:1;	/* Using DMA or PIO */
-		unsigned reserved321	:3;	/* Reserved */
-		unsigned reserved654	:3;	/* Reserved (Tag Type) */
-		unsigned reserved7	:1;	/* Reserved */
-#elif defined(__BIG_ENDIAN_BITFIELD)
-		unsigned reserved7	:1;	/* Reserved */
-		unsigned reserved654	:3;	/* Reserved (Tag Type) */
-		unsigned reserved321	:3;	/* Reserved */
-		unsigned dma		:1;	/* Using DMA or PIO */
-#else
-#error "Bitfield endianness not defined! Check your byteorder.h"
-#endif
-	} b;
-} idefloppy_feature_reg_t;
-
-/*
- *	ATAPI Byte Count Register.
- */
-typedef union {
-	unsigned all			:16;
-	struct {
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-		unsigned low		:8;	/* LSB */
-		unsigned high		:8;	/* MSB */
-#elif defined(__BIG_ENDIAN_BITFIELD)
-		unsigned high		:8;	/* MSB */
-		unsigned low		:8;	/* LSB */
-#else
-#error "Bitfield endianness not defined! Check your byteorder.h"
-#endif
-	} b;
-} idefloppy_bcount_reg_t;
-
-/*
- *	ATAPI Interrupt Reason Register.
- */
-typedef union {
-	unsigned all			:8;
-	struct {
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-		unsigned cod		:1;	/* Information transferred is command (1) or data (0) */
-		unsigned io		:1;	/* The device requests us to read (1) or write (0) */
-		unsigned reserved	:6;	/* Reserved */
-#elif defined(__BIG_ENDIAN_BITFIELD)
-		unsigned reserved	:6;	/* Reserved */
-		unsigned io		:1;	/* The device requests us to read (1) or write (0) */
-		unsigned cod		:1;	/* Information transferred is command (1) or data (0) */
-#else
-#error "Bitfield endianness not defined! Check your byteorder.h"
-#endif
-	} b;
-} idefloppy_ireason_reg_t;
-
-/*
- *	ATAPI floppy Drive Select Register
- */
-typedef union {	
-	unsigned all			:8;
-	struct {
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-		unsigned sam_lun	:3;	/* Logical unit number */
-		unsigned reserved3	:1;	/* Reserved */
-		unsigned drv		:1;	/* The responding drive will be drive 0 (0) or drive 1 (1) */
-		unsigned one5		:1;	/* Should be set to 1 */
-		unsigned reserved6	:1;	/* Reserved */
-		unsigned one7		:1;	/* Should be set to 1 */
-#elif defined(__BIG_ENDIAN_BITFIELD)
-		unsigned one7		:1;	/* Should be set to 1 */
-		unsigned reserved6	:1;	/* Reserved */
-		unsigned one5		:1;	/* Should be set to 1 */
-		unsigned drv		:1;	/* The responding drive will be drive 0 (0) or drive 1 (1) */
-		unsigned reserved3	:1;	/* Reserved */
-		unsigned sam_lun	:3;	/* Logical unit number */
-#else
-#error "Bitfield endianness not defined! Check your byteorder.h"
-#endif
-	} b;
-} idefloppy_drivesel_reg_t;
-
-/*
- *	ATAPI Device Control Register
- */
-typedef union {			
-	unsigned all			:8;
-	struct {
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-		unsigned zero0		:1;	/* Should be set to zero */
-		unsigned nien		:1;	/* Device interrupt is disabled (1) or enabled (0) */
-		unsigned srst		:1;	/* ATA software reset. ATAPI devices should use the new ATAPI srst. */
-		unsigned one3		:1;	/* Should be set to 1 */
-		unsigned reserved4567	:4;	/* Reserved */
-#elif defined(__BIG_ENDIAN_BITFIELD)
-		unsigned reserved4567	:4;	/* Reserved */
-		unsigned one3		:1;	/* Should be set to 1 */
-		unsigned srst		:1;	/* ATA software reset. ATAPI devices should use the new ATAPI srst. */
-		unsigned nien		:1;	/* Device interrupt is disabled (1) or enabled (0) */
-		unsigned zero0		:1;	/* Should be set to zero */
-#else
-#error "Bitfield endianness not defined! Check your byteorder.h"
-#endif
-	} b;
-} idefloppy_control_reg_t;
-
-/*
- *	The following is used to format the general configuration word of
- *	the ATAPI IDENTIFY DEVICE command.
- */
-struct idefloppy_id_gcw {	
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-	unsigned packet_size		:2;	/* Packet Size */
-	unsigned reserved234		:3;	/* Reserved */
-	unsigned drq_type		:2;	/* Command packet DRQ type */
-	unsigned removable		:1;	/* Removable media */
-	unsigned device_type		:5;	/* Device type */
-	unsigned reserved13		:1;	/* Reserved */
-	unsigned protocol		:2;	/* Protocol type */
-#elif defined(__BIG_ENDIAN_BITFIELD)
-	unsigned protocol		:2;	/* Protocol type */
-	unsigned reserved13		:1;	/* Reserved */
-	unsigned device_type		:5;	/* Device type */
-	unsigned removable		:1;	/* Removable media */
-	unsigned drq_type		:2;	/* Command packet DRQ type */
-	unsigned reserved234		:3;	/* Reserved */
-	unsigned packet_size		:2;	/* Packet Size */
-#else
-#error "Bitfield endianness not defined! Check your byteorder.h"
-#endif
-};
-
-/*
- *	INQUIRY packet command - Data Format
- */
-typedef struct {
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-	unsigned	device_type	:5;	/* Peripheral Device Type */
-	unsigned	reserved0_765	:3;	/* Peripheral Qualifier - Reserved */
-	unsigned	reserved1_6t0	:7;	/* Reserved */
-	unsigned	rmb		:1;	/* Removable Medium Bit */
-	unsigned	ansi_version	:3;	/* ANSI Version */
-	unsigned	ecma_version	:3;	/* ECMA Version */
-	unsigned	iso_version	:2;	/* ISO Version */
-	unsigned	response_format :4;	/* Response Data Format */
-	unsigned	reserved3_45	:2;	/* Reserved */
-	unsigned	reserved3_6	:1;	/* TrmIOP - Reserved */
-	unsigned	reserved3_7	:1;	/* AENC - Reserved */
-#elif defined(__BIG_ENDIAN_BITFIELD)
-	unsigned	reserved0_765	:3;	/* Peripheral Qualifier - Reserved */
-	unsigned	device_type	:5;	/* Peripheral Device Type */
-	unsigned	rmb		:1;	/* Removable Medium Bit */
-	unsigned	reserved1_6t0	:7;	/* Reserved */
-	unsigned	iso_version	:2;	/* ISO Version */
-	unsigned	ecma_version	:3;	/* ECMA Version */
-	unsigned	ansi_version	:3;	/* ANSI Version */
-	unsigned	reserved3_7	:1;	/* AENC - Reserved */
-	unsigned	reserved3_6	:1;	/* TrmIOP - Reserved */
-	unsigned	reserved3_45	:2;	/* Reserved */
-	unsigned	response_format :4;	/* Response Data Format */
-#else
-#error "Bitfield endianness not defined! Check your byteorder.h"
-#endif
-	u8		additional_length;	/* Additional Length (total_length-4) */
-	u8		rsv5, rsv6, rsv7;	/* Reserved */
-	u8		vendor_id[8];		/* Vendor Identification */
-	u8		product_id[16];		/* Product Identification */
-	u8		revision_level[4];	/* Revision Level */
-	u8		vendor_specific[20];	/* Vendor Specific - Optional */
-	u8		reserved56t95[40];	/* Reserved - Optional */
-						/* Additional information may be returned */
-} idefloppy_inquiry_result_t;
-
-/*
- *	REQUEST SENSE packet command result - Data Format.
- */
-typedef struct {
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-	unsigned	error_code	:7;	/* Current error (0x70) */
-	unsigned	valid		:1;	/* The information field conforms to SFF-8070i */
-	u8		reserved1	:8;	/* Reserved */
-	unsigned	sense_key	:4;	/* Sense Key */
-	unsigned	reserved2_4	:1;	/* Reserved */
-	unsigned	ili		:1;	/* Incorrect Length Indicator */
-	unsigned	reserved2_67	:2;
-#elif defined(__BIG_ENDIAN_BITFIELD)
-	unsigned	valid		:1;	/* The information field conforms to SFF-8070i */
-	unsigned	error_code	:7;	/* Current error (0x70) */
-	u8		reserved1	:8;	/* Reserved */
-	unsigned	reserved2_67	:2;
-	unsigned	ili		:1;	/* Incorrect Length Indicator */
-	unsigned	reserved2_4	:1;	/* Reserved */
-	unsigned	sense_key	:4;	/* Sense Key */
-#else
-#error "Bitfield endianness not defined! Check your byteorder.h"
-#endif
-	u32		information __attribute__ ((packed));
-	u8		asl;			/* Additional sense length (n-7) */
-	u32		command_specific;	/* Additional command specific information */
-	u8		asc;			/* Additional Sense Code */
-	u8		ascq;			/* Additional Sense Code Qualifier */
-	u8		replaceable_unit_code;	/* Field Replaceable Unit Code */
-	u8		sksv[3];
-	u8		pad[2];			/* Padding to 20 bytes */
-} idefloppy_request_sense_result_t;
-
-/*
  *	Pages of the SELECT SENSE / MODE SENSE packet commands.
  */
 #define	IDEFLOPPY_CAPABILITIES_PAGE	0x1b
@@ -602,9 +310,6 @@
 	u8		reserved[4];
 } idefloppy_mode_parameter_header_t;
 
-#define IDEFLOPPY_MIN(a,b)	((a)<(b) ? (a):(b))
-#define	IDEFLOPPY_MAX(a,b)	((a)>(b) ? (a):(b))
-
 /*
  *	idefloppy_end_request is used to finish servicing a request.
  *
@@ -663,7 +368,7 @@ static void idefloppy_input_buffers(stru
 			atapi_discard_data(drive, bcount);
 			return;
 		}
-		count = IDEFLOPPY_MIN(bio->bi_size - pc->b_count, bcount);
+		count = min_t(unsigned int, bio->bi_size - pc->b_count, bcount);
 		atapi_read(drive, bio_data(bio) + pc->b_count, count);
 		bcount -= count; pc->b_count += count;
 	}
@@ -690,7 +395,7 @@ static void idefloppy_output_buffers(str
 			atapi_write_zeros (drive, bcount);
 			return;
 		}
-		count = IDEFLOPPY_MIN(pc->b_count, bcount);
+		count = min_t(unsigned int, pc->b_count, bcount);
 		atapi_write(drive, pc->b_data, count);
 		bcount -= count; pc->b_data += count; pc->b_count -= count;
 	}
@@ -743,13 +448,13 @@ static struct request *idefloppy_next_rq
  *	idefloppy_analyze_error is called on each failed packet command retry
  *	to analyze the request sense.
  */
-static void idefloppy_analyze_error(struct ata_device *drive, idefloppy_request_sense_result_t *result)
+static void idefloppy_analyze_error(struct ata_device *drive, atapi_request_sense_result_t *result)
 {
 	idefloppy_floppy_t *floppy = drive->driver_data;
 
 	floppy->sense_key = result->sense_key; floppy->asc = result->asc; floppy->ascq = result->ascq;
-	floppy->progress_indication= result->sksv[0] & 0x80 ?
-		(unsigned short)get_unaligned((u16 *)(result->sksv+1)):0x10000;
+	floppy->progress_indication= result->sksv ?
+		(unsigned short)get_unaligned((u16 *)(result->sk_specific)):0x10000;
 #if IDEFLOPPY_DEBUG_LOG
 	if (floppy->failed_pc)
 		printk (KERN_INFO "ide-floppy: pc = %x, sense key = %x, asc = %x, ascq = %x\n",floppy->failed_pc->c[0],result->sense_key,result->asc,result->ascq);
@@ -766,7 +471,7 @@ static void idefloppy_request_sense_call
 	printk (KERN_INFO "ide-floppy: Reached idefloppy_request_sense_callback\n");
 #endif
 	if (!floppy->pc->error) {
-		idefloppy_analyze_error(drive,(idefloppy_request_sense_result_t *) floppy->pc->buffer);
+		idefloppy_analyze_error(drive,(atapi_request_sense_result_t *) floppy->pc->buffer);
 		idefloppy_end_request(drive, rq, 1);
 	} else {
 		printk (KERN_ERR "Error in REQUEST SENSE itself - Aborting request!\n");
@@ -791,7 +496,7 @@ static void idefloppy_pc_callback(struct
 static void idefloppy_create_request_sense_cmd(struct atapi_packet_command *pc)
 {
 	atapi_init_pc(pc);
-	pc->c[0] = IDEFLOPPY_REQUEST_SENSE_CMD;
+	pc->c[0] = ATAPI_REQUEST_SENSE_CMD;
 	pc->c[4] = 255;
 	pc->request_transfer = 18;
 	pc->callback = &idefloppy_request_sense_callback;
@@ -806,7 +511,7 @@ static void idefloppy_retry_pc(struct at
 {
 	struct atapi_packet_command *pc;
 	struct request *rq;
-	idefloppy_error_reg_t error;
+	atapi_error_reg_t error;
 
 	error.all = IN_BYTE(IDE_ERROR_REG);
 	pc = idefloppy_next_pc_storage(drive);
@@ -824,9 +529,9 @@ static ide_startstop_t idefloppy_pc_intr
 	unsigned long flags;
 	struct ata_channel *ch = drive->channel;
 	idefloppy_floppy_t *floppy = drive->driver_data;
-	idefloppy_status_reg_t status;
-	idefloppy_bcount_reg_t bcount;
-	idefloppy_ireason_reg_t ireason;
+	atapi_status_reg_t status;
+	atapi_bcount_reg_t bcount;
+	atapi_ireason_reg_t ireason;
 	struct atapi_packet_command *pc = floppy->pc;
 	unsigned int temp;
 
@@ -864,7 +569,7 @@ static ide_startstop_t idefloppy_pc_intr
 			printk (KERN_INFO "ide-floppy: %s: I/O error\n",drive->name);
 #endif
 			rq->errors++;
-			if (pc->c[0] == IDEFLOPPY_REQUEST_SENSE_CMD) {
+			if (pc->c[0] == ATAPI_REQUEST_SENSE_CMD) {
 				printk (KERN_ERR "ide-floppy: I/O error in request sense command\n");
 				return ide_stopped;
 			}
@@ -955,7 +660,7 @@ static ide_startstop_t idefloppy_transfe
 	struct ata_channel *ch = drive->channel;
 	ide_startstop_t startstop;
 	idefloppy_floppy_t *floppy = drive->driver_data;
-	idefloppy_ireason_reg_t ireason;
+	atapi_ireason_reg_t ireason;
 	int ret;
 
 	/* FIXME: Move this lock upwards.
@@ -1010,7 +715,7 @@ static ide_startstop_t idefloppy_transfe
 	struct ata_channel *ch = drive->channel;
 	idefloppy_floppy_t *floppy = drive->driver_data;
 	ide_startstop_t startstop;
-	idefloppy_ireason_reg_t ireason;
+	atapi_ireason_reg_t ireason;
 	int ret;
 
 	if (ata_status_poll(drive, DRQ_STAT, BUSY_STAT,
@@ -1057,17 +762,17 @@ static ide_startstop_t idefloppy_issue_p
 		struct atapi_packet_command *pc)
 {
 	idefloppy_floppy_t *floppy = drive->driver_data;
-	idefloppy_bcount_reg_t bcount;
+	atapi_bcount_reg_t bcount;
 	int dma_ok = 0;
 	ata_handler_t *pkt_xfer_routine;
 
 #if IDEFLOPPY_DEBUG_BUGS
-	if (floppy->pc->c[0] == IDEFLOPPY_REQUEST_SENSE_CMD && pc->c[0] == IDEFLOPPY_REQUEST_SENSE_CMD) {
+	if (floppy->pc->c[0] == ATAPI_REQUEST_SENSE_CMD && pc->c[0] == ATAPI_REQUEST_SENSE_CMD) {
 		printk(KERN_ERR "ide-floppy: possible ide-floppy.c bug - Two request sense in serial were issued\n");
 	}
 #endif
 
-	if (floppy->failed_pc == NULL && pc->c[0] != IDEFLOPPY_REQUEST_SENSE_CMD)
+	if (floppy->failed_pc == NULL && pc->c[0] != ATAPI_REQUEST_SENSE_CMD)
 		floppy->failed_pc=pc;
 	floppy->pc=pc;							/* Set the current packet command */
 
@@ -1162,7 +867,7 @@ static void idefloppy_create_prevent_cmd
 #endif
 
 	atapi_init_pc (pc);
-	pc->c[0] = IDEFLOPPY_PREVENT_REMOVAL_CMD;
+	pc->c[0] = ATAPI_ALLOW_PREVENT_REMOVAL_CMD;
 	pc->c[4] = prevent;
 	pc->callback = idefloppy_pc_callback;
 }
@@ -1170,7 +875,7 @@ static void idefloppy_create_prevent_cmd
 static void idefloppy_create_read_capacity_cmd(struct atapi_packet_command *pc)
 {
 	atapi_init_pc(pc);
-	pc->c[0] = IDEFLOPPY_READ_CAPACITY_CMD;
+	pc->c[0] = ATAPI_READ_CAPACITIES_CMD;
 	pc->c[7] = 255;
 	pc->c[8] = 255;
 	pc->request_transfer = 255;
@@ -1181,7 +886,7 @@ static void idefloppy_create_format_unit
 		int b, int l, int flags)
 {
 	atapi_init_pc (pc);
-	pc->c[0] = IDEFLOPPY_FORMAT_UNIT_CMD;
+	pc->c[0] = ATAPI_FORMAT_UNIT_CMD;
 	pc->c[1] = 0x17;
 
 	memset(pc->buffer, 0, 12);
@@ -1207,7 +912,7 @@ static void idefloppy_create_mode_sense_
 	unsigned short length = sizeof(idefloppy_mode_parameter_header_t);
 
 	atapi_init_pc(pc);
-	pc->c[0] = IDEFLOPPY_MODE_SENSE_CMD;
+	pc->c[0] = ATAPI_MODE_SENSE10_CMD;
 	pc->c[1] = 0;
 	pc->c[2] = page_code + (type << 6);
 
@@ -1229,7 +934,7 @@ static void idefloppy_create_mode_sense_
 static void idefloppy_create_start_stop_cmd(struct atapi_packet_command *pc, int start)
 {
 	atapi_init_pc(pc);
-	pc->c[0] = IDEFLOPPY_START_STOP_CMD;
+	pc->c[0] = ATAPI_START_STOP_CMD;
 	pc->c[4] = start;
 	pc->callback = idefloppy_pc_callback;
 }
@@ -1237,7 +942,7 @@ static void idefloppy_create_start_stop_
 static void idefloppy_create_test_unit_ready_cmd(struct atapi_packet_command *pc)
 {
 	atapi_init_pc(pc);
-	pc->c[0] = IDEFLOPPY_TEST_UNIT_READY_CMD;
+	pc->c[0] = ATAPI_TEST_UNIT_READY_CMD;
 	pc->callback = idefloppy_pc_callback;
 }
 
@@ -1255,10 +960,10 @@ static void idefloppy_create_rw_cmd(idef
 
 	atapi_init_pc(pc);
 	if (test_bit (IDEFLOPPY_USE_READ12, &floppy->flags)) {
-		pc->c[0] = cmd == READ ? IDEFLOPPY_READ12_CMD : IDEFLOPPY_WRITE12_CMD;
+		pc->c[0] = cmd == READ ? ATAPI_READ12_CMD : ATAPI_WRITE12_CMD;
 		put_unaligned(htonl (blocks), (unsigned int *) &pc->c[6]);
 	} else {
-		pc->c[0] = cmd == READ ? IDEFLOPPY_READ10_CMD : IDEFLOPPY_WRITE10_CMD;
+		pc->c[0] = cmd == READ ? ATAPI_READ10_CMD : ATAPI_WRITE10_CMD;
 		put_unaligned(htons (blocks), (unsigned short *) &pc->c[7]);
 	}
 	put_unaligned(htonl(block), (unsigned int *) &pc->c[2]);
@@ -1655,7 +1360,7 @@ static int idefloppy_get_format_progress
 	}
 	else
 	{
-		idefloppy_status_reg_t status;
+		atapi_status_reg_t status;
 		unsigned long flags;
 
 		__save_flags(flags);
@@ -1861,7 +1566,7 @@ static unsigned long idefloppy_capacity(
  */
 static int idefloppy_identify_device(struct ata_device *drive,struct hd_driveid *id)
 {
-	struct idefloppy_id_gcw gcw;
+	struct atapi_id_gcw gcw;
 #if IDEFLOPPY_DEBUG_INFO
 	unsigned short mask,i;
 	char buffer[80];
@@ -1976,7 +1681,7 @@ static int idefloppy_identify_device(str
  */
 static void idefloppy_setup(struct ata_device *drive, idefloppy_floppy_t *floppy)
 {
-	struct idefloppy_id_gcw gcw;
+	struct atapi_id_gcw gcw;
 	int i;
 
 	*((unsigned short *) &gcw) = drive->id->config;
--- linux-2.5.22/drivers/ide/ide-tape.c	Tue Jun 18 00:29:02 2002
+++ linux/drivers/ide/ide-tape.c	Tue Jun 18 23:52:42 2002
@@ -771,32 +771,6 @@
 } idetape_stage_t;
 
 /*
- *	REQUEST SENSE packet command result - Data Format.
- */
-typedef struct {
-	unsigned	error_code	:7;	/* Current of deferred errors */
-	unsigned	valid		:1;	/* The information field conforms to QIC-157C */
-	__u8		reserved1	:8;	/* Segment Number - Reserved */
-	unsigned	sense_key	:4;	/* Sense Key */
-	unsigned	reserved2_4	:1;	/* Reserved */
-	unsigned	ili		:1;	/* Incorrect Length Indicator */
-	unsigned	eom		:1;	/* End Of Medium */
-	unsigned	filemark 	:1;	/* Filemark */
-	__u32		information __attribute__ ((packed));
-	__u8		asl;			/* Additional sense length (n-7) */
-	__u32		command_specific;	/* Additional command specific information */
-	__u8		asc;			/* Additional Sense Code */
-	__u8		ascq;			/* Additional Sense Code Qualifier */
-	__u8		replaceable_unit_code;	/* Field Replaceable Unit Code */
-	unsigned	sk_specific1 	:7;	/* Sense Key Specific */
-	unsigned	sksv		:1;	/* Sense Key Specific information is valid */
-	__u8		sk_specific2;		/* Sense Key Specific */
-	__u8		sk_specific3;		/* Sense Key Specific */
-	__u8		pad[2];			/* Padding to 20 bytes */
-} idetape_request_sense_result_t;
-
-
-/*
  *	Most of our global data which we need to save even as we leave the
  *	driver due to an interrupt or a timer event is stored in a variable
  *	of type idetape_tape_t, defined below.
@@ -920,7 +894,7 @@
 	int avg_size;
 	int avg_speed;
 
-	idetape_request_sense_result_t sense;	/* last sense information */
+	atapi_request_sense_result_t sense;	/* last sense information */
 
 	char vendor_id[10];
 	char product_id[18];
@@ -1044,19 +1018,15 @@
 /*
  *	Supported ATAPI tape drives packet commands
  */
-#define IDETAPE_TEST_UNIT_READY_CMD	0x00
 #define IDETAPE_REWIND_CMD		0x01
-#define IDETAPE_REQUEST_SENSE_CMD	0x03
 #define IDETAPE_READ_CMD		0x08
 #define IDETAPE_WRITE_CMD		0x0a
 #define IDETAPE_WRITE_FILEMARK_CMD	0x10
 #define IDETAPE_SPACE_CMD		0x11
-#define IDETAPE_INQUIRY_CMD		0x12
 #define IDETAPE_ERASE_CMD		0x19
 #define IDETAPE_MODE_SENSE_CMD		0x1a
 #define IDETAPE_MODE_SELECT_CMD		0x15
 #define IDETAPE_LOAD_UNLOAD_CMD		0x1b
-#define IDETAPE_PREVENT_CMD		0x1e
 #define IDETAPE_LOCATE_CMD		0x2b
 #define IDETAPE_READ_POSITION_CMD	0x34
 #define IDETAPE_READ_BUFFER_CMD		0x3c
@@ -1124,101 +1094,6 @@
 #define	IDETAPE_ERROR_EOD		103
 
 /*
- *	The ATAPI Status Register.
- */
-typedef union {
-	unsigned all			:8;
-	struct {
-		unsigned check		:1;	/* Error occurred */
-		unsigned idx		:1;	/* Reserved */
-		unsigned corr		:1;	/* Correctable error occurred */
-		unsigned drq		:1;	/* Data is request by the device */
-		unsigned dsc		:1;	/* Buffer availability / Media access command finished */
-		unsigned reserved5	:1;	/* Reserved */
-		unsigned drdy		:1;	/* Ignored for ATAPI commands (ready to accept ATA command) */
-		unsigned bsy		:1;	/* The device has access to the command block */
-	} b;
-} idetape_status_reg_t;
-
-/*
- *	The ATAPI error register.
- */
-typedef union {
-	unsigned all			:8;
-	struct {
-		unsigned ili		:1;	/* Illegal Length Indication */
-		unsigned eom		:1;	/* End Of Media Detected */
-		unsigned abrt		:1;	/* Aborted command - As defined by ATA */
-		unsigned mcr		:1;	/* Media Change Requested - As defined by ATA */
-		unsigned sense_key	:4;	/* Sense key of the last failed packet command */
-	} b;
-} idetape_error_reg_t;
-
-/*
- *	ATAPI Feature Register
- */
-typedef union {
-	unsigned all			:8;
-	struct {
-		unsigned dma		:1;	/* Using DMA or PIO */
-		unsigned reserved321	:3;	/* Reserved */
-		unsigned reserved654	:3;	/* Reserved (Tag Type) */
-		unsigned reserved7	:1;	/* Reserved */
-	} b;
-} idetape_feature_reg_t;
-
-/*
- *	ATAPI Byte Count Register.
- */
-typedef union {
-	unsigned all			:16;
-	struct {
-		unsigned low		:8;	/* LSB */
-		unsigned high		:8;	/* MSB */
-	} b;
-} idetape_bcount_reg_t;
-
-/*
- *	ATAPI Interrupt Reason Register.
- */
-typedef union {
-	unsigned all			:8;
-	struct {
-		unsigned cod		:1;	/* Information transferred is command (1) or data (0) */
-		unsigned io		:1;	/* The device requests us to read (1) or write (0) */
-		unsigned reserved	:6;	/* Reserved */
-	} b;
-} idetape_ireason_reg_t;
-
-/*
- *	ATAPI Drive Select Register
- */
-typedef union {	
-	unsigned all			:8;
-	struct {
-		unsigned sam_lun	:4;	/* Should be zero with ATAPI (not used) */
-		unsigned drv		:1;	/* The responding drive will be drive 0 (0) or drive 1 (1) */
-		unsigned one5		:1;	/* Should be set to 1 */
-		unsigned reserved6	:1;	/* Reserved */
-		unsigned one7		:1;	/* Should be set to 1 */
-	} b;
-} idetape_drivesel_reg_t;
-
-/*
- *	ATAPI Device Control Register
- */
-typedef union {
-	unsigned all			:8;
-	struct {
-		unsigned zero0		:1;	/* Should be set to zero */
-		unsigned nien		:1;	/* Device interrupt is disabled (1) or enabled (0) */
-		unsigned srst		:1;	/* ATA software reset. ATAPI devices should use the new ATAPI srst. */
-		unsigned one3		:1;	/* Should be set to 1 */
-		unsigned reserved4567	:4;	/* Reserved */
-	} b;
-} idetape_control_reg_t;
-
-/*
  *	idetape_chrdev_t provides the link between out character device
  *	interface and our block device interface and the corresponding
  *	ata_device structure.
@@ -1228,45 +1103,6 @@
 } idetape_chrdev_t;
 
 /*
- *	The following is used to format the general configuration word of
- *	the ATAPI IDENTIFY DEVICE command.
- */
-struct idetape_id_gcw {	
-	unsigned packet_size		:2;	/* Packet Size */
-	unsigned reserved234		:3;	/* Reserved */
-	unsigned drq_type		:2;	/* Command packet DRQ type */
-	unsigned removable		:1;	/* Removable media */
-	unsigned device_type		:5;	/* Device type */
-	unsigned reserved13		:1;	/* Reserved */
-	unsigned protocol		:2;	/* Protocol type */
-};
-
-/*
- *	INQUIRY packet command - Data Format (From Table 6-8 of QIC-157C)
- */
-typedef struct {
-	unsigned	device_type	:5;	/* Peripheral Device Type */
-	unsigned	reserved0_765	:3;	/* Peripheral Qualifier - Reserved */
-	unsigned	reserved1_6t0	:7;	/* Reserved */
-	unsigned	rmb		:1;	/* Removable Medium Bit */
-	unsigned	ansi_version	:3;	/* ANSI Version */
-	unsigned	ecma_version	:3;	/* ECMA Version */
-	unsigned	iso_version	:2;	/* ISO Version */
-	unsigned	response_format :4;	/* Response Data Format */
-	unsigned	reserved3_45	:2;	/* Reserved */
-	unsigned	reserved3_6	:1;	/* TrmIOP - Reserved */
-	unsigned	reserved3_7	:1;	/* AENC - Reserved */
-	__u8		additional_length;	/* Additional Length (total_length-4) */
-	__u8		rsv5, rsv6, rsv7;	/* Reserved */
-	__u8		vendor_id[8];		/* Vendor Identification */
-	__u8		product_id[16];		/* Product Identification */
-	__u8		revision_level[4];	/* Revision Level */
-	__u8		vendor_specific[20];	/* Vendor Specific - Optional */
-	__u8		reserved56t95[40];	/* Reserved - Optional */
-						/* Additional information may be returned */
-} idetape_inquiry_result_t;
-
-/*
  *	READ POSITION packet command - Data Format (From Table 6-57)
  */
 typedef struct {
@@ -1407,19 +1243,19 @@ char *idetape_sense_key_verbose (byte id
 char *idetape_command_key_verbose (byte idetape_command_key)
 {
 	switch (idetape_command_key) {
-		case IDETAPE_TEST_UNIT_READY_CMD:	return("TEST_UNIT_READY_CMD");
+		case ATAPI_TEST_UNIT_READY_CMD:		return("TEST_UNIT_READY_CMD");
 		case IDETAPE_REWIND_CMD:		return("REWIND_CMD");
-		case IDETAPE_REQUEST_SENSE_CMD:		return("REQUEST_SENSE_CMD");
+		case ATAPI_REQUEST_SENSE_CMD:		return("REQUEST_SENSE_CMD");
 		case IDETAPE_READ_CMD:			return("READ_CMD");
 		case IDETAPE_WRITE_CMD:			return("WRITE_CMD");
 		case IDETAPE_WRITE_FILEMARK_CMD:	return("WRITE_FILEMARK_CMD");
 		case IDETAPE_SPACE_CMD:			return("SPACE_CMD");
-		case IDETAPE_INQUIRY_CMD:		return("INQUIRY_CMD");
+		case ATAPI_INQUIRY_CMD:			return("INQUIRY_CMD");
 		case IDETAPE_ERASE_CMD:			return("ERASE_CMD");
 		case IDETAPE_MODE_SENSE_CMD:		return("MODE_SENSE_CMD");
 		case IDETAPE_MODE_SELECT_CMD:		return("MODE_SELECT_CMD");
 		case IDETAPE_LOAD_UNLOAD_CMD:		return("LOAD_UNLOAD_CMD");
-		case IDETAPE_PREVENT_CMD:		return("PREVENT_CMD");
+		case ATAPI_ALLOW_PREVENT_REMOVAL_CMD:	return("ALLOW_PREVENT_REMOVAL_CMD");
 		case IDETAPE_LOCATE_CMD:		return("LOCATE_CMD");
 		case IDETAPE_READ_POSITION_CMD:		return("READ_POSITION_CMD");
 		case IDETAPE_READ_BUFFER_CMD:		return("READ_BUFFER_CMD");
@@ -1574,7 +1410,7 @@ static struct request *idetape_next_rq_s
  *	to analyze the request sense. We currently do not utilize this
  *	information.
  */
-static void idetape_analyze_error(struct ata_device *drive, idetape_request_sense_result_t *result)
+static void idetape_analyze_error(struct ata_device *drive, atapi_request_sense_result_t *result)
 {
 	idetape_tape_t *tape = drive->driver_data;
 	struct atapi_packet_command *pc = tape->failed_pc;
@@ -1887,7 +1723,7 @@ static void idetape_request_sense_callba
 		printk (KERN_INFO "ide-tape: Reached idetape_request_sense_callback\n");
 #endif
 	if (!tape->pc->error) {
-		idetape_analyze_error (drive, (idetape_request_sense_result_t *) tape->pc->buffer);
+		idetape_analyze_error (drive, (atapi_request_sense_result_t *) tape->pc->buffer);
 		idetape_end_request(drive, rq, 1);
 	} else {
 		printk (KERN_ERR "ide-tape: Error in REQUEST SENSE itself - Aborting request!\n");
@@ -1898,7 +1734,7 @@ static void idetape_request_sense_callba
 static void idetape_create_request_sense_cmd(struct atapi_packet_command *pc)
 {
 	atapi_init_pc(pc);
-	pc->c[0] = IDETAPE_REQUEST_SENSE_CMD;
+	pc->c[0] = ATAPI_REQUEST_SENSE_CMD;
 	pc->c[4] = 20;
 	pc->request_transfer = 18;
 	pc->callback = &idetape_request_sense_callback;
@@ -1941,7 +1777,7 @@ static void idetape_retry_pc(struct ata_
 	idetape_tape_t *tape = drive->driver_data;
 	struct atapi_packet_command *pc;
 	struct request *rq;
-	idetape_error_reg_t error;
+	atapi_error_reg_t error;
 
 	error.all = IN_BYTE (IDE_ERROR_REG);
 	pc = idetape_next_pc_storage (drive);
@@ -1981,9 +1817,9 @@ static ide_startstop_t idetape_pc_intr(s
 	unsigned long flags;
 	struct ata_channel *ch = drive->channel;
 	idetape_tape_t *tape = drive->driver_data;
-	idetape_status_reg_t status;
-	idetape_bcount_reg_t bcount;
-	idetape_ireason_reg_t ireason;
+	atapi_status_reg_t status;
+	atapi_bcount_reg_t bcount;
+	atapi_ireason_reg_t ireason;
 	struct atapi_packet_command *pc = tape->pc;
 
 	unsigned int temp;
@@ -2043,14 +1879,14 @@ static ide_startstop_t idetape_pc_intr(s
 			status.b.check = 1;
 		}
 #endif
-		if (status.b.check && pc->c[0] == IDETAPE_REQUEST_SENSE_CMD)
+		if (status.b.check && pc->c[0] == ATAPI_REQUEST_SENSE_CMD)
 			status.b.check = 0;
 		if (status.b.check || test_bit (PC_DMA_ERROR, &pc->flags)) {	/* Error detected */
 #if IDETAPE_DEBUG_LOG
 			if (tape->debug_level >= 1)
 				printk (KERN_INFO "ide-tape: %s: I/O error, ",tape->name);
 #endif
-			if (pc->c[0] == IDETAPE_REQUEST_SENSE_CMD) {
+			if (pc->c[0] == ATAPI_REQUEST_SENSE_CMD) {
 				printk (KERN_ERR "ide-tape: I/O error in request sense command\n");
 				return ide_stopped;
 			}
@@ -2196,7 +2032,7 @@ static ide_startstop_t idetape_transfer_
 	struct ata_channel *ch = drive->channel;
 	idetape_tape_t *tape = drive->driver_data;
 	struct atapi_packet_command *pc = tape->pc;
-	idetape_ireason_reg_t ireason;
+	atapi_ireason_reg_t ireason;
 	int retries = 100;
 	ide_startstop_t startstop;
 	int ret;
@@ -2240,16 +2076,16 @@ static ide_startstop_t idetape_issue_pac
 		struct request *rq, struct atapi_packet_command *pc)
 {
 	idetape_tape_t *tape = drive->driver_data;
-	idetape_bcount_reg_t bcount;
+	atapi_bcount_reg_t bcount;
 	int dma_ok = 0;
 
 #if IDETAPE_DEBUG_BUGS
-	if (tape->pc->c[0] == IDETAPE_REQUEST_SENSE_CMD && pc->c[0] == IDETAPE_REQUEST_SENSE_CMD) {
+	if (tape->pc->c[0] == ATAPI_REQUEST_SENSE_CMD && pc->c[0] == ATAPI_REQUEST_SENSE_CMD) {
 		printk (KERN_ERR "ide-tape: possible ide-tape.c bug - Two request sense in serial were issued\n");
 	}
 #endif /* IDETAPE_DEBUG_BUGS */
 
-	if (tape->failed_pc == NULL && pc->c[0] != IDETAPE_REQUEST_SENSE_CMD)
+	if (tape->failed_pc == NULL && pc->c[0] != ATAPI_REQUEST_SENSE_CMD)
 		tape->failed_pc = pc;
 	tape->pc = pc;							/* Set the current packet command */
 
@@ -2261,7 +2097,7 @@ static ide_startstop_t idetape_issue_pac
 		 *	example).
 		 */
 		if (!test_bit (PC_ABORT, &pc->flags)) {
-			if (!(pc->c[0] == IDETAPE_TEST_UNIT_READY_CMD && tape->sense_key == 2 &&
+			if (!(pc->c[0] == ATAPI_TEST_UNIT_READY_CMD && tape->sense_key == 2 &&
 			      tape->asc == 4 && (tape->ascq == 1 || tape->ascq == 8))) {
 				printk (KERN_ERR "ide-tape: %s: I/O error, pc = %2x, key = %2x, asc = %2x, ascq = %2x\n",
 					tape->name, pc->c[0], tape->sense_key, tape->asc, tape->ascq);
@@ -2451,7 +2287,7 @@ static void idetape_media_access_finishe
 {
 	idetape_tape_t *tape = drive->driver_data;
 	struct atapi_packet_command *pc = tape->pc;
-	idetape_status_reg_t status;
+	atapi_status_reg_t status;
 
 	if (tape->onstream)
 		printk(KERN_INFO "ide-tape: bug: onstream, media_access_finished\n");
@@ -2609,7 +2445,7 @@ static ide_startstop_t idetape_do_reques
 	idetape_tape_t *tape = drive->driver_data;
 	struct atapi_packet_command *pc;
 	struct request *postponed_rq = tape->postponed_rq;
-	idetape_status_reg_t status;
+	atapi_status_reg_t status;
 	int ret;
 
 #if IDETAPE_DEBUG_LOG
@@ -2631,7 +2467,7 @@ static ide_startstop_t idetape_do_reques
 	/*
 	 *	Retry a failed packet command
 	 */
-	if (tape->failed_pc != NULL && tape->pc->c[0] == IDETAPE_REQUEST_SENSE_CMD) {
+	if (tape->failed_pc != NULL && tape->pc->c[0] == ATAPI_REQUEST_SENSE_CMD) {
 		int ret;
 
 		/* FIXME: make this unlocking go away*/
@@ -3193,7 +3029,7 @@ static void idetape_create_write_filemar
 static void idetape_create_test_unit_ready_cmd(struct atapi_packet_command *pc)
 {
 	atapi_init_pc(pc);
-	pc->c[0] = IDETAPE_TEST_UNIT_READY_CMD;
+	pc->c[0] = ATAPI_TEST_UNIT_READY_CMD;
 	pc->callback = idetape_pc_callback;
 }
 
@@ -3374,7 +3210,7 @@ static int idetape_create_prevent_cmd(st
 		return 0;
 
 	atapi_init_pc(pc);
-	pc->c[0] = IDETAPE_PREVENT_CMD;
+	pc->c[0] = ATAPI_ALLOW_PREVENT_REMOVAL_CMD;
 	pc->c[4] = prevent;
 	pc->callback = idetape_pc_callback;
 
@@ -3634,7 +3470,7 @@ static void idetape_insert_pipeline_into
 static void idetape_create_inquiry_cmd(struct atapi_packet_command *pc)
 {
 	atapi_init_pc(pc);
-	pc->c[0] = IDETAPE_INQUIRY_CMD;
+	pc->c[0] = ATAPI_INQUIRY_CMD;
 	pc->c[4] = pc->request_transfer = 254;
 	pc->callback = idetape_pc_callback;
 }
@@ -5572,7 +5408,7 @@ static int idetape_chrdev_release (struc
  */
 static int idetape_identify_device(struct ata_device *drive,struct hd_driveid *id)
 {
-	struct idetape_id_gcw gcw;
+	struct atapi_id_gcw gcw;
 #if IDETAPE_DEBUG_INFO
 	unsigned short mask,i;
 #endif /* IDETAPE_DEBUG_INFO */
@@ -5791,14 +5627,14 @@ static void idetape_get_inquiry_results(
 	char *r;
 	idetape_tape_t *tape = drive->driver_data;
 	struct atapi_packet_command pc;
-	idetape_inquiry_result_t *inquiry;
+	atapi_inquiry_result_t *inquiry;
 
 	idetape_create_inquiry_cmd(&pc);
 	if (idetape_queue_pc_tail (drive, &pc)) {
 		printk (KERN_ERR "ide-tape: %s: can't get INQUIRY results\n", tape->name);
 		return;
 	}
-	inquiry = (idetape_inquiry_result_t *) pc.buffer;
+	inquiry = (atapi_inquiry_result_t *) pc.buffer;
 	memcpy(tape->vendor_id, inquiry->vendor_id, 8);
 	memcpy(tape->product_id, inquiry->product_id, 16);
 	memcpy(tape->firmware_revision, inquiry->revision_level, 4);
@@ -5985,7 +5821,7 @@ static void idetape_setup(struct ata_dev
 	unsigned long t1, tmid, tn;
 	unsigned long t;
 	int speed;
-	struct idetape_id_gcw gcw;
+	struct atapi_id_gcw gcw;
 	int stage_size;
 	struct sysinfo si;
 