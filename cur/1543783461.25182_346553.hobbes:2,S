Date: Thu, 1 Sep 2005 21:26:27 -0700
From: "Chen, Kenneth W" <>
Subject: RE: [PATCH 1/1] Implement shared page tables
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/9/2/5

Dave McCracken wrote on Tuesday, August 30, 2005 3:13 PM
> This patch implements page table sharing for all shared memory regions that
> span an entire page table page.  It supports sharing at multiple page
> levels, depending on the architecture.
In function pt_share_pte():
> +		while ((svma = next_shareable_vma(vma, svma, &iter))) {
> +			spgd = pgd_offset(svma->vm_mm, address);
> +			if (pgd_none(*spgd))
> +				continue;
> +
> +			spud = pud_offset(spgd, address);
> +			if (pud_none(*spud))
> +				continue;
> +
> +			spmd = pmd_offset(spud, address);
> +			if (pmd_none(*spmd))
> +				continue;
....
> +			page = pmd_page(*spmd);
> +			pt_increment_share(page);
> +			pmd_populate(vma->vm_mm, pmd, page);
> +		}
Do you really have to iterate through all the vma?  Can't you just break
out of the while loop on first successful match and populating the pmd?
I would think you will find them to be the same pte page. Or did I miss
some thing?
--- ./mm/ptshare.c.orig	2005-09-01 21:16:35.311915518 -0700
+++ ./mm/ptshare.c	2005-09-01 21:18:24.629296992 -0700
@@ -200,6 +200,7 @@ pt_share_pte(struct vm_area_struct *vma,
 			page = pmd_page(*spmd);
 			pt_increment_share(page);
 			pmd_populate(vma->vm_mm, pmd, page);
+			break;
 		}
 	}
 	pte = pte_alloc_map(vma->vm_mm, pmd, address);
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/