Date: Sun, 31 Aug 2003 19:41:14 -0400
From: Robert Love <>
Subject: Re: [SHED] Questions.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2003/8/31/191

On Sun, 2003-08-31 at 18:41, Ian Kumlien wrote:
> hummm, I assume that a high pri process can preempt a low pri process...
> The rest sounds sane to me =), Please tell me what i'm missing.. =)
No no.  The rule is "the highest priority process with timeslice
remaining runs" not just "the highest priority process runs."
Otherwise, timeslice wouldn't matter much!
When a process exhausts its timeslice, it is moved to the "expired"
list.  When all currently running tasks expire their timeslice, the
scheduler begins servicing from the "expired" list (which then becomes
the "active" list, and the old active list becomes the expired).
This implies that a high priority, which has exhausted its timeslice,
will not be allowed to run again until _all_ other runnable tasks
exhaust their timeslice (this ignores the reinsertion into the active
array of interactive tasks, but that is an optimization that just
complicates this discussion).
If timeslices did not play a role, then high priority tasks would always
monopolize the system.
This is a classic priority-based round-robin scheduler.
> > Once a task exhausts its timeslice, it cannot run until all other tasks
> > exhaust their timeslice.  If this were not the case, high priority tasks
> > could monopolize the system.
> 
> All other? including sleeping?... How many tasks can be assumed to run
> on the cpu at a time?....
I wasn't clear: all other _runnable_ tasks.
Once a task "expires" (exhausts its timeslice), it will not run again
until all other tasks, even those of a lower priority, exhaust their
timeslice.
This is a major difference between normal tasks and real-time tasks.
> Should preempt send the new quantum value to all "low pri, high quantum"
> processes?
I don't follow this?
> Damn thats a tough cookie, i still think that the priority inversion is
> bad. Don't know enough about this to actually provide a solution... 
> Any one else that has a view point?
Priority inversion is bad, but the priority inversion in this case is
intended.  Higher priority tasks cannot starve lower ones.  It is a
classic Unix philosophy that 'all tasks make some forward progress'
If you need to guarantee that a task always runs when runnable, you want
real-time.
If you just want to give a scheduling boost, to ensure greater
runnability, lower latency, and larger timeslices... nice values
suffice.
> Hummm, the skips in xmms tells me that something is bad.. 
> (esp since it works perfectly on the previus scheduler)
A lot of this is just the interactivity estimator making the wrong
estimate.
> Since it's rescheduled after a short runtime or, might be.
> From someones mail i saw (afair), there was much more context switches
> in 2.6 than in 2.4. And each schedule consumes time and cycles.
Context switches (as in process to process changes) should be about the
same?
Interrupt frequency has gone up in x86 (1000 vs 100).  Maybe that is
what they are seeing.
> Oh yes, but otoh, if you are really keen on the latency then you'll do
> realtime =)
Agreed.  But at the same time, not every "interactive" task should be
real-time.  In fact, nearly all should not.  I do not want my text
editor or mailer to be RT, for example.
They just need a scheduling boost.
	Robert Love
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/