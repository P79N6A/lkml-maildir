Date: Tue, 05 Jul 2005 19:12:21 +0900 (JST)
From: Masatake YAMATO <>
Subject: [PATCH] Avoid to use kmalloc in usb/core/message.c
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/7/5/26

In some functions in drivers/usb/core/message.c kmalloc is used to
allocate fix size of memory chunks; and the chunks is freed at the end
of each functions. The sizes are not so large: 8(struct
usb_ctrlrequest), 18(struct usb_device_descriptor), and 2(u16) bytes.
I wonder why the invocations of kmalloc are needed in these functions.
Following patch is for avoiding invocations of kmalloc. Instead stacks
are used.
The patch is generated by co-diff against 
rsync://kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git
Signed-off-by: Masatake YAMATO <jet@gyve.org>
Index: drivers/usb/core/message.c
===================================================================
--- 6f51e67e4a433ee0ff866a6ac18a4bce798fe0c7/drivers/usb/core/message.c  (mode:100644)
+++ uncommitted/drivers/usb/core/message.c  (mode:100644)
@@ -142,11 +142,9 @@
 int usb_control_msg(struct usb_device *dev, unsigned int pipe, __u8 request, __u8 requesttype,
                         __u16 value, __u16 index, void *data, __u16 size, int timeout)
 {
-       struct usb_ctrlrequest *dr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_NOIO);
+       struct usb_ctrlrequest dr_rec;
+       struct usb_ctrlrequest *dr = &dr_rec;
        int ret;
-
-       if (!dr)
-               return -ENOMEM;
        dr->bRequestType= requesttype;
        dr->bRequest = request;
@@ -158,7 +156,6 @@
        ret = usb_internal_control_msg(dev, pipe, dr, data, size, timeout);
-       kfree(dr);
        return ret;
 }
@@ -794,19 +791,17 @@
  */
 int usb_get_device_descriptor(struct usb_device *dev, unsigned int size)
 {
+       struct usb_device_descriptor  desc_rec;
        struct usb_device_descriptor *desc;
        int ret;
        if (size > sizeof(*desc))
                return -EINVAL;
-       desc = kmalloc(sizeof(*desc), GFP_NOIO);
-       if (!desc)
-               return -ENOMEM;
+       desc = &desc_rec;
        ret = usb_get_descriptor(dev, USB_DT_DEVICE, 0, desc, size);
        if (ret >= 0)
                memcpy(&dev->descriptor, desc, size);
-       kfree(desc);
        return ret;
 }
@@ -835,17 +830,13 @@
 int usb_get_status(struct usb_device *dev, int type, int target, void *data)
 {
        int ret;
-       u16 *status = kmalloc(sizeof(*status), GFP_KERNEL);
-
-       if (!status)
-               return -ENOMEM;
+       u16 status;
        ret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
-               USB_REQ_GET_STATUS, USB_DIR_IN | type, 0, target, status,
-               sizeof(*status), USB_CTRL_GET_TIMEOUT);
+               USB_REQ_GET_STATUS, USB_DIR_IN | type, 0, target, &status,
+               sizeof(status), USB_CTRL_GET_TIMEOUT);
-       *(u16 *)data = *status;
-       kfree(status);
+       *(u16 *)data = status;
        return ret;
 }
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/