Date: Tue, 26 Oct 1999 14:11:21 -0400 (EDT)
From: Alexander Viro <>
Subject: Re: [PATCH] fix fat fs for 2.3.23/2.3.24pre1
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/10/26/112

On Tue, 26 Oct 1999, Mikael Pettersson wrote:
> Compiling the fat file system in kernel 2.3.24pre1 produces
> these warnings:
> 
> gcc -D__KERNEL__ -I/tmp/linux-2.3.24-pre1/include -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer -fno-strict-aliasing -pipe -fno-strength-reduce -mpreferred-stack-boundary=2 -msoft-float -DCPU=686 -march=i686   -c -o file.o file.c
> file.c: In function `fat_write_partial_page':
> file.c:127: warning: assignment makes integer from pointer without a cast
> file.c:148: warning: passing arg 1 of `__free_page' makes pointer from integer without a cast
> ...
> gcc -D__KERNEL__ -I/tmp/linux-2.3.24-pre1/include -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer -fno-strict-aliasing -pipe -fno-strength-reduce -mpreferred-stack-boundary=2 -msoft-float -DCPU=686 -march=i686   -c -o mmap.o mmap.c
> mmap.c:88: warning: initialization from incompatible pointer type
> 
> The warning in file.c is almost harmless, but mmap.c's nopage
> was broken completely (it would return an "unsigned long" page
> address instead of a "struct page*").
fat/mmap.c should be dropped: it is not used and it _always_ had been
broken. No need to bother with special-casing here.
As for the file.c - yep, it is needed. Ditto for hpfs/file.c, BTW.
Your fix is not enough - you missed page_cache_entry(). And that one
was _not_ harmless.
								Al
Patch follows:
diff -urN linux/fs/fat/Makefile linux.bird/fs/fat/Makefile
--- linux/fs/fat/Makefile	Mon Jun 21 12:36:44 1999
+++ linux.bird/fs/fat/Makefile	Tue Oct 26 14:03:30 1999
@@ -8,7 +8,7 @@
 # Note 2! The CFLAGS definitions are now in the main makefile.
 
 O_TARGET := fat.o
-O_OBJS   := buffer.o cache.o dir.o file.o inode.o misc.o mmap.o tables.o cvf.o
+O_OBJS   := buffer.o cache.o dir.o file.o inode.o misc.o tables.o cvf.o
 OX_OBJS  := fatfs_syms.o
 M_OBJS   := $(O_TARGET)
 
diff -urN linux/fs/fat/fatfs_syms.c linux.bird/fs/fat/fatfs_syms.c
--- linux/fs/fat/fatfs_syms.c	Sun Sep 12 11:56:11 1999
+++ linux.bird/fs/fat/fatfs_syms.c	Tue Oct 26 13:59:05 1999
@@ -33,7 +33,6 @@
 EXPORT_SYMBOL(fat__get_entry);
 EXPORT_SYMBOL(fat_lock_creation);
 EXPORT_SYMBOL(fat_mark_buffer_dirty);
-EXPORT_SYMBOL(fat_mmap);
 EXPORT_SYMBOL(fat_notify_change);
 EXPORT_SYMBOL(fat_parent_ino);
 EXPORT_SYMBOL(fat_put_super);
@@ -54,7 +53,6 @@
 EXPORT_SYMBOL(lock_fat);
 EXPORT_SYMBOL(unlock_fat);
 EXPORT_SYMBOL(fat_dir_ioctl);
-EXPORT_SYMBOL(fat_readpage);
 EXPORT_SYMBOL(fat_add_entries);
 EXPORT_SYMBOL(fat_dir_empty);
 
diff -urN linux/fs/fat/file.c linux.bird/fs/fat/file.c
--- linux/fs/fat/file.c	Sat Oct  9 16:10:12 1999
+++ linux.bird/fs/fat/file.c	Tue Oct 26 13:56:09 1999
@@ -115,7 +115,7 @@
 	struct inode *inode = dentry->d_inode;
 	struct page *new_page, **hash;
 	unsigned long pgpos;
-	unsigned long page_cache = 0;
+	struct page *page_cache = NULL;
 	long status;
 
 	pgpos = MSDOS_I(inode)->i_realsize & PAGE_CACHE_MASK;
@@ -130,7 +130,7 @@
 				status = -ENOMEM;
 				goto out;
 			}
-			new_page = page_cache_entry(page_cache);
+			new_page = page_cache;
 			if (add_to_page_cache_unique(new_page,inode,pgpos,hash))
 				goto repeat_find;
 			page_cache = 0;
diff -urN linux/fs/fat/mmap.c linux.bird/fs/fat/mmap.c
--- linux/fs/fat/mmap.c	Sun Sep 12 06:21:33 1999
+++ linux.bird/fs/fat/mmap.c	Wed Dec 31 19:00:00 1969
@@ -1,131 +0,0 @@
-/*
- *	linux/fs/fat/mmap.c
- *
- *	Written by Jacques Gelinas (jacques@solucorp.qc.ca)
- *	Inspired by fs/nfs/mmap.c (Jon Tombs 15 Aug 1993)
- *
- *	mmap handling for fat-based filesystems
- */
-
-#define ASC_LINUX_VERSION(V, P, S)	(((V) * 65536) + ((P) * 256) + (S))
-#include <linux/version.h>
-
-#include <linux/stat.h>
-#include <linux/sched.h>
-#include <linux/kernel.h>
-#include <linux/mm.h>
-#include <linux/shm.h>
-#include <linux/errno.h>
-#include <linux/mman.h>
-#include <linux/string.h>
-#include <linux/malloc.h>
-#include <linux/msdos_fs.h>
-
-#include <asm/uaccess.h>
-#include <asm/system.h>
-
-/*
- * Fill in the supplied page for mmap
- */
-static unsigned long fat_file_mmap_nopage(
-	struct vm_area_struct * area,
-	unsigned long address,
-	int error_code)
-{
-	struct inode * inode = area->vm_file->f_dentry->d_inode;
-	unsigned long page;
-	unsigned int clear;
-	int pos;
-	long gap;	/* distance from eof to pos */
-
-	page = __get_free_page(GFP_KERNEL);
-	if (!page)
-		return page;
-	address &= PAGE_MASK;
-	pos = address - area->vm_start + area->vm_offset;
-
-	clear = 0;
-	gap = inode->i_size - pos;
-	if (gap <= 0){
-		/* mmaping beyond end of file */
-		clear = PAGE_SIZE;
-	}else{
-		int cur_read;
-		int need_read;
-		struct file filp;
-		if (gap < PAGE_SIZE){
-			clear = PAGE_SIZE - gap;
-		}
-		filp.f_reada = 0;
-		filp.f_pos = pos;
-		filp.f_dentry=area->vm_file->f_dentry;
-		need_read = PAGE_SIZE - clear;
-		{
-			mm_segment_t cur_fs = get_fs();
-			set_fs (KERNEL_DS);
-			cur_read = fat_file_read (&filp, (char*)page,
-						  need_read, &filp.f_pos);
-			set_fs (cur_fs);
-		}
-		if (cur_read != need_read){
-			printk ("MSDOS: Error while reading an mmap file %d <> %d\n"
-				,cur_read,need_read);
-		}
-	}
-	if (clear > 0){
-		memset ((char*)page+PAGE_SIZE-clear,0,clear);
-	}
-	return page;
-}
-
-struct vm_operations_struct fat_file_mmap = {
-	NULL,			/* open */
-	NULL,			/* close */
-	NULL,			/* unmap */
-	NULL,			/* protect */
-	NULL,			/* sync */
-	NULL,			/* advise */
-	fat_file_mmap_nopage,	/* nopage */
-	NULL,			/* wppage */
-	NULL			/* swapout */
-};
-
-/*
- * This is used for a general mmap of an msdos file
- * Returns 0 if ok, or a negative error code if not.
- */
-int fat_mmap(struct file * file, struct vm_area_struct * vma)
-{
-	struct inode *inode = file->f_dentry->d_inode;
-	if (MSDOS_SB(inode->i_sb)->cvf_format &&
-	    MSDOS_SB(inode->i_sb)->cvf_format->cvf_mmap)
-		return MSDOS_SB(inode->i_sb)->cvf_format->cvf_mmap(file,vma);
-
-	if (vma->vm_flags & VM_SHARED)	/* only PAGE_COW or read-only supported now */
-		return -EINVAL;
-	if (vma->vm_offset & (inode->i_sb->s_blocksize - 1))
-		return -EINVAL;
-	if (!inode->i_sb || !S_ISREG(inode->i_mode))
-		return -EACCES;
-	if (!IS_RDONLY(inode)) {
-		inode->i_atime = CURRENT_TIME;
-		mark_inode_dirty(inode);
-	}
-
-	vma->vm_ops = &fat_file_mmap;
-	return 0;
-}
-
-
-int fat_readpage(struct file *file, struct page * page)
-{
-	struct dentry * dentry = file->f_dentry;
-	struct inode * inode = dentry->d_inode;
-	if (MSDOS_SB(inode->i_sb)->cvf_format &&
-	    MSDOS_SB(inode->i_sb)->cvf_format->cvf_readpage)
-		return MSDOS_SB(inode->i_sb)->cvf_format->cvf_readpage(inode,page);
-	    
-	printk("fat_readpage called with no handler (shouldn't happen)\n");
-	return -1;
-}
-
diff -urN linux/fs/hpfs/file.c linux.bird/fs/hpfs/file.c
--- linux/fs/hpfs/file.c	Sat Oct 23 14:24:01 1999
+++ linux.bird/fs/hpfs/file.c	Tue Oct 26 13:53:45 1999
@@ -91,7 +91,7 @@
 	struct inode *inode = dentry->d_inode;
 	struct page *new_page, **hash;
 	unsigned long pgpos;
-	unsigned long page_cache = 0;
+	struct page * page_cache = NULL;
 	long status;
 
 	printk("- off: %08x\n", (int)page->offset);
@@ -109,10 +109,10 @@
 				status = -ENOMEM;
 				goto out;
 			}
-			new_page = page_cache_entry(page_cache);
+			new_page = page_cache;
 			if (add_to_page_cache_unique(new_page,inode,pgpos,hash))
 				goto repeat_find;
-			page_cache = 0;
+			page_cache = NULL;
 		}
 		printk("A\n");
 		status = block_write_cont_page(file, new_page, PAGE_SIZE, 0, NULL);
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/