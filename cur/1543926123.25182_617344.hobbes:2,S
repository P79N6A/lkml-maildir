Date: Wed, 14 Nov 2007 14:27:36 +0100
From: Peter Zijlstra <>
Subject: Re: Divide-by-zero in the 2.6.23 scheduler code
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/11/14/160

On Tue, 2007-11-13 at 20:14 -0500, Chuck Ebbert wrote:
> 
https://bugzilla.redhat.com/show_bug.cgi?id=340161
While I see the user has a divide by zero, I'm not understanding it.
> The problem code has been removed in 2.6.24. The below patch disables
> SCHED_FEAT_PRECISE_CPU_LOAD which causes the offending code to be skipped
> but does not prevent the user from enabling it.
> 
> The divide-by-zero is here in kernel/sched.c:
> 
> static void update_cpu_load(struct rq *this_rq)
> {
> 	u64 fair_delta64, exec_delta64, idle_delta64, sample_interval64, tmp64;
> 	unsigned long total_load = this_rq->ls.load.weight;
> 	unsigned long this_load =  total_load;
> 	struct load_stat *ls = &this_rq->ls;
> 	int i, scale;
> 
> 	this_rq->nr_load_updates++;
> 	if (unlikely(!(sysctl_sched_features & SCHED_FEAT_PRECISE_CPU_LOAD)))
> 		goto do_avg;
> 
> 	/* Update delta_fair/delta_exec fields first */
> 	update_curr_load(this_rq);
> 
> 	fair_delta64 = ls->delta_fair + 1;
Shouldn't that +1 avoid fair_delta64 from being 0?
> 	ls->delta_fair = 0;
> 
> 	exec_delta64 = ls->delta_exec + 1;
> 	ls->delta_exec = 0;
> 
> 	sample_interval64 = this_rq->clock - ls->load_update_last;
> 	ls->load_update_last = this_rq->clock;
> 
> 	if ((s64)sample_interval64 < (s64)TICK_NSEC)
> 		sample_interval64 = TICK_NSEC;
This avoids sample_interval64 from being 0.
> 	if (exec_delta64 > sample_interval64)
> 		exec_delta64 = sample_interval64;
> 
> 	idle_delta64 = sample_interval64 - exec_delta64;
> 
> ======>	tmp64 = div64_64(SCHED_LOAD_SCALE * exec_delta64, fair_delta64);
> 	tmp64 = div64_64(tmp64 * exec_delta64, sample_interval64);
> 
> 	this_load = (unsigned long)tmp64;
> 
> do_avg:
> 
> 	/* Update our load: */
> 	for (i = 0, scale = 1; i < CPU_LOAD_IDX_MAX; i++, scale += scale) {
> 		unsigned long old_load, new_load;
> 
> 		/* scale is effectively 1 << i now, and >> i divides by scale */
> 
> 		old_load = this_rq->cpu_load[i];
> 		new_load = this_load;
> 
> 		this_rq->cpu_load[i] = (old_load*(scale-1) + new_load) >> i;
> 	}
> }
> 
As for the patch, better to just rip out the entire feature..
[unhandled content-type:application/pgp-signature]