Date: Thu, 20 Dec 2007 15:22:30 +0100
From: Ingo Molnar <>
Subject: [git pull] scheduler + debugging updates
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/12/20/236

Linus, please pull this scheduler+debugging git tree from:
   git://git.kernel.org/pub/scm/linux/kernel/git/mingo/linux-2.6-sched.git
These patches successfully passed a couple of hundred 32-bit and 64-bit 
x86 random kernel builds and bootups. (The debug patch is fine IMO - 
i'll redo this push if it's questionable.)
Thanks!
	Ingo
------------------>
Arjan van de Ven (1):
      debug: add end-of-oops marker
Peter Zijlstra (1):
      sched: rt: account the cpu time during the tick
 panic.c    |   18 ++++++++++++++++++
 sched_rt.c |    2 ++
 2 files changed, 20 insertions(+)
diff --git a/kernel/panic.c b/kernel/panic.c
index 6f6e03e..da4d6ba 100644
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -19,6 +19,7 @@
 #include <linux/nmi.h>
 #include <linux/kexec.h>
 #include <linux/debug_locks.h>
+#include <linux/random.h>
 
 int panic_on_oops;
 int tainted;
@@ -266,12 +267,29 @@ void oops_enter(void)
 }
 
 /*
+ * 64-bit random ID for oopses:
+ */
+static u64 oops_id;
+
+static int init_oops_id(void)
+{
+	if (!oops_id)
+		get_random_bytes(&oops_id, sizeof(oops_id));
+
+	return 0;
+}
+late_initcall(init_oops_id);
+
+/*
  * Called when the architecture exits its oops handler, after printing
  * everything.
  */
 void oops_exit(void)
 {
 	do_oops_enter_exit();
+	init_oops_id();
+	printk(KERN_WARNING "---[ end trace %016llx ]---\n",
+		(unsigned long long)oops_id);
 }
 
 #ifdef CONFIG_CC_STACKPROTECTOR
diff --git a/kernel/sched_rt.c b/kernel/sched_rt.c
index ee9c8b6..9ba3daa 100644
--- a/kernel/sched_rt.c
+++ b/kernel/sched_rt.c
@@ -208,6 +208,8 @@ move_one_task_rt(struct rq *this_rq, int this_cpu, struct rq *busiest,
 
 static void task_tick_rt(struct rq *rq, struct task_struct *p)
 {
+	update_curr_rt(rq);
+
 	/*
 	 * RR tasks need a special form of timeslice management.
 	 * FIFO tasks have no timeslices.