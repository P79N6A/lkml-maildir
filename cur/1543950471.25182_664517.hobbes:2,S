Date: Thu, 6 Mar 2008 08:11:59 -0800 (PST)
From: Linus Torvalds <>
Subject: Re: [patch] Re: using long instead of atomic_t when only set/read is required
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/3/6/246

On Thu, 6 Mar 2008, Mark Lord wrote:
> 
> But also consider something like this:
> 
> 	void store_task(void)
> 	{
> 		*the_task = current;
> 	}
> 
> In this case, there is no guarantee that the assignment
> can be done atomically on all CPU types.  Some RISC archs
> (eg. MIPS R2xxx) require an (interruptible) instruction pair
> to store values to a potentially unaligned address.
You'd better not be using unaligned accesses for memory-ordering-sensitive 
things (I think x86 happens get even that right for most cases, but I 
don't think the architecture specification guarantees it, and I'm pretty 
sure that you might find problems on cache crossing writes, for example)
But quite frankly, if you have an architecture that can't do the above as 
a single write when it's a pointer, then you have a totally broken 
architecture. It's not worth supporting.
(There are data structures that are harder than native words: bytes and 
shorts can require load-modify-write cycles, and "u64" and friends can 
obviously be multiple words, so you shouldn't depend on things for those 
"complex" cases. But we *definitely* depend on atomicity for regular word 
accesses).
		Linus