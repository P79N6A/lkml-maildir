Date: Fri, 6 Jan 2006 22:36:26 +0300
From: Alexey Dobriyan <>
Subject: Re: drivers/acpi/scan.c: inconsequent NULL handling
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/1/6/316

On Fri, Jan 06, 2006 at 05:29:29PM +0100, Adrian Bunk wrote:
> static int
> acpi_bus_match (
>         struct acpi_device      *device,
>         struct acpi_driver      *driver)
> {
>         if (driver && driver->ops.match)
>                 return driver->ops.match(device, driver);
>         return acpi_match_ids(device, driver->ids);
> }
> Either driver can be NULL, in which case the driver->ids is a possible
> NULL pointer reference, or it can't, in which case the check whether
> it's NULL is superfluous.
Follow the mon^Wcall tree.
drivers/acpi/scan.c:478: * acpi_bus_match 
drivers/acpi/scan.c:484:acpi_bus_match(struct acpi_device *device, struct acpi_driver *driver)
drivers/acpi/scan.c:564:		if (!acpi_bus_match(dev, drv)) {
drivers/acpi/scan.c:682:		if (!acpi_bus_match(device, driver)) {
1. acpi_bus_match()
   Second arg is passed without changes.
	acpi_driver_attach()
		acpi_bus_register_driver()
	  ===>	if (!driver) <===
			return_VALUE(-EINVAL);
		spin_lock(&acpi_device_lock);
		list_add_tail(&driver->node, &acpi_bus_drivers);
		spin_unlock(&acpi_device_lock);
		count = acpi_driver_attach(driver);
2. acpi_bus_match()
	acpi_bus_find_driver()
		atomic_inc(&driver->references);
			    ^^^^^^^^
                spin_unlock(&acpi_device_lock);
		if (!acpi_bus_match(device, driver)) {
Looks like it can't.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/