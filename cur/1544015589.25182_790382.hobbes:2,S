Date: Mon, 12 Jan 2009 01:12:55 +0100
From: Andi Kleen <>
Subject: Re: gcc inlining heuristics was Re: [PATCH -v7][RFC]: mutex: implement adaptive spinning
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2009/1/11/369

On Sun, Jan 11, 2009 at 03:05:53PM -0800, Linus Torvalds wrote:
> 
> 
> On Sun, 11 Jan 2009, Linus Torvalds wrote:
> > On Sun, 11 Jan 2009, Andi Kleen wrote:
> > > 
> > > Was -- i think that got fixed in gcc. But again only in newer versions.
> > 
> > I doubt it. People have said that about a million times, it has never 
> > gotten fixed, and I've never seen any actual proof.
> 
> In fact, I just double-checked.
> Try this:
Hmm, I actually had tested it some time ago with my own program
(supposed to emulate an ioctl)
extern void f5(char *);
static void f3(void)
{
	char y[100];
	f5(y);
}
static void f2(void)
{
	char x[100];
	f5(x);
}
int f(int cmd)
{
	switch (cmd) { 
	case 1: f3(); break;
	case 2: f2(); break;
	}
	return 1;
}
and with gcc 4.3.1 I get:
.globl f
	.type	f, @function
f:
.LFB4:
	subq	$120, %rsp			<---- not 200 bytes, stack gets reused; dunno where the 20 comes from
.LCFI0:
	cmpl	$1, %edi
	je	.L4
	cmpl	$2, %edi
	je	.L4
	movl	$1, %eax
	addq	$120, %rsp
	ret
	.p2align 4,,10
	.p2align 3
.L4:
	movq	%rsp, %rdi
	call	f5
	movl	$1, %eax
	addq	$120, %rsp
	ret
.LFE4:
so at least least for this case it works. Your case also doesn't work for me.
So it looks like gcc didn't like something you did in your test program.
Could be a pointer aliasing problem of some sort.
But yes it doesn't work as well as we hoped.
-Andi