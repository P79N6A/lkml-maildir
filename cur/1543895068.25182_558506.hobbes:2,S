Date: Sun, 17 Jun 2007 00:00:30 +0200 (CEST)
From: Jan Engelhardt <>
Subject: Re: [PATCH] update checkpatch.pl to version 0.05
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/6/16/184

On Jun 16 2007 22:42, Andy Whitcroft wrote:
>@@ -180,12 +182,17 @@ sub ctx_block_get {
> sub ctx_block_outer {
> 	my ($linenr, $remain) = @_;
> 
>-	return ctx_block_get($linenr, $remain, 1);
>+	return ctx_block_get($linenr, $remain, 1, '\{', '\}');
'\\{'.
Or, if it works, directly use
	return &ctx_block_get($linenr, $remain, 1, qr/\{/, qr/\}/);
>+sub ctx_statement {
>+	my ($linenr, $remain) = @_;
>+
>+	return ctx_block_get($linenr, $remain, 0, '\(', '\)');
^^
>+	my $ident	= '[A-Za-z\d_]+';
Oh yes, use the qr operator here. (qr{}, qr//, choose anything like you
would do with m//)
>+	my $storage	= '(?:extern|static)';
>+	my $sparse	= '(?:__user|__kernel|__force|__iomem)';
>+	my $type	= '(?:unsigned\s+)?' .
>+			  '(?:void|char|short|int|long|unsigned|float|double|' .
>+			  'long\s+long|' .
>+			  "struct\\s+${ident}|" .
>+			  "union\\s+${ident}|" .
>+			  "${ident}_t)" .
>+			  "(?:\\s+$sparse)*" .
>+			  '(?:\s*\*+)?';
>+	my $attribute	= '(?:__read_mostly|__init|__initdata)';
>+
>+	my $Ident	= $ident;
>+	my $Type	= $type;
>+	my $Storage	= $storage;
>+	my $Declare	= "(?:$storage\\s+)?$type";
>+	my $Attribute	= $attribute;
>+
> #trailing whitespace
>-		if ($line=~/\+.*\S\s+$/) {
>+		if ($line=~/^\+.*\S\s+$/) {
                if ($line =~ /^\+.*\S\s+$/) {
> 			my $herevet = "$here\n" . cat_vet($line) . "\n\n";
> 			print "trailing whitespace\n";
> 			print "$herevet";
>@@ -392,17 +420,20 @@ sub process {
> 		#
> 		next if ($in_comment);
> 
>-		# Remove comments from the line before processing.
>+# Remove comments from the line before processing.
> 		$line =~ s@/\*.*\*/@@g;
> 		$line =~ s@/\*.*@@;
C being a wonderful language, has this nice pitfall for parsers
	foo = number /*pointer_to_int;
> 		$line =~ s@.*\*/@@;
> 
>-		#
>-		# Checks which may be anchored in the context.
>-		#
>+# Standardise the strings and chars within the input to simplify matching.
>+		$line = sanitise_line($line);
>+
>+#
>+# Checks which may be anchored in the context.
>+#
> 
>-		# Check for switch () and associated case and default
>-		# statements should be at the same indent.
>+# Check for switch () and associated case and default
>+# statements should be at the same indent.
> 		if ($line=~/\bswitch\s*\(.*\)/) {
Codingstyle warrants \bswitch\s+  :)
> # * goes on variable not on type
>-		my $type = '(?:char|short|int|long|unsigned|float|double|' .
>-			   'struct\s+[A-Za-z\d_]+|' .
>-			   'union\s+[A-Za-z\d_]+)';
>-
qr. (I don't know what it is good for - compare qr/xyz/ with 'xyz'...,
but there's a reason to its existence, so let's use it :-)
	Jan
-- 
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/