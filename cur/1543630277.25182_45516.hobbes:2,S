Date: Sun, 12 May 2002 23:04:07 +0200 (CEST)
From: "Wojciech \"Sas\" Cieciwa" <>
Subject: HPFS and linux-2.4.18
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2002/5/12/87

Hi,
One of my friend found posibility bug.
When he trying to mount a OS/2 filesystem [hpfs] he take back 
"Segmentation fault" error [see Attachment 1]
I check difference between 2.4.18 and 2.4.6 [which works fine]
[diff in Attachment 2]
When I apply difference to 2.4.18 mount works OK.
Can anyone check this?
Thanx.
-- 
{Wojciech 'Sas' Cieciwa}  {Member of PLD Team                               }
{e-mail: cieciwa@alpha.zarz.agh.edu.pl, 
http://www2.zarz.agh.edu.pl/~cieciwa
}
maj 11 00:03:34 <aflinta>	[root@warp root]# mount -t hpfs /dev/hda3 /mnt/os2/
maj 11 00:03:34 <aflinta>	Segmentation fault
maj 11 00:04:28 <aflinta>	May 10 23:39:56 warp (aflinta-16590): starting (version 1.0.9), pid 16590 user 'aflinta'
maj 11 00:04:29 <aflinta>	May 10 23:58:00 warp kernel: invalid operand: 0000
maj 11 00:04:29 <aflinta>	May 10 23:58:00 warp kernel: CPU:    0
maj 11 00:04:29 <aflinta>	May 10 23:58:00 warp kernel: EIP:    0010:[grow_buffers+80/252]    Tainted: P 
maj 11 00:04:29 <aflinta>	May 10 23:58:00 warp kernel: EFLAGS: 00010286
maj 11 00:04:29 <aflinta>	May 10 23:58:00 warp kernel: eax: fffffe00   ebx: 00000003   ecx: 00000200   edx: 00000000
maj 11 00:04:31 <aflinta>	May 10 23:58:00 warp kernel: esi: 00000000   edi: 00000303   ebp: 00000000   esp: cae93dc8
maj 11 00:04:33 <aflinta>	May 10 23:58:00 warp kernel: ds: 0018   es: 0018   ss: 0018
maj 11 00:04:35 <aflinta>	May 10 23:58:00 warp kernel: Process mount (pid: 16678, stackpage=cae93000)
maj 11 00:04:37 <aflinta>	May 10 23:58:00 warp kernel: Stack: 00000303 00000000 00000000 00000000 00002360 c0132b9b 00000303 00000000 
maj 11 00:04:42 <aflinta>	May 10 23:58:00 warp kernel:        00000000 cae93e60 c7b4cc00 cff11ae0 c0132d78 00000303 00000000 00000000 
maj 11 00:04:45 <aflinta>	May 10 23:58:00 warp kernel:        cff11ae0 d4ed653c 00000303 00000000 00000000 00000000 d4edf39d c7b4cc00 
maj 11 00:04:48 <aflinta>	May 10 23:58:00 warp kernel: Call Trace: [getblk+39/64] [bread+24/112] [reiserfs:__insmod_reiserfs_S.bss_L6624+72692252/301754548] [reiserfs:__insmod_reiserfs_S.bss_L6624+72728701/301718099] [insert_super+63/68] 
maj 11 00:04:52 <aflinta>	May 10 23:58:00 warp kernel:    [reiserfs:__insmod_reiserfs_S.bss_L6624+72745000/301701800] [get_sb_bdev+540/644] [reiserfs:__insmod_reiserfs_S.bss_L6624+72745000/301701800] [set_devname+39/84] [do_kern_mount+167/308] [reiserfs:__insmod_reiserfs_S.bss_L6624+72745000/301701800] 
maj 11 00:04:56 <aflinta>	May 10 23:58:00 warp kernel:    [do_add_mount+32/472] [do_mount+674/816] [copy_mount_options+77/156] [sys_mount+132/196] [system_call+51/56] 
maj 11 00:04:59 <aflinta>	May 10 23:58:00 warp kernel: 
maj 11 00:05:01 <aflinta>	May 10 23:58:00 warp kernel: Code: 0f 0b 89 fa b9 ff ff ff ff b6 00 41 8b 44 24 20 d3 e0 3d ff 
diff -Nur linux-2.4.18-2.27/fs/hpfs/buffer.c linux-2.4.6/fs/hpfs/buffer.c
--- linux-2.4.18-2.27/fs/hpfs/buffer.c	Mon Feb 25 20:38:08 2002
+++ linux-2.4.6/fs/hpfs/buffer.c	Sat Dec  9 20:43:03 2000
@@ -122,9 +122,12 @@
 void *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,
 		 int ahead)
 {
+	kdev_t dev = s->s_dev;
 	struct buffer_head *bh;
 
-	*bhp = bh = sb_bread(s, secno);
+	if (!ahead || secno + ahead >= s->s_hpfs_fs_size)
+		*bhp = bh = bread(dev, secno, 512);
+	else *bhp = bh = bread(dev, secno, 512);
 	if (bh != NULL)
 		return bh->b_data;
 	else {
@@ -140,7 +143,7 @@
 	struct buffer_head *bh;
 	/*return hpfs_map_sector(s, secno, bhp, 0);*/
 
-	if ((*bhp = bh = sb_getblk(s, secno)) != NULL) {
+	if ((*bhp = bh = getblk(s->s_dev, secno, 512)) != NULL) {
 		if (!buffer_uptodate(bh)) wait_on_buffer(bh);
 		mark_buffer_uptodate(bh, 1);
 		return bh->b_data;
@@ -155,6 +158,7 @@
 void *hpfs_map_4sectors(struct super_block *s, unsigned secno, struct quad_buffer_head *qbh,
 		   int ahead)
 {
+	kdev_t dev = s->s_dev;
 	struct buffer_head *bh;
 	char *data;
 
@@ -169,22 +173,24 @@
 		goto bail;
 	}
 
-	qbh->bh[0] = bh = sb_bread(s, secno);
+	if (!ahead || secno + 4 + ahead > s->s_hpfs_fs_size)
+		qbh->bh[0] = bh = bread(dev, secno, 512);
+	else qbh->bh[0] = bh = bread(dev, secno, 512);
 	if (!bh)
 		goto bail0;
 	memcpy(data, bh->b_data, 512);
 
-	qbh->bh[1] = bh = sb_bread(s, secno + 1);
+	qbh->bh[1] = bh = bread(dev, secno + 1, 512);
 	if (!bh)
 		goto bail1;
 	memcpy(data + 512, bh->b_data, 512);
 
-	qbh->bh[2] = bh = sb_bread(s, secno + 2);
+	qbh->bh[2] = bh = bread(dev, secno + 2, 512);
 	if (!bh)
 		goto bail2;
 	memcpy(data + 2 * 512, bh->b_data, 512);
 
-	qbh->bh[3] = bh = sb_bread(s, secno + 3);
+	qbh->bh[3] = bh = bread(dev, secno + 3, 512);
 	if (!bh)
 		goto bail3;
 	memcpy(data + 3 * 512, bh->b_data, 512);
diff -Nur linux-2.4.18-2.27/fs/hpfs/file.c linux-2.4.6/fs/hpfs/file.c
--- linux-2.4.18-2.27/fs/hpfs/file.c	Mon Aug 13 02:37:53 2001
+++ linux-2.4.6/fs/hpfs/file.c	Fri Dec 29 23:07:57 2000
@@ -11,8 +11,6 @@
 #include <linux/smp_lock.h>
 #include "hpfs_fn.h"
 
-#define BLOCKS(size) (((size) + 511) >> 9)
-
 /* HUH? */
 int hpfs_open(struct inode *i, struct file *f)
 {
@@ -48,7 +46,7 @@
 	unsigned n, disk_secno;
 	struct fnode *fnode;
 	struct buffer_head *bh;
-	if (BLOCKS(inode->u.hpfs_i.mmu_private) <= file_secno) return 0;
+	if (((inode->i_size + 511) >> 9) <= file_secno) return 0;
 	n = file_secno - inode->i_hpfs_file_sec;
 	if (n < inode->i_hpfs_n_secs) return inode->i_hpfs_disk_sec + n;
 	if (!(fnode = hpfs_map_fnode(inode->i_sb, inode->i_ino, &bh))) return 0;
diff -Nur linux-2.4.18-2.27/fs/hpfs/inode.c linux-2.4.6/fs/hpfs/inode.c
--- linux-2.4.18-2.27/fs/hpfs/inode.c	Mon Sep 10 16:31:25 2001
+++ linux-2.4.6/fs/hpfs/inode.c	Mon Jan 22 19:40:47 2001
@@ -12,7 +12,6 @@
 
 static struct file_operations hpfs_file_ops =
 {
-	llseek:		generic_file_llseek,
 	read:		generic_file_read,
 	write:		hpfs_file_write,
 	mmap:		generic_file_mmap,
@@ -300,12 +299,10 @@
 {
 	struct inode *inode = dentry->d_inode;
 	int error;
-	if ((attr->ia_valid & ATTR_SIZE) && attr->ia_size > inode->i_size) 
-		return -EINVAL;
+	if ((attr->ia_valid & ATTR_SIZE) && attr->ia_size > inode->i_size) return -EINVAL;
 	if (inode->i_sb->s_hpfs_root == inode->i_ino) return -EINVAL;
 	if ((error = inode_change_ok(inode, attr))) return error;
-	error = inode_setattr(inode, attr);
-	if (error) return error;
+	inode_setattr(inode, attr);
 	hpfs_write_inode(inode);
 	return 0;
 }
diff -Nur linux-2.4.18-2.27/fs/hpfs/super.c linux-2.4.6/fs/hpfs/super.c
--- linux-2.4.18-2.27/fs/hpfs/super.c	Mon Feb 25 20:38:08 2002
+++ linux-2.4.6/fs/hpfs/super.c	Tue Jun 12 04:15:27 2001
@@ -3,7 +3,7 @@
  *
  *  Mikulas Patocka (mikulas@artax.karlin.mff.cuni.cz), 1998-1999
  *
- *  mounting, unmounting, error handling
+ *  mouning, unmounting, error handling
  */
 
 #include <linux/string.h>