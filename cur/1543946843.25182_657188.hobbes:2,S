Date: Wed, 20 Feb 2008 22:34:00 +0100
From: Dmitry Adamushko <>
Subject: [PATCH 0/2] kthread: synchronization issues
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/2/20/550

[ I've taken the liberty of CC'ing people who replied on my previous
message dedicated to this topic ]
Andrew,
could you please check whether this series makes any difference
on the 'permanent-pause-upon-power-off' issue you observed earlier?
You would also need to take along another fix (included below).
Although, I've sent it to you for -mm inclusion a few days ago.
And sure, remove that 'magic' msleep(1) thing in softlockup.c ::
cpu_callback() :-)
Thanks in advance.
[PATCH 1/2] kthread: add a missing memory barrier to kthread_stop()
[PATCH 2/2] kthread: call wake_up_process() whithout the lock being held
---
(this one is from Ingo's sched-devel tree)
softlockup: fix task state setting
kthread_stop() can be called when a 'watchdog' thread is executing after
kthread_should_stop() but before set_task_state(TASK_INTERRUPTIBLE).
Signed-off-by: Dmitry Adamushko <dmitry.adamushko@gmail.com>
Signed-off-by: Ingo Molnar <mingo@elte.hu>
---
diff --git a/kernel/softlockup.c b/kernel/softlockup.c
index 7c2da88..b0fdb49 100644
--- a/kernel/softlockup.c
+++ b/kernel/softlockup.c
@@ -216,26 +216,25 @@ static int watchdog(void *__bind_cpu)
 	/* initialize timestamp */
 	touch_softlockup_watchdog();
 
+	set_current_state(TASK_INTERRUPTIBLE);
 	/*
 	 * Run briefly once per second to reset the softlockup timestamp.
 	 * If this gets delayed for more than 60 seconds then the
 	 * debug-printout triggers in softlockup_tick().
 	 */
 	while (!kthread_should_stop()) {
-		set_current_state(TASK_INTERRUPTIBLE);
 		touch_softlockup_watchdog();
 		schedule();
 
 		if (kthread_should_stop())
 			break;
 
-		if (this_cpu != check_cpu)
-			continue;
-
-		if (sysctl_hung_task_timeout_secs)
+		if (this_cpu == check_cpu && sysctl_hung_task_timeout_secs)
 			check_hung_uninterruptible_tasks(this_cpu);
 
+		set_current_state(TASK_INTERRUPTIBLE);
 	}
+	__set_current_state(TASK_RUNNING);
 
 	return 0;
 }