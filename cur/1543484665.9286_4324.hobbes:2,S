Date: Fri, 05 Feb 1999 18:43:55 -0500
From: Tomasz Przygoda <>
Subject: Re: [patch] inode leakage again
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/2/6/25

Well, I was happy for few moments...
My machines silently die with this patch :(
The seems to be a rock-solid deadlock somewhere.
Is that inode leak fix in the 2.2.2-pre2 the same as the one I've got from
Andrea?
Andrea Arcangeli wrote:
> On Thu, 4 Feb 1999, Tomasz Przygoda wrote:
>
> > Hi,
> >
> > Andrea Arcangeli wrote:
> >
> > > On Wed, 3 Feb 1999, Tomasz Przygoda wrote:
> > > > /proc/sys/fs/inode-nr : 1268624 3
> > > > /proc/sys/fs/inode-state : 1268624 9 1 0 0 0 0
> > >
> > > Please send me your .config and show me the output of `mount`. What the
> > > system is used for? How can you reproduce? How can I reproduce here?
> >
> > Well, I'm able to get same sort of numbers with any of the 2.2.x; where x =
> > {0-pre7, 0, 1}.
>
> Just fixed, apply this patch against 2.2.1 and be happy:
>
> Index: inode.c
> ===================================================================
> RCS file: /var/cvs/linux/fs/inode.c,v
> retrieving revision 1.1.1.2
> diff -u -r1.1.1.2 inode.c
> --- inode.c     1999/01/26 18:30:24     1.1.1.2
> +++ inode.c     1999/02/04 15:35:46
> @@ -4,6 +4,10 @@
>   * (C) 1997 Linus Torvalds
>   */
>
> +/*
> + * Fixed inode leakage in 2.2.1. Copyright (C) 1999  Andrea Arcangeli
> + */
> +
>  #include <linux/fs.h>
>  #include <linux/string.h>
>  #include <linux/mm.h>
> @@ -62,9 +66,8 @@
>  struct {
>         int nr_inodes;
>         int nr_free_inodes;
> -       int preshrink;          /* pre-shrink dcache? */
> -       int dummy[4];
> -} inodes_stat = {0, 0, 0,};
> +       int dummy[5];
> +} inodes_stat = {0, 0, };
>
>  int max_inodes;
>
> @@ -329,12 +332,14 @@
>
>  static int free_inodes(int goal)
>  {
> -       struct list_head *tmp, *head = &inode_in_use;
> +       struct list_head * head = &inode_in_use, * tmp, * this = head->prev;
>         LIST_HEAD(freeable);
> -       int found = 0, depth = goal << 1;
> +       int found = 0;
>
> -       while ((tmp = head->prev) != head && depth--) {
> +       while ((tmp = this) != head)
> +       {
>                 struct inode * inode = list_entry(tmp, struct inode, i_list);
> +               this = this->prev;
>                 list_del(tmp);
>                 if (CAN_UNUSE(inode)) {
>                         list_del(&inode->i_hash);
> @@ -403,7 +408,7 @@
>         /*
>          * Check whether to restock the unused list.
>          */
> -       if (inodes_stat.preshrink) {
> +       if (inodes_stat.nr_inodes > max_inodes) {
>                 struct list_head *tmp;
>                 try_to_free_inodes(8);
>                 tmp = inode_unused.next;
> @@ -436,9 +441,6 @@
>                  */
>                 inodes_stat.nr_inodes += INODES_PER_PAGE;
>                 inodes_stat.nr_free_inodes += INODES_PER_PAGE - 1;
> -               inodes_stat.preshrink = 0;
> -               if (inodes_stat.nr_inodes > max_inodes)
> -                       inodes_stat.preshrink = 1;
>                 return inode;
>         }
>
> @@ -447,7 +449,6 @@
>          * the dcache and then try again to free some inodes.
>          */
>         prune_dcache(inodes_stat.nr_inodes >> 2);
> -       inodes_stat.preshrink = 1;
>
>         spin_lock(&inode_lock);
>         free_inodes(inodes_stat.nr_inodes >> 2);
>
> Andrea Arcangeli
-- Tomek,
"Office'97, Windows'98 - every Microsoft product has an expiration date."
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/