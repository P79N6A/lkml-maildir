Date: Mon, 9 Aug 1999 02:13:19 +0200 (CEST)
From: Andrea Arcangeli <>
Subject: [patch] ext2/inode.c fixes
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/8/10/2

In 2.3.13-pre8 mark_buffer_dirty can't sleep, but I think that it would be
nice to have the ext2 robust against a possible sleeps of
mark_buffer_dirty (since IMO it's not obvious that mark_buffer_dirty has
not to sleep). IMO mark_buffer_dirty is the natural place where to call
balance_dirty()... Anyway that's outside the scope of this email and I'll
address that leather.
This patch will make ext2:
o	robust against possible sleeps of mark_buffer_dirty()
o	will avoid silenty ignoring the allocation of the last block
	under us when BUG() will be #undef. If I understood well
	the reason nobody can race with the allocation of the real data
	block is that we are serialized by the per-page-lock (the buffer
	is always <= PAGE_SIZE).
o	will avoid ignoring somebody racing with us in the block_getblk
	path.
--- 2.3.13-pre8-tmp/fs/ext2/inode.c.~1~	Tue Jul 13 02:02:09 1999
+++ 2.3.13-pre8-tmp/fs/ext2/inode.c	Mon Aug  9 01:52:28 1999
@@ -259,20 +259,22 @@
 	}
 	if (metadata) {
 		result = getblk (inode->i_dev, tmp, blocksize);
+		memset(result->b_data, 0, blocksize);
+		mark_buffer_uptodate(result, 1);
+		mark_buffer_dirty(result, 1);
 		if (*p) {
 			ext2_free_blocks (inode, tmp, 1);
-			brelse (result);
+			bforget (result);
 			goto repeat;
 		}
-		memset(result->b_data, 0, blocksize);
-		mark_buffer_uptodate(result, 1);
-		mark_buffer_dirty(result, 1);
 	} else {
 		if (*p) {
 			/*
 			 * Nobody is allowed to change block allocation
 			 * state from under us:
 			 */
+			ext2_error (inode->i_sb, "block_getblk",
+				    "data block filled under us");
 			BUG();
 			ext2_free_blocks (inode, tmp, 1);
 			goto repeat;
@@ -366,22 +368,28 @@
 		goto out;
 	if (metadata) {
 		result = getblk (bh->b_dev, tmp, blocksize);
+		memset(result->b_data, 0, inode->i_sb->s_blocksize);
+		mark_buffer_uptodate(result, 1);
+		mark_buffer_dirty(result, 1);
 		if (*p) {
 			ext2_free_blocks (inode, tmp, 1);
-			brelse (result);
+			bforget (result);
 			goto repeat;
 		}
-		memset(result->b_data, 0, inode->i_sb->s_blocksize);
-		mark_buffer_uptodate(result, 1);
-		mark_buffer_dirty(result, 1);
 	} else {
+		if (*p) {
+			/*
+			 * Nobody is allowed to change block allocation
+			 * state from under us:
+			 */
+			ext2_error (inode->i_sb, "block_getblk",
+				    "data block filled under us");
+			BUG();
+			ext2_free_blocks (inode, tmp, 1);
+			goto repeat;
+		}
 		*phys = tmp;
 		*new = 1;
-	}
-	if (*p) {
-		ext2_free_blocks (inode, tmp, 1);
-		brelse (result);
-		goto repeat;
 	}
 	*p = le32_to_cpu(tmp);
 	mark_buffer_dirty(bh, 1);
Andrea
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/