Date: 11 Jul 2001 14:56:43 +0200
From: Trond Myklebust <>
Subject: Re: 2.4.7p6 hang
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2001/7/11/73

>>>>> " " == Klaus Dittrich <kladit@t-online.de> writes:
     > Kernel: 2.4.7p5 or 2.4.7p6 System: PII-SMP, BX-Chipset
     > The kernel boots up to the message
     > ..  Linux NET4.0 for Linux 2.4 Based upon Swansea University
     > Computer Society NET3.039
     > and then stops.
     > I actually use 2.4.7p3 without problems.
I have the same problem on my setup. To me, it looks like the loop in
spawn_ksoftirqd() is suffering from some sort of atomicity problem.
I managed to band-aid over the problem by replacing the loop with a
semaphore which the child clears when it has been initialized (as per
the appended patch).
Linus?
Cheers,
  Trond
--- linux-2.4.7-smp/kernel/softirq.c.orig	Wed Jul 11 10:31:50 2001
+++ linux-2.4.7-smp/kernel/softirq.c	Wed Jul 11 14:43:03 2001
@@ -371,6 +371,8 @@
 	}
 }
 
+static DECLARE_MUTEX_LOCKED(ksoftirqd_start);
+
 static int ksoftirqd(void * __bind_cpu)
 {
 	int bind_cpu = *(int *) __bind_cpu;
@@ -391,6 +393,7 @@
 	mb();
 
 	ksoftirqd_task(cpu) = current;
+	up(&ksoftirqd_start);
 
 	for (;;) {
 		if (!softirq_pending(cpu))
@@ -416,12 +419,8 @@
 		if (kernel_thread(ksoftirqd, (void *) &cpu,
 				  CLONE_FS | CLONE_FILES | CLONE_SIGNAL) < 0)
 			printk("spawn_ksoftirqd() failed for cpu %d\n", cpu);
-		else {
-			while (!ksoftirqd_task(cpu_logical_map(cpu))) {
-				current->policy |= SCHED_YIELD;
-				schedule();
-			}
-		}
+		else
+			down(&ksoftirqd_start);
 	}
 
 	return 0;
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/