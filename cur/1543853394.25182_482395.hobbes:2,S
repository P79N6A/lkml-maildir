Date: Tue, 14 Nov 2006 16:47:37 -0800
From: Andrew Morton <>
Subject: Re: [RFC 0/4] Cpu-Hotplug: Use per subsystem hot-cpu mutexes.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/11/14/322

On Tue, 14 Nov 2006 17:48:32 +0530
Gautham R Shenoy <ego@in.ibm.com> wrote:
> Since 2.6.18-something, the community has been bugged by the problem to
> provide a clean and a stable mechanism to postpone a cpu-hotplug event
> as lock_cpu_hotplug was badly broken.
> 
> This is another proposal towards solving that problem. This one is 
> along the lines of the solution provided in kernel/workqueue.c
The approach seems sane to me.  Sort-of direct, specific and transactional..
I applied this fixup:
diff -puN kernel/cpu.c~define-and-use-new-eventscpu_lock_acquire-and-cpu_lock_release-fix kernel/cpu.c
--- a/kernel/cpu.c~define-and-use-new-eventscpu_lock_acquire-and-cpu_lock_release-fix
+++ a/kernel/cpu.c
@@ -139,7 +139,8 @@ static int _cpu_down(unsigned int cpu)
 	if (err == NOTIFY_BAD) {
 		printk("%s: attempt to take down CPU %u failed\n",
 				__FUNCTION__, cpu);
-		return -EINVAL;
+		err = -EINVAL;
+		goto out_release;
 	}
 
 	/* Ensure that we are not runnable on dying cpu */
@@ -187,6 +188,7 @@ out_thread:
 	err = kthread_stop(p);
 out_allowed:
 	set_cpus_allowed(current, old_allowed);
+out_release:
 	raw_notifier_call_chain(&cpu_chain, CPU_LOCK_RELEASE,
 						(void *)(long)cpu);
 	return err;
_
please send a patch to fix up the kerneldoc things which Randy spotted,
thanks.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/