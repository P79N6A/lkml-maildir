Date: Sat, 19 Jun 1999 00:35:13 -0700 (PDT)
From: "B. James Phillippe" <>
Subject: Re: waitpid advice ? (killing off a kernel thread)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/6/19/12

On Sat, 19 Jun 1999, David Waite wrote:
> The problem is that the drivers have threads running that are not dying
> before I start deallocating resources.
...
> Anyways, my question is.. obviously my method of killing and then waiting
> for the process to die is not working right. What can I do instead? Wait
I had a similar problem with a modular kernel-thread project that I'm
working on.  I solved it by using a semaphore to coordinate the module
unloading and thread cleanup.  Something like this:
static struct semaphore thread_sema = MUTEX_LOCKED;
static int thread_func(void *unused)
{
	...
	/* wake cleanup_module */
	up(&thread_sema);
}
void cleanup_module(void)
{
	send_sig(SIGTERM, thread_task, 1);
	/* wait for thread_func */
	down(&thread_sema);
}
I don't know if this is SMP-safe, though..
-bp
--
# bryan at terran dot org
# 
http://www.terran.org/~bryan
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/