Date: Fri, 21 Sep 2007 22:57:04 +0200
From: Muli Ben-Yehuda <>
Subject: [PATCH 1/2] x86-64: Calgary - fix calgary=disable=<busnum> for CalIOC2
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/9/21/411

The old check we used based on dev->bus->number is wrong for devices
on CalIOC2. Instead look whether we have an IOMMU table for that bus -
if not, translation is disabled.
Thanks to Murillo Fernandes Bernardes <bernarde@br.ibm.com> for
spotting, suggesting a fix and testing.
Signed-off-by: Muli Ben-Yehuda <muli@il.ibm.com>
Acked-by: Murillo Fernandes Bernardes <bernarde@br.ibm.com>
---
Andi, This is Calgary 2.6.24 material - please apply.
 pci-calgary.c |   16 +++++++++++-----
 1 files changed, 11 insertions(+), 5 deletions(-)
diff -r ca20f7bdb869 -r c9308d0538d9 arch/x86_64/kernel/pci-calgary.c
--- a/arch/x86_64/kernel/pci-calgary.c	Sun Aug 12 11:38:08 2007 +0300
+++ b/arch/x86_64/kernel/pci-calgary.c	Sun Aug 12 11:43:49 2007 +0300
@@ -220,6 +220,12 @@ static inline unsigned int num_dma_pages
 	return npages;
 }
 
+static inline int translation_enabled(struct iommu_table *tbl)
+{
+	/* only PHBs with translation enabled have an IOMMU table */
+	return (tbl != NULL);
+}
+
 static inline int translate_phb(struct pci_dev* dev)
 {
 	int disabled = bus_info[dev->bus->number].translation_disabled;
@@ -384,7 +390,7 @@ static void calgary_unmap_sg(struct devi
 {
 	struct iommu_table *tbl = find_iommu_table(dev);
 
-	if (!translate_phb(to_pci_dev(dev)))
+	if (!translation_enabled(tbl))
 		return;
 
 	while (nelems--) {
@@ -424,7 +430,7 @@ static int calgary_map_sg(struct device 
 	unsigned long entry;
 	int i;
 
-	if (!translate_phb(to_pci_dev(dev)))
+	if (!translation_enabled(tbl))
 		return calgary_nontranslate_map_sg(dev, sg, nelems, direction);
 
 	for (i = 0; i < nelems; i++ ) {
@@ -471,7 +477,7 @@ static dma_addr_t calgary_map_single(str
 	uaddr = (unsigned long)vaddr;
 	npages = num_dma_pages(uaddr, size);
 
-	if (translate_phb(to_pci_dev(dev)))
+	if (translation_enabled(tbl))
 		dma_handle = iommu_alloc(tbl, vaddr, npages, direction);
 	else
 		dma_handle = virt_to_bus(vaddr);
@@ -485,7 +491,7 @@ static void calgary_unmap_single(struct 
 	struct iommu_table *tbl = find_iommu_table(dev);
 	unsigned int npages;
 
-	if (!translate_phb(to_pci_dev(dev)))
+	if (!translation_enabled(tbl))
 		return;
 
 	npages = num_dma_pages(dma_handle, size);
@@ -510,7 +516,7 @@ static void* calgary_alloc_coherent(stru
 		goto error;
 	memset(ret, 0, size);
 
-	if (translate_phb(to_pci_dev(dev))) {
+	if (translation_enabled(tbl)) {
 		/* set up tces to cover the allocated range */
 		mapping = iommu_alloc(tbl, ret, npages, DMA_BIDIRECTIONAL);
 		if (mapping == bad_dma_address)
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/