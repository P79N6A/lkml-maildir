Date: Sun, 14 Dec 2008 22:59:51 +0100
From: Jiri Slaby <>
Subject: broken do_each_pid_{thread,task}
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/12/14/139

Hi,
I'm getting
`if (type == PIDTYPE_PID)' is unreachable
warning from kernel/exit.c. The preprocessed code looks like:
do {
         struct hlist_node *pos___;
         if (pgrp != ((void *)0))
                 for (LIST ITERATION) {
                         {
                          if (!((p->state & 4) != 0))
                           continue;
                          retval = 1;
                          break;
                         }
                         if (PIDTYPE_PGID == PIDTYPE_PID)
                                 break;
                 }
} while (0);
and it's obviously wrong.
After investigating this code usage all around, it's broken on many places
this or similar way.
For do_each_pid_thread(), even this code snippet from fs/ioprio.c is broken
due to double do {} while expansion:
do_each_pid_thread(pgrp, PIDTYPE_PGID, p) {
  ret = set_task_ioprio(p, ioprio);
  if (ret)
    break;
} while_each_pid_thread(pgrp, PIDTYPE_PGID, p);
Any idea how to get rid of this issue?