Date: 27 May 1999 12:27:10 +0200
From: Trond Myklebust <>
Subject: Re: Kernel 2.2.2 and NFS
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/5/29/3

Does stock Linux-2.2.9 show the same problems against the AIX server?
If not, you could perhaps just grab the linux/fs/{nfs,lockd} and
linux/net/sunrpc directories from linux 2.2.9?  You'll also want to
copy over linux/include/linux/nfs*.h and
linux/include/linux/{lockd,sunrpc}, and you'll need the following
patch to sew it all together.
It's an ugly 'solution' to your problem, but it might work.
Cheers,
  Trond
diff -u --recursive --new-file linux-2.2.8-pre4/fs/autofs/root.c linux-2.2.8-pre4-patched/fs/autofs/root.c
--- linux-2.2.8-pre4/fs/autofs/root.c	Sat Apr 24 06:20:37 1999
+++ linux-2.2.8-pre4-patched/fs/autofs/root.c	Sat May  8 21:34:56 1999
@@ -168,7 +168,7 @@
  * yet completely filled in, and revalidate has to delay such
  * lookups..
  */
-static int autofs_revalidate(struct dentry * dentry)
+static int autofs_revalidate(struct dentry * dentry, int flags)
 {
 	struct inode * dir = dentry->d_parent->d_inode;
 	struct autofs_sb_info *sbi = autofs_sbi(dir->i_sb);
@@ -241,7 +241,7 @@
 	d_add(dentry, NULL);
 
 	up(&dir->i_sem);
-	autofs_revalidate(dentry);
+	autofs_revalidate(dentry, 0);
 	down(&dir->i_sem);
 
 	/*
diff -u --recursive --new-file linux-2.2.8-pre4/fs/coda/dir.c linux-2.2.8-pre4-patched/fs/coda/dir.c
--- linux-2.2.8-pre4/fs/coda/dir.c	Sat Apr 24 06:20:37 1999
+++ linux-2.2.8-pre4-patched/fs/coda/dir.c	Sat May  8 21:42:13 1999
@@ -44,7 +44,7 @@
 static int coda_readdir(struct file *file, void *dirent, filldir_t filldir);
 
 /* dentry ops */
-static int coda_dentry_revalidate(struct dentry *de);
+static int coda_dentry_revalidate(struct dentry *de, int);
 static void coda_dentry_delete(struct dentry *);
 
 /* support routines */
@@ -778,7 +778,7 @@
 }
 
 /* called when a cache lookup succeeds */
-static int coda_dentry_revalidate(struct dentry *de)
+static int coda_dentry_revalidate(struct dentry *de, int flags)
 {
 	int valid = 1;
 	struct inode *inode = de->d_inode;
diff -u --recursive --new-file linux-2.2.8-pre4/fs/devpts/root.c linux-2.2.8-pre4-patched/fs/devpts/root.c
--- linux-2.2.8-pre4/fs/devpts/root.c	Sat Apr 24 06:20:37 1999
+++ linux-2.2.8-pre4-patched/fs/devpts/root.c	Sat May  8 21:36:05 1999
@@ -18,7 +18,7 @@
 
 static int devpts_root_readdir(struct file *,void *,filldir_t);
 static struct dentry *devpts_root_lookup(struct inode *,struct dentry *);
-static int devpts_revalidate(struct dentry *);
+static int devpts_revalidate(struct dentry *, int);
 
 static struct file_operations devpts_root_operations = {
 	NULL,                   /* llseek */
@@ -116,7 +116,7 @@
  * the pty really does still exist.  Never revalidate negative dentries;
  * for simplicity (fix later?)
  */
-static int devpts_revalidate(struct dentry * dentry)
+static int devpts_revalidate(struct dentry * dentry, int flags)
 {
 	struct devpts_sb_info *sbi;
 
diff -u --recursive --new-file linux-2.2.8-pre4/fs/hfs/sysdep.c linux-2.2.8-pre4-patched/fs/hfs/sysdep.c
--- linux-2.2.8-pre4/fs/hfs/sysdep.c	Wed Dec 23 23:10:36 1998
+++ linux-2.2.8-pre4-patched/fs/hfs/sysdep.c	Sat May  8 21:37:12 1999
@@ -18,7 +18,7 @@
 #include <linux/hfs_fs_i.h>
 #include <linux/hfs_fs.h>
 
-static int hfs_revalidate_dentry(struct dentry *);
+static int hfs_revalidate_dentry(struct dentry *, int);
 static int hfs_hash_dentry(struct dentry *, struct qstr *);
 static int hfs_compare_dentry(struct dentry *, struct qstr *, struct qstr *);
 static void hfs_dentry_iput(struct dentry *, struct inode *);
@@ -89,7 +89,7 @@
 	iput(inode);
 }
 
-static int hfs_revalidate_dentry(struct dentry *dentry)
+static int hfs_revalidate_dentry(struct dentry *dentry, int flags)
 {
 	struct inode *inode = dentry->d_inode;
 	int diff;
diff -u --recursive --new-file linux-2.2.8-pre4/fs/namei.c linux-2.2.8-pre4-patched/fs/namei.c
--- linux-2.2.8-pre4/fs/namei.c	Sat Apr 24 06:20:38 1999
+++ linux-2.2.8-pre4-patched/fs/namei.c	Sat May  8 21:32:17 1999
@@ -225,12 +225,12 @@
 /*
  * Internal lookup() using the new generic dcache.
  */
-static struct dentry * cached_lookup(struct dentry * parent, struct qstr * name)
+static struct dentry * cached_lookup(struct dentry * parent, struct qstr * name, int flags)
 {
 	struct dentry * dentry = d_lookup(parent, name);
 
 	if (dentry && dentry->d_op && dentry->d_op->d_revalidate) {
-		if (!dentry->d_op->d_revalidate(dentry) && !d_invalidate(dentry)) {
+		if (!dentry->d_op->d_revalidate(dentry, flags) && !d_invalidate(dentry)) {
 			dput(dentry);
 			dentry = NULL;
 		}
@@ -245,7 +245,7 @@
  * We get the directory semaphore, and after getting that we also
  * make sure that nobody added the entry to the dcache in the meantime..
  */
-static struct dentry * real_lookup(struct dentry * parent, struct qstr * name)
+static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, int flags)
 {
 	struct dentry * result;
 	struct inode *dir = parent->d_inode;
@@ -258,7 +258,7 @@
 	 * FIXME! This could use version numbering or similar to
 	 * avoid unnecessary cache lookups.
 	 */
-	result = cached_lookup(parent, name);
+	result = cached_lookup(parent, name, flags);
 	if (!result) {
 		struct dentry * dentry = d_alloc(parent, name);
 		result = ERR_PTR(-ENOMEM);
@@ -392,9 +392,9 @@
 		/* This does the actual lookups.. */
 		dentry = reserved_lookup(base, &this);
 		if (!dentry) {
-			dentry = cached_lookup(base, &this);
+			dentry = cached_lookup(base, &this, flags);
 			if (!dentry) {
-				dentry = real_lookup(base, &this);
+				dentry = real_lookup(base, &this, flags);
 				if (IS_ERR(dentry))
 					break;
 			}
diff -u --recursive --new-file linux-2.2.8-pre4/fs/ncpfs/dir.c linux-2.2.8-pre4-patched/fs/ncpfs/dir.c
--- linux-2.2.8-pre4/fs/ncpfs/dir.c	Mon Apr 26 18:26:55 1999
+++ linux-2.2.8-pre4-patched/fs/ncpfs/dir.c	Sat May  8 21:50:05 1999
@@ -112,14 +112,14 @@
 /*
  * Dentry operations routines
  */
-static int ncp_lookup_validate(struct dentry *);
+static int ncp_lookup_validate(struct dentry *, int);
 static int ncp_hash_dentry(struct dentry *, struct qstr *);
 static int ncp_compare_dentry (struct dentry *, struct qstr *, struct qstr *);
 static void ncp_delete_dentry(struct dentry *);
 
 struct dentry_operations ncp_dentry_operations =
 {
-	ncp_lookup_validate,	/* d_validate(struct dentry *) */
+	ncp_lookup_validate,	/* d_revalidate(struct dentry *, int) */
 	ncp_hash_dentry,	/* d_hash */
 	ncp_compare_dentry,    	/* d_compare */
 	ncp_delete_dentry	/* d_delete(struct dentry *) */
@@ -345,7 +345,7 @@
 
 
 static int
-ncp_lookup_validate(struct dentry * dentry)
+ncp_lookup_validate(struct dentry * dentry, int flags)
 {
 	struct ncp_server *server;
 	struct inode *dir = dentry->d_parent->d_inode;
diff -u --recursive --new-file linux-2.2.8-pre4/fs/smbfs/dir.c linux-2.2.8-pre4-patched/fs/smbfs/dir.c
--- linux-2.2.8-pre4/fs/smbfs/dir.c	Sat Apr 24 06:20:38 1999
+++ linux-2.2.8-pre4-patched/fs/smbfs/dir.c	Sat May  8 21:44:25 1999
@@ -191,14 +191,14 @@
 /*
  * Dentry operations routines
  */
-static int smb_lookup_validate(struct dentry *);
+static int smb_lookup_validate(struct dentry *, int);
 static int smb_hash_dentry(struct dentry *, struct qstr *);
 static int smb_compare_dentry(struct dentry *, struct qstr *, struct qstr *);
 static void smb_delete_dentry(struct dentry *);
 
 static struct dentry_operations smbfs_dentry_operations =
 {
-	smb_lookup_validate,	/* d_validate(struct dentry *) */
+	smb_lookup_validate,	/* d_revalidate(struct dentry *) */
 	smb_hash_dentry,	/* d_hash */
 	smb_compare_dentry,	/* d_compare */
 	smb_delete_dentry	/* d_delete(struct dentry *) */
@@ -208,7 +208,7 @@
  * This is the callback when the dcache has a lookup hit.
  */
 static int
-smb_lookup_validate(struct dentry * dentry)
+smb_lookup_validate(struct dentry * dentry, int flags)
 {
 	struct inode * inode = dentry->d_inode;
 	unsigned long age = jiffies - dentry->d_time;
diff -u --recursive --new-file linux-2.2.8-pre4/fs/umsdos/dir.c linux-2.2.8-pre4-patched/fs/umsdos/dir.c
--- linux-2.2.8-pre4/fs/umsdos/dir.c	Sat Apr 24 06:20:38 1999
+++ linux-2.2.8-pre4-patched/fs/umsdos/dir.c	Sat May  8 21:47:55 1999
@@ -30,7 +30,7 @@
  */
 
 /* nothing for now ... */
-static int umsdos_dentry_validate(struct dentry *dentry)
+static int umsdos_dentry_validate(struct dentry *dentry, int flags)
 {
 	return 1;
 }
@@ -46,7 +46,7 @@
 
 struct dentry_operations umsdos_dentry_operations =
 {
-	umsdos_dentry_validate,	/* d_validate(struct dentry *) */
+	umsdos_dentry_validate,	/* d_revalidate(struct dentry *, int) */
 	NULL,			/* d_hash */
 	NULL,			/* d_compare */
 	umsdos_dentry_dput,	/* d_delete(struct dentry *) */
diff -u --recursive --new-file linux-2.2.8-pre4/fs/vfat/namei.c linux-2.2.8-pre4-patched/fs/vfat/namei.c
--- linux-2.2.8-pre4/fs/vfat/namei.c	Sat Apr 24 06:20:38 1999
+++ linux-2.2.8-pre4-patched/fs/vfat/namei.c	Sat May  8 21:45:42 1999
@@ -71,7 +71,7 @@
 static int vfat_hash(struct dentry *parent, struct qstr *qstr);
 static int vfat_cmpi(struct dentry *dentry, struct qstr *a, struct qstr *b);
 static int vfat_cmp(struct dentry *dentry, struct qstr *a, struct qstr *b);
-static int vfat_revalidate(struct dentry *dentry);
+static int vfat_revalidate(struct dentry *dentry, int);
 
 static struct dentry_operations vfat_dentry_ops[4] = {
 	{
@@ -106,7 +106,7 @@
 	MOD_DEC_USE_COUNT;
 }
 
-static int vfat_revalidate(struct dentry *dentry)
+static int vfat_revalidate(struct dentry *dentry, int flags)
 {
 	PRINTK1(("vfat_revalidate: %s\n", dentry->d_name.name));
 	if (dentry->d_time == dentry->d_parent->d_inode->i_version) {
diff -u --recursive --new-file linux-2.2.8-pre4/include/linux/dcache.h linux-2.2.8-pre4-patched/include/linux/dcache.h
--- linux-2.2.8-pre4/include/linux/dcache.h	Fri Mar 19 17:08:57 1999
+++ linux-2.2.8-pre4-patched/include/linux/dcache.h	Sat May  8 21:30:04 1999
@@ -77,7 +77,7 @@
 };
 
 struct dentry_operations {
-	int (*d_revalidate)(struct dentry *);
+	int (*d_revalidate)(struct dentry *, int);
 	int (*d_hash) (struct dentry *, struct qstr *);
 	int (*d_compare) (struct dentry *, struct qstr *, struct qstr *);
 	void (*d_delete)(struct dentry *);
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/