Date: Mon, 4 Dec 2006 14:08:26 +0300
From: Evgeniy Polyakov <>
Subject: Re: [PATCH  v2 04/13] Connection Manager
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/12/4/58

On Sat, Dec 02, 2006 at 04:49:58PM -0600, Steve Wise (swise@opengridcomputing.com) wrote:
> +static int send_halfclose(struct iwch_ep *ep, gfp_t gfp)
> +{
> +	struct cpl_close_con_req *req;
> +	struct sk_buff *skb;
> +
> +	PDBG("%s ep %p\n", __FUNCTION__, ep);
> +	skb = get_skb(NULL, sizeof(*req), gfp);
> +	if (!skb) {
> +		printk(KERN_ERR MOD "%s - failed to alloc skb\n", __FUNCTION__);
> +		return -ENOMEM;
> +	}
> +	skb->priority = CPL_PRIORITY_DATA;
> +	set_arp_failure_handler(skb, arp_failure_discard);
> +	req = (struct cpl_close_con_req *) skb_put(skb, sizeof(*req));
> +	req->wr.wr_hi = htonl(V_WR_OP(FW_WROPCODE_OFLD_CLOSE_CON));
> +	req->wr.wr_lo = htonl(V_WR_TID(ep->hwtid));
> +	OPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_CLOSE_CON_REQ, ep->hwtid));
> +	l2t_send(ep->com.tdev, skb, ep->l2t);
> +	return 0;
> +}
> +
> +static int send_abort(struct iwch_ep *ep, struct sk_buff *skb, gfp_t gfp)
> +{
> +	struct cpl_abort_req *req;
> +
> +	PDBG("%s ep %p\n", __FUNCTION__, ep);
> +	skb = get_skb(skb, sizeof(*req), gfp);
> +	if (!skb) {
> +		printk(KERN_ERR MOD "%s - failed to alloc skb.\n",
> +		       __FUNCTION__);
> +		return -ENOMEM;
> +	}
> +	skb->priority = CPL_PRIORITY_DATA;
> +	set_arp_failure_handler(skb, abort_arp_failure);
> +	req = (struct cpl_abort_req *) skb_put(skb, sizeof(*req));
> +	req->wr.wr_hi = htonl(V_WR_OP(FW_WROPCODE_OFLD_HOST_ABORT_CON_REQ));
> +	req->wr.wr_lo = htonl(V_WR_TID(ep->hwtid));
> +	OPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_ABORT_REQ, ep->hwtid));
> +	req->cmd = CPL_ABORT_SEND_RST;
> +	l2t_send(ep->com.tdev, skb, ep->l2t);
> +	return 0;
> +}
> +
> +static int send_connect(struct iwch_ep *ep)
> +{
> +	struct cpl_act_open_req *req;
> +	struct sk_buff *skb;
> +	u32 opt0h, opt0l, opt2;
> +	unsigned int mtu_idx;
> +	int wscale;
> +
> +	PDBG("%s ep %p\n", __FUNCTION__, ep);
> +
> +	skb = get_skb(NULL, sizeof(*req), GFP_KERNEL);
> +	if (!skb) {
> +		printk(KERN_ERR MOD "%s - failed to alloc skb.\n",
> +		       __FUNCTION__);
> +		return -ENOMEM;
> +	}
> +	mtu_idx = find_best_mtu(T3C_DATA(ep->com.tdev), dst_mtu(ep->dst));
> +	wscale = compute_wscale(rcv_win);
> +	opt0h = V_NAGLE(0) |
> +	    V_NO_CONG(nocong) |
> +	    V_KEEP_ALIVE(1) |
> +	    F_TCAM_BYPASS |
> +	    V_WND_SCALE(wscale) |
> +	    V_MSS_IDX(mtu_idx) |
> +	    V_L2T_IDX(ep->l2t->idx) | V_TX_CHANNEL(ep->l2t->smt_idx);
> +	opt0l = V_TOS((ep->tos >> 2) & M_TOS) | V_RCV_BUFSIZ(rcv_win>>10);
> +	opt2 = V_FLAVORS_VALID(0) | V_CONG_CONTROL_FLAVOR(0);
> +	skb->priority = CPL_PRIORITY_SETUP;
> +	set_arp_failure_handler(skb, act_open_req_arp_failure);
> +
> +	req = (struct cpl_act_open_req *) skb_put(skb, sizeof(*req));
> +	req->wr.wr_hi = htonl(V_WR_OP(FW_WROPCODE_FORWARD));
> +	OPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_ACT_OPEN_REQ, ep->atid));
> +	req->local_port = ep->com.local_addr.sin_port;
> +	req->peer_port = ep->com.remote_addr.sin_port;
> +	req->local_ip = ep->com.local_addr.sin_addr.s_addr;
> +	req->peer_ip = ep->com.remote_addr.sin_addr.s_addr;
> +	req->opt0h = htonl(opt0h);
> +	req->opt0l = htonl(opt0l);
> +	req->params = 0;
> +	req->opt2 = htonl(opt2);
> +	l2t_send(ep->com.tdev, skb, ep->l2t);
> +	return 0;
> +}
...
> +static int act_establish(struct t3cdev *tdev, struct sk_buff *skb, void *ctx)
> +{
> +	struct iwch_ep *ep = ctx;
> +	struct cpl_act_establish *req = cplhdr(skb);
> +	unsigned int tid = GET_TID(req);
> +
> +	PDBG("%s ep %p tid %d\n", __FUNCTION__, ep, tid);
> +
> +	dst_confirm(ep->dst);
> +
> +	/* setup the hwtid for this connection */
> +	ep->hwtid = tid;
> +	cxgb3_insert_tid(ep->com.tdev, &t3c_client, ep, tid);
> +
> +	ep->snd_seq = ntohl(req->snd_isn);
> +
> +	set_emss(ep, ntohs(req->tcp_opt));
> +
> +	/* dealloc the atid */
> +	cxgb3_free_atid(ep->com.tdev, ep->atid);
> +
> +	/* start MPA negotiation */
> +	send_mpa_req(ep, skb);
> +
> +	return 0;
> +}
> +
> +static void abort_connection(struct iwch_ep *ep, struct sk_buff *skb)
> +{
> +	PDBG("%s ep %p\n", __FILE__, ep);
> +	state_set(&ep->com, ABORTING);
> +	send_abort(ep, skb, GFP_KERNEL);
> +}
Could you convince network core developers that it is not own TCP
implementation which will mess with existing one?
This and a lot of other changes in this driver definitely says you
implement your own stack of protocols on top of infiniband hardware.
-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/