Date: Mon, 16 Aug 1999 10:48:21 -0300 (EST)
From: Raul Dias <>
Subject: Re: Problems writting a CHAR Driver with interruptible_sleep (wait_ queu e)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/8/16/143

On 14 Aug, Benjamin LaHaise wrote:
> struct wait_queue *my_wait_queue = NULL;
> 
> foo_irq()
> {
> 	wake_up_interruptible(&my_wait_queue);
> }
> 
> foo_read()
> {
> 	struct wait_queue wait = { current, NULL };
> 
> 	current->state = TASK_INTERRUPTIBLE;
> 	add_wait_queue(&my_wait_queue, &wait);
> 
> 	/* now start the hardware.  if the interrupt comes in before we
> 	 * enter schedule, the task is set back to TASK_RUNNING and the
> 	 * schedule becomes a no-op
> 	 */
> 	...
> 
> 	schedule();
> 	if (signal_pending(current))
> 		ret = -ERESTARTSYS;
> 
> 	...cleanup
> 
> 	remove_wait_queue(&my_wait_queue, &wait);
> 	return ret;
> }
hi,
This implementation worked for a while until I discover a Hardware
problem.
Sometimes the hardware fails to generate the interrupt.
So I changed:
schedule();    to   schedule_timeout(1);
But 1 jiffie (0.1 secs) is too long!
Is there a way to specify a timeout value of 100 microseconds?
This is the last one:
Can I count the time with a higher precision than with jiffies?
I need to keep track of the time on every read, but a jiffie is too
slow.
Best Regards,
Raul Dias
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/