Date: Wed, 29 Dec 1999 13:15:14 -0500
From: Jeff Dike <>
Subject: [PATCH] put_dirty_page doesn't dirty page
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/12/29/51

This seems to me to be a definite bug.  If so, the patch is this:
--- orig/mm/memory.c    Tue Dec 21 11:49:29 1999
+++ um/mm/memory.c      Sun Dec 26 12:08:26 1999
@@ -743,7 +743,7 @@
                return 0;
        }
        flush_page_to_ram(page);
-       set_pte(pte, pte_mkwrite(mk_pte(page, PAGE_COPY)));
+       set_pte(pte, pte_mkdirty(pte_mkwrite(mk_pte(page, PAGE_COPY))));
 /* no need for flush_tlb */
        return page;
 }
If it's not, then I'd appreciate some advice.  The scenario I'm seeing is this:
a process execs, the top of its stack is initialized by put_dirty_page, but 
left clean
later, it runs short of memory, sees this clean page at the top of the stack,
and frees it (it doesn't need to be written to swap because it's clean and 
anyway, I didn't configure any swap).
when the process returns back to that page, it faults, gets a brand-new 
zero-filled page, which is not what it wants.
it then dies a horrible death.
This is with the user-mode port.  I'm perfectly willing to believe that I'm 
doing something wrong, but I don't see it.  If someone can clue me in as to 
what is supposed to prevent the scenario above from happening, I'd appreciate 
it.
				Jeff
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/