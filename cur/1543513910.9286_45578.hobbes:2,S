Date: Sun, 24 Oct 1999 10:35:50 +1000
From: Keith Owens <>
Subject: Re: how much stack space can I use
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/10/23/134

On Sat, 23 Oct 1999 17:36:12 +0200, 
Manfred Spraul <manfreds@colorfullife.com> wrote:
>How much stack space can I use without causing a stack overflow? None of
>these functions are recursive, and they don't call any subfunctions
>which need more than a few bytes stack space.
Anybody looking at stack usage might find this script useful, it can
also be found in 
ftp://ftp.ocs.com.au/pub/kernel.stack.gz.
  It taks a
while to run, mainly because objdump --disassemble of everything takes
a while.  Some interesting results from 2.2.23 :-
7c4 ncr53c8xx_detect
824 dvd_read_disckey
824 dvd_read_manufact
914 mmc_ioctl
mmc_ioctl is worrying.  That code contains a switch statement with
allocations on individual case statements.  gcc version egcs-2.91.66
19990314/Linux (egcs-1.1.2 release) has consolidated all the
allocations into a single large allocation at the start of the routine.
#!/bin/bash
#
#	Run a compiled ix86 kernel and print large local stack usage.
#
#	Before running this script, cd /usr/src/linux or wherever you keep
#	your compiled kernel and modules.
#
#	/>:/{s/[<>:]*//g; h; }   On lines that contain '>:' (headings like
#	c0100000 <_stext>:), remove <, > and : and hold the line.  Identifies
#	the procedure and its start address.
#
#	/subl.*$0x[^,][^,][^,].*,%esp/{    Select lines containing
#	subl...0x...,%esp but only if there are at least 3 digits between 0x and
#	,%esp.  These are local stacks of at least 0x100 bytes.
#
#	s/.*$0x\([^,]*\).*/\1/;   Extract just the stack adjustment
#	/^[89a-f].......$/d;   Ignore lines with 8 digit offsets that are 
#	negative.  Some compilers adjust the stack on exit, seems to be related
#	to goto statements
#	G;   Append the held line (procedure and start address).
#	s/\(.*\)\n.* \(.*\)/\1 \2/;  Remove the newline and procedure start 
#	address.  Leaves just stack size and procedure name.
#	p; };   Print stack size and procedure name.
#
#	/subl.*%.*,%esp/{   Selects adjustment of %esp by register, dynamic 
#	arrays on stack.
#	G;   Append the held line (procedure and start address).
#	s/\(.*\)\n\(.*\)/Dynamic \2 \1/;   Reformat to "Dynamic", procedure 
#	start address, procedure name and the instruction that adjusts the
#	stack, including its offset within the proc.
#	p; };   Print the dynamic line.
#
#
#	Leading spaces in the sed string are required.
#
objdump --disassemble vmlinux modules/*.o | \
sed -ne '/>:/{s/[<>:]*//g; h; };
 /subl.*$0x[^,][^,][^,].*,%esp/{
 s/.*$0x\([^,]*\).*/\1/; /^[89a-f].......$/d; G; s/\(.*\)\n.* \(.*\)/\1 \2/; p; };
 /subl.*%.*,%esp/{ G; s/\(.*\)\n\(.*\)/Dynamic \2 \1/; p; }; ' | \
sort
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/