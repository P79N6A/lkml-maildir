Date: 22 Oct 2002 21:59:17 -0700
From: Kristis Makris <>
Subject: [PATCH] niceness magic numbers, 2.4.20-pre11
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2002/10/23/4

This untested patch removes use of process priority magic numbers in
sys_nice, sys_setpriority, sys_getpriority, and properly uses their
#define'd values.
It would be nice if someone tested if it applies against 2.5.
diff -ur linux-2.4.20-pre11.orig/include/linux/resource.h linux/include/linux/resource.h
--- linux-2.4.20-pre11.orig/include/linux/resource.h	Tue Jun 18 20:10:36 2002
+++ linux/include/linux/resource.h	Sat Oct 19 13:55:10 2002
@@ -43,7 +43,7 @@
 };
 
 #define	PRIO_MIN	(-20)
-#define	PRIO_MAX	20
+#define	PRIO_MAX	19
 
 #define	PRIO_PROCESS	0
 #define	PRIO_PGRP	1
diff -ur linux-2.4.20-pre11.orig/kernel/sched.c linux/kernel/sched.c
--- linux-2.4.20-pre11.orig/kernel/sched.c	Sat Oct 19 13:26:59 2002
+++ linux/kernel/sched.c	Sat Oct 19 13:41:19 2002
@@ -870,17 +870,19 @@
 	if (increment < 0) {
 		if (!capable(CAP_SYS_NICE))
 			return -EPERM;
-		if (increment < -40)
-			increment = -40;
+
+		/* +1 to account for 0 in min<-->max range */
+		if (increment < PRIO_MIN - (PRIO_MAX + 1))
+			increment = PRIO_MIN - (PRIO_MAX + 1);
 	}
-	if (increment > 40)
-		increment = 40;
+	if (increment > -(PRIO_MIN - (PRIO_MAX + 1)))
+		increment = -(PRIO_MIN - (PRIO_MAX + 1));
 
 	newprio = current->nice + increment;
-	if (newprio < -20)
-		newprio = -20;
-	if (newprio > 19)
-		newprio = 19;
+	if (newprio < PRIO_MIN)
+		newprio = PRIO_MIN;
+	if (newprio > PRIO_MAX)
+		newprio = PRIO_MAX;
 	current->nice = newprio;
 	return 0;
 }
diff -ur linux-2.4.20-pre11.orig/kernel/sys.c linux/kernel/sys.c
--- linux-2.4.20-pre11.orig/kernel/sys.c	Sat Oct 19 11:58:48 2002
+++ linux/kernel/sys.c	Sat Oct 19 13:37:48 2002
@@ -204,10 +204,10 @@
 
 	/* normalize: avoid signed division (rounding problems) */
 	error = -ESRCH;
-	if (niceval < -20)
-		niceval = -20;
-	if (niceval > 19)
-		niceval = 19;
+	if (niceval < PRIO_MIN)
+		niceval = PRIO_MIN;
+	if (niceval > PRIO_MAX)
+		niceval = PRIO_MAX;
 
 	read_lock(&tasklist_lock);
 	for_each_task(p) {
@@ -249,7 +249,8 @@
 		long niceval;
 		if (!proc_sel(p, which, who))
 			continue;
-		niceval = 20 - p->nice;
+		niceval = PRIO_MAX + 1 - p->nice; /* +1 to account for 0
+						   * in 0<-->max range */
 		if (niceval > retval)
 			retval = niceval;
 	}