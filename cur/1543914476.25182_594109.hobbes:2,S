Date: Thu, 13 Sep 2007 15:45:01 -0400
From: Chuck Ebbert <>
Subject: Re: [PATCH] Memory shortage can result in inconsistent flocks state
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/9/13/279

On 09/13/2007 03:34 PM, J. Bruce Fields wrote:
>> Doesn't that create a leak in some cases?
>>
>>>         for_each_lock(inode, before) {
>>>                 struct file_lock *fl = *before;
>>>                 if (IS_POSIX(fl))
>>>                         break;
>>>                 if (IS_LEASE(fl))
>>>                         continue;
>>>                 if (filp != fl->fl_file)
>>>                         continue;
>>>                 if (request->fl_type == fl->fl_type)
>>>                         goto out;  <<<<<<<<<<<<<<<< LEAK?
> 
> You mean, a leak of the memory allocated for new_fl?  That's freed at
> the exit labeled with "out".  It's the only exit:
> 
> 	out:
> 	        unlock_kernel();
> 		if (new_fl)
> 			locks_free_lock(new_fl);
> 		return error;
> 
> And new_fl is initially NULL, assigned only once by the allocation, then
> assigned to NULL only at the very end when we know we've succeeded.
> 
> Am I missing something else?
> 
Never mind, I didn't look closely enough. Looks good to me.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/