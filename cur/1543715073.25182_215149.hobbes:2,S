Date: Tue, 20 Apr 2004 11:09:19 +0200
From: Zoltan Menyhart <>
Subject: Dynamic System Calls & System Call Hijacking - demo syscall
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2004/4/20/25

/*
 * Demo dynamic syscall
 */
#include <linux/module.h>
#include <asm/dyn_syscall.h>
const char name[] = "foo";
asmlinkage long
sys_foo(const int cmd, const caddr_t address, const size_t length,
					const int node, const pid_t pid)
{
	printk("\nsys_foo(%d, 0x%p, 0x%lx, %d, %d)\n",
					cmd, address, length, node, pid);
	return 0;
}
int syscall;
static int __init
init_foo(void)
{
	int	rc;
	printk("\nModule Foo\n");
	rc = dyn_syscall_reg(name, 0, (dyn_syscall_t) sys_foo);
	printk("dyn_syscall_reg() returned: %d\n", rc);
	if (rc < 0)
		return rc;
	syscall = rc;
	rc = syscall_unlock(name, syscall);
	if (rc < 0)
		panic("syscall_unlock() returned: %d\n", rc);
	return 0;
}
static void __exit
exit_foo(void)
{
	printk("\nModule Foo getting unloaded\n");
	int	rc;
	rc = prep_restore_syscall(name, syscall);
	if (rc < 0)
		panic("prep_restore_syscall() returned: %d\n", rc);
	while((rc = syscall_trylock(name, syscall)) == -EAGAIN){
		/*
		 * Having some blocking syscalls? Don't just busy wait,
		 * wake them up, sleep a bit in the mean time.
		 */
	}
	if (rc < 0)
		panic("syscall_trylock() returned: %d\n", rc);
	rc = dyn_syscall_unreg(name, syscall);
	if (rc < 0)
		panic("dyn_syscall_unreg() returned: %d\n", rc);
}
module_init(init_foo);
module_exit(exit_foo);