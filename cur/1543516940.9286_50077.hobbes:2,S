Date: Wed, 24 Nov 1999 13:53:48 -0800
From: Erich Boleyn <>
Subject: Re: spin_unlock optimization(i386)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/11/24/108

> ---------
> AFAICS, the rmb() during set_current_state() is still required:
> 
> __wait_on_inode()
> add_wait_queue();
> current->state=TASK_UNINTERRUPTIBLE;
> if(inode->i_state & I_LOCK) {
> 	schedule();
> 
> without rmb(), current->state=TASK_UNINTERRUPTIBLE would be a normal
> write, and thus the following read for inode->i_state could be executed
> _before_ setting state -> wake-up is lost.
I presume this is single-processor situation, or just referring to
interrupts on the same processor.  This is clearly not a thread/multi-
processor safe code sequence.
That is perfectly safe, since any read will only officially execute
after the store is finished, and the internal checking will guarantee
this even in the face of an interrupt just after the write and before
the read above.  The read can only be hoisted above the store
speculatively, with the results getting thrown away if there turns out
to be some conflict, such as an interrupt being taken.  And, BTW, an
IRET to return from an interrupt handler is a serializing instruction.
Remeber, "speculative execution" doesn't mean that it ignores ordering
constraints of the code involved on a single processor.  Otherwise many
normal programs would fail.
Erich Boleyn
PMD IA32 Architecture
Intel
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/