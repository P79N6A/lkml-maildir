Date: Sun, 28 Dec 2008 23:58:31 +0100
From: Henrik Rydberg <>
Subject: [PATCH 1/2] input: Allow certain EV_ABS events to bypass all filtering
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/12/28/88

With the upcoming multi-touch interface as an example, there is
a need to make certain that all reported events actually get passed
to the event handler. This patch equips the input core with the
ability to bypass all filtering for certain EV_ABS events.
Signed-off-by: Henrik Rydberg <rydberg@euromail.se>
---
 drivers/input/input.c |   23 +++++++++++++++++++++++
 1 files changed, 23 insertions(+), 0 deletions(-)
diff --git a/drivers/input/input.c b/drivers/input/input.c
index c13ced3..8b865ba 100644
--- a/drivers/input/input.c
+++ b/drivers/input/input.c
@@ -29,6 +29,13 @@ MODULE_LICENSE("GPL");
 #define INPUT_DEVICES	256
+/*
+ * EV_ABS events which should not be cached are listed here.
+ */
+static __initdata unsigned int input_abs_bypass_init_data[] = {
+	0
+};
+
 static LIST_HEAD(input_dev_list);
 static LIST_HEAD(input_handler_list);
@@ -42,6 +49,8 @@ static DEFINE_MUTEX(input_mutex);
 static struct input_handler *input_table[8];
+static unsigned long input_abs_bypass[BITS_TO_LONGS(ABS_CNT)];
+
 static inline int is_event_supported(unsigned int code,
 				     unsigned long *bm, unsigned int max)
 {
@@ -185,6 +194,11 @@ static void input_handle_event(struct input_dev *dev,
 	case EV_ABS:
 		if (is_event_supported(code, dev->absbit, ABS_MAX)) {
+			if (test_bit(code, input_abs_bypass)) {
+				disposition = INPUT_PASS_TO_HANDLERS;
+				break;
+			}
+
 			value = input_defuzz_abs_event(value,
 					dev->abs[code], dev->absfuzz[code]);
@@ -1630,10 +1644,19 @@ static const struct file_operations input_fops = {
 	.open = input_open_file,
 };
+static void __init input_init_abs_bypass()
+{
+	const unsigned int *p;
+	for (p = input_abs_bypass_init_data; *p; p++)
+		input_abs_bypass[BIT_WORD(*p)] |= BIT_MASK(*p);
+}
+
 static int __init input_init(void)
 {
 	int err;
+	input_init_abs_bypass();
+
 	err = class_register(&input_class);
 	if (err) {
 		printk(KERN_ERR "input: unable to register input_dev class\n");