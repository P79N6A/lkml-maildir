Date: Thu, 9 Mar 2006 17:11:06 -0800
From: Greg KH <>
Subject: Re: [PATCH 8 of 20] ipath - sysfs support for core driver
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/3/9/399

On Thu, Mar 09, 2006 at 04:35:38PM -0800, Bryan O'Sullivan wrote:
> +static ssize_t show_node_info(struct device *dev,
> +			       struct device_attribute *attr,
> +			       char *buf)
> +{
> +	static const size_t count = 10;
> +	struct ipath_devdata *dd = dev_get_drvdata(dev);
> +	u32 *nodeinfo;
> +	int ret;
> +
> +	if (!dd->ipath_statusp) {
> +		ret = -EINVAL;
> +		goto bail;
> +	}
> +
> +	nodeinfo = (u32 *) buf;
> +
> +	/* so we only initialize non-zero fields. */
> +	memset(nodeinfo, 0, count * sizeof(u32));
> +
> +	nodeinfo[0] =		/* BaseVersion is SMA */
> +		/* ClassVersion is SMA */
> +		(1 << 8)		/* NodeType  */
> +		|(1 << 0);		/* NumPorts */
> +	nodeinfo[1] = (u32) (dd->ipath_guid >> 32);
> +	nodeinfo[2] = (u32) (dd->ipath_guid & 0xffffffff);
> +	/* PortGUID == SystemImageGUID for us */
> +	nodeinfo[3] = nodeinfo[1];
> +	/* PortGUID == SystemImageGUID for us */
> +	nodeinfo[4] = nodeinfo[2];
> +	/* PortGUID == NodeGUID for us */
> +	nodeinfo[5] = nodeinfo[3];
> +	/* PortGUID == NodeGUID for us */
> +	nodeinfo[6] = nodeinfo[4];
> +	nodeinfo[7] = (4 << 16)	/* we support 4 pkeys */
> +		|(dd->ipath_deviceid << 0);
> +	/* our chip version as 16 bits major, 16 bits minor */
> +	nodeinfo[8] = dd->ipath_minrev | (dd->ipath_majrev << 16);
> +	nodeinfo[9] = (dd->ipath_unit << 24) | (dd->ipath_vendorid << 0);
> +
> +	ret = count * sizeof(u32);
> +bail:
> +	return ret;
> +}
> +
> +static ssize_t show_port_info(struct device *dev,
> +			       struct device_attribute *attr,
> +			       char *buf)
> +{
> +	static const size_t count = 13;
> +	int ret;
> +	u32 tmp, tmp2;
> +	struct ipath_devdata *dd = dev_get_drvdata(dev);
> +	u32 *portinfo;
> +
> +	if (!dd->ipath_statusp) {
> +		ret = -EINVAL;
> +		goto bail;
> +	}
> +
> +	portinfo = (u32 *) buf;
> +
> +	/* so we only initialize non-zero fields. */
> +	memset(portinfo, 0, count * sizeof portinfo);
> +
> +	/*
> +	 * Notimpl yet M_Key (64)
> +	 * Notimpl yet GID (64)
> +	 */
> +
> +	portinfo[4] = (dd->ipath_lid << 16);
> +
> +	/*
> +	 * Notimpl yet SMLID (should we store this in the driver, in case
> +	 * SMA dies?)  CapabilityMask is 0, we don't support any of these
> +	 * DiagCode is 0; we don't store any diag info for now Notimpl yet
> +	 * M_KeyLeasePeriod (we don't support M_Key)
> +	 */
> +
> +	/* LocalPortNum is whichever port number they ask for */
> +	portinfo[7] = (dd->ipath_unit << 24)
> +		/* LinkWidthEnabled */
> +		| (2 << 16)
> +		/* LinkWidthSupported (really 2, but not IB valid) */
> +		| (3 << 8)
> +		/* LinkWidthActive */
> +		| (2 << 0);
> +	tmp = dd->ipath_lastibcstat & IPATH_IBSTATE_MASK;
> +	tmp2 = 5;
> +	if (tmp == IPATH_IBSTATE_INIT)
> +		tmp = 2;
> +	else if (tmp == IPATH_IBSTATE_ARM)
> +		tmp = 3;
> +	else if (tmp == IPATH_IBSTATE_ACTIVE)
> +		tmp = 4;
> +	else {
> +		tmp = 0;	/* down */
> +		tmp2 = tmp & 0xf;
> +	}
> +
> +	portinfo[8] = (1 << 28)	/* LinkSpeedSupported */
> +		|(tmp << 24)	/* PortState */
> +		|(tmp2 << 20)	/* PortPhysicalState */
> +		|(2 << 16)
> +
> +		/* LinkDownDefaultState */
> +		/* M_KeyProtectBits == 0 */
> +		/* NotImpl yet LMC == 0 (we can support all values) */
> +		| (1 << 4)		/* LinkSpeedActive */
> +		|(1 << 0);		/* LinkSpeedEnabled */
> +	switch (dd->ipath_ibmtu) {
> +	case 4096:
> +		tmp = 5;
> +		break;
> +	case 2048:
> +		tmp = 4;
> +		break;
> +	case 1024:
> +		tmp = 3;
> +		break;
> +	case 512:
> +		tmp = 2;
> +		break;
> +	case 256:
> +		tmp = 1;
> +		break;
> +	default:		/* oops, something is wrong */
> +		ipath_dbg("Problem, ipath_ibmtu 0x%x not a valid IB MTU, "
> +			  "treat as 2048\n", dd->ipath_ibmtu);
> +		tmp = 4;
> +		break;
> +	}
> +	portinfo[9] = (tmp << 28)
> +		/* NeighborMTU */
> +		/* Notimpl MasterSMSL */
> +		| (1 << 20)
> +
> +		/* VLCap */
> +		/* Notimpl InitType (actually, an SMA decision) */
> +		/* VLHighLimit is 0 (only one VL) */
> +		; /* VLArbitrationHighCap is 0 (only one VL) */
> +	portinfo[10] =		/* VLArbitrationLowCap is 0 (only one VL) */
> +		/* InitTypeReply is SMA decision */
> +		(5 << 16)		/* MTUCap 4096 */
> +		|(7 << 13)		/* VLStallCount */
> +		|(0x1f << 8)	/* HOQLife */
> +		|(1 << 4)
> +
> +		/* OperationalVLs 0 */
> +		/* PartitionEnforcementInbound */
> +		/* PartitionEnforcementOutbound not enforced */
> +		/* FilterRawinbound not enforced */
> +		;			/* FilterRawOutbound not enforced */
> +	/* M_KeyViolations are not counted by hardware, SMA can count */
> +	tmp = ipath_read_creg32(dd, dd->ipath_cregs->cr_errpkey);
> +	/* P_KeyViolations are counted by hardware. */
> +	portinfo[11] = ((tmp & 0xffff) << 0);
> +	portinfo[12] =
> +		/* Q_KeyViolations are not counted by hardware */
> +		(1 << 8)
> +
> +		/* GUIDCap */
> +		/* SubnetTimeOut handled by SMA */
> +		/* RespTimeValue handled by SMA */
> +		;
> +	/* LocalPhyErrors are programmed to max */
> +	portinfo[12] |= (0xf << 20)
> +		| (0xf << 16)	/* OverRunErrors are programmed to max */
> +		;
> +
> +	ret = count * sizeof(u32);
> +bail:
> +	return ret;
> +}
These two files sure do show a lot of different stuff, all in a
predefined structure for a single file.  Please break them up into the
different individual files please.
thanks,
greg k-h
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/