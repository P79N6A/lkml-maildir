Date: Sat, 26 Jan 2008 22:00:06 -0800
From: Andrew Morton <>
Subject: Re: Can any one tell me why cond_resched in do_select?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/1/27/2

> On Thu, 24 Jan 2008 03:01:53 +0800 "Wang Nan" <wn.at.lkml@gmail.com> wrote:
> Hi, everyone.
> I have a question regarding to select system call's code. In
> do_select() function, after check each fd in the set, do_select() call
> cond_resched(). That line, according to my view, is to reduce the
> system freeze time when do the busy querying. But before the call,
> when entering into the big loop, do_select call
> set_current_state(TASK_INTERRUPTIBLE). Then, if the reschedule really
> taken up, the current process will not return unless it catch a
> signal, or one of already registered fd send an event.
> I've tried in UML. If I replace the cond_resched() into schedule(),
> when sys_select() called, the process halt just like I've said.
> I don't think there is a bug because this code exist so long time and
> no really bad thing happened. I just want to know that, since no
> schedule() allowed here, can we delete the useless line?
It does look a bit odd.  IIRC, cond_resched() is special, in that if it is
called in state TASK_INTERRUPTIBLE it will _not_ return in state
TASK_RUNNING after having called schedule().
Search for PREEMPT_ACTIVE in kernel/sched.c.  See if you can work out what
this code:
	if (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {
		if (unlikely((prev->state & TASK_INTERRUPTIBLE) &&
				unlikely(signal_pending(prev)))) {
			prev->state = TASK_RUNNING;
		} else {
			deactivate_task(rq, prev, 1);
		}
		switch_count = &prev->nvcsw;
	}
is doing, then send a patch which adds the missing comment :)