Date: Thu, 31 Jan 2008 16:27:53 +0800
From: "Huang, Ying" <>
Subject: Re: [PATCH 2/5] x86: c_p_a clflush_cache_range fix
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/1/31/47

On Thu, 2008-01-31 at 08:40 +0100, Andi Kleen wrote:
> On Thursday 31 January 2008 08:36:02 Huang, Ying wrote:
> > Because in i386 early boot stage, boot_cpu_data may be not available,
> > which makes clflush_cach_range() into infinite loop, which is called
> > by change_page_attr(). This patch fixes this by providing a default
> > clflush_size of 64. But the better method may be providing a
> > early_identify_cpu() for i386.
> 
> There already is one. arch/x86/kernel/cpu/common.c:early_cpu_detect 
> Just set it to 64 there.
Thanks. The following is a new patch based on your reminding.
--------------------------------------------------------------------
Because in i386 early boot stage, boot_cpu_data may be not available,
which makes clflush_cach_range() into infinite loop, which is called
by change_page_attr(). This patch fixes this by setting
boot_cpu_data.x86_clflush_size in early_cpu_detect().
Signed-off-by: Huang Ying <ying.huang@intel.com>
---
 arch/x86/kernel/cpu/common.c |    5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@ -274,8 +274,10 @@ void __init cpu_detect(struct cpuinfo_x8
 		if (c->x86 >= 0x6)
 			c->x86_model += ((tfms >> 16) & 0xF) << 4;
 		c->x86_mask = tfms & 15;
-		if (cap0 & (1<<19))
+		if (cap0 & (1<<19)) {
 			c->x86_cache_alignment = ((misc >> 8) & 0xff) * 8;
+			c->x86_clflush_size = ((misc >> 8) & 0xff) * 8;
+		}
 	}
 }
 static void __cpuinit early_get_cap(struct cpuinfo_x86 *c)
@@ -317,6 +319,7 @@ static void __init early_cpu_detect(void
 	struct cpuinfo_x86 *c = &boot_cpu_data;
 
 	c->x86_cache_alignment = 32;
+	c->x86_clflush_size = 32;
 
 	if (!have_cpuid_p())
 		return;