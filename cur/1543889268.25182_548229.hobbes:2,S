Date: Wed, 23 May 2007 17:25:00 +0100
From: Russell King <>
Subject: Re: [PATCH -rt] ARM TLB flush fix: don't forget to re-enable preemption
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/5/23/219

On Wed, May 23, 2007 at 09:13:57AM -0700, Kevin Hilman wrote:
> On Wed, 2007-05-23 at 10:22 +0100, Russell King wrote:
> > In which case shouldn't it be at the end of the function so it includes
> > the write buffer handling as well?
> > 
> > However, I think I agree with Daniel on this one.  I don't see the point
> > of the preempt_disable() here.
> 
> Note that my patch simply adds an enable to match the disable added by
> the -rt patch.  I'm not sure where the disable originally came from, but
> there are disable/enable pairs scattered throughout tlbflush.h in the
> -rt patch.
> 
> If this one isn't necessary, then the others probably are not either.
> In most cases there are 2 mcr instructions inside the critical section.
> One for the dsb() and the other for the actual function.
> 
> Russell, is there a reason any of these sections should be atomic?
I don't see any reason for them to be - when switching to another process
we'll generally do a full TLB flush anyway, so what's the point in making
these flushes atomic?
Consider:
flush_tlb_page()
 first mcr - invalidates tlb single entry
	--- context switch, invalidates entire tlb, inc dsb ---
		something else runs
	--- context switch, invalidates entire tlb, inc dsb, again ---
 dsb
That context switch is harmless - we end up with the entire TLB being
invalidated and a DSB following.  Now consider:
flush_tlb_page()
	--- context switch, invalidates entire tlb, inc dsb ---
		something else runs
	--- context switch, invalidates entire tlb, inc dsb, again ---
 preempt_disable()
 first mcr - invalidates tlb single entry
 dsb
 preempt_enable()
Any difference?  No.  Without the preempt disable/enable fiddling?  No.
flush_tlb_page()
 preempt_disable()
 first mcr - invalidates tlb single entry
 dsb
 preempt_enable()
	--- context switch, invalidates entire tlb, inc dsb ---
		something else runs
	--- context switch, invalidates entire tlb, inc dsb, again ---
Any difference?  No.  Without the preempt disable/enable fiddling?  No.
In every case of a preemption occuring in the middle of a tlb operation,
the ultimate result is identical irrespective of preempt control
sprinkling.
-- 
Russell King
 Linux kernel    2.6 ARM Linux   - 
http://www.arm.linux.org.uk/
 maintainer of:
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/