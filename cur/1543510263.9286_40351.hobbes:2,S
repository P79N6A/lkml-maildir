Date: Wed, 22 Sep 1999 18:01:12 +0100 (BST)
From: Mark Cooke <>
Subject: 2.2.13pre11 / ikd oops.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/9/22/97

Alan, all,
This oops occurred on a previously completely stable box running
2.2.13pre9. I had applied 2.2.12-ikd4 and rebooted in preparation for
some deadlock tracing of the Umax UDS11 interface on SMP.
I imagine that the oops is just a side-effect of the ikd deadlock
stuff, and isn't a real issue. The oops occurred after about 8hrs of
uptime.
The box wasn't particularly busy at the time - just running rc5,
handling my email etc.
Attached is also a diff to ikd4 so that it applied to 2.2.13pre11
Regards,
Mark
+-------------------------------------------------------------------------+
Mark Cooke                  The views expressed above are mine and are not
Systems Programmer          necessarily representative of university policy
University Of Birmingham    URL: 
http://www.sr.bham.ac.uk/~mpc/
+-------------------------------------------------------------------------+
Deadlock threshold exceeded, forcing Oops. 
Unable to handle kernel NULL pointer dereference at virtual address 00000000 
current->tss.cr3 = 11898000, %cr3 = 11898000 
*pde = 00000000 
Oops: 0002 
CPU:    0 
EIP:    0010:[mcount+734/756] 
EFLAGS: 00010202 
eax: 00000001   ebx: 00000e88   ecx: 0000003b   edx: 0000004a 
esi: d1896000   edi: d1896000   ebp: d1897f10   esp: d1897efc 
ds: 0018   es: 0018   ss: 0018 
Process X (pid: 1223, process nr: 71, stackpage=d1897000) 
Stack: 00040000 00000012 d1896000 c0153f56 00000246 d1897f1c c0153f56 00000000  
       d1897f54 c013b5eb d0b6bd80 00000000 d4186cd0 0000009f d4186ce0 00000145  
       00000012 d1896000 00002716 00000000 00000000 c8e4a000 d1897fbc c013ba5f  
Call Trace: [sock_poll+14/52] (0) [do_select+335/564] (12) [sys_select+911/1216] (56) [system_call+61/68] (104) [<ffffffff>] [aux_poll+13/76] 1223 0 [ret_from_sys_call+6/24] 8632 1 [sock_poll+14/52] 1223 0 [unix_poll+14/144] 1223 0 [sock_poll+14/52] 1223 0 [unix_poll+14/144] 1223 0 [system_call+35/68] 8632 1 [sock_poll+14/52] 1223 0 [old_select+19/112] 8632 1 [unix_poll+14/144] 1223 0 [sys_select+19/1216] 8632 1 [sock_poll+14/52] 1223 0 [kmalloc_wrap+19/460] 8632 1 [unix_poll+14/144] 1223 0 [do_select+19/564] 8632 1 [sock_poll+14/52] 1223 0 [unix_poll+14/144] 1223 0 [sock_poll+14/52] 1223 0 [unix_poll+14/144] 1223 0 [sock_poll+14/52] 1223 0 [unix_poll+14/144] 1223 0 [sock_poll+14/52] 1223 0 [unix_poll+14/144] 1223 0 [sock_poll+14/52] 1223 0 [unix_poll+14/144] 1223 0 [sock_poll+14/52] 1223 0 [unix_poll+14/144] 1223 0 [sock_poll+14/52] 1223 0 [unix_poll+14/144] 1223 0 [sock_poll+14/52] 1223 0  
Code: c6 05 00 00 00 00 00 8d 76 00 8d 65 e8 5b 5e 5f 89 ec 5d c3  
--- 2.2.12-ikd4	Wed Sep 22 12:30:48 1999
+++ 2.2.12-ikd4-ac11	Wed Sep 22 12:31:26 1999
@@ -12112,13 +12112,13 @@
   * Ted Ts'o, 2/11/93.
   * Modified for sysctl support, 1/8/97, Chris Horn.
 + * syslog_to_console for SysRQ dumploGs. 12/04/1998.
-+ *	Keith Owens <kaos@ocs.com.au>
++ *     Keith Owens <kaos@ocs.com.au>
+  * Fixed SMP synchronization, 08/08/99, Manfred Spraul 
+  *     manfreds@colorfullife.com
   */
- 
- #include <linux/mm.h>
-@@ -214,6 +216,46 @@
+@@ -240,6 +242,46 @@
+ 	}
  out:
- 	unlock_kernel();
  	return error;
 +}
 +
@@ -12647,7 +12647,7 @@
  #include <linux/config.h>
  #include <linux/mm.h>
  #include <linux/kernel_stat.h>
-@@ -101,6 +102,7 @@
+@@ -104,6 +105,7 @@
  
  #define list(x) (mem_map+(x))
  
@@ -12655,15 +12655,15 @@
  	map_nr &= mask;
  	nr_free_pages -= mask;
  	while (mask + (1 << (NR_MEM_LISTS-1))) {
-@@ -167,6 +169,7 @@
- 				MARK_USED(map_nr, new_order, area); \
- 				nr_free_pages -= 1 << order; \
- 				EXPAND(ret, map_nr, order, new_order, area); \
-+				MEMLEAK_ALLOC_NOLOCK(ADDRESS(map_nr)); \
- 				spin_unlock_irqrestore(&page_alloc_lock, flags); \
- 				return ADDRESS(map_nr); \
- 			} \
-@@ -230,7 +233,11 @@
+@@ -165,6 +167,7 @@
+ 			nr_free_pages -= 1 << order; \
+ 			area->count--; \
+ 			EXPAND(ret, map_nr, order, new_order, area); \
++			MEMLEAK_ALLOC_NOLOCK(ADDRESS(map_nr)); \
+ 			spin_unlock_irqrestore(&page_alloc_lock, flags); \
+ 			return ADDRESS(map_nr); \
+ 		} \
+@@ -186,7 +189,11 @@
  
  int low_on_memory = 0;
  