Date: Tue, 21 Mar 2000 07:39:29 +0000
From: Giuliano Procida <>
Subject: Re: [PATCH] consistent types for bitops
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/3/21/63

Here is the patch, sorry!
On Mon, Mar 20, 2000 at 04:03:07PM +0000, Giuliano Procida wrote:
> Not terribly tested, but not terribly complex! It fixes some warnings
> when passing pointers to const into test_bit and find_* (and friends).
> 
> Giuliano.
Only in kernel-2.3.49-68/include/: asm
diff -ru linux/include/asm-alpha/bitops.h kernel-2.3.49-68/include/asm-alpha/bitops.h
--- linux/include/asm-alpha/bitops.h	Fri Feb 25 06:36:05 2000
+++ kernel-2.3.49-68/include/asm-alpha/bitops.h	Mon Mar 20 15:48:03 2000
@@ -149,7 +149,7 @@
 	return oldbit != 0;
 }
 
-extern __inline__ int test_bit(int nr, volatile void * addr)
+extern __inline__ int test_bit(int nr, const volatile void * addr)
 {
 	return (1UL & (((const int *) addr)[nr >> 5] >> (nr & 31))) != 0UL;
 }
@@ -240,9 +240,9 @@
 /*
  * Find next zero bit in a bitmap reasonably efficiently..
  */
-extern inline unsigned long find_next_zero_bit(void * addr, unsigned long size, unsigned long offset)
+extern inline unsigned long find_next_zero_bit(const void * addr, unsigned long size, unsigned long offset)
 {
-	unsigned long * p = ((unsigned long *) addr) + (offset >> 6);
+	const unsigned long * p = ((const unsigned long *) addr) + (offset >> 6);
 	unsigned long result = offset & ~63UL;
 	unsigned long tmp;
 
Only in kernel-2.3.49-68/include/asm-alpha: bitops.h~
diff -ru linux/include/asm-arm/bitops.h kernel-2.3.49-68/include/asm-arm/bitops.h
--- linux/include/asm-arm/bitops.h	Tue Jul 21 01:23:32 1998
+++ kernel-2.3.49-68/include/asm-arm/bitops.h	Mon Mar 20 15:47:33 2000
@@ -24,15 +24,15 @@
 extern int test_and_set_bit(int nr, volatile void * addr);
 extern int test_and_clear_bit(int nr, volatile void * addr);
 extern int test_and_change_bit(int nr, volatile void * addr);
-extern int find_first_zero_bit(void * addr, unsigned size);
-extern int find_next_zero_bit(void * addr, int size, int offset);
+extern int find_first_zero_bit(const void * addr, unsigned size);
+extern int find_next_zero_bit(const void * addr, int size, int offset);
 
 /*
  * This routine doesn't need to be atomic.
  */
 extern __inline__ int test_bit(int nr, const void * addr)
 {
-    return ((unsigned char *) addr)[nr >> 3] & (1U << (nr & 7));
+    return ((const unsigned char *) addr)[nr >> 3] & (1U << (nr & 7));
 }	
 
 /*
Only in kernel-2.3.49-68/include/asm-arm: bitops.h~
diff -ru linux/include/asm-generic/bitops.h kernel-2.3.49-68/include/asm-generic/bitops.h
--- linux/include/asm-generic/bitops.h	Tue Jul 21 01:23:32 1998
+++ kernel-2.3.49-68/include/asm-generic/bitops.h	Mon Mar 20 15:37:08 2000
@@ -42,7 +42,7 @@
 	return retval;
 }
 
-extern __inline__ int test_bit(int nr, int * addr)
+extern __inline__ int test_bit(int nr, const int * addr)
 {
 	int	mask;
 
Only in kernel-2.3.49-68/include/asm-generic: bitops.h~
Only in kernel-2.3.49-68/include/asm-i386: #pci.h#
Only in kernel-2.3.49-68/include/asm-i386: .#pci.h
diff -ru linux/include/asm-i386/bitops.h kernel-2.3.49-68/include/asm-i386/bitops.h
--- linux/include/asm-i386/bitops.h	Thu Mar  2 22:01:17 2000
+++ kernel-2.3.49-68/include/asm-i386/bitops.h	Mon Mar 20 15:50:45 2000
@@ -29,9 +29,9 @@
 extern int test_and_clear_bit(int nr, volatile void * addr);
 extern int test_and_change_bit(int nr, volatile void * addr);
 extern int __constant_test_bit(int nr, const volatile void * addr);
-extern int __test_bit(int nr, volatile void * addr);
-extern int find_first_zero_bit(void * addr, unsigned size);
-extern int find_next_zero_bit (void * addr, int size, int offset);
+extern int __test_bit(int nr, const volatile void * addr);
+extern int find_first_zero_bit(const void * addr, unsigned size);
+extern int find_next_zero_bit(const void * addr, int size, int offset);
 extern unsigned long ffz(unsigned long word);
 
 /*
@@ -106,7 +106,7 @@
 	return ((1UL << (nr & 31)) & (((const volatile unsigned int *) addr)[nr >> 5])) != 0;
 }
 
-extern __inline__ int __test_bit(int nr, volatile void * addr)
+extern __inline__ int __test_bit(int nr, const volatile void * addr)
 {
 	int oldbit;
 
@@ -125,7 +125,7 @@
 /*
  * Find-bit routines..
  */
-extern __inline__ int find_first_zero_bit(void * addr, unsigned size)
+extern __inline__ int find_first_zero_bit(const void * addr, unsigned size)
 {
 	int d0, d1, d2;
 	int res;
@@ -147,9 +147,9 @@
 	return res;
 }
 
-extern __inline__ int find_next_zero_bit (void * addr, int size, int offset)
+extern __inline__ int find_next_zero_bit (const void * addr, int size, int offset)
 {
-	unsigned long * p = ((unsigned long *) addr) + (offset >> 5);
+	const unsigned long * p = ((const unsigned long *) addr) + (offset >> 5);
 	int set = 0, bit = offset & 31, res;
 	
 	if (bit) {
@@ -170,7 +170,7 @@
 	/*
 	 * No zero yet, search remaining full bytes for a zero
 	 */
-	res = find_first_zero_bit (p, size - 32 * (p - (unsigned long *) addr));
+	res = find_first_zero_bit (p, size - 32 * (p - (const unsigned long *) addr));
 	return (offset + set + res);
 }
 
Only in kernel-2.3.49-68/include/asm-i386: bitops.h~
diff -ru linux/include/asm-ia64/bitops.h kernel-2.3.49-68/include/asm-ia64/bitops.h
--- linux/include/asm-ia64/bitops.h	Thu Feb 10 03:45:43 2000
+++ kernel-2.3.49-68/include/asm-ia64/bitops.h	Mon Mar 20 15:46:32 2000
@@ -120,7 +120,7 @@
 }
 
 extern __inline__ int
-test_bit (int nr, volatile void *addr)
+test_bit (int nr, const volatile void *addr)
 {
 	return 1 & (((const volatile __u32 *) addr)[nr >> 5] >> (nr & 31));
 }
@@ -182,9 +182,9 @@
  * Find next zero bit in a bitmap reasonably efficiently..
  */
 extern inline int
-find_next_zero_bit (void *addr, unsigned long size, unsigned long offset)
+find_next_zero_bit (const void *addr, unsigned long size, unsigned long offset)
 {
-	unsigned long *p = ((unsigned long *) addr) + (offset >> 6);
+	const unsigned long *p = ((const unsigned long *) addr) + (offset >> 6);
 	unsigned long result = offset & ~63UL;
 	unsigned long tmp;
 
Only in kernel-2.3.49-68/include/asm-ia64: bitops.h~
diff -ru linux/include/asm-m68k/bitops.h kernel-2.3.49-68/include/asm-m68k/bitops.h
--- linux/include/asm-m68k/bitops.h	Wed Sep  2 17:39:18 1998
+++ kernel-2.3.49-68/include/asm-m68k/bitops.h	Mon Mar 20 15:46:13 2000
@@ -148,9 +148,9 @@
 	return ((1UL << (nr & 31)) & (((const unsigned int *) vaddr)[nr >> 5])) != 0;
 }
 
-extern __inline__ int find_first_zero_bit(void * vaddr, unsigned size)
+extern __inline__ int find_first_zero_bit(const void * vaddr, unsigned size)
 {
-	unsigned long *p = vaddr, *addr = vaddr;
+	const unsigned long *p = vaddr, *addr = vaddr;
 	unsigned long allones = ~0UL;
 	int res;
 	unsigned long num;
@@ -171,11 +171,11 @@
 	return ((p - addr) << 5) + (res ^ 31);
 }
 
-extern __inline__ int find_next_zero_bit (void *vaddr, int size,
-				      int offset)
+extern __inline__ int find_next_zero_bit (const void *vaddr, int size,
+					  int offset)
 {
-	unsigned long *addr = vaddr;
-	unsigned long *p = addr + (offset >> 5);
+	const unsigned long *addr = vaddr;
+	const unsigned long *p = addr + (offset >> 5);
 	int set = 0, bit = offset & 31UL, res;
 
 	if (offset >= size)
Only in kernel-2.3.49-68/include/asm-m68k: bitops.h~
diff -ru linux/include/asm-mips/bitops.h kernel-2.3.49-68/include/asm-mips/bitops.h
--- linux/include/asm-mips/bitops.h	Mon Feb 28 15:18:20 2000
+++ kernel-2.3.49-68/include/asm-mips/bitops.h	Mon Mar 20 15:44:38 2000
@@ -49,9 +49,9 @@
 
 extern __inline__ int test_bit(int nr, const void *addr);
 #ifndef __MIPSEB__
-extern __inline__ int find_first_zero_bit (void *addr, unsigned size);
+extern __inline__ int find_first_zero_bit (const void *addr, unsigned size);
 #endif
-extern __inline__ int find_next_zero_bit (void * addr, int size, int offset);
+extern __inline__ int find_next_zero_bit (const void * addr, int size, int offset);
 extern __inline__ unsigned long ffz(unsigned long word);
 
 #include <asm/mipsregs.h>
@@ -249,7 +249,7 @@
 
 /* Little endian versions. */
 
-extern __inline__ int find_first_zero_bit (void *addr, unsigned size)
+extern __inline__ int find_first_zero_bit (const void *addr, unsigned size)
 {
 	unsigned long dummy;
 	int res;
@@ -297,9 +297,9 @@
 	return res;
 }
 
-extern __inline__ int find_next_zero_bit (void * addr, int size, int offset)
+extern __inline__ int find_next_zero_bit (const void * addr, int size, int offset)
 {
-	unsigned int *p = ((unsigned int *) addr) + (offset >> 5);
+	const unsigned int *p = ((const unsigned int *) addr) + (offset >> 5);
 	int set = 0, bit = offset & 31, res;
 	unsigned long dummy;
 	
@@ -398,9 +398,9 @@
  * on Linus's ALPHA routines, which are pretty portable BTW.
  */
 
-extern __inline__ int find_next_zero_bit(void *addr, int size, int offset)
+extern __inline__ int find_next_zero_bit(const void *addr, int size, int offset)
 {
-	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
+	const unsigned long *p = ((const unsigned long *) addr) + (offset >> 5);
 	unsigned long result = offset & ~31UL;
 	unsigned long tmp;
 
@@ -487,9 +487,9 @@
 #define ext2_find_first_zero_bit(addr, size) \
         ext2_find_next_zero_bit((addr), (size), 0)
 
-extern __inline__ unsigned long ext2_find_next_zero_bit(void *addr, unsigned long size, unsigned long offset)
+extern __inline__ unsigned long ext2_find_next_zero_bit(const void *addr, unsigned long size, unsigned long offset)
 {
-	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
+	const unsigned long *p = ((const unsigned long *) addr) + (offset >> 5);
 	unsigned long result = offset & ~31UL;
 	unsigned long tmp;
 
Only in kernel-2.3.49-68/include/asm-mips: bitops.h~
diff -ru linux/include/asm-mips64/bitops.h kernel-2.3.49-68/include/asm-mips64/bitops.h
--- linux/include/asm-mips64/bitops.h	Fri Feb 25 06:53:35 2000
+++ kernel-2.3.49-68/include/asm-mips64/bitops.h	Mon Mar 20 15:42:47 2000
@@ -133,7 +133,7 @@
 }
 
 extern __inline__ unsigned long
-test_bit(int nr, volatile void * addr)
+test_bit(int nr, const volatile void * addr)
 {
 	return 1UL & (((const long *) addr)[nr >> 6] >> (nr & 0x3f));
 }
@@ -143,7 +143,7 @@
 /* Little endian versions. */
 
 extern __inline__ int
-find_first_zero_bit (void *addr, unsigned size)
+find_first_zero_bit (const void *addr, unsigned size)
 {
 	unsigned long dummy;
 	int res;
@@ -192,9 +192,9 @@
 }
 
 extern __inline__ int
-find_next_zero_bit (void * addr, int size, int offset)
+find_next_zero_bit (const void * addr, int size, int offset)
 {
-	unsigned int *p = ((unsigned int *) addr) + (offset >> 5);
+	const unsigned int *p = ((const unsigned int *) addr) + (offset >> 5);
 	int set = 0, bit = offset & 31, res;
 	unsigned long dummy;
 	
@@ -285,9 +285,9 @@
  */
 
 extern __inline__ unsigned long
-find_next_zero_bit(void *addr, unsigned long size, unsigned long offset)
+find_next_zero_bit(const void *addr, unsigned long size, unsigned long offset)
 {
-	unsigned long *p = ((unsigned long *) addr) + (offset >> 6);
+	const unsigned long *p = ((const unsigned long *) addr) + (offset >> 6);
 	unsigned long result = offset & ~63UL;
 	unsigned long tmp;
 
@@ -377,9 +377,9 @@
         ext2_find_next_zero_bit((addr), (size), 0)
 
 extern inline unsigned long
-ext2_find_next_zero_bit(void *addr, unsigned long size, unsigned long offset)
+ext2_find_next_zero_bit(const void *addr, unsigned long size, unsigned long offset)
 {
-	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
+	const unsigned long *p = ((const unsigned long *) addr) + (offset >> 5);
 	unsigned long result = offset & ~31UL;
 	unsigned long tmp;
 
Only in kernel-2.3.49-68/include/asm-mips64: bitops.h~
diff -ru linux/include/asm-ppc/bitops.h kernel-2.3.49-68/include/asm-ppc/bitops.h
--- linux/include/asm-ppc/bitops.h	Thu Feb 10 03:47:20 2000
+++ kernel-2.3.49-68/include/asm-ppc/bitops.h	Mon Mar 20 15:41:16 2000
@@ -145,10 +145,10 @@
 #define find_first_zero_bit(addr, size) \
 	find_next_zero_bit((addr), (size), 0)
 
-extern __inline__ unsigned long find_next_zero_bit(void * addr,
+extern __inline__ unsigned long find_next_zero_bit(const void * addr,
 	unsigned long size, unsigned long offset)
 {
-	unsigned int * p = ((unsigned int *) addr) + (offset >> 5);
+	const unsigned int * p = ((const unsigned int *) addr) + (offset >> 5);
 	unsigned int result = offset & ~31UL;
 	unsigned int tmp;
 
@@ -235,10 +235,10 @@
 #define ext2_find_first_zero_bit(addr, size) \
         ext2_find_next_zero_bit((addr), (size), 0)
 
-extern __inline__ unsigned long ext2_find_next_zero_bit(void *addr,
+extern __inline__ unsigned long ext2_find_next_zero_bit(const void *addr,
 	unsigned long size, unsigned long offset)
 {
-	unsigned int *p = ((unsigned int *) addr) + (offset >> 5);
+	const unsigned int *p = ((const unsigned int *) addr) + (offset >> 5);
 	unsigned int result = offset & ~31UL;
 	unsigned int tmp;
 
Only in kernel-2.3.49-68/include/asm-ppc: bitops.h~
diff -ru linux/include/asm-sh/bitops.h kernel-2.3.49-68/include/asm-sh/bitops.h
--- linux/include/asm-sh/bitops.h	Sat Nov  6 18:40:31 1999
+++ kernel-2.3.49-68/include/asm-sh/bitops.h	Mon Mar 20 15:40:17 2000
@@ -112,9 +112,9 @@
 	return result;
 }
 
-extern __inline__ int find_next_zero_bit(void *addr, int size, int offset)
+extern __inline__ int find_next_zero_bit(const void *addr, int size, int offset)
 {
-	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
+	const unsigned long *p = ((const unsigned long *) addr) + (offset >> 5);
 	unsigned long result = offset & ~31UL;
 	unsigned long tmp;
 
@@ -202,9 +202,9 @@
 #define ext2_find_first_zero_bit(addr, size) \
         ext2_find_next_zero_bit((addr), (size), 0)
 
-extern __inline__ unsigned long ext2_find_next_zero_bit(void *addr, unsigned long size, unsigned long offset)
+extern __inline__ unsigned long ext2_find_next_zero_bit(const void *addr, unsigned long size, unsigned long offset)
 {
-	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
+	const unsigned long *p = ((const unsigned long *) addr) + (offset >> 5);
 	unsigned long result = offset & ~31UL;
 	unsigned long tmp;
 
Only in kernel-2.3.49-68/include/asm-sh: bitops.h~
diff -ru linux/include/asm-sparc/bitops.h kernel-2.3.49-68/include/asm-sparc/bitops.h
--- linux/include/asm-sparc/bitops.h	Thu Feb 10 03:47:20 2000
+++ kernel-2.3.49-68/include/asm-sparc/bitops.h	Mon Mar 20 15:38:55 2000
@@ -208,9 +208,9 @@
  * on Linus's ALPHA routines, which are pretty portable BTW.
  */
 
-extern __inline__ unsigned long find_next_zero_bit(void *addr, unsigned long size, unsigned long offset)
+extern __inline__ unsigned long find_next_zero_bit(const void *addr, unsigned long size, unsigned long offset)
 {
-	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
+	const unsigned long *p = ((const unsigned long *) addr) + (offset >> 5);
 	unsigned long result = offset & ~31UL;
 	unsigned long tmp;
 
@@ -356,9 +356,9 @@
 #define find_first_zero_le_bit(addr, size) \
         find_next_zero_le_bit((addr), (size), 0)
 
-extern __inline__ unsigned long find_next_zero_le_bit(void *addr, unsigned long size, unsigned long offset)
+extern __inline__ unsigned long find_next_zero_le_bit(const void *addr, unsigned long size, unsigned long offset)
 {
-	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
+	const unsigned long *p = ((const unsigned long *) addr) + (offset >> 5);
 	unsigned long result = offset & ~31UL;
 	unsigned long tmp;
 
Only in kernel-2.3.49-68/include/asm-sparc: bitops.h~
diff -ru linux/include/asm-sparc64/bitops.h kernel-2.3.49-68/include/asm-sparc64/bitops.h
--- linux/include/asm-sparc64/bitops.h	Thu Feb 10 03:47:20 2000
+++ kernel-2.3.49-68/include/asm-sparc64/bitops.h	Mon Mar 20 15:39:47 2000
@@ -241,9 +241,9 @@
  * on Linus's ALPHA routines, which are pretty portable BTW.
  */
 
-extern __inline__ unsigned long find_next_zero_bit(void *addr, unsigned long size, unsigned long offset)
+extern __inline__ unsigned long find_next_zero_bit(const void *addr, unsigned long size, unsigned long offset)
 {
-	unsigned long *p = ((unsigned long *) addr) + (offset >> 6);
+	const unsigned long *p = ((const unsigned long *) addr) + (offset >> 6);
 	unsigned long result = offset & ~63UL;
 	unsigned long tmp;
 
@@ -338,9 +338,9 @@
 #define find_first_zero_le_bit(addr, size) \
         find_next_zero_le_bit((addr), (size), 0)
 
-extern __inline__ unsigned long find_next_zero_le_bit(void *addr, unsigned long size, unsigned long offset)
+extern __inline__ unsigned long find_next_zero_le_bit(const void *addr, unsigned long size, unsigned long offset)
 {
-	unsigned long *p = ((unsigned long *) addr) + (offset >> 6);
+	const unsigned long *p = ((const unsigned long *) addr) + (offset >> 6);
 	unsigned long result = offset & ~63UL;
 	unsigned long tmp;
 
Only in kernel-2.3.49-68/include/asm-sparc64: bitops.h~
Only in kernel-2.3.49-68/include/: config
Only in kernel-2.3.49-68/include/linux: autoconf.h
Only in kernel-2.3.49-68/include/linux: compile.h
Only in kernel-2.3.49-68/include/linux: modules
Only in kernel-2.3.49-68/include/linux: modversions.h
Only in kernel-2.3.49-68/include/linux: version.h