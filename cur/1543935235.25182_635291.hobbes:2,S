Date: Mon, 7 Jan 2008 13:59:54 -0500
From: Mathieu Desnoyers <>
Subject: Re: [PATCH 2/2] Markers Implementation for Preempt RCU Boost Tracing
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/1/7/247

* Ingo Molnar (mingo@elte.hu) wrote:
> 
> * Frank Ch. Eigler <fche@redhat.com> wrote:
> 
> > > [...] this is a general policy matter. It is _so much easier_ to add 
> > > markers if they _can_ have near-zero overhead (as in 1-2 
> > > instructions). Otherwise we'll keep arguing about it, especially if 
> > > any is added to performance-critical codepath. (where we are 
> > > counting instructions)
> > 
> > The effect of the immediate-values patch, combined with gcc 
> > CFLAGS+=-freorder-blocks, *is* to keep the overhead at 1-2 
> > dcache-impact-free instructions.  The register saves, parameter 
> > evaluation, the function call, can all be moved out of line.
> 
> well, -freorder-blocks seems to be default-enabled at -O2 on gcc 4.2, so 
> we should already be getting that, right?
> 
> There's one thing that would make out-of-line tracepoints have a lot 
> less objectionable to me: right now the 'out of line' area is put to the 
> end of functions. That splinters the kernel image with inactive, rarely 
> taken areas of code - blowing up its icache footprint considerably. For 
> example sched.o has ~100 functions, with the average function size being 
> 200 bytes. At 64 bytes L1 cacheline size that's a 10-20% icache waste 
> already.
Hrm, I agree this can be a problem on architectures with more standard
associative icaches, but aren't most x86_64 machines (and modern x86_32)
using an instruction trace cache instead ? This makes the problem
irrelevant.
But I agree that, as Frank proposed, -freorder-blocks-and-partition
could help us in that matter for the architectures using an associative
L1 icache.
Mathieu
> 
> It's true that keeping the off-site code within the function keeps total 
> codesize slightly smaller, because the offsets (and hence the 
> conditional jumps) are thus 8 bit - but that's below 1% and the 
> cache-blow-up aspect is more severe in practice at 10-20%.
> 
> So it would be nice if we could collect all this offline code and stuff 
> it away into another portion of the kernel image. (or, into another 
> portion of the object file - which would still be good enough in 
> practice)
> 
> 	Ingo
-- 
Mathieu Desnoyers
Computer Engineering Ph.D. Student, Ecole Polytechnique de Montreal
OpenPGP key fingerprint: 8CD5 52C3 8E3C 4140 715F  BA06 3F25 A8FE 3BAE 9A68