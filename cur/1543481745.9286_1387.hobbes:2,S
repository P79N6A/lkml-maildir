Date: Sun, 24 Jan 1999 00:24:27 +0300
From: "Ivan N. Kokshaysky" <>
Subject: [PATCH] some Alpha cleanups
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/1/23/134

Hi!
In the ide_disk.c: forcing int pointer to the location known
to be unaligned looks ugly for me (and for alpha too :) and
causes unaligned trap. I suggest the following patch (or use
macros from asm/unaligned.h instead)
--- linux-2.2.0-pre9/drivers/block/ide-disk.c	Fri Jan 15 09:58:47 1999
+++ linux/drivers/block/ide-disk.c	Thu Jan 21 21:45:55 1999
@@ -781,14 +781,16 @@
 	printk("\n");
 
 	if (drive->select.b.lba) {
-		if (*(int *)&id->cur_capacity0 < id->lba_capacity) {
+		capacity = (id->cur_capacity1 << 16) | id->cur_capacity0;
+		if (capacity < id->lba_capacity) {
 #ifdef DEBUG
 			printk("     CurSects=%d, LBASects=%d, ",
-				*(int *)&id->cur_capacity0, id->lba_capacity);
+				capacity, id->lba_capacity);
 #endif
-			*(int *)&id->cur_capacity0 = id->lba_capacity;
+			id->cur_capacity0 = (id->lba_capacity >>  0) & 0xffff;
+			id->cur_capacity1 = (id->lba_capacity >> 16) & 0xffff;
 #ifdef DEBUG
-			printk( "Fixed CurSects=%d\n", *(int *)&id->cur_capacity0);
+			printk( "Fixed CurSects=%d\n", id->lba_capacity);
 #endif
 		}
 	}
=======
Following patch allows use of eth_copy_and_sum without
an unaligned trap on alphas.
--- linux-2.2.0-pre9/net/ethernet/eth.c	Tue Jan 13 02:28:25 1998
+++ linux/net/ethernet/eth.c	Thu Jan 21 21:47:07 1999
@@ -284,7 +284,7 @@
 	 */
 	memcpy(dest->data,src,sizeof(struct iphdr)+ETH_HLEN);	/* ethernet is always >= 34 */
 	length -= sizeof(struct iphdr) + ETH_HLEN;
-	iph=(struct iphdr*)(src+ETH_HLEN);
+	iph=(struct iphdr*)(dest->data+ETH_HLEN);
 	ip_length = ntohs(iph->tot_len) - sizeof(struct iphdr);
 
 	/* Also watch out for bogons - min IP size is 8 (rfc-1042) */
=======
Ethernet drivers utilizing the rx_copybreak algorithm cause
unaligned traps with long packets, so it should be disabled
on alpha (it was already done in the tulip driver) until we
find a better solution (maybe use get/put_unaligned in the
ip_rcv?). Here is the patch for eepro100, which I currently
use, but other drivers for busmastering NICs could be fixed
the same way.
--- linux-2.2.0-pre9/drivers/net/eepro100.c	Sat Jan 16 01:36:21 1999
+++ linux/drivers/net/eepro100.c	Thu Jan 21 21:49:59 1999
@@ -35,7 +35,12 @@
 
 /* Set the copy breakpoint for the copy-only-tiny-buffer Rx method.
    Lower values use more memory, but are faster. */
+/* It's also causes a lot of unaligned traps on Alpha :-( */
+#ifdef __alpha__
+static int rx_copybreak = 1518;
+#else
 static int rx_copybreak = 200;
+#endif
 
 /* Maximum events (Rx packets, etc.) to handle at each interrupt. */
 static int max_interrupt_work = 200;
=======
Recent changes in the arch/alpha/Makefile (turning on
the proper cpu optimizations) missed SX164 systems
which are both PYXIS and PCA56
--- linux-2.2.0-pre9/arch/alpha/Makefile	Sun Jan 17 04:02:50 1999
+++ linux/arch/alpha/Makefile	Thu Jan 21 21:42:53 1999
@@ -36,7 +36,15 @@
     CFLAGS := $(CFLAGS) -mcpu=ev4
   endif
   ifeq ($(CONFIG_ALPHA_PYXIS),y)
-    CFLAGS := $(CFLAGS) -mcpu=ev56
+    ifeq ($(CONFIG_ALPHA_SX164),y)
+      ifeq ($(have_mcpu_pca56),y)
+        CFLAGS := $(CFLAGS) -mcpu=pca56
+      else
+        CFLAGS := $(CFLAGS) -mcpu=ev56
+      endif
+    else
+      CFLAGS := $(CFLAGS) -mcpu=ev56
+    endif
   endif
   ifeq ($(CONFIG_ALPHA_POLARIS),y)
     ifeq ($(have_mcpu_pca56),y)
@@ -67,7 +75,11 @@
    CFLAGS := $(CFLAGS) -Wa,-mev6
  endif
  ifeq ($(CONFIG_ALPHA_PYXIS),y)
-   CFLAGS := $(CFLAGS) -Wa,-m21164a -DBWIO_ENABLED
+   ifeq ($(CONFIG_ALPHA_SX164),y)
+     CFLAGS := $(CFLAGS) -Wa,-m21164pc -DBWIO_ENABLED
+   else
+     CFLAGS := $(CFLAGS) -Wa,-m21164a -DBWIO_ENABLED
+   endif
  endif
  ifeq ($(CONFIG_ALPHA_POLARIS),y)
    CFLAGS := $(CFLAGS) -Wa,-m21164pc
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/