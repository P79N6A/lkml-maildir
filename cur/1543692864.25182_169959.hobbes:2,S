Date: Thu, 2 Oct 2003 03:46:52 +0200 (MEST)
From:  Andries.Brouwer@cwi ...
Subject: [PATCH on sparse] - was Re: [PATCH] fat sparse fixes
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2003/10/1/331

    From: Linus Torvalds <torvalds@osdl.org>
    On Mon, 29 Sep 2003 Andries.Brouwer@cwi.nl wrote:
    > -        if (put_user(0, d2->d_name)            ||
    > +        if (put_user(0, d2->d_name+0)            ||
    The above seems to just work around a sparse bug. Please don't - I'd 
    rather have regular code and try to fix the sparse problem.
    Hmm.. I wonder why sparse doesn't get the address space right on arrays. 
    It should see that "d2" is a user pointer , so d2->d_name is one too.
    It gets it right if you add the "+0", or if you add a "&" in front. So 
    it looks like the sparse array->pointer degeneration misses something.
Please examine the below diff.
Andries
--- sparse-bk/evaluate.c	Wed Sep 10 07:00:14 2003
+++ sparse-bk-aeb/evaluate.c	Thu Oct  2 03:33:33 2003
@@ -799,11 +799,14 @@
 	struct symbol *ctype = op->ctype, *sym;
 
 	sym = alloc_symbol(expr->pos, SYM_NODE);
+
 	if (ctype->type == SYM_NODE) {
+		sym->ctype = ctype->ctype;
 		ctype = ctype->ctype.base_type;
 		merge_type(sym, ctype);
-	}
-	sym->ctype = ctype->ctype;
+	} else
+		sym->ctype = ctype->ctype;
+
 	if (ctype->type != SYM_PTR && ctype->type != SYM_ARRAY) {
 		warn(expr->pos, "cannot derefence this type");
 		return 0;
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/