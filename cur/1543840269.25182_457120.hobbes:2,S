Date: Thu, 24 Aug 2006 13:14:40 +0200
From: Ingo Molnar <>
Subject: Re: [RFC][PATCH 3/4] (Refcount + Waitqueue) implementation for cpu_hotplug "locking"
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/8/24/116

* Gautham R Shenoy <ego@in.ibm.com> wrote:
>  void lock_cpu_hotplug(void)
>  {
> +	DECLARE_WAITQUEUE(wait, current);
> +	spin_lock(&cpu_hotplug.lock);
> +	cpu_hotplug.reader_count++;
this should be per-CPU - lock_cpu_hotplug() should _not_ be a globally 
synchronized event.
CPU removal is such a rare event that we can easily do something like a 
global read-mostly 'CPU is locked for writes' flag (plus a completion 
queue) that the 'write' side takes atomically - combined with per-CPU 
refcount and a waitqueue that the read side increases/decreases and 
wakes. Read-locking of the CPU is much more common and should be 
fundamentally scalable: it should increase the per-CPU refcount, then 
check the global 'writer active' flag, and if the writer flag is set, it 
should wait on the global completion queue. When a reader drops the 
refcount it should wake up the per-CPU waitqueue. [in which a writer 
might be waiting for the refcount to go down to 0.]
	Ingo
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/