Date: Wed, 26 May 1999 12:47:07 -0400 (EDT)
From: Jeff Garzik <>
Subject: [patch] vga16 alpha updates, need testing
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/5/28/80

With this patch, the penguin boot logo can be seen by any Alpha owner
with a VGA card.  Please review this patch for correctness, I have
tested it on my Alpha only.
I am looking for feedback from anyone willing to test this patch, both
on Alpha, and also on other platforms to make sure I didn't break
things.
Thanks to rth, Ben, Petr, Martin, Geert, and everyone else who helped
out with input, insight, and info.
Patch and patch info below.
	Jeff
Patch URL:
http://havoc.gtf.org/garzik/kernel/files/19990526-vga16-alpha-fixes.patch
Patch ChangeLog, against virgin 2.3.3:
	arch/alpha/kernel/process.c, include/asm-alpha/semaphore.h:
	rth's fixes for Alpha so that 2.3.3 will work.
	(cut these if you've applied them already)
	drivers/video/Config.in: Add VGA16 fb to Alpha section.
	drivers/video/fbcon-vga-planes.c: Replace direct memory accesses
	with readb/writeb.
	drivers/video/fbcon.c: Replace direct memory accesses
	with readb/writeb.
	bug fixes: call correct scr_memcpy variant
	drivers/video/vga16fb.c: Rip out VGA constants.  Rename
	constants to those in new include/video/vga.h.
	include/video/vga.h: Move VGA16fb constants here, clean up
	namespace by prefixing with 'VGA_'.  There are a ton of other fb
	drivers that could use these common constants.
Index: arch/alpha/kernel/process.c
===================================================================
RCS file: /usr/local/cvsroot/linux_2_3/arch/alpha/kernel/process.c,v
retrieving revision 1.1.1.1
retrieving revision 1.1.1.1.6.1
diff -u -r1.1.1.1 -r1.1.1.1.6.1
--- arch/alpha/kernel/process.c	1999/05/16 06:27:48	1.1.1.1
+++ arch/alpha/kernel/process.c	1999/05/25 16:15:24	1.1.1.1.6.1
@@ -58,10 +58,10 @@
 static struct file * init_fd_array[NR_OPEN] = { NULL, };
 static struct files_struct init_files = INIT_FILES;
 static struct signal_struct init_signals = INIT_SIGNALS;
-struct mm_struct init_mm = INIT_MM;
+struct mm_struct init_mm = INIT_MM(init_mm);
 
 union task_union init_task_union __attribute__((section("init_task")))
-	 = { task: INIT_TASK };
+	 = { task: INIT_TASK(init_task_union.task) };
 
 /*
  * No need to acquire the kernel lock, we're entirely local..
Index: drivers/video/Config.in
===================================================================
RCS file: /usr/local/cvsroot/linux_2_3/drivers/video/Config.in,v
retrieving revision 1.1.1.1
retrieving revision 1.1.1.1.6.1
diff -u -r1.1.1.1 -r1.1.1.1.6.1
--- drivers/video/Config.in	1999/05/16 06:27:02	1.1.1.1
+++ drivers/video/Config.in	1999/05/22 02:22:49	1.1.1.1.6.1
@@ -71,6 +71,7 @@
   fi
   if [ "$ARCH" = "alpha" ]; then
     tristate 'TGA framebuffer support' CONFIG_FB_TGA
+    bool 'VGA 16-color graphics console' CONFIG_FB_VGA16
   fi
   if [ "$ARCH" = "i386" ]; then
     bool 'VESA VGA graphics console' CONFIG_FB_VESA
Index: drivers/video/fbcon-vga-planes.c
===================================================================
RCS file: /usr/local/cvsroot/linux_2_3/drivers/video/fbcon-vga-planes.c,v
retrieving revision 1.1.1.1
retrieving revision 1.1.1.1.6.1
diff -u -r1.1.1.1 -r1.1.1.1.6.1
--- drivers/video/fbcon-vga-planes.c	1999/05/16 06:27:20	1.1.1.1
+++ drivers/video/fbcon-vga-planes.c	1999/05/23 01:06:43	1.1.1.1.6.1
@@ -44,7 +44,8 @@
    OR. */
 static inline void rmw(volatile char *p)
 {
-	*p |= 1;
+	readb(p);
+	writeb(1, p);
 }
 
 /* Set the Graphics Mode Register.  Bits 0-1 are write mode, bit 3 is
@@ -122,8 +123,12 @@
 		dest = p->screen_base + dx + dy * p->line_length;
 		src = p->screen_base + sx + sy * p->line_length;
 		while (height--) {
-			for (x = 0; x < width; x++) 
-				*dest++ = *src++;
+			for (x = 0; x < width; x++) {
+				readb(src);
+				writeb(0, dest);
+				dest++;
+				src++;
+			}
 			src += line_ofs;
 			dest += line_ofs;
 		}
@@ -132,8 +137,12 @@
 		dest = p->screen_base + dx + width + (dy + height - 1) * p->line_length;
 		src = p->screen_base + sx + width + (sy + height - 1) * p->line_length;
 		while (height--) {
-			for (x = 0; x < width; x++)
-				*--dest = *--src;
+			for (x = 0; x < width; x++) {
+				dest--;
+				src--;
+				readb(src);
+				writeb(0, dest);
+			}
 			src -= line_ofs;
 			dest -= line_ofs;
 		}
@@ -160,8 +169,10 @@
 
 	where = p->screen_base + sx + sy * p->line_length;
 	while (height--) {
-		for (x = 0; x < width; x++)
-			*where++ = 0;
+		for (x = 0; x < width; x++) {
+			writeb(0, where);
+			where++;
+		}
 		where += line_ofs;
 	}
 }
@@ -211,13 +222,13 @@
 	selectmask();
 
 	setmask(0xff);
-	*where = bg;
+	writeb(bg, where);
 	rmb();
-	*(volatile char*)where; /* fill latches */
+	readb(where); /* fill latches */
 	setmode(3);
 	wmb();
 	for (y = 0; y < fontheight(p); y++, where += p->line_length) 
-		*where = cdat[y];
+		writeb(cdat[y], where);
 	wmb();
 }
 
@@ -237,9 +248,9 @@
 
 	setmask(0xff);
 	where = p->screen_base + xx + yy * p->line_length * fontheight(p);
-	*where = bg;
+	writeb(bg, where);
 	rmb();
-	*(volatile char*)where;
+	readb(where); /* fill latches */
 	wmb();
 	selectmask();
 	for (n = 0; n < count; n++) {
@@ -250,7 +261,7 @@
 		while (cdat < end) {
 			outb(*cdat++, GRAPHICS_DATA_REG);	
 			wmb();
-			*where = fg;
+			writeb(fg, where);
 			where += p->line_length;
 		}
 		where += 1 - p->line_length * fontheight(p);
@@ -277,9 +288,9 @@
 
 	setmask(0xff);
 	where = p->screen_base + xx + yy * p->line_length * fontheight(p);
-	*where = bg;
+	writeb(bg, where);
 	rmb();
-	*(volatile char*)where; /* fill latches with background */
+	readb(where); /* fill latches */
 	setmode(3);	
 	wmb();
 	for (n = 0; n < count; n++) {
@@ -288,7 +299,7 @@
 		u8 *cdat = p->fontdata + (c & p->charmask) * fontheight(p);
 
 		for (y = 0; y < fontheight(p); y++, cdat++) {
-			*where = *cdat;
+			writeb (*cdat, where);
 			where += p->line_length;
 		}
 		where += 1 - p->line_length * fontheight(p);
Index: drivers/video/fbcon.c
===================================================================
RCS file: /usr/local/cvsroot/linux_2_3/drivers/video/fbcon.c,v
retrieving revision 1.1.1.1
retrieving revision 1.1.1.1.6.4
diff -u -r1.1.1.1 -r1.1.1.1.6.4
--- drivers/video/fbcon.c	1999/05/16 06:27:07	1.1.1.1
+++ drivers/video/fbcon.c	1999/05/26 16:26:58	1.1.1.1.6.4
@@ -526,7 +526,7 @@
     	q = (unsigned short *)(conp->vc_origin + conp->vc_size_row * old_rows);
     	step = logo_lines * old_cols;
     	for (r = q - logo_lines * old_cols; r < q; r++)
-    	    if (*r != conp->vc_video_erase_char)
+    	    if (readw(r) != conp->vc_video_erase_char)
     	    	break;
 	if (r != q && nr_rows >= old_rows + logo_lines) {
     	    save = kmalloc(logo_lines * nr_cols * 2, GFP_KERNEL);
@@ -535,7 +535,7 @@
     	    	scr_memsetw(save, conp->vc_video_erase_char, logo_lines * nr_cols * 2);
     	    	r = q - step;
     	    	for (cnt = 0; cnt < logo_lines; cnt++, r += i)
-    	    		scr_memcpyw_to(save + cnt * nr_cols, r, 2 * i);
+			scr_memcpyw_from(save + cnt * nr_cols, r, 2 * i);
     	    	r = q;
     	    }
     	}
@@ -543,7 +543,7 @@
     	    /* We can scroll screen down */
 	    r = q - step - old_cols;
     	    for (cnt = old_rows - logo_lines; cnt > 0; cnt--) {
-    	    	scr_memcpyw(r + step, r, conp->vc_size_row);
+		scr_memcpyw(r + step, r, conp->vc_size_row);
     	    	r -= old_cols;
     	    }
     	    if (!save) {
@@ -551,10 +551,11 @@
     		conp->vc_pos += logo_lines * conp->vc_size_row;
     	    }
     	}
-    	scr_memsetw((unsigned short *)conp->vc_origin, conp->vc_video_erase_char, 
-    		conp->vc_size_row * logo_lines);
+    	scr_memsetw((unsigned short *)conp->vc_origin,
+		    conp->vc_video_erase_char, 
+    		    conp->vc_size_row * logo_lines);
     }
-    
+
     /*
      *  ++guenther: console.c:vc_allocate() relies on initializing
      *  vc_{cols,rows}, but we must not set those if we are only
@@ -603,13 +604,13 @@
 	}
 	if (save) {
     	    q = (unsigned short *)(conp->vc_origin + conp->vc_size_row * old_rows);
-	    scr_memcpyw_from(q, save, logo_lines * nr_cols * 2);
+	    memcpy(q, save, logo_lines * nr_cols * 2);
 	    conp->vc_y += logo_lines;
     	    conp->vc_pos += logo_lines * conp->vc_size_row;
     	    kfree(save);
 	}
     }
-	
+
     if (logo) {
 	logo_shown = -2;
     	conp->vc_top = logo_lines;
@@ -625,6 +626,7 @@
     	    softback_top = 0;
     	}
     }
+
 }
 
 
@@ -2255,13 +2257,15 @@
 				outb_p(*src >> 4,0x3cf);
 				outb_p(8,0x3ce);
 				outb_p(1 << (7 - x1 % 4 * 2),0x3cf);
-				*(volatile char *) dst |= 1;
+				readb(dst);
+				writeb(0, dst);
 
 				outb_p(0,0x3ce);
 				outb_p(*src & 0xf,0x3cf);
 				outb_p(8,0x3ce);
 				outb_p(1 << (7 - (1 + x1 % 4 * 2)),0x3cf);
-				*(volatile char *) dst |= 1;
+				readb(dst);
+				writeb(0, dst);
 
 				src++;
 			}
Index: drivers/video/vga16fb.c
===================================================================
RCS file: /usr/local/cvsroot/linux_2_3/drivers/video/vga16fb.c,v
retrieving revision 1.1.1.1
retrieving revision 1.1.1.1.6.1
diff -u -r1.1.1.1 -r1.1.1.1.6.1
--- drivers/video/vga16fb.c	1999/05/16 06:27:20	1.1.1.1
+++ drivers/video/vga16fb.c	1999/05/22 02:25:16	1.1.1.1.6.1
@@ -28,6 +28,7 @@
 
 #include <video/fbcon.h>
 #include <video/fbcon-vga-planes.h>
+#include <video/vga.h>
 
 #define dac_reg	(0x3c8)
 #define dac_val	(0x3c9)
@@ -64,104 +65,12 @@
 	int vesa_blanked;
 } vga16fb;
 
-/* Some of the code below is taken from SVGAlib.  The original,
-   unmodified copyright notice for that code is below. */
-/* VGAlib version 1.2 - (c) 1993 Tommy Frandsen                    */
-/*                                                                 */
-/* This library is free software; you can redistribute it and/or   */
-/* modify it without any restrictions. This library is distributed */
-/* in the hope that it will be useful, but without any warranty.   */
-
-/* Multi-chipset support Copyright 1993 Harm Hanemaayer */
-/* partially copyrighted (C) 1993 by Hartmut Schirmer */
-
-/* VGA data register ports */
-#define CRT_DC  0x3D5		/* CRT Controller Data Register - color emulation */
-#define CRT_DM  0x3B5		/* CRT Controller Data Register - mono emulation */
-#define ATT_R   0x3C1		/* Attribute Controller Data Read Register */
-#define GRA_D   0x3CF		/* Graphics Controller Data Register */
-#define SEQ_D   0x3C5		/* Sequencer Data Register */
-#define MIS_R   0x3CC		/* Misc Output Read Register */
-#define MIS_W   0x3C2		/* Misc Output Write Register */
-#define IS1_RC  0x3DA		/* Input Status Register 1 - color emulation */
-#define IS1_RM  0x3BA		/* Input Status Register 1 - mono emulation */
-#define PEL_D   0x3C9		/* PEL Data Register */
-#define PEL_MSK 0x3C6		/* PEL mask register */
-
-/* EGA-specific registers */
-#define GRA_E0	0x3CC		/* Graphics enable processor 0 */
-#define GRA_E1	0x3CA		/* Graphics enable processor 1 */
-
-
-/* VGA index register ports */
-#define CRT_IC  0x3D4		/* CRT Controller Index - color emulation */
-#define CRT_IM  0x3B4		/* CRT Controller Index - mono emulation */
-#define ATT_IW  0x3C0		/* Attribute Controller Index & Data Write Register */
-#define GRA_I   0x3CE		/* Graphics Controller Index */
-#define SEQ_I   0x3C4		/* Sequencer Index */
-#define PEL_IW  0x3C8		/* PEL Write Index */
-#define PEL_IR  0x3C7		/* PEL Read Index */
-
-/* standard VGA indexes max counts */
-#define CRT_C   24		/* 24 CRT Controller Registers */
-#define ATT_C   21		/* 21 Attribute Controller Registers */
-#define GRA_C   9		/* 9  Graphics Controller Registers */
-#define SEQ_C   5		/* 5  Sequencer Registers */
-#define MIS_C   1		/* 1  Misc Output Register */
-
-#define CRTC_H_TOTAL		0
-#define CRTC_H_DISP		1
-#define CRTC_H_BLANK_START	2
-#define CRTC_H_BLANK_END	3
-#define CRTC_H_SYNC_START	4
-#define CRTC_H_SYNC_END		5
-#define CRTC_V_TOTAL		6
-#define CRTC_OVERFLOW		7
-#define CRTC_PRESET_ROW		8
-#define CRTC_MAX_SCAN		9
-#define CRTC_CURSOR_START	0x0A
-#define CRTC_CURSOR_END		0x0B
-#define CRTC_START_HI		0x0C
-#define CRTC_START_LO		0x0D
-#define CRTC_CURSOR_HI		0x0E
-#define CRTC_CURSOR_LO		0x0F
-#define CRTC_V_SYNC_START	0x10
-#define CRTC_V_SYNC_END		0x11
-#define CRTC_V_DISP_END		0x12
-#define CRTC_OFFSET		0x13
-#define CRTC_UNDERLINE		0x14
-#define CRTC_V_BLANK_START	0x15
-#define CRTC_V_BLANK_END	0x16
-#define CRTC_MODE		0x17
-#define CRTC_LINE_COMPARE	0x18
-#define CRTC_REGS		0x19
-
-#define ATC_MODE		0x10
-#define ATC_OVERSCAN		0x11
-#define ATC_PLANE_ENABLE	0x12
-#define ATC_PEL			0x13
-#define ATC_COLOR_PAGE		0x14
-
-#define SEQ_CLOCK_MODE		0x01
-#define SEQ_PLANE_WRITE		0x02
-#define SEQ_CHARACTER_MAP	0x03
-#define SEQ_MEMORY_MODE		0x04
-
-#define GDC_SR_VALUE		0x00
-#define GDC_SR_ENABLE		0x01
-#define GDC_COMPARE_VALUE	0x02
-#define GDC_DATA_ROTATE		0x03
-#define GDC_PLANE_READ		0x04
-#define GDC_MODE		0x05
-#define GDC_MISC		0x06
-#define GDC_COMPARE_MASK	0x07
-#define GDC_BIT_MASK		0x08
 
 struct vga16fb_par {
-	u8 crtc[CRTC_REGS];
-	u8 atc[ATT_C];
-	u8 gdc[GRA_C];
-	u8 seq[SEQ_C];
+	u8 crtc[VGA_CRTC_REGS];
+	u8 atc[VGA_ATT_C];
+	u8 gdc[VGA_GRA_C];
+	u8 seq[VGA_SEQ_C];
 	u8 misc;
 	u8 vss;
 	struct fb_var_screeninfo var;
@@ -217,17 +126,17 @@
 static void vga16fb_pan_var(struct fb_info *info, struct fb_var_screeninfo *var)
 {
 	u32 pos = (var->xres_virtual * var->yoffset + var->xoffset) >> 3;
-	outb(CRTC_START_HI, CRT_IC);
-	outb(pos >> 8, CRT_DC);
-	outb(CRTC_START_LO, CRT_IC);
-	outb(pos & 0xFF, CRT_DC);
+	outb(VGA_CRTC_START_HI, VGA_CRT_IC);
+	outb(pos >> 8, VGA_CRT_DC);
+	outb(VGA_CRTC_START_LO, VGA_CRT_IC);
+	outb(pos & 0xFF, VGA_CRT_DC);
 #if 0
 	/* if someone supports xoffset in bit resolution */
-	inb(IS1_RC);		/* reset flip-flop */
-	outb(ATC_PEL, ATT_IW);
-	outb(xoffset & 7, ATT_IW);
-	inb(IS1_RC);
-	outb(0x20, ATT_IW);
+	inb(VGA_IS1_RC);		/* reset flip-flop */
+	outb(VGA_ATC_PEL, VGA_ATT_IW);
+	outb(xoffset & 7, VGA_ATT_IW);
+	inb(VGA_IS1_RC);
+	outb(0x20, VGA_ATT_IW);
 #endif
 }
 
@@ -339,7 +248,7 @@
 		}
 	}
 	par->misc |= best->misc;
-	par->seq[SEQ_CLOCK_MODE] |= best->seq_clock_mode;
+	par->seq[VGA_SEQ_CLOCK_MODE] |= best->seq_clock_mode;
 	par->var.pixclock = best->pixclock;		
 }
 			       
@@ -389,17 +298,17 @@
 		FAIL("hslen too big");
 	if (right + hslen + left > 64)
 		FAIL("hblank too big");
-	par->crtc[CRTC_H_TOTAL] = xtotal - 5;
-	par->crtc[CRTC_H_BLANK_START] = xres - 1;
-	par->crtc[CRTC_H_DISP] = xres - 1;
+	par->crtc[VGA_CRTC_H_TOTAL] = xtotal - 5;
+	par->crtc[VGA_CRTC_H_BLANK_START] = xres - 1;
+	par->crtc[VGA_CRTC_H_DISP] = xres - 1;
 	pos = xres + right;
-	par->crtc[CRTC_H_SYNC_START] = pos;
+	par->crtc[VGA_CRTC_H_SYNC_START] = pos;
 	pos += hslen;
-	par->crtc[CRTC_H_SYNC_END] = pos & 0x1F;
+	par->crtc[VGA_CRTC_H_SYNC_END] = pos & 0x1F;
 	pos += left - 2; /* blank_end + 2 <= total + 5 */
-	par->crtc[CRTC_H_BLANK_END] = (pos & 0x1F) | 0x80;
+	par->crtc[VGA_CRTC_H_BLANK_END] = (pos & 0x1F) | 0x80;
 	if (pos & 0x20)
-		par->crtc[CRTC_H_SYNC_END] |= 0x80;
+		par->crtc[VGA_CRTC_H_SYNC_END] |= 0x80;
 
 	yres = var->yres;
 	lower = var->lower_margin;
@@ -444,59 +353,59 @@
 		FAIL("ytotal too big");
 	if (vslen > 16)
 		FAIL("vslen too big");
-	par->crtc[CRTC_V_TOTAL] = ytotal - 2;
+	par->crtc[VGA_CRTC_V_TOTAL] = ytotal - 2;
 	r7 = 0x10;	/* disable linecompare */
 	if (ytotal & 0x100) r7 |= 0x01;
 	if (ytotal & 0x200) r7 |= 0x20;
-	par->crtc[CRTC_PRESET_ROW] = 0;
-	par->crtc[CRTC_MAX_SCAN] = 0x40;	/* 1 scanline, no linecmp */
+	par->crtc[VGA_CRTC_PRESET_ROW] = 0;
+	par->crtc[VGA_CRTC_MAX_SCAN] = 0x40;	/* 1 scanline, no linecmp */
 	par->var.vmode = var->vmode;
 	if (var->vmode & FB_VMODE_DOUBLE)
-		par->crtc[CRTC_MAX_SCAN] |= 0x80;
-	par->crtc[CRTC_CURSOR_START] = 0x20;
-	par->crtc[CRTC_CURSOR_END]   = 0x00;
+		par->crtc[VGA_CRTC_MAX_SCAN] |= 0x80;
+	par->crtc[VGA_CRTC_CURSOR_START] = 0x20;
+	par->crtc[VGA_CRTC_CURSOR_END]   = 0x00;
 	pos = yoffset * vxres + (xoffset >> 3);
-	par->crtc[CRTC_START_HI]     = pos >> 8;
-	par->crtc[CRTC_START_LO]     = pos & 0xFF;
-	par->crtc[CRTC_CURSOR_HI]    = 0x00;
-	par->crtc[CRTC_CURSOR_LO]    = 0x00;
+	par->crtc[VGA_CRTC_START_HI]     = pos >> 8;
+	par->crtc[VGA_CRTC_START_LO]     = pos & 0xFF;
+	par->crtc[VGA_CRTC_CURSOR_HI]    = 0x00;
+	par->crtc[VGA_CRTC_CURSOR_LO]    = 0x00;
 	pos = yres - 1;
-	par->crtc[CRTC_V_DISP_END] = pos & 0xFF;
-	par->crtc[CRTC_V_BLANK_START] = pos & 0xFF;
+	par->crtc[VGA_CRTC_V_DISP_END] = pos & 0xFF;
+	par->crtc[VGA_CRTC_V_BLANK_START] = pos & 0xFF;
 	if (pos & 0x100)
 		r7 |= 0x0A;	/* 0x02 -> DISP_END, 0x08 -> BLANK_START */
 	if (pos & 0x200) {
 		r7 |= 0x40;	/* 0x40 -> DISP_END */
-		par->crtc[CRTC_MAX_SCAN] |= 0x20; /* BLANK_START */
+		par->crtc[VGA_CRTC_MAX_SCAN] |= 0x20; /* BLANK_START */
 	}
 	pos += lower;
-	par->crtc[CRTC_V_SYNC_START] = pos & 0xFF;
+	par->crtc[VGA_CRTC_V_SYNC_START] = pos & 0xFF;
 	if (pos & 0x100)
 		r7 |= 0x04;
 	if (pos & 0x200)
 		r7 |= 0x80;
 	pos += vslen;
-	par->crtc[CRTC_V_SYNC_END] = (pos & 0x0F) | 0x10; /* disabled IRQ */
+	par->crtc[VGA_CRTC_V_SYNC_END] = (pos & 0x0F) | 0x10; /* disabled IRQ */
 	pos += upper - 1; /* blank_end + 1 <= ytotal + 2 */
-	par->crtc[CRTC_V_BLANK_END] = pos & 0xFF; /* 0x7F for original VGA,
+	par->crtc[VGA_CRTC_V_BLANK_END] = pos & 0xFF; /* 0x7F for original VGA,
                      but some SVGA chips requires all 8 bits to set */
 	if (vxres >= 512)
 		FAIL("vxres too long");
-	par->crtc[CRTC_OFFSET] = vxres >> 1;
-	par->crtc[CRTC_UNDERLINE] = 0x1F;
-	par->crtc[CRTC_MODE] = rMode | 0xE3;
-	par->crtc[CRTC_LINE_COMPARE] = 0xFF;
-	par->crtc[CRTC_OVERFLOW] = r7;
+	par->crtc[VGA_CRTC_OFFSET] = vxres >> 1;
+	par->crtc[VGA_CRTC_UNDERLINE] = 0x1F;
+	par->crtc[VGA_CRTC_MODE] = rMode | 0xE3;
+	par->crtc[VGA_CRTC_LINE_COMPARE] = 0xFF;
+	par->crtc[VGA_CRTC_OVERFLOW] = r7;
 
 	par->vss = 0x00;	/* 3DA */
 
 	for (i = 0x00; i < 0x10; i++)
 		par->atc[i] = i;
-	par->atc[ATC_MODE] = 0x81;
-	par->atc[ATC_OVERSCAN] = 0x00;	/* 0 for EGA, 0xFF for VGA */
-	par->atc[ATC_PLANE_ENABLE] = 0x0F;
-	par->atc[ATC_PEL] = xoffset & 7;
-	par->atc[ATC_COLOR_PAGE] = 0x00;
+	par->atc[VGA_ATC_MODE] = 0x81;
+	par->atc[VGA_ATC_OVERSCAN] = 0x00;	/* 0 for EGA, 0xFF for VGA */
+	par->atc[VGA_ATC_PLANE_ENABLE] = 0x0F;
+	par->atc[VGA_ATC_PEL] = xoffset & 7;
+	par->atc[VGA_ATC_COLOR_PAGE] = 0x00;
 	
 	par->misc = 0xC3;	/* enable CPU, ports 0x3Dx, positive sync */
 	par->var.sync = var->sync;
@@ -505,20 +414,20 @@
 	if (var->sync & FB_SYNC_VERT_HIGH_ACT)
 		par->misc &= ~0x80;
 	
-	par->seq[SEQ_CLOCK_MODE] = 0x01;
-	par->seq[SEQ_PLANE_WRITE] = 0x0F;
-	par->seq[SEQ_CHARACTER_MAP] = 0x00;
-	par->seq[SEQ_MEMORY_MODE] = 0x06;
-	
-	par->gdc[GDC_SR_VALUE] = 0x00;
-	par->gdc[GDC_SR_ENABLE] = 0x0F;
-	par->gdc[GDC_COMPARE_VALUE] = 0x00;
-	par->gdc[GDC_DATA_ROTATE] = 0x20;
-	par->gdc[GDC_PLANE_READ] = 0;
-	par->gdc[GDC_MODE] = 0x00;
-	par->gdc[GDC_MISC] = 0x05;
-	par->gdc[GDC_COMPARE_MASK] = 0x0F;
-	par->gdc[GDC_BIT_MASK] = 0xFF;
+	par->seq[VGA_SEQ_CLOCK_MODE] = 0x01;
+	par->seq[VGA_SEQ_PLANE_WRITE] = 0x0F;
+	par->seq[VGA_SEQ_CHARACTER_MAP] = 0x00;
+	par->seq[VGA_SEQ_MEMORY_MODE] = 0x06;
+	
+	par->gdc[VGA_GDC_SR_VALUE] = 0x00;
+	par->gdc[VGA_GDC_SR_ENABLE] = 0x0F;
+	par->gdc[VGA_GDC_COMPARE_VALUE] = 0x00;
+	par->gdc[VGA_GDC_DATA_ROTATE] = 0x20;
+	par->gdc[VGA_GDC_PLANE_READ] = 0;
+	par->gdc[VGA_GDC_MODE] = 0x00;
+	par->gdc[VGA_GDC_MISC] = 0x05;
+	par->gdc[VGA_GDC_COMPARE_MASK] = 0x0F;
+	par->gdc[VGA_GDC_BIT_MASK] = 0xFF;
 
 	vga16fb_clock_chip(par, var->pixclock, info);
 
@@ -544,64 +453,64 @@
 {
 	int i;
 
-	outb(inb(MIS_R) | 0x01, MIS_W);
+	outb(inb(VGA_MIS_R) | 0x01, VGA_MIS_W);
 
 	/* Enable graphics register modification */
 	if (!info->isVGA) {
-		outb(0x00, GRA_E0);
-		outb(0x01, GRA_E1);
+		outb(0x00, EGA_GRA_E0);
+		outb(0x01, EGA_GRA_E1);
 	}
 	
 	/* update misc output register */
-	outb(par->misc, MIS_W);
+	outb(par->misc, VGA_MIS_W);
 	
 	/* synchronous reset on */
-	outb(0x00, SEQ_I);
-	outb(0x01, SEQ_D);
+	outb(0x00, VGA_SEQ_I);
+	outb(0x01, VGA_SEQ_D);
 	
 	/* write sequencer registers */
-	outb(1, SEQ_I);
-	outb(par->seq[1] | 0x20, SEQ_D);
-	for (i = 2; i < SEQ_C; i++) {
-		outb(i, SEQ_I);
-		outb(par->seq[i], SEQ_D);
+	outb(1, VGA_SEQ_I);
+	outb(par->seq[1] | 0x20, VGA_SEQ_D);
+	for (i = 2; i < VGA_SEQ_C; i++) {
+		outb(i, VGA_SEQ_I);
+		outb(par->seq[i], VGA_SEQ_D);
 	}
 	
 	/* synchronous reset off */
-	outb(0x00, SEQ_I);
-	outb(0x03, SEQ_D);
+	outb(0x00, VGA_SEQ_I);
+	outb(0x03, VGA_SEQ_D);
 	
 	/* deprotect CRT registers 0-7 */
-	outb(0x11, CRT_IC);
-	outb(par->crtc[0x11], CRT_DC);
+	outb(0x11, VGA_CRT_IC);
+	outb(par->crtc[0x11], VGA_CRT_DC);
 
 	/* write CRT registers */
-	for (i = 0; i < CRTC_REGS; i++) {
-		outb(i, CRT_IC);
-		outb(par->crtc[i], CRT_DC);
+	for (i = 0; i < VGA_CRTC_REGS; i++) {
+		outb(i, VGA_CRT_IC);
+		outb(par->crtc[i], VGA_CRT_DC);
 	}
 	
 	/* write graphics controller registers */
-	for (i = 0; i < GRA_C; i++) {
-		outb(i, GRA_I);
-		outb(par->gdc[i], GRA_D);
+	for (i = 0; i < VGA_GRA_C; i++) {
+		outb(i, VGA_GRA_I);
+		outb(par->gdc[i], VGA_GRA_D);
 	}
 	
 	/* write attribute controller registers */
-	for (i = 0; i < ATT_C; i++) {
-		inb_p(IS1_RC);		/* reset flip-flop */
-		outb_p(i, ATT_IW);
-		outb_p(par->atc[i], ATT_IW);
+	for (i = 0; i < VGA_ATT_C; i++) {
+		inb_p(VGA_IS1_RC);		/* reset flip-flop */
+		outb_p(i, VGA_ATT_IW);
+		outb_p(par->atc[i], VGA_ATT_IW);
 	}
 
 	/* Wait for screen to stabilize. */
 	mdelay(50);
 
-	outb(0x01, SEQ_I);
-	outb(par->seq[1], SEQ_D);
+	outb(0x01, VGA_SEQ_I);
+	outb(par->seq[1], VGA_SEQ_D);
 
-	inb(IS1_RC);
-	outb(0x20, ATT_IW);
+	inb(VGA_IS1_RC);
+	outb(0x20, VGA_ATT_IW);
 	
 	return 0;
 }
Index: include/asm-alpha/semaphore.h
===================================================================
RCS file: /usr/local/cvsroot/linux_2_3/include/asm-alpha/semaphore.h,v
retrieving revision 1.1.1.2
retrieving revision 1.1.1.2.4.1
diff -u -r1.1.1.2 -r1.1.1.2.4.1
--- include/asm-alpha/semaphore.h	1999/05/21 22:43:31	1.1.1.2
+++ include/asm-alpha/semaphore.h	1999/05/25 16:15:25	1.1.1.2.4.1
@@ -17,15 +17,58 @@
 	atomic_t count;
 	atomic_t waking;		/* biased by -1 */
 	wait_queue_head_t wait;
+#if WAITQUEUE_DEBUG
+	long __magic;
+#endif
 };
 
-#define MUTEX ((struct semaphore) \
- { ATOMIC_INIT(1), ATOMIC_INIT(-1), NULL })
-#define MUTEX_LOCKED ((struct semaphore) \
- { ATOMIC_INIT(0), ATOMIC_INIT(-1), NULL })
+#if WAITQUEUE_DEBUG
+# define __SEM_DEBUG_INIT(name)		, (long)&(name).__magic
+#else
+# define __SEM_DEBUG_INIT(name)
+#endif
+
+#define __SEMAPHORE_INITIALIZER(name,count)		\
+	{ ATOMIC_INIT(count), ATOMIC_INIT(-1),		\
+	  __WAIT_QUEUE_HEAD_INITIALIZER((name).wait)	\
+	  __SEM_DEBUG_INIT(name) }
+
+#define __MUTEX_INITIALIZER(name) \
+	__SEMAPHORE_INITIALIZER(name,1)
 
-#define sema_init(sem, val)	atomic_set(&((sem)->count), val)
+#define __DECLARE_SEMAPHORE_GENERIC(name,count) \
+	struct semaphore name = __SEMAPHORE_INITIALIZER(name,count)
 
+#define DECLARE_MUTEX(name) __DECLARE_SEMAPHORE_GENERIC(name,1)
+#define DECLARE_MUTEX_LOCKED(name) __DECLARE_SEMAPHORE_GENERIC(name,0)
+
+extern inline void sema_init (struct semaphore *sem, int val)
+{
+	/*
+	 * Logically, 
+	 *   *sem = (struct semaphore)__SEMAPHORE_INITIALIZER((*sem),val);
+	 * except that gcc produces better initializing by parts yet.
+	 */
+
+	atomic_set(&sem->count, val);
+	atomic_set(&sem->waking, -1);
+	init_waitqueue_head(&sem->wait);
+#if WAITQUEUE_DEBUG
+	sem->__magic = (long)&sem->__magic;
+#endif
+}
+
+static inline void init_MUTEX (struct semaphore *sem)
+{
+	sema_init(sem, 1);
+}
+
+static inline void init_MUTEX_LOCKED (struct semaphore *sem)
+{
+	sema_init(sem, 0);
+}
+
+
 extern void __down(struct semaphore * sem);
 extern int  __down_interruptible(struct semaphore * sem);
 extern int  __down_trylock(struct semaphore * sem);
@@ -57,8 +100,13 @@
 	   a function that ordinarily wouldn't.  Otherwise we could
 	   have it done by the macro directly, which can be optimized
 	   the linker.  */
-	register void *pv __asm__("$27") = __down_failed;
+	register void *pv __asm__("$27");
+
+#if WAITQUEUE_DEBUG
+	CHECK_MAGIC(sem->__magic);
+#endif
 	
+	pv = __down_failed;
 	__asm__ __volatile__ (
 		"/* semaphore down operation */\n"
 		"1:	ldl_l	$24,%1\n"
@@ -88,8 +136,13 @@
 	   value is in $24.  */
 
 	register int ret __asm__("$24");
-	register void *pv __asm__("$27") = __down_failed_interruptible;
+	register void *pv __asm__("$27");
 
+#if WAITQUEUE_DEBUG
+	CHECK_MAGIC(sem->__magic);
+#endif
+	
+	pv = __down_failed_interruptible;
 	__asm__ __volatile__ (
 		"/* semaphore down interruptible operation */\n"
 		"1:	ldl_l	$24,%2\n"
@@ -144,6 +197,10 @@
 	   } while (tmp == 0);
 	*/
 
+#if WAITQUEUE_DEBUG
+	CHECK_MAGIC(sem->__magic);
+#endif
+	
 	__asm__ __volatile__(
 		"1:	ldq_l	%1,%4\n"
 		"	lda	%3,1\n"
@@ -179,8 +236,13 @@
 	   it's return address in $28.  The pv is loaded as usual.
 	   The gp is clobbered (in the module case) as usual.  */
 
-	register void *pv __asm__("$27") = __up_wakeup;
+	register void *pv __asm__("$27");
 
+#if WAITQUEUE_DEBUG
+	CHECK_MAGIC(sem->__magic);
+#endif
+	
+	pv = __up_wakeup;
 	__asm__ __volatile__ (
 		"/* semaphore up operation */\n"
 		"	mb\n"
Index: include/video/vga.h
===================================================================
RCS file: vga.h
diff -N vga.h
--- /dev/null	Wed May 26 12:26:43 1999
+++ /tmp/cvsMAA0yTdzd	Wed May 26 12:31:19 1999
@@ -0,0 +1,111 @@
+/*
+ * linux/include/video/vga.h -- standard VGA chipset constants
+ * 
+ * Copyright 1999 Ben Pfaff <pfaffben@debian.org> and Petr Vandrovec <VANDROVE@vc.cvut.cz>
+ * Based on VGA info at 
http://www.goodnet.com/~tinara/FreeVGA/home.htm
+ * Based on VESA framebuffer (c) 1998 Gerd Knorr <kraxel@goldbach.in-berlin.de>
+ * Moved from vga16fb.c 1999/05/21 by Jeff Garzik <jgarzik@pobox.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License.  See the file COPYING in the main directory of this
+ * archive for more details.  
+ */
+
+#ifndef __linux_video_vga_h__
+#define __linux_video_vga_h__
+
+
+/* Some of the code below is taken from SVGAlib.  The original,
+   unmodified copyright notice for that code is below. */
+/* VGAlib version 1.2 - (c) 1993 Tommy Frandsen                    */
+/*                                                                 */
+/* This library is free software; you can redistribute it and/or   */
+/* modify it without any restrictions. This library is distributed */
+/* in the hope that it will be useful, but without any warranty.   */
+
+/* Multi-chipset support Copyright 1993 Harm Hanemaayer */
+/* partially copyrighted (C) 1993 by Hartmut Schirmer */
+
+/* VGA data register ports */
+#define VGA_CRT_DC  	0x3D5	/* CRT Controller Data Register - color emulation */
+#define VGA_CRT_DM  	0x3B5	/* CRT Controller Data Register - mono emulation */
+#define VGA_ATT_R   	0x3C1	/* Attribute Controller Data Read Register */
+#define VGA_GRA_D   	0x3CF	/* Graphics Controller Data Register */
+#define VGA_SEQ_D   	0x3C5	/* Sequencer Data Register */
+#define VGA_MIS_R   	0x3CC	/* Misc Output Read Register */
+#define VGA_MIS_W   	0x3C2	/* Misc Output Write Register */
+#define VGA_IS1_RC  	0x3DA	/* Input Status Register 1 - color emulation */
+#define VGA_IS1_RM  	0x3BA	/* Input Status Register 1 - mono emulation */
+#define VGA_PEL_D   	0x3C9	/* PEL Data Register */
+#define VGA_PEL_MSK 	0x3C6	/* PEL mask register */
+
+/* EGA-specific registers */
+#define EGA_GRA_E0	0x3CC	/* Graphics enable processor 0 */
+#define EGA_GRA_E1	0x3CA	/* Graphics enable processor 1 */
+
+/* VGA index register ports */
+#define VGA_CRT_IC  	0x3D4	/* CRT Controller Index - color emulation */
+#define VGA_CRT_IM  	0x3B4	/* CRT Controller Index - mono emulation */
+#define VGA_ATT_IW  	0x3C0	/* Attribute Controller Index & Data Write Register */
+#define VGA_GRA_I   	0x3CE	/* Graphics Controller Index */
+#define VGA_SEQ_I   	0x3C4	/* Sequencer Index */
+#define VGA_PEL_IW  	0x3C8	/* PEL Write Index */
+#define VGA_PEL_IR  	0x3C7	/* PEL Read Index */
+
+/* standard VGA indexes max counts */
+#define VGA_CRT_C   	24	/* 24 CRT Controller Registers */
+#define VGA_ATT_C   	21	/* 21 Attribute Controller Registers */
+#define VGA_GRA_C   	9	/* 9  Graphics Controller Registers */
+#define VGA_SEQ_C   	5	/* 5  Sequencer Registers */
+#define VGA_MIS_C   	1	/* 1  Misc Output Register */
+
+#define VGA_CRTC_H_TOTAL	0
+#define VGA_CRTC_H_DISP		1
+#define VGA_CRTC_H_BLANK_START	2
+#define VGA_CRTC_H_BLANK_END	3
+#define VGA_CRTC_H_SYNC_START	4
+#define VGA_CRTC_H_SYNC_END	5
+#define VGA_CRTC_V_TOTAL	6
+#define VGA_CRTC_OVERFLOW	7
+#define VGA_CRTC_PRESET_ROW	8
+#define VGA_CRTC_MAX_SCAN	9
+#define VGA_CRTC_CURSOR_START	0x0A
+#define VGA_CRTC_CURSOR_END	0x0B
+#define VGA_CRTC_START_HI	0x0C
+#define VGA_CRTC_START_LO	0x0D
+#define VGA_CRTC_CURSOR_HI	0x0E
+#define VGA_CRTC_CURSOR_LO	0x0F
+#define VGA_CRTC_V_SYNC_START	0x10
+#define VGA_CRTC_V_SYNC_END	0x11
+#define VGA_CRTC_V_DISP_END	0x12
+#define VGA_CRTC_OFFSET		0x13
+#define VGA_CRTC_UNDERLINE	0x14
+#define VGA_CRTC_V_BLANK_START	0x15
+#define VGA_CRTC_V_BLANK_END	0x16
+#define VGA_CRTC_MODE		0x17
+#define VGA_CRTC_LINE_COMPARE	0x18
+#define VGA_CRTC_REGS		0x19
+
+#define VGA_ATC_MODE		0x10
+#define VGA_ATC_OVERSCAN	0x11
+#define VGA_ATC_PLANE_ENABLE	0x12
+#define VGA_ATC_PEL		0x13
+#define VGA_ATC_COLOR_PAGE	0x14
+
+#define VGA_SEQ_CLOCK_MODE	0x01
+#define VGA_SEQ_PLANE_WRITE	0x02
+#define VGA_SEQ_CHARACTER_MAP	0x03
+#define VGA_SEQ_MEMORY_MODE	0x04
+
+#define VGA_GDC_SR_VALUE	0x00
+#define VGA_GDC_SR_ENABLE	0x01
+#define VGA_GDC_COMPARE_VALUE	0x02
+#define VGA_GDC_DATA_ROTATE	0x03
+#define VGA_GDC_PLANE_READ	0x04
+#define VGA_GDC_MODE		0x05
+#define VGA_GDC_MISC		0x06
+#define VGA_GDC_COMPARE_MASK	0x07
+#define VGA_GDC_BIT_MASK	0x08
+
+
+#endif /* __linux_video_vga_h__ */
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/