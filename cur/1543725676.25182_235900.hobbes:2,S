Date: Fri, 23 Jul 2004 17:52:18 +0200
From: maximilian attems <>
Subject: [patch-kj] use list_for_each()/list_for_each_save() in fs/dcache.c
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2004/7/23/89

Use list_for_each() where applicable
- for (list = ymf_devs.next; list != &ymf_devs; list = list->next) {
+ list_for_each(list, &ymf_devs) {
pure cosmetic change, defined as a preprocessor macro in:
include/linux/list.h
applies cleanly to 2.6.8-rc2
From: Domen Puncer <domen@coderock.org>
Signed-off-by: Maximilian Attems <janitor@sternwelten.at>
---
 linux-2.6.7-bk20-max/fs/dcache.c |   21 +++++----------------
 1 files changed, 5 insertions(+), 16 deletions(-)
diff -puN fs/dcache.c~list_for_each-fs-dcache fs/dcache.c
--- linux-2.6.7-bk20/fs/dcache.c~list_for_each-fs-dcache	2004-07-11 14:40:57.000000000 +0200
+++ linux-2.6.7-bk20-max/fs/dcache.c	2004-07-11 14:40:57.000000000 +0200
@@ -288,15 +288,11 @@ struct dentry * dget_locked(struct dentr
 
 struct dentry * d_find_alias(struct inode *inode)
 {
-	struct list_head *head, *next, *tmp;
+	struct list_head *tmp, *next;
 	struct dentry *alias, *discon_alias=NULL;
 
 	spin_lock(&dcache_lock);
-	head = &inode->i_dentry;
-	next = inode->i_dentry.next;
-	while (next != head) {
-		tmp = next;
-		next = tmp->next;
+	list_for_each_safe(tmp, next, &inode->i_dentry) {
 		prefetch(next);
 		alias = list_entry(tmp, struct dentry, d_alias);
  		if (!d_unhashed(alias)) {
@@ -324,8 +320,7 @@ void d_prune_aliases(struct inode *inode
 	struct list_head *tmp, *head = &inode->i_dentry;
 restart:
 	spin_lock(&dcache_lock);
-	tmp = head;
-	while ((tmp = tmp->next) != head) {
+	list_for_each(tmp, head) {
 		struct dentry *dentry = list_entry(tmp, struct dentry, d_alias);
 		if (!atomic_read(&dentry->d_count)) {
 			__dget_locked(dentry);
@@ -442,10 +437,7 @@ void shrink_dcache_sb(struct super_block
 	 * superblock to the most recent end of the unused list.
 	 */
 	spin_lock(&dcache_lock);
-	next = dentry_unused.next;
-	while (next != &dentry_unused) {
-		tmp = next;
-		next = tmp->next;
+	list_for_each_safe(tmp, next, &dentry_unused) {
 		dentry = list_entry(tmp, struct dentry, d_lru);
 		if (dentry->d_sb != sb)
 			continue;
@@ -457,10 +449,7 @@ void shrink_dcache_sb(struct super_block
 	 * Pass two ... free the dentries for this superblock.
 	 */
 repeat:
-	next = dentry_unused.next;
-	while (next != &dentry_unused) {
-		tmp = next;
-		next = tmp->next;
+	list_for_each_safe(tmp, next, &dentry_unused) {
 		dentry = list_entry(tmp, struct dentry, d_lru);
 		if (dentry->d_sb != sb)
 			continue;
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/