Date: Sun, 11 Mar 2001 03:18:27 +0100
From: Alex Baretta <>
Subject: Re: Possible bug with poll syscall
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2001/3/10/63

Alex Baretta wrote:
> 
> Alex Baretta wrote:
> >
> > I am using poll with the POLLIN flag to wait for connection
> > requests on a set of listening sockets in a server process.
> > Although clients attempt to connect to those sockets, poll does
> > returns zero after the expiration of the timeout.
...
There was a bug in my code. I am unable to find it, but I wrote a
minimal to case to prove my point, and actually I proved myself
wrong. Test case follows. If I ever find the time I'll try to
experiment and discover why in "the real thing" poll did not work
for me.
#include <sys/poll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdio.h>
int main(int argc, char **argv) {
  struct pollfd fds;
  int res1, res2, nevents;
  struct sockaddr_in sockaddr;
  fds.fd = socket(PF_INET, SOCK_STREAM, 0);
  fds.events = POLLIN;
  
  
  sockaddr.sin_family = AF_INET;
  sockaddr.sin_addr.s_addr = htonl(INADDR_ANY);
  sockaddr.sin_port = htons(50000);
  
  res1 = bind(fds.fd, (struct sockaddr *)&sockaddr,
sizeof(sockaddr));
  res2 = listen(fds.fd, 20);
  if (fds.fd == -1 || res1 == -1 || res2 == -1) {
    fprintf(stderr, "The program failed miserably.\n");
    exit(1);
  }
  
  fprintf(stderr, "I'm about to suspend myself on a poll
syscall!\n");
  nevents = poll(&fds, 1, -1);
  fprintf(stderr, "Waking up: nevents = %d\n", nevents);
  
  return 0;
};
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/