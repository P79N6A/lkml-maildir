Date: Thu, 16 Mar 2000 10:22:28 +0100
From: Remco Nonhebel <>
Subject: Real time/Serial programming
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/3/16/213

Hello,
My name is Remco Nonhebel, I'm a Dutch student Microelectronics and I
have to write a program to read data from three serial ports. This data
is coming from three pieces of hardware. Okay, the serial programming is
not the problem. The problem is that I have to add a time stamp to the
message coming from the hardware boards. These time stamps have to be
very accurate. I know i can use gettimeofday to get the time since Epoch
in milliseconds. To read data from the serial port i use a select on the
file descriptor.
For testing I am using a dos-pc (because it is not
multitasking/threading) that is sending little frames to my Linux  PC.
When I reviewed the time stamps the Linux PC added, I noticed they were
fixed to 10 milliseconds (no matter which baudrate). But I have to be
more accurate than that.... After a few test (with sending the data at
random times), I have concluded the problem is at the receiving side.
The code for getting the data from the serial port:
int highlevel_io_read(int fd, unsigned char *dest, int count, int
timeout,
   char *description)
{
   int i, result;
   struct timeval tv;
   fd_set fdset;
   FD_ZERO(&fdset);
   for (i=0; i<count; i+=result)
   {
      if (timeout)
      {
         FD_SET(fd, &fdset);
         tv.tv_sec  = timeout / 1000000;
         tv.tv_usec = timeout % 1000000;
         if (select(fd+1, &fdset, NULL, NULL, &tv) < 0)
         {
            log_log_errno(LOG_ERR, "select error on: %s", description);
            return -1;
         }
         if (!FD_ISSET(fd, &fdset))
         {
            log_log(LOG_WARNING, "timeout on: %s", description);
            return i;
         }
      }
      if ((result = read(fd, dest + i, count - i)) < 0)
      {
         log_log_errno(LOG_ERR, "read error on: %s", description);
         return -1;
      }
      /* end of file / closed socket */
      if (result == 0)
      {
         log_log(LOG_DEBUG, "fd closed for: %s", description);
         return i;
      }
   }
   return i;
}
The timeout value for the select is 1 second
I have been trying to give the process realtime priority with:
  sch.sched_priority = 99;
  t = sched_setscheduler(0,SCHED_FIFO,&sch);
but that didn't make any difference.
Here's my question:
Why are the time stamps fixed to 10 milliseconds and what can I do to
get a more accurate time stamp?
I am not subscribed to the linux-kernel mailing list, so if you reply to
this mail, could you please reply it to:
nonhebel@umailme.com
or at least cc it to that address....
Greetinx,
Remco Nonhebel
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/