Date: Wed, 14 Jan 2009 18:18:00 +0100
From: Nick Piggin <>
Subject: Re: [PATCH -v11][RFC] mutex: implement adaptive spinning
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2009/1/14/343

On Wed, Jan 14, 2009 at 06:00:36PM +0100, Peter Zijlstra wrote:
> Full series, including changelogs available at:
> 
> 
http://programming.kicks-ass.net/kernel-patches/mutex-adaptive-spin/
> 
> and should shortly appear in a git tree near Ingo :-)
Linus is going to take a wholesale conversion of mutexes to adaptive
mutexes? He's gone soft. I put on my asbestos underwear for no reason,
then.
> @@ -173,21 +237,21 @@ __mutex_lock_common(struct mutex *lock, 
>  			spin_unlock_mutex(&lock->wait_lock, flags);
> 
>  			debug_mutex_free_waiter(&waiter);
> +			preempt_enable();
>  			return -EINTR;
>  		}
>  		__set_task_state(task, state);
> 
>  		/* didnt get the lock, go to sleep: */
>  		spin_unlock_mutex(&lock->wait_lock, flags);
> -		schedule();
> +		__schedule();
Why does this need to do a preempt-disabled schedule? After we schedule
away, the next task can do arbitrary things or reschedule itself, so if
we have not anticipated such a condition here, then I can't see what
__schedule protects. At least a comment is in order?
Pity to add the call overhead to schedule just for this case. BTW.
__schedule shouldn't need to be asmlinkage?
>  		spin_lock_mutex(&lock->wait_lock, flags);
>  	}
> 