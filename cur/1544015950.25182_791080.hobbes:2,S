Date: Tue, 13 Jan 2009 02:43:33 +0100
From: Ingo Molnar <>
Subject: Re: [git pull] fixes for tip/sched/rt
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2009/1/12/649

* Gregory Haskins <ghaskins@novell.com> wrote:
> +#ifdef CONFIG_SMP
> +	if (prio < prev_prio) {
> +		struct rq *rq = rq_of_rt_rq(rt_rq);
> 
>  		/*
>  		 * If the new task is higher in priority than anything on the
> -		 * run-queue, we have a new high that must be published to
> -		 * the world.  We also know that the previous high becomes
> -		 * our next-highest.
> +		 * run-queue, we know that the previous high becomes our
> +		 * next-highest.
>  		 */
> +		rt_rq->highest_prio.next = prev_prio;
> +
>  		if (rq->online)
>  			cpupri_set(&rq->rd->cpupri, rq->cpu, prio);
nice cleanups.
couldnt this portion too be moved into a helper function?
>  #ifdef CONFIG_SMP
> +	if (rt_rq->rt_nr_running && (prio <= rt_rq->highest_prio.next))
> +		rt_rq->highest_prio.next = next_prio(rq);
> 
> +	if (rq->online && rt_rq->highest_prio.curr != prev_prio)
>  		cpupri_set(&rq->rd->cpupri, rq->cpu, rt_rq->highest_prio.curr);
> +#endif
ditto.
> +static inline
> +void inc_rt_tasks(struct sched_rt_entity *rt_se, struct rt_rq *rt_rq)
> +{
> +	int prio = rt_se_prio(rt_se);
> +
> +	WARN_ON(!rt_prio(prio));
> +	rt_rq->rt_nr_running++;
> +
> +	inc_rt_prio(rt_rq, prio);
> +	inc_rt_migration(rt_se, rt_rq);
> +
> +#ifdef CONFIG_RT_GROUP_SCHED
> +	if (rt_se_boosted(rt_se))
> +		rt_rq->rt_nr_boosted++;
> +
> +	if (rt_rq->tg)
> +		start_rt_bandwidth(&rt_rq->tg->rt_bandwidth);
> +#else
> +	start_rt_bandwidth(&def_rt_bandwidth);
> +#endif
ditto.
	Ingo