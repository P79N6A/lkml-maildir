Date: Wed, 23 May 2007 20:09:45 +0400
From: Oleg Nesterov <>
Subject: Re: 2.6.22-rc2-mm1
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/5/23/247

On 05/23, Andrew Morton wrote:
>
> On Wed, 23 May 2007 10:47:04 -0400 (EDT) Alan Stern <stern@rowland.harvard.edu> wrote:
> 
> > Is it possible to get an Alt-SysRq-T stack trace during those 20 
> > seconds?  Knowing what those threads are waiting for would be a big 
> > help.
>
> [  144.201264] khubd         D 00400005     0   160      2 (L-TLB)
> [  144.204358]        c207fe78 00000046 90399a85 00400005 00000246 c207fe60 c25b0cc4 c206f4cc 
> [  144.204539]        00000286 00000000 769e4cea 0040000a 90399a85 00400005 c32713c0 c207fed4 
> [  144.207754]        00000001 c207fe94 c207febc c02e8e1b 00000000 00000000 00000000 00000000 
> [  144.210934] Call Trace:
> [  144.217012]  [<c02e8e1b>] wait_for_completion+0x68/0x91
> [  144.220090]  [<c011824f>] default_wake_function+0x0/0x9
> [  144.223158]  [<c0127a41>] flush_cpu_workqueue+0x4d/0x55
> [  144.226223]  [<c0127a69>] wq_barrier_func+0x0/0x8
> [  144.229269]  [<c026343d>] usb_release_dev+0x28/0x63
> [  144.232340]  [<c0233011>] device_release+0x37/0x7c
> [  144.235431]  [<c01cb6c7>] kobject_cleanup+0x3d/0x54
> [  144.238520]  [<c01cb6de>] kobject_release+0x0/0x8
> [  144.241631]  [<c01cc2a7>] kref_put+0x75/0x82
> [  144.244699]  [<c0265482>] hub_thread+0x376/0xa74
> [  144.247768]  [<c01180c2>] pick_next_task_fair+0xf2/0x12a
> [  144.250815]  [<c0116af1>] __wake_up_common+0x31/0x4f
> [  144.253864]  [<c012a259>] autoremove_wake_function+0x0/0x35
> [  144.256902]  [<c026510c>] hub_thread+0x0/0xa74
> [  144.259944]  [<c012a102>] kthread+0x36/0x5c
> [  144.262891]  [<c012a0cc>] kthread+0x0/0x5c
> [  144.265757]  [<c010464b>] kernel_thread_helper+0x7/0x10
> [  144.268716]  =======================
Looks like usb_release_dev() does flush_workqueue() under usb_lock_device().
Is it possible? If yes, flush_workqueue() stalls because this lock is need
to finish the execution of ->wakeup_work (below).
	usb_release_dev:
		#ifdef  CONFIG_USB_SUSPEND
			cancel_delayed_work(&udev->autosuspend);
			flush_workqueue(ksuspend_usb_wq);
		#endif
What is the reason for flush_workqueue() here? _IF_ it is only needed to flush
->autosuspend, we can use cancel_rearming_delayed_work(&udev->autosuspend).
> [  144.137704] ksuspend_usbd D 00400005     0   157      2 (L-TLB)
> [  144.140830]        c2085f18 00000046 9072767a 00400005 c20626f0 c010449b c3182118 c206288c 
> [  144.141011]        c3182120 c3182120 76d728df 0040000a 9072767a 00400005 c3271200 c3182118 
> [  144.144263]        c3182120 00000246 c20626f0 c02ea1c9 00000000 00000000 00000000 00000000 
> [  144.147576] Call Trace:
> [  144.153929]  [<c010449b>] common_interrupt+0x23/0x28
> [  144.157245]  [<c02ea1c9>] __down+0xba/0xc6
> [  144.160528]  [<c011824f>] default_wake_function+0x0/0x9
> [  144.163832]  [<c02664fc>] hcd_resume_work+0x0/0x43
> [  144.167126]  [<c02e9fd3>] __down_failed+0x7/0xc
> [  144.170372]  [<c0266518>] hcd_resume_work+0x1c/0x43
> [  144.173603]  [<c01278cf>] run_workqueue+0x6d/0xdf
> [  144.176780]  [<c0127b4c>] worker_thread+0x0/0xd0
> [  144.179885]  [<c0127b4c>] worker_thread+0x0/0xd0
> [  144.182930]  [<c0127c12>] worker_thread+0xc6/0xd0
> [  144.185964]  [<c012a259>] autoremove_wake_function+0x0/0x35
> [  144.189056]  [<c012a102>] kthread+0x36/0x5c
> [  144.192118]  [<c012a0cc>] kthread+0x0/0x5c
> [  144.195153]  [<c010464b>] kernel_thread_helper+0x7/0x10
Oleg.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/