Date: Fri, 27 May 2005 22:46:40 +0200
From: Michal Schmidt <>
Subject: Re: [patch] Real-Time Preemption, -RT-2.6.12-rc4-V0.7.47-06
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/5/27/229

I wrote:
> I'm attaching a patch which changes a semaphore in cpufreq into a 
> completion. With this patch, my system runs OK even with cpufreqd.
> 
Although the patch worked for me, it was probably bogus.
The real reason why cpufreq caused problems was that it does:
   init_MUTEX_LOCKED(&policy->lock);
and later:
   up(&policy->lock);
where policy->lock is declared as:
   struct semaphore        lock;
In PREEMPT_RT, the init_MUTEX_LOCKED is defined in include/linux/rt_lock.h :
   /*
    * No locked initialization for RT semaphores:
    */
   #define init_MUTEX_LOCKED(sem) compat_init_MUTEX_LOCKED(sem)
(BTW, I don't understand why we have init_MUTEX but no init_MUTEX_LOCKED 
for RT semaphores).
Therefore we have an inconsistency - the up() gets translated into 
rt_up() because the lock is of type struct semaphore. However, 
compat_init_MUTEX_LOCKED assumes that it has a struct compat_semaphore.
The compiler actually warns about incompatible pointers but I missed 
that warning at first.
So the fix is to change the lock type into compat_semaphore. I'm 
attaching the patch. It works for me with 2.6.12-rc5-RT-V0.7.47-12.
Regards
Michal
diff -Nurp -X linux-RT4/Documentation/dontdiff linux-RT4/include/linux/cpufreq.h linux-RT3/include/linux/cpufreq.h
--- linux-RT4/include/linux/cpufreq.h	2005-05-27 22:00:11.000000000 +0200
+++ linux-RT3/include/linux/cpufreq.h	2005-05-27 21:54:52.000000000 +0200
@@ -81,7 +81,7 @@ struct cpufreq_policy {
         unsigned int		policy; /* see above */
 	struct cpufreq_governor	*governor; /* see below */
 
- 	struct semaphore	lock;   /* CPU ->setpolicy or ->target may
+ 	struct compat_semaphore	lock;   /* CPU ->setpolicy or ->target may
 					   only be called once a time */
 
 	struct work_struct	update; /* if update_policy() needs to be