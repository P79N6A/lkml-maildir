Date: Sat, 13 Nov 1999 18:57:47 +0100
From: Martin Dalecki <>
Subject: PATCH for FAT in 2.3.28
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/11/13/64

The following is fixing the compilation of the fat FS as a runtime
loadable
module. I have tested the patch on my ZIP drive. Apparently there is
only
one one other filesystem out there which is using the same partial page
write interface, which appears as a leftover from older VFS versions.
(At least for fat I can't see what the special function was doing
different
then the generic one. At least it didn't touch any special FAT fields in
the inode.)
--
	Marcin Daleckidiff -ur linux/fs/fat/file.c linux-2.3.28/fs/fat/file.c
--- linux/fs/fat/file.c	Sun Nov  7 20:02:22 1999
+++ linux-2.3.28/fs/fat/file.c	Sat Nov 13 05:21:13 1999
@@ -109,46 +109,6 @@
 	return 0;
 }
 
-static int fat_write_partial_page(struct file *file, struct page *page, unsigned long offset, unsigned long bytes, const char * buf)
-{
-	struct dentry *dentry = file->f_dentry;
-	struct inode *inode = dentry->d_inode;
-	struct page *new_page, **hash;
-	unsigned long pgpos;
-	struct page *page_cache = NULL;
-	long status;
-
-	pgpos = MSDOS_I(inode)->i_realsize >> PAGE_CACHE_SHIFT;
-	while (pgpos < page->index) {
-		hash = page_hash(&inode->i_data, pgpos);
-repeat_find:	new_page = __find_lock_page(&inode->i_data, pgpos, hash);
-		if (!new_page) {
-			if (!page_cache) {
-				page_cache = page_cache_alloc();
-				if (page_cache)
-					goto repeat_find;
-				status = -ENOMEM;
-				goto out;
-			}
-			new_page = page_cache;
-			if (add_to_page_cache_unique(new_page,&inode->i_data,pgpos,hash))
-				goto repeat_find;
-			page_cache = NULL;
-		}
-		status = block_write_cont_page(file, new_page, PAGE_SIZE, 0, NULL);
-		UnlockPage(new_page);
-		page_cache_release(new_page);
-		if (status < 0)
-			goto out;
-		pgpos = MSDOS_I(inode)->i_realsize >> PAGE_CACHE_SHIFT;
-	}
-	status = block_write_cont_page(file, page, offset, bytes, buf);
-out:
-	if (page_cache)
-		page_cache_free(page_cache);
-	return status;
-}
-
 ssize_t fat_file_write(
 	struct file *filp,
 	const char *buf,
@@ -171,7 +131,7 @@
 	int retval;
 
 	retval = generic_file_write(filp, buf, count, ppos,
-					fat_write_partial_page);
+					block_write_partial_page);
 	if (retval > 0) {
 		inode->i_mtime = inode->i_ctime = CURRENT_TIME;
 		MSDOS_I(inode)->i_attrs |= ATTR_ARCH;