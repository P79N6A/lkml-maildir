Date: Thu, 22 Jan 2009 09:34:57 +0100
From: Ingo Molnar <>
Subject: Re: [PATCH v2] softlockup: remove hung_task_check_count
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2009/1/22/42

* Mandeep Singh Baines <msb@google.com> wrote:
> > do the need_resched() check first (it's very lighweight) - and thus 
> > only do the heavy ops (get-task-struct & tasklist_lock unlock) if that 
> > is set?
> 
> Wanted to upper-bound the amount of time the lock is held. In order to 
> give others a chance to write_lock the tasklist, released the lock 
> regardless of whether a re-schedule is need.
but this:
> +static void check_hung_reschedule(struct task_struct *t)
> +{
> +	get_task_struct(t);
> +	read_unlock(&tasklist_lock);
> +	if (need_resched())
> +		schedule();
> +	read_lock(&tasklist_lock);
> +	put_task_struct(t);
> +}
does not actually achieve that. Releasing a lock does not mean that other 
CPUs will immediately be able to get it - if the ex-owner quickly 
re-acquires it then it will often succeed in doing so. Perhaps adding a 
cpu_relax() would increase the chance ... but still, it looks a bit weird.
	Ingo