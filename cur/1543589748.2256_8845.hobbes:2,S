Date: Wed, 2 May 2001 20:32:45 +0200 (CEST)
From: Mikulas Patocka <>
Subject: Re: How can do to disable the L1 cache in linux ?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2001/5/2/142

> Dear All,
>  How can do to disable the L1 cache in linux ?
> Are there some commands or directives to disable it ??
I wrote this some times ago when playing with caches. Compile cctlmod.c as
a module, insert it to kernel, and use con and coff to enable and disable
caches. 
Note that the code is quite old, maybe it doesn't work with 2.4 kernels,
and I don't want support it. If it doesn't work, fix it yourself. 
Mikulas
#include <errno.h>
#include <asm/unistd.h>
#define __NR_disable_cache	250
#define __NR_enable_cache	251
#define __NR_disable_cache_wt	252
#define __NR_disable_page_cache	253
#define __NR_enable_page_cache	254
_syscall0(int, disable_cache)
_syscall0(int, enable_cache)
_syscall0(int, disable_cache_wt)
_syscall1(int, disable_page_cache, void *, page)
_syscall1(int, enable_page_cache, void *, page)
#define MODULE
#define __KERNEL__
#include <linux/autoconf.h>
#include <linux/module.h>
#include <linux/modversions.h>
#include <linux/mm.h>
#include <linux/sched.h>
#include <asm/pgtable.h>
extern void *sys_call_table[];
flush_t()
{
	__asm__ __volatile__ (
		"movl %%cr3, %%eax\n\t"
		"movl %%eax, %%cr3\n\t"
		:::"ax", "cc");
}
disable_cache()
{
	__asm__ __volatile__ (
		"cli\n\t"
		"movl %%cr0, %%eax\n\t"
		"orl $0x60000000, %%eax\n\t"
		"movl %%eax, %%cr0\n\t"
		"wbinvd\n\t"
		"sti\n\t"
		:::"ax", "cc");
	return 0;
}
enable_cache()
{
	__asm__ __volatile__ (
		"cli\n\t"
		"movl %%cr0, %%eax\n\t"
		"andl $0x9fffffff, %%eax\n\t"
		"movl %%eax, %%cr0\n\t"
		"wbinvd\n\t"
		"sti\n\t"
		:::"ax", "cc");
	return 0;
}
disable_cache_wt()
{
	__asm__ __volatile__ (
		"cli\n\t"
		"movl %%cr0, %%eax\n\t"
		"andl $0xdfffffff, %%eax\n\t"
		"orl $0x40000000, %%eax\n\t"
		"movl %%eax, %%cr0\n\t"
		"wbinvd\n\t"
		"sti\n\t"
		:::"ax", "cc");
	return 0;
}
disable_page_cache(unsigned long pg)
{
	pte_t *pte = pte_offset(pmd_offset(pgd_offset(current->mm, pg), pg), pg);
	*(unsigned *)pte |= 0x18;
	flush_t();
	return 0;
}
enable_page_cache(unsigned long pg)
{
	pte_t *pte = pte_offset(pmd_offset(pgd_offset(current->mm, pg), pg), pg);
	*(unsigned *)pte &= ~0x18;
	flush_t();
	return 0;
}
init_module()
{
	sys_call_table[250] = disable_cache;
	sys_call_table[251] = enable_cache;
	sys_call_table[252] = disable_cache_wt;
	sys_call_table[253] = disable_page_cache;
	sys_call_table[254] = enable_page_cache;
	return 0;
}
cleanup_module()
{
	sys_call_table[250] = sys_call_table[251] = sys_call_table[252] = 0;
	sys_call_table[253] = sys_call_table[254] = 0;
}
#include "cctl.h"
main()
{
	if (enable_cache()) perror("enable_cache"), exit(1);
	return 0;
}
#include "cctl.h"
main()
{
	if (disable_cache()) perror("disable_cache"), exit(1);
	return 0;
}