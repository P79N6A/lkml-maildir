Date: Wed, 19 Oct 2005 00:10:09 -0700 (PDT)
From: Zwane Mwaikambo <>
Subject: Re: i386 nmi_watchdog: Merge check_nmi_watchdog fixes from x86_64
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/10/19/18

On Tue, 18 Oct 2005, Eric W. Biederman wrote:
> Andy Isaacson <adi@hexapodia.org> writes:
> 
> > +static __init void nmi_cpu_busy(void *data)
> > +{
> > +	volatile int *endflag = data;
> > +	local_irq_enable();
> > +	while (*endflag == 0)
> > +		barrier();
> > +}
> >  static int __init check_nmi_watchdog(void)
> >  {
> > +	volatile int endflag = 0;
> > ...
> > +	if (nmi_watchdog == NMI_LOCAL_APIC)
> > +		smp_call_function(nmi_cpu_busy, (void *)&endflag, 0, 0);
> > ...
> > +	endflag = 1;
> > 	printk("OK.\n");
> >         if (nmi_watchdog == NMI_LOCAL_APIC)
> > 		nmi_hz = 1;
> > +       kfree(prev_nmi_count);
> > 	return 0;
> > }
> 
> Probably a counter, to ensure the code exits.  The code prints
Why not just use the 'wait' variable to smp_call_function to at least 
ensure that the lifetime of endflag isn't exceeded? Something like;
static __init void nmi_cpu_busy(void *data)
{
	volatile int *endflag = data;
	local_irq_enable();
	while (*endflag == 0) {
		cpu_relax();
		rmb();
	}
}
static int __init check_nmi_watchdog(void)
{
	volatile int endflag = 0;
...
	if (nmi_watchdog == NMI_LOCAL_APIC)
		smp_call_function(nmi_cpu_busy, (void *)&endflag, 0, 1);
...
	endflag = 1;
	wmb();
Thanks,
	Zwane
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/