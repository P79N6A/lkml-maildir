Date: Mon, 13 Jun 2005 15:30:47 +0200
From: quade <>
Subject: latency error (~2ms) with nanosleep
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/6/13/80

Playing around with the (simple) measurement of latency-times
I noticed, that the systemcall "nanosleep" has always a minimal
latency from about ~2ms (haven't run it all night, so...). It
seems to be a systematical error.
A short investigation shows, that "sys_nanosleep()" uses
schedule_timeout(), but schedule_timeout() is working exactly
as expected. Therefore I think it has something to do with
the scheduling?
Has someone an explanation for the ~2ms error?
If it is indeed a systematical error, does it make sense to
"adjust" (correct) this error in the systemcall "sys_nanosleep()"?
Find attached my small test program.
Juergen.
#include <stdio.h>
#include <time.h>
#include <sched.h>
#include <sys/time.h>
#define TAKTFREQ  600
static inline unsigned long long int rdtsc()
{
	unsigned long long int x;
	__asm__ volatile (".byte 0x0f, 0x31" : "=A" (x));
	return x;
}
// XXX - I know, there can be an overrun ...
static inline unsigned long time_in_usec( struct timeval *tv )
{
	return (tv->tv_sec*1000000)+tv->tv_usec;
}
int main( int argc, char **argv )
{
	int i;
	struct timespec delay;
	struct timeval tvstart, tvend;
	unsigned long start, end, timediff, maxdiff, shouldbetime;
	unsigned long mindiff;
#if 1
	struct sched_param SchedulingParameter;
	SchedulingParameter.sched_priority = 50;
	if( sched_setscheduler( 0, SCHED_RR, &SchedulingParameter )!= 0 ) {
		perror( "Set Scheduling Priority" );
		return -1;
	}
#endif
	for( shouldbetime=1000; shouldbetime<51000;shouldbetime+=1000 ) {
		mindiff = 0xffffffff;
		maxdiff = 0;
		for( i=0; i<30; i++ ) {
			delay.tv_sec  = 0;
			delay.tv_nsec = shouldbetime*1000; // in nsec
			gettimeofday(&tvstart,NULL);
			start = rdtsc();
			nanosleep( &delay, NULL );
			end = rdtsc();
			gettimeofday(&tvend,NULL);
#if 0
			printf("timdiff: %ld - %ld\n",
				(end-start)/TAKTFREQ,  // 600 MHz - in usec
				time_in_usec(&tvend)-time_in_usec(&tvstart));
#endif
			timediff = time_in_usec(&tvend)-time_in_usec(&tvstart);
			timediff -= shouldbetime;
			if( (timediff > maxdiff)&&i>0 )
				maxdiff = timediff;
			if( (timediff < mindiff)&&i>0 )
				mindiff = timediff;
		}
		//printf("%7.1ld-> max diff: %ld\n", shouldbetime, maxdiff );
		printf("%7.1ld %ld %ld\n", shouldbetime, maxdiff, mindiff );
	}
	return 0;
}