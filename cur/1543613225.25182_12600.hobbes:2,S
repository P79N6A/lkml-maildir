Date: Thu, 13 Dec 2001 05:25:53 +0100 (CET)
From: Christer Weinigel <>
Subject: Asking for opinions on GPIO API
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2001/12/12/151

Hi,
I'm working on a small embedded computer based on the National
Semiconductor SC2200 CPU.  This CPU has a lot of GPIO pins and I'm
wondering how to design a good API to control these pins.
Right now I have a few functions looking like this:
/* read the input from the GPIO and return 1/0 */
unsigned sc2200_gpio_get(unsigned index);
/* set and clear the pin */
void sc2200_gpio_set(unsigned index);
void sc2200_gpio_clr(unsigned index);
would it be better to have a function which takes the desired state of
the pin as an argument instead?
void sc2200_gpio_set(unsigned index, unsigned state);
Second, I have a pure implementation question, right now the set
function looks like this:
void sc2200_gpio_set(unsigned index) {
        unsigned flags;
        spin_lock_irqsave(&sc2200_gpio_lock, flags);
        outl(inl(gpio_base) | (1 << (index & 31)), gpio_base);
        spin_unlock_irqrestore(&sc2200_gpio_lock, flags);
}
which is safe, but clearing the interrupts is a rather expensive
operation, so I'd like to avoid it if possible.  Is it possible to do
something like the atomic set_bit function but with outl/inl?  Are
there any tricks that can be done?  Since the SC2200 is an ix86 CPU I
can use assembly language if neccesary and at least for this design, I
know that the system is a uniprocessor system and thus I won't have to
consider possible races between two CPU's.
    /Christer
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/