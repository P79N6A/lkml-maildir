Date: Wed, 4 Apr 2007 16:04:02 +0200
From: "Dmitry Adamushko" <>
Subject: [sched] redundant reschedule when set_user_nice() boosts a prio of a task from the "expired" array
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/4/4/207

Hello,
Scenario:
Currently running [task1] boosts a priority (lowers a static_prio) of
[task2] via { setpriority -> set_user_nice } and [task2] happens to be
in the "expired" array at the moment.
According to the set_user_nice(), "delta" is negative (the prio is
boosted) and, hence, resched_task(rq->curr) is called.
As the [task2] is in the "expired" array and there are still tasks (at
least [task1]) in the "active" one, the triggered reschedule is just
useless (e.g. gets control back to [task1]).
Am I missing something?
The same is applicable to rt_mutex_setprio().
Of course, not a big deal, but it's easily avoidable, e.g. (delta < 0
&& array == rq->active).
Thanks in advance for any comments.
-- 
Best regards,
Dmitry Adamushko
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/