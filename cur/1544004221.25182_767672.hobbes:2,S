Date: Tue, 11 Nov 2008 21:59:05 +0100
From: Oleg Nesterov <>
Subject: [PATCH] workqueues: kill cpu_singlethread_map, use get_cpu_mask() instead
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/11/11/314

Now that we have cpu_bit_bitmap[] we don't need cpu_singlethread_map, we
can use get_cpu_mask(singlethread_cpu) directly.
Signed-off-by: Oleg Nesterov <oleg@redhat.com>
--- K-28/kernel/workqueue.c~WQ_KILL_ST_MAP	2008-11-11 21:06:20.000000000 +0100
+++ K-28/kernel/workqueue.c	2008-11-11 21:37:46.000000000 +0100
@@ -73,7 +73,6 @@ static DEFINE_SPINLOCK(workqueue_lock);
 static LIST_HEAD(workqueues);
 
 static int singlethread_cpu __read_mostly;
-static cpumask_t cpu_singlethread_map __read_mostly;
 /*
  * _cpu_down() first removes CPU from cpu_online_map, then CPU_DEAD
  * flushes cwq->worklist. This means that flush_workqueue/wait_on_work
@@ -92,7 +91,7 @@ static inline int is_single_threaded(str
 static const cpumask_t *wq_cpu_map(struct workqueue_struct *wq)
 {
 	return is_single_threaded(wq)
-		? &cpu_singlethread_map : &cpu_populated_map;
+		? get_cpu_mask(singlethread_cpu) : &cpu_populated_map;
 }
 
 static
@@ -980,7 +979,6 @@ void __init init_workqueues(void)
 {
 	cpu_populated_map = cpu_online_map;
 	singlethread_cpu = first_cpu(cpu_possible_map);
-	cpu_singlethread_map = cpumask_of_cpu(singlethread_cpu);
 	hotcpu_notifier(workqueue_cpu_callback, 0);
 	keventd_wq = create_workqueue("events");
 	BUG_ON(!keventd_wq);