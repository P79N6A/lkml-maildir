Date: Sat, 9 Feb 2008 11:42:17 +0000
From: Carlos Corbacho <>
Subject: Re: [GIT PATCH] ACPI patches for 2.6.25-rc0 (#2)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/2/9/73

On Saturday 09 February 2008 06:19:36 Ingo Molnar wrote:
> (Carlos Cc:-ed too)
>
> * Ingo Molnar <mingo@elte.hu> wrote:
> > * Len Brown <lenb@kernel.org> wrote:
> > > Len Brown (6):
> > >       ACPI: add newline to printk
> > >       ACPI: build WMI on X86 only
> > >       acer-wmi, tc1100-wmi: select ACPI_WMI
> >
> > hm, this new WMI code caused a bootup crash in the overnight x86.git
> > tests:
I suspect this is a problem on systems without ACPI-WMI in the DSDT - though I 
can't reproduce this here on my other box that lacks ACPI-WMI.
Ingo, can you try the patch below and see if this cures it?
---
ACPI: WMI: Fix crash on WMI free systems
From: Carlos Corbacho <carlos@strangeworlds.co.uk>
We have two pointers in the find_guid() code that aren't checked before
we use them. On ACPI-WMI free systems, this can sometimes cause a crash if
another driver tries to use any of the methods provided by WMI.
Also throw in an extra early check to see if the GUID list is empty, so we
can try to bail out before reaching this code as well.
Spotted by Ingo Molnar.
Signed-off-by: Carlos Corbacho <carlos@strangeworlds.co.uk>
CC: Ingo Molnar <mingo@elte.hu>
CC: Linus Torvalds <torvalds@linux-foundation.org>
CC: Andrew Morton <akpm@linux-foundation.org>
CC: Len Brown <lenb@kernel.org>
---
 drivers/acpi/wmi.c |    8 ++++++++
 1 files changed, 8 insertions(+), 0 deletions(-)
diff --git a/drivers/acpi/wmi.c b/drivers/acpi/wmi.c
index 36b84ab..b54e734 100644
--- a/drivers/acpi/wmi.c
+++ b/drivers/acpi/wmi.c
@@ -201,12 +201,20 @@ static bool find_guid(const char *guid_string, struct wmi_block **out)
 	struct guid_block *block;
 	struct list_head *p;
 
+	if (list_empty(&wmi_blocks.list))
+		return 0;
+
 	wmi_parse_guid(guid_string, tmp);
 	wmi_swap_bytes(tmp, guid_input);
 
 	list_for_each(p, &wmi_blocks.list) {
 		wblock = list_entry(p, struct wmi_block, list);
+		if (!wblock)
+			return 0;
+
 		block = &wblock->gblock;
+		if (!block)
+			return 0;
 
 		if (memcmp(block->guid, guid_input, 16) == 0) {
 			if (out)
-- 
E-Mail: carlos@strangeworlds.co.uk
Web: strangeworlds.co.uk
GPG Key ID: 0x23EE722D