Date: Tue, 10 Sep 2002 03:07:00 +0200
From: Daniel Phillips <>
Subject: Re: invalidate_inode_pages in 2.5.32/3
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2002/9/9/298

On Tuesday 10 September 2002 01:51, Chuck Lever wrote:
> On Tue, 10 Sep 2002, Daniel Phillips wrote:
> > On Tuesday 10 September 2002 00:03, Andrew Morton wrote:
> > > But there are
> > > apparently reasons why NFS cannot sleepingly lock pages in this
> > > particular context.
> >
> > If only we knew what those were.  It's hard to keep the word 'bogosity'
> > from popping into my head.
> 
> rpciod must never call a function that sleeps.  if this happens, the whole
> NFS client stops working until the function wakes up again.  this is not
> really bogus -- it is similar to restrictions placed on socket callbacks.
Ah, a warm body with answers :-)
It *sounds* bogus: why should we be satisfied with a function that doesn't
do its job reliably (invalidate_inode_pages) in order to avoid coming up
with a way of keeping the client daemon from blocking?  How about having
invalidate_inode_pages come back with "sorry boss, I couldn't complete the
job so I started as much IO as I could and I'm back now, try again later"?
> async RPC tasks (ie, the rpciod process) invokes invalidate_inode_pages
> during normal, everyday processing, so it must not sleep.  that's why it
> today ignores locked pages.
OK, that's half the job, the other half is to know that something's been
ignored, and get back to it later.  Either there is a valid reason for 
getting rid of these pages or there isn't, and if there is a valid reason,
then getting rid of only some of them must surely leave the door wide
open to strange misbehaviour.
> thus:
> 
> 1.  whatever function purges a file's cached data must not sleep when
>     invoked from an async RPC task.
[otherwise other tasks using the client will stall needlessly]
>     ...likewise, such a function must not
>     sleep if the caller holds the file's i_sem.
> 
> 2.  access to the file must be serialized somehow with in-flight I/O
>     (locked pages).  we don't want to start new reads before all dirty
>     pages have been flushed back to the server.  dirty pages that have
>     not yet been scheduled must be dealt with correctly.
State machine!
> 3.  mmap'd pages must behave reasonably when a file's cache is purged.
>     clean pages should be faulted back in.  what to do with dirty mmap'd
>     pages?
I don't know, sorry.  What?
You've probably been through this before, but could you please explain
the ground rules behind the cache purging strategy?
-- 
Daniel
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/