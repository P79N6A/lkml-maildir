Date: Tue, 06 Nov 2007 11:07:12 +0900
From: OGAWA Hirofumi <>
Subject: Re: [PATCH 2/2] fat: optimize fat_count_free_clusters()
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/11/5/371

Andrew Morton <akpm@linux-foundation.org> writes:
>> +/* 128kb is the whole sectors for FAT12 and FAT16 */
>> +#define FAT_READA_SIZE		(128 * 1024)
>> +
>> +static void fat_ent_reada(struct super_block *sb, struct fat_entry *fatent,
>> +			  unsigned long reada_blocks)
>> +{
>> +	struct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;
>> +	sector_t blocknr;
>> +	int i, offset;
>> +
>> +	ops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);
>> +
>> +	for (i = 0; i < reada_blocks; i++)
>> +		sb_breadahead(sb, blocknr + i);
>> +}
>
> You might find that it's simpler and faster to call
> page_cache_sync_readahead() against sb->s_bdev->bd_inode->i_mapping.
>
> Or maybe not - that requires a struct file_ra_state.  We _used_ to have a
> nice simple read-some-stuff-into-pagecache function which didn't need an
> ra_state but that seems to have disappeared in the various recent readahead
> churn.  Oh well.
Yes. I found it, but I gave up for now by file_ra_state. Also I'd like
to use a large block to read FAT.  I'll rethink this code after large
block was merged.
Thanks.
-- 
OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/