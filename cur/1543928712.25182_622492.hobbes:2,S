Date: Thu, 29 Nov 2007 14:24:05 +0100
From: "Vegard Nossum" <>
Subject: Re: [RFC] kmemcheck: trap uses of uninitialized memory (v2)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/11/29/143

On 29 Nov 2007 11:29:48 +0100, Andi Kleen <andi@firstfloor.org> wrote:
> Vegard Nossum <vegard.nossum@gmail.com> writes:
> >
> > - We properly flush TLB entries that change. This used to not be the case, and so we
>
> For low values of "properly" @)
>
> > +     pte = lookup_address(addr);
> > +     change_page_attr(page, 1, __pgprot(pte->pte_low | _PAGE_VISIBLE));
> > +     __flush_tlb_one(addr);
>
> That's not enough, you need to flush all CPUs.
>
> Also when you don't call global_flush_tlb() eventually because c_p_a() will leak flush
> objects over time.
We don't need to flush all CPUs. This is my rationale: The debug
exception (single-step trap) will always happen on the same CPU that
the page fault occurred on. Page fault shows the page, debug exception
hides the page again. Between those two operations, nothing else can
happen that will use the TLB entry in question (unless you have some
weird race condition, but then the code is in error anyway).
What is c_p_a() and what is a flush object?
>
> -Andi
>
Vegard
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/