Date: Mon, 2 Apr 2007 20:56:07 +0200
From: Ingo Molnar <>
Subject: Re: [RFC] Cpu-hotplug: Using the Process Freezer (try2)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/4/2/278

* Srivatsa Vaddagiri <vatsa@in.ibm.com> wrote:
> flush_workqueue() <- One of biggest offenders of lock_cpu_hotplug() to date
> 	for_each_online_cpu(cpu)
> 		flush_cpu_workqueue
> 			TASK_UNINTERRUPTIBLE sleep
> 
> If we don't wait for this thread from being frozen "voluntarily" 
> (because it is in TASK_UNINTERRUPTIBLE sleep), then flush_workqueue is 
> clearly racy wrt cpu hotplug.
ok. But the only real problem would be for_each_online_cpu() loops that 
might sleep, correct? I did a quick audit and those seem to be in the 
minority by a factor of 1:10.
So ... to make the audit obviously safe, how about mechanically 
converting 100% of the for_each_online_cpu() loops to something like:
	mask = get_each_online_cpu_mask();
	for_each_cpu_mask(mask) {
		...
	}
	put_each_online_cpu_mask(mask);
where get_each_online_cpu_mask() also does a preempt_disable() 
implicitly, and put_each_online_cpu_mask() does a preempt_enable(). 
(Note that no locking is needed - only preemption-disabling.)
the 10% loops that _can_ schedule would trigger the __might_sleep() 
atomicity test in schedule()), and those would have to be converted a 
bit more cleverly, on a case by case basis. (for example a number of 
them might not even have to sleep on the for_each_online_cpu() loop)
hm?
	Ingo
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/