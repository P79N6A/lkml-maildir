Date: Tue, 29 Apr 2008 21:25:56 +0200
From: Jens Axboe <>
Subject: Re: [PATCH] Optimize lock in queue unplugging
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/4/29/534

On Tue, Apr 29 2008, Mikulas Patocka wrote:
> Hi
> 
> Mike Anderson was doing an OLTP benchmark on a computer with 48 physical 
> disks mapped to one logical device via device mapper.
> 
> He found that there was a slowdown on request_queue->lock in function 
> generic_unplug_device. The slowdown is caused by the fact that when some 
> code calls unplug on the device mapper, device mapper calls unplug on all 
> physical disks. These unplug calls take the lock, find that the queue is 
> already unplugged, release the lock and exit.
> 
> With the below patch, performance of the benchmark was increased by 18% 
> (the whole OLTP application, not just block layer microbenchmarks).
> 
> So I'm submitting this patch for upstream. I think the patch is correct, 
> because when more threads call simultaneously plug and unplug, it is 
> unspecified, if the queue is or isn't plugged (so the patch can't make 
> this worse). And the caller that plugged the queue should unplug it 
> anyway. (if it doesn't, there's 3ms timeout).
Where were these unplug calls coming from? The block layer will
generally only unplug when it is already unplugged, so if you are seeing
so many unplug calls that the patch redues overhead by as much
described, perhaps the callsite is buggy?
-- 
Jens Axboe