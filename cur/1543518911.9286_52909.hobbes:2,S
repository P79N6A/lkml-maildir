Date: Sun, 12 Dec 1999 06:51:58 -0500 (EST)
From:  afei@jhu ...
Subject: question again about ext2 fs/ext2/namei.c
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/12/12/36

I did not see any implementation in ext2_find_entry of forward
compatibility hooks for B-tree directories in fs/ext2/namei.c
From what I read, it simply scans the the block and the read ahead blocks
to find the directory entry. There is no B-tree involved
So what I am missing here, or B-tree directory is used somewhere else?
Thank you.
Fei
/*
 *  linux/fs/ext2/namei.c
 *
 * Copyright (C) 1992, 1993, 1994, 1995
 * Remy Card (card@masi.ibp.fr)
 * Laboratoire MASI - Institut Blaise Pascal
 * Universite Pierre et Marie Curie (Paris VI)
 *
 *  from
 *
 *  linux/fs/minix/namei.c
 *
 *  Copyright (C) 1991, 1992  Linus Torvalds
 *
 *  Big-endian to little-endian byte-swapping/bitmaps by
 *        David S. Miller (davem@caip.rutgers.edu), 1995
 *  Directory entry file type support and forward compatibility hooks
 *     for B-tree directories by Theodore Ts'o (tytso@mit.edu), 1998
 */
static struct buffer_head * ext2_find_entry (struct inode * dir,
                    const char *  const name, int namelen,
                    struct ext2_dir_entry_2 ** res_dir)
{
   struct super_block * sb;
   struct buffer_head * bh_use[NAMEI_RA_SIZE];
   struct buffer_head * bh_read[NAMEI_RA_SIZE];
   unsigned long offset;
   int block, toread, i, err;
   *res_dir = NULL; 
   sb = dir->i_sb;
   if (namelen > EXT2_NAME_LEN)
      return NULL; 
   memset (bh_use, 0, sizeof (bh_use));
   toread = 0;
   for (block = 0; block < NAMEI_RA_SIZE; ++block) {
      struct buffer_head * bh;
      if ((block << EXT2_BLOCK_SIZE_BITS (sb)) >= dir->i_size)
         break; 
      bh = ext2_getblk (dir, block, 0, &err);
      bh_use[block] = bh;
      if (bh && !buffer_uptodate(bh))
         bh_read[toread++] = bh;
   }
   for (block = 0, offset = 0; offset < dir->i_size; block++) {
      struct buffer_head * bh;
      struct ext2_dir_entry_2 * de;
      char *  dlimit;
      if ((block % NAMEI_RA_BLOCKS) == 0 && toread) {
         ll_rw_block (READ, toread, bh_read);
         toread = 0;
      }
      bh = bh_use[block % NAMEI_RA_SIZE];
      if (!bh) {
#if  0
         ext2_error (sb, "ext2_find_entry",
                "directory #%lu contains a hole at offset %lu",
                dir->i_ino, offset);
#endif 
         offset += sb->s_blocksize;
         continue; 
      }
      wait_on_buffer (bh);
      if (!buffer_uptodate(bh)) {
         /*
          * read error: all bets are off
          */
         break; 
      }
      de = (struct ext2_dir_entry_2 *) bh->b_data;
      dlimit = bh->b_data + sb->s_blocksize;
      while ((char * ) de < dlimit) {
         /* this code is executed quadratically often */
         /* do minimal checking `by hand' */
         int de_len;
         if ((char * ) de + namelen <= dlimit &&
             ext2_match (namelen, name, de)) {
            /* found a match -
               just to be sure, do a full check */
            if (!ext2_check_dir_entry("ext2_find_entry",
                       dir, de, bh, offset))
               goto failure;
            for (i = 0; i < NAMEI_RA_SIZE; ++i) {
               if (bh_use[i] != bh)
                  brelse (bh_use[i]);
            }
            *res_dir = de;
            return bh;
         }
         /* prevent looping on a bad block */
         de_len = le16_to_cpu(de->rec_len);
         if (de_len <= 0)
            goto failure;
         offset += de_len;
         de = (struct ext2_dir_entry_2 *)
            ((char * ) de + de_len);
      }
      brelse (bh);
      if (((block + NAMEI_RA_SIZE) << EXT2_BLOCK_SIZE_BITS (sb)) >=
          dir->i_size)
         bh = NULL; 
      else 
         bh = ext2_getblk (dir, block + NAMEI_RA_SIZE, 0, &err);
      bh_use[block % NAMEI_RA_SIZE] = bh;
      if (bh && !buffer_uptodate(bh))
         bh_read[toread++] = bh;
   }
failure:
   for (i = 0; i < NAMEI_RA_SIZE; ++i)
      brelse (bh_use[i]);
   return NULL; 
}
 *~~~~~~~~~~~~~~~~~~~~~+_____________________+~~~~~~~~~~~~~~~~~~~*
 *  Email:afei@jhu.edu | WWW:   
http://aa.eps.jhu.edu/~feiliu
    *
  *  (410)889-9876(H)  | Johns Hopkins Univ. | (410)516-7047(O) *
   *-------------------+_____________________+-----------------*
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/