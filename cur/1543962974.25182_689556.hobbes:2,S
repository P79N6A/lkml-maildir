Date: Mon, 5 May 2008 11:18:09 +0100
From: Ralf Baechle <>
Subject: Re: [PATCH v2] unify sys_pipe implementation
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/5/5/150

On Mon, May 05, 2008 at 10:30:09AM +0200, DM wrote:
> >  + * sys_pipe() is the normal C calling standard for creating
> >  + * a pipe. It's not the way Unix traditionally does this, though.
> >  + */
> >  +asmlinkage long sys_pipe(int __user *fildes)
> >  +{
> >  +       int fd[2];
> >  +       int error;
> >  +
> >  +       error = do_pipe(fd);
> >  +       if (!error) {
> >  +               if (copy_to_user(fildes, fd, sizeof(fd)))
> >  +                       error = -EFAULT;
> >  +       }
> >  +       return error;
> >  +}
> >  +
> [...]
> 
> I realize this code is old, but wouldn't file descriptors leak if
> copy_to_user fails?
The MIPS implementation doesn't have this problem; it returns the
file descriptors in the result registers $v0 and $v1.
But an interesting catch after so many years!
  Ralf