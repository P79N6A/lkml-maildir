Date: Wed, 19 May 1999 22:36:51 +0100 (GMT)
From: Tim Waugh <>
Subject: [PATCH] Re: Please test: New TGA Framebuffer Driver
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/5/22/8

On Wed, 19 May 1999, Martin Lucina wrote:
> As far as a fast_memmove() for Alpha goes, you said you were using a
> hacked memcpy and this is probably what we should do (and maybe
> install it as the global one) unless someone else wants to write a
> real one.
Here's a patch against 2.3.3.  This should get rid of the stalling when
doing ncurses stuff on a TGA console.
It's untested, but it compiles.  I'm compiling a kernel with it now, but
it's compiling over NFS, with 32Mb and no swap, so things are progressing
slowly.
As I say, I hacked together something like this the other day and it
worked.
Tim.
*/
--- linux-2.3.3/arch/alpha/lib/memcpy.c	Tue Apr  7 16:05:05 1998
+++ linux/arch/alpha/lib/memcpy.c	Wed May 19 16:55:50 1999
@@ -116,3 +116,80 @@
 
 /* For backward modules compatibility, define __memcpy.  */
 asm("__memcpy = memcpy; .globl __memcpy");
+
+/* memmove.  This can be optimised some more. */
+static void __memmove_aligned (void *dest, const void *src, size_t n)
+{
+	size_t c;
+	unsigned long *s, *d;
+
+	if (dest <= src) {
+		while (((unsigned long) dest) & 7) {
+			if (n <= 0) return;
+			n--;
+			* (char *) dest++ = * (char *) src++;
+		}
+
+		c = n / 8;
+		s = (unsigned long *) src;
+		d = (unsigned long *) dest;
+		while (c--)
+			*d++ = *s++;
+
+		dest = d;
+		src = s;
+		n %= 8;
+		while (n--)
+			* (char *) dest++ = * (char *) src++;
+
+		return;
+	}
+
+	dest += n;
+	src += n;
+	while (((unsigned long) dest) & 7) {
+		if (n <= 0) return;
+		n--;
+		* (char *) --dest = * (char *) --src;
+	}
+
+	c = n / 8;
+	s = (unsigned long *) src;
+	d = (unsigned long *) dest;
+	while (c--)
+		*--d = *--s;
+
+	n %= 8;
+	dest = d;
+	src = s;
+	while (n--)
+		* (char *) --dest = * (char *) --src;
+}
+
+static void __memmove_unaligned (void *dest, const void *src, size_t n)
+{
+	/* No optimisation. */
+	char *d, *s;
+	if (dest <= src) {
+		d = (char *) dest;
+		s = (char *) src;
+		while (n--)
+			*d++ = *s++;
+		return;
+	}
+
+	d = (char *) dest + n;
+	s = (char *) src + n;
+	while (n--)
+		*--d = *--s;
+}
+
+void *memmove (void *dest, const void *src, size_t n)
+{
+	if (!(((unsigned long) dest ^ (unsigned long) src) & 7)) {
+		__memmove_aligned (dest, src, n);
+		return dest;
+	}
+	__memmove_unaligned (dest, src, n);
+	return dest;
+}
--- linux-2.3.3/include/asm-alpha/string.h	Sun Aug  9 20:09:06 1998
+++ linux/include/asm-alpha/string.h	Wed May 19 22:24:36 1999
@@ -43,6 +43,7 @@
 #define __HAVE_ARCH_STRCHR
 #define __HAVE_ARCH_STRRCHR
 #define __HAVE_ARCH_STRLEN
+#define __HAVE_ARCH_MEMMOVE
 
 /* The following routine is like memset except that it writes 16-bit
    aligned values.  The DEST and COUNT parameters must be even for 
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/