Date: Tue, 23 Feb 1999 08:04:48 EST
From: "geisj" <>
Subject: 2.0.36 and socket not connect and running out of file descriptors
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/2/23/69

I am using slackware 3.5 and 2.0.36. The enclosed code
below is trying to open a terminal server (every minute
until it is successfully opened) at a given
IP and port. The code works if the connection is there
to be made. HOWEVER, if the connection is not there 
the connect() call fails and DisablePort is called.
DisablePort() calls shutdown and close(). shutdown()
returns an error of ENOTCONN (which I expect). 
The problem I have is my code keeps trying to open the 
connection once a minute. Every time I try to open the
connection the file descriptors keep getting used up until 
eventually I run out.
Is there something else I need to do to cleanup the failed
connection? Or is this a kernel problem?
The DIAGNOSTIC_LOG() functions just open up a file and write
the text passed into a file. Yes I fclose() the file handle
for that when I am done.
Thanks for the information.
Please CC me directly.
Jerry Geis
geisj@pagestation.com
----------- code ---------
unsigned int port = hw_ptr->term_port + hw_ptr->comm_port;
struct in_addr *ptr;
struct sockaddr_in tserver_addr;
struct hostent *server_info;            /* server information */
char address[20];
MaskWakeUpSignal();			/* need to avoid EINTR */
/* lookup server in and get the address */
server_info = gethostbyname(hw_ptr->term_ip);
if(server_info == NULL)
        {
        DIAGNOSTIC_LOG_2("No server information for terminal server %s IP: %s", hw_ptr->node_name, hw_ptr->term_ip);
        return(-1);
        }
ptr = (struct in_addr *) *server_info->h_addr_list;
strcpy(address, (char *) inet_ntoa((struct in_addr) *ptr));
DIAGNOSTIC_LOG_4("Opening terminal server %s name:%s address:%s port:x%04x", hw_ptr->node_name, server_info->h_name, address, port);
memset(&tserver_addr, 0, sizeof(tserver_addr));
tserver_addr.sin_family = AF_INET;
tserver_addr.sin_addr.s_addr = inet_addr(address);
tserver_addr.sin_port = htons(port);
DIAGNOSTIC_MESSAGE_3("Waiting on socket %s %s using port x%04x", hw_ptr->node_name, hw_ptr->term_ip, port);
if((hw_ptr->fd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
        {
        DIAGNOSTIC_LOG_3("Socket error %d for %s %s", errno, hw_ptr->node_name, hw_ptr->term_ip);
        return(-1);
        }
DIAGNOSTIC_MESSAGE_2("Waiting on connect %s %s", hw_ptr->node_name, hw_ptr->term_ip);
if(connect(hw_ptr->fd, (struct sockaddr *) &tserver_addr, sizeof(tserver_addr)) < 0)
        {
        DisablePort(hw_ptr, FALSE);
        DIAGNOSTIC_LOG_4("Connect error %d for %s node %s port x%04x.", errno, hw_ptr->term_ip, hw_ptr->node_name, hw_ptr->term_port + hw_ptr->comm_port);
        return(-1);
        }
return(hw_ptr->fd);
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/