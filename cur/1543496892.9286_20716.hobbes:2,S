Date: Wed, 26 May 1999 19:45:15 +0800 (CST)
From: dinon <>
Subject: Re: linux-kernel-digest V1 #3852
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/5/28/150

On Mon, 24 May 1999 owner-linux-kernel-digest@vger.rutgers.edu wrote:
> From: HighWind Software Information <info@highwind.com>
> Date: Sat, 22 May 1999 08:17:24 -0400 (EDT)
> Subject: writev() BUGS!
> 
> 1. The following program hangs with VECTOR_COUNT set to high values
> (greater than 16). It seems that Linux advertises a UIO_MAXIOV that is
> large (1024) but it doesn't work for values that high.
> 
> Just compile the program and see for yourself. Then reset VECTOR_COUNT
> to 16 and it works just fine.
> 
> % uname -a
> Linux magic.highwind.com 2.2.5-15 #1 Mon Apr 19 23:00:46 EDT 1999 i686 unknown
> 
> I'm fairly sure this is in the latest kernel as well.
> 
> 
> 2. Although I do not have a test program for it, I am 100% sure that
> even in the latest kernel, I sometimes see PARTIAL ::writev()'s of
> data on blocking network connections.
> 	Given that ::writev() on a blocking socket should never do
> that, I suspect something isn't right in the networking code.
> 	I wish this test program would show that problem,
> unfortunately, it doesn't. However, I KNOW for a fact that I have seen
> it. Perhaps some kind of signal logic interrupts writev(). I'm unsure.
> 
> 	In any case, ::writev() does sometimes perform a partial write
> on a blocking socket, that is a BUG.
   You're wrong here. man writev.
   It says that writev operates just like write except that data is
   take from vector instead of a contiguous buffer.
   Both write and writev do sometimes perform a partial write on
   a blocking(and non-blocking) socket.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/