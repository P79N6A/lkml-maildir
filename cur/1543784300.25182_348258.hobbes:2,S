Date: Thu, 08 Sep 2005 17:03:58 +0200
From: "Jan Beulich" <>
Subject: [PATCH] rmmod notifier chain
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/9/8/117

(Note: Patch also attached because the inline version is certain to get
line wrapped.)
Debugging and maintenance support code occasionally needs to know not
only of module insertions, but also modulke removals. This adds a
notifier
chain for this purpose.
Signed-off-by: Jan Beulich <jbeulich@novell.com>
diff -Npru 2.6.13/include/linux/module.h
2.6.13-rmmod-notifier/include/linux/module.h
--- 2.6.13/include/linux/module.h	2005-08-29 01:41:01.000000000
+0200
+++ 2.6.13-rmmod-notifier/include/linux/module.h	2005-09-01
11:32:12.000000000 +0200
@@ -431,6 +431,8 @@ const struct exception_table_entry *sear
 
 int register_module_notifier(struct notifier_block * nb);
 int unregister_module_notifier(struct notifier_block * nb);
+int register_rmmodule_notifier(struct notifier_block * nb);
+int unregister_rmmodule_notifier(struct notifier_block * nb);
 
 extern void print_modules(void);
 
diff -Npru 2.6.13/kernel/module.c
2.6.13-rmmod-notifier/kernel/module.c
--- 2.6.13/kernel/module.c	2005-08-29 01:41:01.000000000 +0200
+++ 2.6.13-rmmod-notifier/kernel/module.c	2005-09-02
09:46:24.000000000 +0200
@@ -62,6 +62,8 @@ static LIST_HEAD(modules);
 
 static DECLARE_MUTEX(notify_mutex);
 static struct notifier_block * module_notify_list;
+static DECLARE_MUTEX(rmmod_notify_mutex);
+static struct notifier_block * rmmodule_notify_list;
 
 int register_module_notifier(struct notifier_block * nb)
 {
@@ -83,6 +85,26 @@ int unregister_module_notifier(struct no
 }
 EXPORT_SYMBOL(unregister_module_notifier);
 
+int register_rmmodule_notifier(struct notifier_block * nb)
+{
+	int err;
+	down(&rmmod_notify_mutex);
+	err = notifier_chain_register(&rmmodule_notify_list, nb);
+	up(&rmmod_notify_mutex);
+	return err;
+}
+EXPORT_SYMBOL(register_rmmodule_notifier);
+
+int unregister_rmmodule_notifier(struct notifier_block * nb)
+{
+	int err;
+	down(&rmmod_notify_mutex);
+	err = notifier_chain_unregister(&rmmodule_notify_list, nb);
+	up(&rmmod_notify_mutex);
+	return err;
+}
+EXPORT_SYMBOL(unregister_rmmodule_notifier);
+
 /* We require a truly strong try_module_get() */
 static inline int strong_try_module_get(struct module *mod)
 {
@@ -1165,6 +1187,10 @@ static int __unlink_module(void *_mod)
 /* Free a module, remove from lists, etc (must hold module mutex). */
 static void free_module(struct module *mod)
 {
+	down(&rmmod_notify_mutex);
+	notifier_call_chain(&rmmodule_notify_list, MODULE_STATE_GOING,
mod);
+	up(&rmmod_notify_mutex);
+
 	/* Delete from various lists */
 	stop_machine_run(__unlink_module, mod, NR_CPUS);
 	remove_sect_attrs(mod);
@@ -1910,9 +1936,13 @@ sys_init_module(void __user *umod,
                    buggy refcounters. */
 		mod->state = MODULE_STATE_GOING;
 		synchronize_sched();
-		if (mod->unsafe)
+		if (mod->unsafe) {
 			printk(KERN_ERR "%s: module is now stuck!\n",
 			       mod->name);
+			down(&rmmod_notify_mutex);
+			notifier_call_chain(&rmmodule_notify_list,
MODULE_STATE_GOING, mod);
+			up(&rmmod_notify_mutex);
+		}
 		else {
 			module_put(mod);
 			down(&module_mutex);
[unhandled content-type:application/octet-stream]