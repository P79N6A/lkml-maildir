Date: Sat, 10 Mar 2007 02:54:00 -0800
From: "Luong Ngo" <>
Subject: Re: Sleeping thread not receive signal until it wakes up
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/3/10/107

On 3/10/07, Sergey Vlasov <vsu@altlinux.ru> wrote:
> On Fri, 9 Mar 2007 16:10:29 -0800 Luong Ngo wrote:
>
> > Thanks Parav, adding singal_allow(SIGALRM) wakeup the blocking
> > interruptible_sleep_on and checking the signal_pending would return
> > true now.
>
> This means that there is also a bug in your userspace program -
> somehow when it invokes ioctl(), it has SIGALRM blocked.  Use
> sigprocmask() (or pthread_sigmask() if your program is multithreaded)
> to ensure that SIGALRM is not blocked when you are expecting it to be
> processed.  (Even if your program does not block SIGALRM, it may
> inherit a blocked SIGALRM from another program which have started it,
> so the safest way is to unblock SIGALRM explicitly.)
>
When creating the thread, which would make ioctl call, the parent
thread does not call any sigprocmask so I assume that means none of
the signals is masked. Hence SIGALRM should be received by the thread.
But this did not happen until I call allow_signal explicitly in the
ioctl handler of the driver. I did not call sigprocmask with
SIG_BLOCK.
> Using allow_signal() is needed only if you create a kernel thread and
> want that thread to handle signals.
>
Could the execution of ioctl in the driver be done in a kernel thread
that created to handle the user ioctl request and therefore it needs
allow_signal?
Thanks a lot,
LNgo
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/