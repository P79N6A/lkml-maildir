Date: Thu, 25 Feb 1999 20:09:21 +0100
From: Romano Giannetti <>
Subject: Re: PROBLEM: Sending mail-attachment > 45k with Netscape via sendmail hangs
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/2/25/138

On Thu, Feb 25, 1999 at 05:48:38PM +0100, Matthias Moeller wrote:
> read(3, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 15) = 15
> select(4, [3], NULL, NULL, NULL)        = 1 (in [3])
> read(3, "\0\0\0\0\0\0\0\0\0\0", 15)     = 10
> select(4, [3], NULL, NULL, NULL <unfinished ...>
> 
> The blocking select() call is the same as the select()
> calls before. And even if the receiver would be busy,
> netstat should report data in the Recv-Q, right? It doesn't.
> Instead it reports data in the Send-Q of the sender.
> 
> > 
> > You said you had a simple demo app, for this - can you let me have a look at
> > it
> 
> I have attached client.c, serv.c and Makefile. Serv listens on port 3333
I tried to change the program to simply use a pipe, and it seems it
blocks in the select too. I hope I did it right, I am not so good in 
unix hacking... attached it goes. 
-- 
Romano Giannetti, Professor  -  Univ. Pontificia Comillas (Madrid, Spain)
Electronic Engineer - phone +34 915 422 800 ext 2410  fax +34 915 596 569
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <sys/types.h>
#include <unistd.h>
#include <errno.h>
#include <netinet/in.h>
#include <netdb.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <signal.h>
#define PORT 3333
#define READ_SIZE 15
static char buffer[READ_SIZE];
int pipe_fd[2];
#define p_write pipe_fd[1]
#define p_read  pipe_fd[0]
int client()
{
        struct sockaddr_in addr;
        struct hostent *hostent;
        int sock, flgs, len, cnt, i;
        fd_set rfds;
        sock=p_read;    
        flgs = fcntl(sock, F_GETFL, 0);
        fcntl(sock, F_SETFL, flgs|O_NONBLOCK);
        
        cnt = 0;
        do
          {
                  FD_ZERO(&rfds);
                  FD_SET(sock, &rfds);
                  if(select(sock + 1, &rfds, NULL, NULL, NULL) <= 0)
                    { perror("select()"); exit(1); }
                  
                  len = read(sock, buffer, READ_SIZE);
                  if(len > 0)
                    cnt += len;
                  
                  printf("cnt=%d\n",cnt);
                  
          } while(len>0);
        close(sock);
        printf("Got %d bytes.\nConnection closed\n", cnt);
        
        
        return 0;
}
#define WRITE_SIZE 1585
static const char str[WRITE_SIZE];
static void sigint(int s)
{
    printf("***SIGINT\n");
    fflush(stdout);
    close(p_write);
    close(p_read);
    exit(0);
}
static void sigpipe(int s)
{
    printf("***SIGPIPE\n");
    fflush(stdout);
    close(p_write);
    close(p_read);
    exit(0);
}
int serv()
{
        int pid, sock;
        struct sockaddr_in addr, accept_addr;
        int addrlen = 0;
        int i, size, written, flgs;
        const char *ptr;
        fd_set wfds;
        
        sock=p_write;
        
        flgs = fcntl(sock, F_GETFL, 0);
        fcntl(sock, F_SETFL, flgs|O_NONBLOCK);
            
        printf("sending %d bytes of data...\n",3200*sizeof(str));
        for(i = 0; i < 3200; i++)
          {
                  size = sizeof(str);
                  ptr = str;
                  while(size)
                    {
                            FD_ZERO(&wfds);
                            FD_SET(sock, &wfds);
                            if(select(sock+1, NULL, &wfds, NULL, NULL) < 0)
                              { perror("select()"); abort(); }
                            
                            if((written = write(sock, ptr, size)) < 0)
                              { perror("write()");  abort(); }
                            
                            size -= written;
                            ptr += written;
                    }
          }
        
        printf("ready, sent %d bytes of data\n",3200*sizeof(str));
        fflush(stdout);
        close(sock);
        exit(0);
}
int main() {
        int pid;
        pipe(pipe_fd);
        signal(SIGINT, sigint);
        signal(SIGPIPE, sigpipe);
        pid=fork();
        if (pid<0) {
                perror("Main:");
                exit(1);
        }
        if (pid==0) {
                serv();
        } else {
                client();
        }
        return 0;
}