Date: Fri, 06 Feb 2004 20:05:48 +0100
From: Matthias Urlichs <>
Subject: Re: VFS locking: f_pos thread-safe ?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2004/2/6/145

Hi, Joel Becker wrote:
> This reads:  "all of the specified effects of the other call,
> or none of them."  If I read that correctly, if f_pos is at N, and
> threads A and B concurrently read M bytes, then each thread's read()
> must either start at f_pos = N or f_pos = N+M, but never at N < f_pos <
> N+M.  So as long as our code doesn't partially update f_pos, it is
> valid.
Umm, strictly speaking there are three possible valid cases:
thread A reads M @N   thread B reads M @N     file pointer ends up as N+M
thread A reads M @N   thread B reads M @M+N   file pointer ends up as N+2M
thread A reads M @M+N thread B reads M @N     file pointer ends up as N+2M
With your description,
thread A reads M @M+N thread B reads M @M+N   file pointer ends up as N+2M
would be equally valid, which I'd declare buggy ^W non-conforming.
-- 
Matthias Urlichs
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/