Date: Wed, 13 Sep 2000 11:02:16 +0100
From: David Howells <>
Subject: Re: [RFC] Wine speedup through kernel module
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/9/13/36

Well, I implemented the syscall last night... I decided it was too hard to do
a generic syscall handler without writing lots of non-portable assembly to do
one of the following (to deal with module reference counting):
    (1) have a function that concocts a syscall 'thunk'
	- needs to either transfer the syscall parameters or fiddle the return
	  address and jump to the handler
	- the latter is hard as the syscall can be called from more than one
	  place in entry.S
    (2) modify the syscall table layout and the syscall entry code
	- this is obviously a major piece of work and would affect all
	  architectures.
Unpleasant either way. I think (1) would probably be the easiest and certainly
the least impact... it just requires providing different thunk writing code on
each arch.
Anyway, for the moment, I decided on a simple dedicated stub in the kernel
proper... This allows me to do reference counting by way of doing a get on the
fd that points to the handle map, thus retaining the existence of the struct
file, which then retains the module in memory.
It all seemed to work, then I removed the printk's, ran a quick check and
guess what... it oopsed! Typical. So I'll have to let you have the code this
evening or tomorrow when I've squashed the bug.
David Howells
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
Please read the FAQ at 
http://www.tux.org/lkml/