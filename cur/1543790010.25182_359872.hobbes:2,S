Date: Sun, 23 Oct 2005 22:49:38 +0200
From: Claudio Scordino <>
Subject: Task profiling in Linux
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/10/23/58

Hi all.
I need some help to make profiling of an application on Linux. I need to 
measure the computation time between different points of my program, 
considering only the CPU time that the task has actually executed (i.e. 
without the intervals of time that the task has been preempted by other 
tasks).
To accomplish that, I can't just read the current time in different parts of 
the program, nor I can set and use a timer, because this wouldn't consider 
preemptions...
I found out that Linux provides the getrusage() syscall which provides the 
information that I need. This syscall also says both user and system times 
used by the task, which is a very useful thing.
However, it has two main drawbacks:
- its precision is very low: I'm working with real-time tasks on a Athlon-64  
and I need a more accurate estimation
- it can't be invoked by a generic task to know the execution time of another 
task
The only idea that I had is to insert some hooks in the kernel functions and 
use some high resolution timer to compute the time that my task has 
actually executed. This timer starts whenever the task obtains the CPU, and is 
stopped whenever the task yields the CPU.
Therefore, I just need to know which functions are invoked when a task starts  
executing on the CPU and when it looses the CPU.
May somebody tell me which are those functions ?
If somebody has suggestions about how doing this profiling, let me know. 
Many thanks,
            Claudio
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/