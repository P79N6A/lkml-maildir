Date: Wed, 5 Jul 2006 19:29:08 +0200
From: Grzegorz Adam Hankiewicz <>
Subject: Re: Linux kernel 2.6.10 sata_nv.c stops working on my hardware
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/7/5/165

On 2006-06-26, Allen Martin <AMartin@nvidia.com> wrote:
> Have you tried the 2.6.9 sata_nv.c on 2.6.10?  All you should have
> to do to get it working is change the host_set->pdev references
> to use to_pci_dev().
> [...]
> You can try changing that back to see if it makes a difference.
> I would also investigate changes in libata too.
I checked the differences between libata-*c and the following
changes seemed relevant to me. Though I have no idea if they do
anything at all for my setup, and I don't know really what to change.
--- linux-2.6.9/drivers/scsi/libata-core.c      2004-10-18 23:53:06.000000000 +0200
+++ linux-2.6.10/drivers/scsi/libata-core.c     2004-12-24 22:33:48.000000000 +0100
@@ -1945,8 +1950,6 @@ void ata_sg_init_one(struct ata_queued_c
        sg->page = virt_to_page(buf);
        sg->offset = (unsigned long) buf & ~PAGE_MASK;
        sg_dma_len(sg) = buflen;
-
-       WARN_ON(buflen > PAGE_SIZE);
 }
 
 void ata_sg_init(struct ata_queued_cmd *qc, struct scatterlist *sg,
@@ -2167,14 +2170,20 @@ static void ata_pio_sector(struct ata_qu
        struct scatterlist *sg = qc->sg;
        struct ata_port *ap = qc->ap;
        struct page *page;
+       unsigned int offset;
        unsigned char *buf;
 
        if (qc->cursect == (qc->nsect - 1))
                ap->pio_task_state = PIO_ST_LAST;
 
        page = sg[qc->cursg].page;
-       buf = kmap(page) +
-             sg[qc->cursg].offset + (qc->cursg_ofs * ATA_SECT_SIZE);
+       offset = sg[qc->cursg].offset + qc->cursg_ofs * ATA_SECT_SIZE;
+
+       /* get the current page and offset */
+       page = nth_page(page, (offset >> PAGE_SHIFT));
+       offset %= PAGE_SIZE;
+
+       buf = kmap(page) + offset;
 
        qc->cursect++;
        qc->cursg_ofs++;
@@ -2265,19 +2318,30 @@ static void ata_pio_block(struct ata_por
                }
        }
 
-       /* handle BSY=0, DRQ=0 as error */
-       if ((status & ATA_DRQ) == 0) {
-               ap->pio_task_state = PIO_ST_ERR;
-               return;
-       }
-
        qc = ata_qc_from_tag(ap, ap->active_tag);
        assert(qc != NULL);
 
-       if (is_atapi_taskfile(&qc->tf))
-               atapi_pio_sector(qc);
-       else
+       if (is_atapi_taskfile(&qc->tf)) {
+               /* no more data to transfer or unsupported ATAPI command */
+               if ((status & ATA_DRQ) == 0) {
+                       ap->pio_task_state = PIO_ST_IDLE;
+
+                       ata_irq_on(ap);
+
+                       ata_qc_complete(qc, status);
+                       return;
+               }
+
+               atapi_pio_bytes(qc);
+       } else {
+               /* handle BSY=0, DRQ=0 as error */
+               if ((status & ATA_DRQ) == 0) {
+                       ap->pio_task_state = PIO_ST_ERR;
+                       return;
+               }
+
                ata_pio_sector(qc);
+       }
 }
 
 static void ata_pio_error(struct ata_port *ap)
@@ -2356,10 +2473,29 @@ static void ata_pio_task(void *_data)
 static void ata_qc_timeout(struct ata_queued_cmd *qc)
 {
        struct ata_port *ap = qc->ap;
+       struct ata_device *dev = qc->dev;
        u8 host_stat = 0, drv_stat;
 
        DPRINTK("ENTER\n");
 
+       /* FIXME: doesn't this conflict with timeout handling? */
+       if (qc->dev->class == ATA_DEV_ATAPI && qc->scsicmd) {
+               struct scsi_cmnd *cmd = qc->scsicmd;
+
+               if (!scsi_eh_eflags_chk(cmd, SCSI_EH_CANCEL_CMD)) {
+
+                       /* finish completing original command */
+                       __ata_qc_complete(qc);
+
+                       atapi_request_sense(ap, dev, cmd);
+
+                       cmd->result = (CHECK_CONDITION << 1) | (DID_OK << 16);
+                       scsi_finish_command(cmd);
+
+                       goto out;
+               }
+       }
+
        /* hack alert!  We cannot use the supplied completion
         * function from inside the ->eh_strategy_handler() thread.
         * libata is the only user of ->eh_strategy_handler() in
--- linux-2.6.9/drivers/scsi/libata-scsi.c      2004-10-18 23:53:51.000000000 +0200
+++ linux-2.6.10/drivers/scsi/libata-scsi.c     2004-12-24 22:34:32.000000000 +0100
@@ -100,7 +97,7 @@ int ata_scsi_ioctl(struct scsi_device *s
                return 0;
 
        default:
-               rc = -EOPNOTSUPP;
+               rc = -ENOTTY;
                break;
        }
@@ -901,8 +898,8 @@ unsigned int ata_scsiop_inq_80(struct at
        };
        memcpy(rbuf, hdr, sizeof(hdr));
 
-       if (buflen > (ATA_SERNO_LEN + 4))
-               ata_dev_id_string(args->dev, (unsigned char *) &rbuf[4],
+       if (buflen > (ATA_SERNO_LEN + 4 - 1))
+               ata_dev_id_string(args->id, (unsigned char *) &rbuf[4],
                                  ATA_ID_SERNO_OFS, ATA_SERNO_LEN);
 
        return 0;
@@ -930,7 +927,7 @@ unsigned int ata_scsiop_inq_83(struct at
        rbuf[3] = 4 + strlen(inq_83_str);       /* page len */
 
        /* our one and only identification descriptor (vendor-specific) */
-       if (buflen > (strlen(inq_83_str) + 4 + 4)) {
+       if (buflen > (strlen(inq_83_str) + 4 + 4 - 1)) {
                rbuf[4 + 0] = 2;        /* code set: ASCII */
                rbuf[4 + 3] = strlen(inq_83_str);
                memcpy(rbuf + 4 + 4, inq_83_str, strlen(inq_83_str));
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/