Date: Wed, 27 Oct 1999 15:37:24 -0700
From: Phil Wilshire <>
Subject: Re: Controlling par port
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/10/27/134

Chris Jones wrote:
> 
> -----BEGIN PGP SIGNED MESSAGE-----
> Hash: SHA1
> 
> Hi
> 
> Could someone point me at some docs for simple control of the parallel
> port?
> 
> 
THis is a bit messy since it uses some bits of RT Linux
Tidy it up thussly
Good luck.
If you find a description of the Parallel port Control reg mail me back
with it please.
Phil Wilshire
/* Parallel Port Example
   Author:     Phil Wilshire  
   Original:   Many Others
   Date:       4/23/99
   $Id$
   This code shows how to set up and use the parallel port
   I have included an interrupt detector
*/
#include <linux/module.h>
#include <asm/io.h>
#include <asm/irq.h>
#include <linux/cons.h>
#include <linux/sched.h>
#define LPT_PORT 0x378
#define LPTS     0x379
#define LPTC     0x37A
#define LPT_IRQ  7
#define PULSE_TIME 10000
#ifndef NULL
#define NULL 0
#endif
static int i;
static int irq_tries[] = {3,4,5,6,9,0};
static int irq_tried[] = {0,0,0,0,0};
static int got_irq;
void irq_handler(void) {
   /* output a small pulse */
   outb(inb_p(LPT_PORT) | (0x01) , LPT_PORT );
   for ( i = 0 ; i < PULSE_TIME ; i++ ) ;
   outb(inb_p(LPT_PORT) & ~(0x01) , LPT_PORT );
}
void dummy_probe(int irq, void * dev_id, struct pt_regs * regs) {
  if ( got_irq == 0 ) got_irq = irq;
  
}
int init_module(void) {
   int inbyte;
   int i;
   int count;
   /* set up interrupt controller */
   /*outb_p(inb_p(0x21)&(0x80),0x21);
     outb_p(0x20,0x20); */
   /* get all the irqs  */
   for ( i = 0; irq_tries[i] ; i++ ) {
     irq_tried[i] = request_irq(irq_tries[i],dummy_probe,
                                SA_INTERRUPT,  "dummy probe", NULL);
   }
   /* run the probe */
   count = 0;
   got_irq = 0;
   do {
     got_irq = 0;
     outb_p(inb_p(LPTC)|(0x10),LPTC);  /* enable */
     outb(0x00, LPT_PORT );      /* low    */
     for ( i = 0 ; i < 10000 ; i++ );
     outb(0xFF, LPT_PORT );      /* high    */
     for ( i = 0 ; i < 10000 ; i++ );
     outb_p(inb_p(LPTC)&~(0x10),LPTC); /* disable */    
     if ( got_irq == 0 ) {
       printk(" %d no irq reported ...\n",count);
     }
     count ++;
   } while ( got_irq <= 0 && count < 5 );
   printk(" got_irq reported %d...\n",got_irq);
   
   /* enable port irqs  */
   return 0;
}
void cleanup_module(void) {
   /* disable port irqs  */
   outb_p(inb_p(LPTC)&~(0x10),LPTC);
   /* give them all back */ 
   for ( i = 0; irq_tries[i] ; i++ ) {
     free_irq(irq_tries[i],NULL);
   }
}
/* makefile  
CFLAGS= -D__KERNEL__  -DMODULE
pport.o : pport.c
        gcc -O2  $(CFLAGS) -c pport.c
*/[unhandled content-type:application/octet-stream]