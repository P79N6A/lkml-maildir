Date: Fri, 10 Mar 2006 14:23:04 +0300
From: Kirill Korotaev <>
Subject: Re: [PATCH] Fix shrink_dcache_parent() against shrink_dcache_memory() race (3rd updated patch)]
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/3/10/82

>>>I really think that we need to stop prune_one_dentry from being called
>>>on dentries for a filesystem that is being unmounted.  With that code
>>>currently in -git, that means passing a 'struct super_block *' into
>>>prune_dcache so that it ignores any filesystem with ->s_root==NULL
>>>unless that filesystem is the filesystem that was passed.
>>
>>Can try...
> 
> Can not ... because of down_read(s_umount) before checking s_root :(
> So what do we do now?
> 
>  1. always get the reference counting right outside of dcache_lock
> 
>  2. hack around with different paths for prune_dcache() when called from
>     shrink_dcache_memory() and shrink_dcache_parent()
3. keep the existing patch from me :))))
> I think that we should go for the first.
just an idea which came to my mind:
can't we fix it the following way:
1. fix select_parent() when called from generic_shutdown_super() to loop 
until _all_ dentries are shrinked (not only those, with d_count = 1);
this guarentees that no dentries are left.
2. no dentries are left, but iput() can be in progress.
So can't we simply make invalidate_inodes() to be in a loop with 
schedule() until no busy inodes are left?!
unregister_netdevice() for example, loops until netdev counter drops to 
zero. Why can't we do it the same way? Any objections?
Thanks,
Kirill
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/