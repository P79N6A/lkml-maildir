Date: Fri, 12 Nov 1999 09:45:15 -0800
From: "Adam J. Richter" <>
Subject: linux-2.3.27 patch to eliminate drivers/net/net_init.c
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/11/12/102

Hi Alan,
	I have implemented your suggestion that I eliminate the
drivers/net/net_init.c by putting all of the utility functions
that make up that file into the existing files into the corresponding
files in the net/ hierarchy (e.g., fiberchannel functions --> net/802/fc.c,
hippi functions --> net/802/hippi.c, etc.).  I am running the
resulting kernel on a notebook computer now and typing in this
message from it, so I know the changes work (well, I did fake
the patch to net/netsyms.c because the ipv4 modularization changes
here change that file substantially).  These changes eliminate
a bunch of #ifdefs and move some code from the core kernel to
loadable modules (which most users do not load).  Also, I think
that this organization will allow some of these exported
routines to become local, but I have not investigated that at this
point.
	I am sending you this patch and cc'ing it to linux-kernel,
in case anybody else sees a problem with it (it does not change
any of the code, it just moves it around).  I guess if this code
looks OK to you, you will send it to Linus or bounce it of off Dave
Miller to Linus.  However, if there is anything more I should do
on my end to get this into the kernel, please let me know.  Otherwise,
I will assume this ball is out of my court.
Adam J. Richter     __     ______________   4880 Stevens Creek Blvd, Suite 104
adam@yggdrasil.com     \ /                  San Jose, California 95129-1034
+1 408 261-6630         | g g d r a s i l   United States of America
fax +1 408 261-6631      "Free Software For The Rest Of Us."
diff -u -r linux-2.3.27/net/802/fc.c linux/net/802/fc.c
--- linux-2.3.27/net/802/fc.c	Thu Oct  7 10:17:09 1999
+++ linux/net/802/fc.c	Thu Nov 11 10:17:00 1999
@@ -10,6 +10,7 @@
  *		v 1.0 03/22/99
  */
 
+#include <linux/module.h>
 #include <asm/uaccess.h>
 #include <asm/system.h>
 #include <linux/types.h>
@@ -33,7 +34,7 @@
 /*
  *	Put the headers on a Fibre Channel packet. 
  */
- 
+static
 int fc_header(struct sk_buff *skb, struct net_device *dev, unsigned short type,
               void *daddr, void *saddr, unsigned len) 
 {
@@ -79,7 +80,7 @@
  *	A neighbour discovery of some species (eg arp) has completed. We
  *	can now send the packet.
  */
- 
+static 
 int fc_rebuild_header(struct sk_buff *skb) 
 {
 	struct fch_hdr *fch=(struct fch_hdr *)skb->data;
@@ -95,3 +96,49 @@
 #endif
 }
 	
+void fc_setup(struct net_device *dev)
+{
+	dev->hard_header        =        fc_header;
+        dev->rebuild_header  	=        fc_rebuild_header;
+                
+        dev->type               =        ARPHRD_IEEE802;
+	dev->hard_header_len    =        FC_HLEN;
+        dev->mtu                =        2024;
+        dev->addr_len           =        FC_ALEN;
+        dev->tx_queue_len       =        100; /* Long queues on fc */
+
+        memset(dev->broadcast,0xFF, FC_ALEN);
+
+        /* New-style flags. */
+        dev->flags              =        IFF_BROADCAST;
+	dev_init_buffers(dev);
+        return;
+}
+
+
+struct net_device *init_fcdev(struct net_device *dev, int sizeof_priv)
+{
+	return init_netdev(dev, sizeof_priv, "fc%d", fc_setup);
+}
+
+int register_fcdev(struct net_device *dev)
+{
+        dev_init_buffers(dev);
+        if (dev->init && dev->init(dev) != 0) {
+                unregister_fcdev(dev);
+                return -EIO;
+        }
+        return 0;
+}                                               
+        
+void unregister_fcdev(struct net_device *dev)
+{
+        rtnl_lock();
+	unregister_netdevice(dev);
+        rtnl_unlock();
+}
+
+EXPORT_SYMBOL(fc_setup);
+EXPORT_SYMBOL(init_fcdev);
+EXPORT_SYMBOL(register_fcdev);
+EXPORT_SYMBOL(unregister_fcdev);
diff -u -r linux-2.3.27/net/802/fddi.c linux/net/802/fddi.c
--- linux-2.3.27/net/802/fddi.c	Wed Aug 18 11:38:48 1999
+++ linux/net/802/fddi.c	Thu Nov 11 10:17:00 1999
@@ -41,6 +41,7 @@
 #include <linux/if_ether.h>
 #include <linux/skbuff.h>
 #include <linux/errno.h>
+#include <linux/module.h>
 #include <net/arp.h>
 #include <net/sock.h>
 
@@ -163,3 +164,42 @@
 
 	return(type);
 }
+
+static int fddi_change_mtu(struct net_device *dev, int new_mtu)
+{
+	if ((new_mtu < FDDI_K_SNAP_HLEN) || (new_mtu > FDDI_K_SNAP_DLEN))
+		return(-EINVAL);
+	dev->mtu = new_mtu;
+	return(0);
+}
+
+void fddi_setup(struct net_device *dev)
+{
+	/*
+	 * Fill in the fields of the device structure with FDDI-generic values.
+	 * This should be in a common file instead of per-driver.
+	 */
+	
+	dev->change_mtu			= fddi_change_mtu;
+	dev->hard_header		= fddi_header;
+	dev->rebuild_header		= fddi_rebuild_header;
+
+	dev->type				= ARPHRD_FDDI;
+	dev->hard_header_len	= FDDI_K_SNAP_HLEN+3;	/* Assume 802.2 SNAP hdr len + 3 pad bytes */
+	dev->mtu				= FDDI_K_SNAP_DLEN;		/* Assume max payload of 802.2 SNAP frame */
+	dev->addr_len			= FDDI_K_ALEN;
+	dev->tx_queue_len		= 100;	/* Long queues on FDDI */
+	
+	memset(dev->broadcast, 0xFF, FDDI_K_ALEN);
+
+	/* New-style flags */
+	dev->flags		= IFF_BROADCAST | IFF_MULTICAST;
+
+	dev_init_buffers(dev);
+	
+	return;
+}
+
+EXPORT_SYMBOL(fddi_header);
+EXPORT_SYMBOL(fddi_rebuild_header);
+EXPORT_SYMBOL(fddi_type_trans);
diff -u -r linux-2.3.27/net/802/hippi.c linux/net/802/hippi.c
--- linux-2.3.27/net/802/hippi.c	Wed Aug 18 11:38:48 1999
+++ linux/net/802/hippi.c	Fri Nov 12 09:19:06 1999
@@ -32,6 +32,8 @@
 #include <linux/hippidevice.h>
 #include <linux/skbuff.h>
 #include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/rtnetlink.h>
 #include <net/arp.h>
 #include <net/sock.h>
 #include <asm/uaccess.h>
@@ -152,3 +154,94 @@
 
 	return hip->snap.ethertype;
 }
+
+static int hippi_change_mtu(struct net_device *dev, int new_mtu)
+{
+	/*
+	 * HIPPI's got these nice large MTUs.
+	 */
+	if ((new_mtu < 68) || (new_mtu > 65280))
+		return -EINVAL;
+	dev->mtu = new_mtu;
+	return(0);
+}
+
+/*
+ * For HIPPI we will actually use the lower 4 bytes of the hardware
+ * address as the I-FIELD rather than the actual hardware address.
+ */
+static int hippi_mac_addr(struct net_device *dev, void *p)
+{
+	struct sockaddr *addr = p;
+	if(dev->start)
+		return -EBUSY;
+	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+	return 0;
+}
+
+
+struct net_device *init_hippi_dev(struct net_device *dev, int sizeof_priv)
+{
+	return init_netdev(dev, sizeof_priv, "hip%d", hippi_setup);
+}
+
+void unregister_hipdev(struct net_device *dev)
+{
+	rtnl_lock();
+	unregister_netdevice(dev);
+	rtnl_unlock();
+}
+
+
+static int hippi_neigh_setup_dev(struct net_device *dev, struct neigh_parms *p)
+{
+	/* Never send broadcast/multicast ARP messages */
+	p->mcast_probes = 0;
+ 
+	/* In IPv6 unicast probes are valid even on NBMA,
+	* because they are encapsulated in normal IPv6 protocol.
+	* Should be a generic flag. 
+	*/
+	if (p->tbl->family != AF_INET6)
+		p->ucast_probes = 0;
+	return 0;
+}
+
+void hippi_setup(struct net_device *dev)
+{
+	dev->set_multicast_list	= NULL;
+	dev->change_mtu			= hippi_change_mtu;
+	dev->hard_header		= hippi_header;
+	dev->rebuild_header 		= hippi_rebuild_header;
+	dev->set_mac_address 		= hippi_mac_addr;
+	dev->hard_header_parse		= NULL;
+	dev->hard_header_cache		= NULL;
+	dev->header_cache_update	= NULL;
+	dev->neigh_setup 		= hippi_neigh_setup_dev; 
+
+	/*
+	 * We don't support HIPPI `ARP' for the time being, and probably
+	 * never will unless someone else implements it. However we
+	 * still need a fake ARPHRD to make ifconfig and friends play ball.
+	 */
+	dev->type		= ARPHRD_HIPPI;
+	dev->hard_header_len 	= HIPPI_HLEN;
+	dev->mtu		= 65280;
+	dev->addr_len		= HIPPI_ALEN;
+	dev->tx_queue_len	= 25 /* 5 */;
+	memset(dev->broadcast, 0xFF, HIPPI_ALEN);
+
+
+	/*
+	 * HIPPI doesn't support broadcast+multicast and we only use
+	 * static ARP tables. ARP is disabled by hippi_neigh_setup_dev. 
+	 */
+	dev->flags = 0; 
+
+	dev_init_buffers(dev);
+}
+
+EXPORT_SYMBOL(hippi_net_init);
+EXPORT_SYMBOL(hippi_header);
+EXPORT_SYMBOL(hippi_rebuild_header);
+EXPORT_SYMBOL(hippi_type_trans);
diff -u -r linux-2.3.27/net/802/tr.c linux/net/802/tr.c
--- linux-2.3.27/net/802/tr.c	Thu Oct 28 14:34:44 1999
+++ linux/net/802/tr.c	Fri Nov 12 03:29:32 1999
@@ -15,6 +15,7 @@
  *        
  */
 
+#include <linux/module.h>
 #include <asm/uaccess.h>
 #include <asm/system.h>
 #include <linux/config.h>
@@ -541,3 +542,81 @@
 
 	proc_net_create("tr_rif",0,rif_get_info);
 }
+
+static void tr_configure(struct net_device *dev)
+{
+	/*
+	 *	Configure and register
+	 */
+	
+	dev->hard_header	= tr_header;
+	dev->rebuild_header	= tr_rebuild_header;
+
+	dev->type		= ARPHRD_IEEE802;
+	dev->hard_header_len	= TR_HLEN;
+	dev->mtu		= 2000;
+	dev->addr_len		= TR_ALEN;
+	dev->tx_queue_len	= 100;	/* Long queues on tr */
+	
+	memset(dev->broadcast,0xFF, TR_ALEN);
+
+	/* New-style flags. */
+	dev->flags		= IFF_BROADCAST | IFF_MULTICAST ;
+}
+
+struct net_device *init_trdev(struct net_device *dev, int sizeof_priv)
+{
+	return init_netdev(dev, sizeof_priv, "tr%d", tr_configure);
+}
+
+void tr_setup(struct net_device *dev)
+{
+}
+
+int register_trdev(struct net_device *dev)
+{
+	dev_init_buffers(dev);
+	
+	if (dev->init && dev->init(dev) != 0) {
+		unregister_trdev(dev);
+		return -EIO;
+	}
+	return 0;
+}
+
+void unregister_trdev(struct net_device *dev)
+{
+	rtnl_lock();
+	unregister_netdevice(dev);
+	rtnl_unlock();
+}
+
+EXPORT_SYMBOL(rif_table);
+EXPORT_SYMBOL(sysctl_tr_rif_timeout);
+EXPORT_SYMBOL(tr_freedev);
+EXPORT_SYMBOL(tr_header);
+EXPORT_SYMBOL(tr_rebuild_header);
+EXPORT_SYMBOL(tr_setup);
+EXPORT_SYMBOL(tr_type_trans);
+EXPORT_SYMBOL(init_trdev);
+EXPORT_SYMBOL(register_trdev);
+EXPORT_SYMBOL(unregister_trdev);
+EXPORT_SYMBOL(rif_init);
+#ifdef CONFIG_PROC_FS
+EXPORT_SYMBOL(rif_get_info);
+#endif
+
+#ifdef MODULE
+int
+init_module(void) {
+	rif_init(NULL);
+}
+
+void
+cleanup_module(void) {
+# ifdef CONFIG_PROC_FS
+  	proc_net_remove("tr_rif");
+# endif
+}
+
+#endif /* MODULE */
diff -u -r linux-2.3.27/net/appletalk/ddp.c linux/net/appletalk/ddp.c
--- linux-2.3.27/net/appletalk/ddp.c	Thu Oct 28 14:34:44 1999
+++ linux/net/appletalk/ddp.c	Fri Nov 12 08:02:08 1999
@@ -82,6 +82,7 @@
 #include <linux/proc_fs.h>
 #include <linux/stat.h>
 #include <linux/init.h>
+#include <linux/if_ltalk.h>
 
 
 #ifdef CONFIG_PROC_FS
@@ -2062,12 +2063,48 @@
 
 static char ddp_snap_id[] = {0x08, 0x00, 0x07, 0x80, 0x9B};
 
+static int ltalk_change_mtu(struct net_device *dev, int mtu)
+{
+	return -EINVAL;
+}
+
+static int ltalk_mac_addr(struct net_device *dev, void *addr)
+{	
+	return -EINVAL;
+}
+
+
+void ltalk_setup(struct net_device *dev)
+{
+	/* Fill in the fields of the device structure with localtalk-generic values. */
+	
+	dev->change_mtu		= ltalk_change_mtu;
+	dev->hard_header	= NULL;
+	dev->rebuild_header 	= NULL;
+	dev->set_mac_address 	= ltalk_mac_addr;
+	dev->hard_header_cache	= NULL;
+	dev->header_cache_update= NULL;
+
+	dev->type		= ARPHRD_LOCALTLK;
+	dev->hard_header_len 	= LTALK_HLEN;
+	dev->mtu		= LTALK_MTU;
+	dev->addr_len		= LTALK_ALEN;
+	dev->tx_queue_len	= 10;	
+	
+	dev->broadcast[0]	= 0xFF;
+
+	dev->flags		= IFF_BROADCAST|IFF_MULTICAST|IFF_NOARP;
+
+	dev_init_buffers(dev);
+}
+
 /*
  * Export symbols for use by drivers when AppleTalk is a module.
  */
 EXPORT_SYMBOL(aarp_send_ddp);
 EXPORT_SYMBOL(atrtr_get_dev);
 EXPORT_SYMBOL(atalk_find_dev_addr);
+EXPORT_SYMBOL(ltalk_setup);
 
 /* Called by proto.c on kernel start up */
 
diff -u -r linux-2.3.27/net/core/dev.c linux/net/core/dev.c
--- linux-2.3.27/net/core/dev.c	Tue Nov  9 11:55:53 1999
+++ linux/net/core/dev.c	Fri Nov 12 08:02:08 1999
@@ -10,6 +10,8 @@
  * 		Authors:	Ross Biro, <bir7@leland.Stanford.Edu>
  *				Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
  *				Mark Evans, <evansmp@uhura.aston.ac.uk>
+ *				Code from drivers/net/net_init.c originally
+ *				written in 1993,1994,1995 by Donald Becker.
  *
  *	Additional Authors:
  *		Florian la Roche <rzsfl@rz.uni-sb.de>
@@ -44,7 +46,13 @@
  *		Dave Miller	:	32bit quantity for the device lock to make it work out
  *					on a Sparc.
  *		Bjorn Ekwall	:	Added KERNELD hack.
+ *					{,un}register_netdev()
  *		Alan Cox	:	Cleaned up the backlog initialise.
+ *					Got fed up of this mess when it was
+ *					in drivers/net/net_init.c and cleaned
+ *					it up   We now share common code and
+ *					have regularised name allocation
+ *					setups. Abolished the 16 card limits.
  *		Craig Metz	:	SIOCGIFCONF fix if space for under
  *					1 device.
  *	    Thomas Bogendoerfer :	Return ENODEV for dev_open, if there
@@ -56,6 +64,8 @@
  *					A network device unload needs to purge
  *					the backlog queue.
  *	Paul Rusty Russel	:	SIOCSIFNAME
+ *	Wolfgang Walter		:	Use dev_close cleanly so we always
+ *					shut things down tidily.
  */
 
 #include <asm/uaccess.h>
@@ -98,6 +108,12 @@
 NET_PROFILE_DEFINE(net_bh)
 NET_PROFILE_DEFINE(net_bh_skb)
 
+#ifdef CONFIG_BRIDGE_MODULE
+void (*handle_bridge_hook)(struct sk_buff *skb, unsigned short type) = NULL;
+int (*br_ioctl_hook) (unsigned int cmd, void *arg) = NULL;
+#endif
+
+
 
 const char *if_port_text[] = {
   "unknown",
@@ -974,6 +990,8 @@
 		 *      If it is bridged then move on
 		 */
 		handle_bridge(skb, type); 
+#elif defined(CONFIG_BRIDGE_MODULE)
+		if (handle_bridge_hook) (*handle_bridge_hook)(skb,type);
 #endif
 
 		/*
@@ -1779,6 +1797,115 @@
 		if (__dev_get_by_index(ifindex) == NULL)
 			return ifindex;
 	}
+}
+
+struct net_device *init_alloc_dev(int sizeof_priv)
+{
+	struct net_device *dev;
+	int alloc_size = sizeof(struct net_device) + IFNAMSIZ
+		+ sizeof_priv + 3;
+	alloc_size &= ~3;		/* Round to dword boundary. */
+	dev = (struct net_device *)kmalloc(alloc_size, GFP_KERNEL);
+	if(dev==NULL)
+	{
+		printk(KERN_ERR "alloc_dev: Unable to allocate device memory.\n");
+		return NULL;
+	}
+	memset(dev, 0, alloc_size);
+	if (sizeof_priv)
+		dev->priv = (void *) (dev + 1);
+	dev->name = sizeof_priv + (char *)(dev + 1);
+	return dev;
+}
+
+/* 
+ *	Create and name a device from a prototype, then perform any needed
+ *	setup.
+ */
+
+struct net_device *init_netdev(struct net_device *dev, int sizeof_priv, char *mask, void (*setup)(struct net_device *))
+{
+	int new_device = 0;
+
+	/*
+	 *	Allocate a device if one is not provided.
+	 */
+	 
+	if (dev == NULL) {
+		dev=init_alloc_dev(sizeof_priv);
+		if(dev==NULL)
+			return NULL;
+		new_device = 1;
+	}
+
+	/*
+	 *	Allocate a name
+	 */
+	 
+	if (dev->name && (dev->name[0] == '\0' || dev->name[0] == ' '))
+	{
+		if(dev_alloc_name(dev, mask)<0)
+		{
+			if(new_device)
+				kfree(dev);
+			return NULL;
+		}
+	}
+	
+	/*
+	 *	Configure via the caller provided setup function then
+	 *	register if needed.
+	 */
+	
+	setup(dev);
+	
+	if (new_device) {
+		rtnl_lock();
+		register_netdevice(dev);
+		rtnl_unlock();
+	}
+	return dev;
+}
+
+int register_netdev(struct net_device *dev)
+{
+	rtnl_lock();
+
+	/*
+	 *	If the name is a format string the caller wants us to
+	 *	do a name allocation
+	 */
+	 
+	if (dev->name && strchr(dev->name, '%'))
+	{
+		if(dev_alloc_name(dev, dev->name)<0)
+			return -EBUSY;
+	}
+	
+	/*
+	 *	Back compatibility hook. Kill this one in 2.5
+	 */
+	
+	if (dev->name && (dev->name[0]==0 || dev->name[0]==' '))
+	{
+		if(dev_alloc_name(dev, "eth%d")<0)
+			return -EBUSY;
+	}
+		
+		
+	if (register_netdevice(dev)) {
+		rtnl_unlock();
+		return -EIO;
+	}
+	rtnl_unlock();
+	return 0;
+}
+
+void unregister_netdev(struct net_device *dev)
+{
+	rtnl_lock();
+	unregister_netdevice(dev);
+	rtnl_unlock();
 }
 
 static int dev_boot_phase = 1;
diff -u -r linux-2.3.27/net/ethernet/eth.c linux/net/ethernet/eth.c
--- linux-2.3.27/net/ethernet/eth.c	Fri Sep  3 14:17:43 1999
+++ linux/net/ethernet/eth.c	Fri Nov 12 08:02:08 1999
@@ -12,7 +12,8 @@
  *		Mark Evans, <evansmp@uhura.aston.ac.uk>
  *		Florian  La Roche, <rzsfl@rz.uni-sb.de>
  *		Alan Cox, <gw4pts@gw4pts.ampr.org>
- * 
+ *		Donald Becker, <becker@cesdis.gsfc.nasa.gov>
+ *
  * Fixes:
  *		Mr Linux	: Arp problems
  *		Alan Cox	: Generic queue tidyup (very tiny here)
@@ -27,6 +28,7 @@
  *		Greg Page	: 802.2 and SNAP stuff.
  *		Alan Cox	: MAC layer pointers/new format.
  *		Paul Gortmaker	: eth_copy_and_sum shouldn't csum padding.
+ 				  Add generic eth_change_mtu() function. 
  *		Alan Cox	: Protect against forwarding explosions with
  *				  older network drivers and IFF_ALLMULTI.
  *	Christer Weinigel	: Better rebuild header message.
@@ -60,6 +62,83 @@
 #include <asm/system.h>
 #include <asm/checksum.h>
 
+/* Fill in the fields of the device structure with ethernet-generic values.
+
+   If no device structure is passed, a new one is constructed, complete with
+   a SIZEOF_PRIVATE private data area.
+
+   If an empty string area is passed as dev->name, or a new structure is made,
+   a new name string is constructed.  The passed string area should be 8 bytes
+   long.
+ */
+
+struct net_device *init_etherdev(struct net_device *dev, int sizeof_priv)
+{
+	return init_netdev(dev, sizeof_priv, "eth%d", ether_setup);
+}
+
+
+static int eth_mac_addr(struct net_device *dev, void *p)
+{
+	struct sockaddr *addr=p;
+	if(dev->start)
+		return -EBUSY;
+	memcpy(dev->dev_addr, addr->sa_data,dev->addr_len);
+	return 0;
+}
+
+static int eth_change_mtu(struct net_device *dev, int new_mtu)
+{
+	if ((new_mtu < 68) || (new_mtu > 1500))
+		return -EINVAL;
+	dev->mtu = new_mtu;
+	return 0;
+}
+
+void ether_setup(struct net_device *dev)
+{
+	/* Fill in the fields of the device structure with ethernet-generic values.
+	   This should be in a common file instead of per-driver.  */
+	
+	dev->change_mtu		= eth_change_mtu;
+	dev->hard_header	= eth_header;
+	dev->rebuild_header 	= eth_rebuild_header;
+	dev->set_mac_address 	= eth_mac_addr;
+	dev->hard_header_cache	= eth_header_cache;
+	dev->header_cache_update= eth_header_cache_update;
+	dev->hard_header_parse	= eth_header_parse;
+
+	dev->type		= ARPHRD_ETHER;
+	dev->hard_header_len 	= ETH_HLEN;
+	dev->mtu		= 1500; /* eth_mtu */
+	dev->addr_len		= ETH_ALEN;
+	dev->tx_queue_len	= 100;	/* Ethernet wants good queues */	
+	
+	memset(dev->broadcast,0xFF, ETH_ALEN);
+
+	/* New-style flags. */
+	dev->flags		= IFF_BROADCAST|IFF_MULTICAST;
+
+	dev_init_buffers(dev);
+}
+
+int ether_config(struct net_device *dev, struct ifmap *map)
+{
+	if (map->mem_start != (u_long)(-1))
+		dev->mem_start = map->mem_start;
+	if (map->mem_end != (u_long)(-1))
+		dev->mem_end = map->mem_end;
+	if (map->base_addr != (u_short)(-1))
+		dev->base_addr = map->base_addr;
+	if (map->irq != (u_char)(-1))
+		dev->irq = map->irq;
+	if (map->dma != (u_char)(-1))
+		dev->dma = map->dma;
+	if (map->port != (u_char)(-1))
+		dev->if_port = map->port;
+	return 0;
+}
+
 static int __init eth_setup(char *str)
 {
 	int ints[5];
@@ -159,7 +238,7 @@
 
 	switch (eth->h_proto)
 	{
-#ifdef CONFIG_INET
+#if defined(CONFIG_INET) || defined(CONFIG_INET_MODULE)
 	case __constant_htons(ETH_P_IP):
  		return arp_find(eth->h_dest, skb);
 #endif	
diff -u -r linux-2.3.27/drivers/net/Makefile linux/drivers/net/Makefile
--- linux-2.3.27/drivers/net/Makefile	Wed Nov 10 12:54:34 1999
+++ linux/drivers/net/Makefile	Fri Nov 12 08:02:08 1999
@@ -87,7 +87,7 @@
   endif
 endif
 
-obj-$(CONFIG_NET) += Space.o setup.o net_init.o loopback.o
+obj-$(CONFIG_NET) += Space.o setup.o loopback.o
 obj-$(CONFIG_SEEQ8005) += seeq8005.o
 obj-$(CONFIG_ETHERTAP) += ethertap.o
 obj-$(CONFIG_NET_SB1000) += sb1000.o
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/