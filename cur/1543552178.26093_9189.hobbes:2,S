Date: Sat, 21 Oct 2000 12:43:29 -0500
From: Bill Wendling <>
Subject: [patch(?)] question wrt context switching during disk i/o
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/10/21/5

Also sprach Mike Galbraith:
} On Fri, 20 Oct 2000, Mark Hahn wrote:
} 
} > > This is something that has been bugging me for a while.  I notice
} > > on my system that during disk write we do much context switching,
} > > but not during disk read.  Why is that?
} > 
} > bdflush is broken in current kernels.  I posted to linux-mm about this,
} > but Rik et al haven't shown any interest.  I normally see bursts of 
} > up to around 40K cs/second when doing writes; I hacked a little 
} > premption counter into the kernel and verified that they're practially
} > all bdflush...
} 
There's some strangness in bdflush(). The comment says:
                /*
                 * If there are still a lot of dirty buffers around,
                 * skip the sleep and flush some more. Otherwise, we
                 * go to sleep waiting a wakeup.
                 */
                if (!flushed || balance_dirty_state(NODEV) < 0) {
                        run_task_queue(&tq_disk);
                        schedule();
                }
but the comment for balance_dirty_state() says:
/* -1 -> no need to flush
    0 -> async flush
    1 -> sync flush (wait for I/O completation) */
int balance_dirty_state(kdev_t dev)
{
Which leads me to believe that the `<' should be either `==' or `<='. I
tried it with the `<=' and it doesn't seem to be so bad...Here's a patch
to see if it helps you?
-- 
|| Bill Wendling			wendling@ganymede.isdn.uiuc.edu
--- linux/fs/buffer.c	Sat Oct 21 02:55:41 2000
+++ linux-2.4.0-test10pre4/fs/buffer.c	Sat Oct 21 12:27:10 2000
@@ -2683,7 +2683,7 @@
 		 * skip the sleep and flush some more. Otherwise, we
 		 * go to sleep waiting a wakeup.
 		 */
-		if (!flushed || balance_dirty_state(NODEV) < 0) {
+		if (!flushed || balance_dirty_state(NODEV) <= 0) {
 			run_task_queue(&tq_disk);
 			schedule();
 		}