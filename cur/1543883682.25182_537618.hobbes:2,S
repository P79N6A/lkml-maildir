Date: Mon, 30 Apr 2007 17:24:15 +0200 (MEST)
From: Mikael Pettersson <>
Subject: Re: [PATCH] [1/1] CPU-i386-Geode: Chipset access macros do not work as expected
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/4/30/256

On 30 Apr 2007 17:32:04 +0200, Andi Kleen wrote:
> > From: Juergen Beisert <juergen.beisert@weihenstephan.org>
> > 
> > Replace NSC/Cyrix specific chipset access macros by inlined functions.
> > With the macros a line like this fails (and does nothing):
> > 	setCx86(CX86_CCR2, getCx86(CX86_CCR2) | 0x88);
> > With inlined functions this line will work as expected.
> 
> Why do the macros not work? 
Delayed evaluation of parameters causing unexpected and broken
interleaving of side-effects. The macros look as follows:
#define getCx86(reg) ({ outb((reg), 0x22); inb(0x23); })
#define setCx86(reg, data) do { \
         outb((reg), 0x22); \
         outb((data), 0x23); \
} while (0)
So the statement
	setCx86(CX86_CCR2, getCx86(CX86_CCR2) | 0x88);
becomes
	outb((CX86_CCR2), 0x22);
	outb((({ outb((CX86_CCR2), 0x22); inb(0x23); }) | 0x88), 0x23);
which is equivalent to
	outb(CX86_CCR2, 0x22);		// setCx86
	outb(CX86_CCR2, 0x22);		// getCx86
	tmp = inb(0x23) | 0x88;		// getCx86
	outb(tmp, 0x23);		// setCx86
which the processor doesn't like.
With inline functions the parameters are fully evaluated
before the bodies, so we get
	outb(CX86_CCR2, 0x22);		// getCx86
	tmp = inb(0x23) | 0x88;		// getCx86
	outb(CX86_CCR2, 0x22);		// setCx86
	outb(tmp, 0x23);		// setCx86
instead.
/Mikael
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/