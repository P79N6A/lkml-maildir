Date: Wed, 05 Mar 2008 20:25:20 +0300
From: Pavel Emelyanov <>
Subject: [PATCH 1/9] Avoid magic constants in drivers/base/map.c
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/3/5/278

The number of chains in the kobj_map structure is hard-coded
with a magic constant of 255. Make a named one instead.
Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
---
 drivers/base/map.c |   21 ++++++++++++---------
 1 files changed, 12 insertions(+), 9 deletions(-)
diff --git a/drivers/base/map.c b/drivers/base/map.c
index e87017f..7de565f 100644
--- a/drivers/base/map.c
+++ b/drivers/base/map.c
@@ -16,6 +16,8 @@
 #include <linux/kobject.h>
 #include <linux/kobj_map.h>
 
+#define KOBJ_MAP_PROBES	255
+
 struct kobj_map {
 	struct probe {
 		struct probe *next;
@@ -25,7 +27,7 @@ struct kobj_map {
 		kobj_probe_t *get;
 		int (*lock)(dev_t, void *);
 		void *data;
-	} *probes[255];
+	} *probes[KOBJ_MAP_PROBES];
 	struct mutex *lock;
 };
 
@@ -38,8 +40,8 @@ int kobj_map(struct kobj_map *domain, dev_t dev, unsigned long range,
 	unsigned i;
 	struct probe *p;
 
-	if (n > 255)
-		n = 255;
+	if (n > KOBJ_MAP_PROBES)
+		n = KOBJ_MAP_PROBES;
 
 	p = kmalloc(sizeof(struct probe) * n, GFP_KERNEL);
 
@@ -56,7 +58,7 @@ int kobj_map(struct kobj_map *domain, dev_t dev, unsigned long range,
 	}
 	mutex_lock(domain->lock);
 	for (i = 0, p -= n; i < n; i++, p++, index++) {
-		struct probe **s = &domain->probes[index % 255];
+		struct probe **s = &domain->probes[index % KOBJ_MAP_PROBES];
 		while (*s && (*s)->range < range)
 			s = &(*s)->next;
 		p->next = *s;
@@ -73,13 +75,14 @@ void kobj_unmap(struct kobj_map *domain, dev_t dev, unsigned long range)
 	unsigned i;
 	struct probe *found = NULL;
 
-	if (n > 255)
-		n = 255;
+	if (n > KOBJ_MAP_PROBES)
+		n = KOBJ_MAP_PROBES;
 
 	mutex_lock(domain->lock);
 	for (i = 0; i < n; i++, index++) {
 		struct probe **s;
-		for (s = &domain->probes[index % 255]; *s; s = &(*s)->next) {
+		for (s = &domain->probes[index % KOBJ_MAP_PROBES];
+				*s; s = &(*s)->next) {
 			struct probe *p = *s;
 			if (p->dev == dev && p->range == range) {
 				*s = p->next;
@@ -101,7 +104,7 @@ struct kobject *kobj_lookup(struct kobj_map *domain, dev_t dev, int *index)
 
 retry:
 	mutex_lock(domain->lock);
-	for (p = domain->probes[MAJOR(dev) % 255]; p; p = p->next) {
+	for (p = domain->probes[MAJOR(dev) % KOBJ_MAP_PROBES]; p; p = p->next) {
 		struct kobject *(*probe)(dev_t, int *, void *);
 		struct module *owner;
 		void *data;
@@ -148,7 +151,7 @@ struct kobj_map *kobj_map_init(kobj_probe_t *base_probe, struct mutex *lock)
 	base->dev = 1;
 	base->range = ~0;
 	base->get = base_probe;
-	for (i = 0; i < 255; i++)
+	for (i = 0; i < KOBJ_MAP_PROBES; i++)
 		p->probes[i] = base;
 	p->lock = lock;
 	return p;
-- 
1.5.3.4