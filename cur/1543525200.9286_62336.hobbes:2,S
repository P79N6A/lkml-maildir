Date: Thu, 10 Feb 2000 17:48:50 +0100
From: Manfred Spraul <>
Subject: [RFC] improve show()
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/2/10/96

show() is used by wait_on_{irq,bh}() to print the call trace, but the
current code has 2 problems:
1) it doesn't handle modules. That's easy to fix, just replace the
for(;;) loop with show_stack(NULL);
2) it prints the call trace of the wrong cpu. If you try to understand
why the kernel locked up, you need the call trace of all cpus.
I've attached my current patch, is such a patch usefull in a normal
(!=ikd) kernel?
--
	Manfred--- 2.3/arch/i386/kernel/irq.c	Thu Feb 10 14:24:45 2000
+++ build-2.3/arch/i386/kernel/irq.c	Thu Feb 10 17:42:16 2000
@@ -187,6 +187,7 @@
 unsigned char global_irq_holder = NO_PROC_ID;
 unsigned volatile int global_irq_lock;
 atomic_t global_irq_count;
+extern void show_stack(unsigned long* esp);
 
 static void show(char * str)
 {
@@ -194,18 +195,28 @@
 	unsigned long *stack;
 	int cpu = smp_processor_id();
 
-	printk("\n%s, CPU %d:\n", str, cpu);
-	printk("irq:  %d [%d %d]\n",
-		atomic_read(&global_irq_count), local_irq_count[0], local_irq_count[1]);
-	printk("bh:   %d [%d %d]\n",
-		spin_is_locked(&global_bh_lock) ? 1 : 0, local_bh_count[0], local_bh_count[1]);
-	stack = (unsigned long *) &stack;
-	for (i = 40; i ; i--) {
-		unsigned long x = *++stack;
-		if (x > (unsigned long) &get_option && x < (unsigned long) &vsprintf) {
-			printk("<[%08lx]> ", x);
-		}
-	}
+	printk("irq:  %d [",atomic_read(&global_irq_count));
+	for(i=0;i < smp_num_cpus;i++)
+		printk(" %d",local_irq_count[i]);
+	printk("]\nbh:   %d [",spin_is_locked(&global_bh_lock) ? 1 : 0);
+	for(i=0;i < smp_num_cpus;i++)
+		printk(" %d",local_bh_count[i]);
+	/* Collect all back traces.
+	 */
+	printk("]\nStack dump:");
+	for(i=0;i< smp_num_cpus;i++) {
+		unsigned long esp;
+		if(i==cpu)
+			continue;
+		printk("\nCPU %d:",i);
+		esp = init_tss[i].esp0;
+		esp &= ~(THREAD_SIZE-1);
+		esp += sizeof(struct task_struct);
+		show_stack((void*)esp);
+ 	}
+	printk("\nCPU %d:",smp_processor_id());
+	show_stack(NULL);
+	printk("\n");
 }
 	
 #define MAXCOUNT 100000000