Date: Tue, 15 May 2007 16:56:36 -0700
From: Andrew Morton <>
Subject: Re: slab hang on boot
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/5/15/326

On Tue, 15 May 2007 16:45:22 -0700 (PDT)
Christoph Lameter <clameter@sgi.com> wrote:
> On Tue, 15 May 2007, Andrew Morton wrote:
> 
> > On Mon, 14 May 2007 16:46:17 -0700 (PDT)
> > Christoph Lameter <clameter@sgi.com> wrote:
> > 
> > > @@ -86,6 +87,9 @@ static inline int kmalloc_index(int size
> > >  	 */
> > >  	WARN_ON_ONCE(size == 0);
> > > 
> > > +	if (size >= (1UL << KMALLOC_SHIFT_HIGH))
> > > +		return -1;
> > > +
> > 
> > I don't quite understand why we did this.  The subsequent logic in
> > kmalloc_index() should return -1 for this `size' anyway.  If it doesn't,
> > it's bust, isn't it?
> 
> KMALLOC_SHIFT_HIGH is not a constant but may be less than 25.
It darn well better be a compile-time constant.
And look:
static inline int kmalloc_index(int size)
{
	/*
	 * We should return 0 if size == 0 but we use the smallest object
	 * here for SLAB legacy reasons.
	 */
	WARN_ON_ONCE(size == 0);
	if (size > (1 << KMALLOC_SHIFT_HIGH))
		return -1;
	if (size > 64 && size <= 96)
		return 1;
	if (size > 128 && size <= 192)
		return 2;
	if (size <=          8) return 3;
	if (size <=         16) return 4;
	if (size <=         32) return 5;
	if (size <=         64) return 6;
	if (size <=        128) return 7;
	if (size <=        256) return 8;
	if (size <=        512) return 9;
	if (size <=       1024) return 10;
	if (size <=   2 * 1024) return 11;
	if (size <=   4 * 1024) return 12;
	if (size <=   8 * 1024) return 13;
	if (size <=  16 * 1024) return 14;
	if (size <=  32 * 1024) return 15;
	if (size <=  64 * 1024) return 16;
	if (size <= 128 * 1024) return 17;
	if (size <= 256 * 1024) return 18;
#if KMALLOC_SHIFT_HIGH > 18
	if (size <=  512 * 1024) return 19;
	if (size <= 1024 * 1024) return 20;
#endif
#if KMALLOC_SHIFT_HIGH > 20
	if (size <=  2 * 1024 * 1024) return 21;
	if (size <=  4 * 1024 * 1024) return 22;
	if (size <=  8 * 1024 * 1024) return 23;
	if (size <= 16 * 1024 * 1024) return 24;
	if (size <= 32 * 1024 * 1024) return 25;
#endif
	return -1;
/*
 * What we really wanted to do and cannot do because of compiler issues is:
 *	int i;
 *	for (i = KMALLOC_SHIFT_LOW; i <= KMALLOC_SHIFT_HIGH; i++)
 *		if (size <= (1 << i))
 *			return i;
 */
}
Either that newly-added test isn't needed, or those ifdefs aren't needed?
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/