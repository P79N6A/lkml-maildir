Date: Wed, 17 Dec 2008 09:14:22 +0800
From: Huang Ying <>
Subject: Re: [RFC PATCH crypto] AES: Add support to Intel AES-NI	instructions
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/12/16/516

On Wed, 2008-12-17 at 07:31 +0800, Herbert Xu wrote:
> On Mon, Dec 15, 2008 at 11:38:01PM +1100, Herbert Xu wrote:
> > On Mon, Dec 15, 2008 at 04:21:06PM +1100, Herbert Xu wrote:
> > >
> > > > a. Do not touch SSE state in soft_irq
> > > > b. Disable/restore soft_irq in kernel_fpu_begin/kernel_fpu_end
> > > > c. Use a per-CPU data structure to save kernel FPU state during
> > > > soft_irq.
> 
> > Here's another option
> > 
> > d. When we're in interrupt context, schedule a task to perform
> > the encryption asynchronously.
> 
> We can also hybridise b. and d.:
> 
> e. When we're in interrupt context, if TS is clear, then we defer
> the operation to a thread.  Otherwise if user-space has touched
> the FPU we save the state, if not then we simply clear TS.  In
> either case we perform the operation immediately and then reset
> TS if user-space didn't touch the FPU.
> 
> This is based on the fact that it should be fairly rare for us
> to interrupt a kernel FPU/SSE operation.  The common case would
> be interrupting a user process or a kernel context which is not
> engaging in any kernel FPU operations.
Yes. This is a better solution with much better performance. How about
hybridise b. and a.:
f. if TS is clear, then use x86_64 implementation. Otherwise if
user-space has touched the FPU, we save the state, if not then simply
clear TS.
I think that could be simpler to be implemented.
Best Regards,
Huang Ying
[unhandled content-type:application/pgp-signature]