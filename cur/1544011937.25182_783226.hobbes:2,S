Date: Mon, 22 Dec 2008 11:39:53 +0100
From: Sebastian Andrzej Siewior <>
Subject: Re: [PATCH v2] add man-page for pthread_mutexattr_setrobust_np()
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/12/22/43

* Bert Wesarg | 2008-12-22 08:32:15 [+0100]:
>> +static int open_existing_lock(void)
>> +{
>> +    int fd;
>> +    int ret;
>> +    struct stat buf;
>> +    int retry = 5;
>> +
>> +    fd = open(lock_name, O_RDWR);
>> +    if (fd < 0)
>> +        return fd;
>> +    do {
>> +        ret = fstat(fd, &buf);
>> +        if (ret < 0)
>Isn't here a close(2) missing?
yes it is. Thx.
>> +            return ret;
>> +
>> +        if (buf.st_size == sizeof(*limi_mutex))
>> +            return fd;
>> +
>> +        close(fd);
>Isn't this close(2) wrong here?
uhhh. Actually I wanted to have the open() within the do while loop. So
I move that and this will be fine then.
>> +        sleep(1);
>> +        retry\-\-;
>> +    } while (retry);
>> +
>> +    close(fd);
>> +    return \-1;
>> +}
>> +
>> +static int create_new_lock(void)
>> +{
>> +    int fd;
>> +    pthread_mutex_t cmutex = PTHREAD_MUTEX_INITIALIZER;
>> +    pthread_mutexattr_t attr;
>> +    int ret;
>> +
>> +    pthread_mutexattr_init(&attr);
>> +    pthread_mutexattr_setrobust_np(&attr, PTHREAD_MUTEX_ROBUST_NP);
>> +    pthread_mutex_init(&cmutex, &attr);
>> +
>> +    fd = open(lock_name, O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR |
>> +            S_IRGRP | S_IWGRP);
>> +    if (fd < 0)
>> +        return fd;
>> +
>> +    ret = write(fd, &cmutex, sizeof(cmutex));
>I think its undefined behavior if you copy a struct pthread_mutex. You
>should use mmap here too.
Why should be this undefined? Is there something special about this
struct? And why should this behave different with mmap() ?
Sebastian