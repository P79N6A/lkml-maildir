Date: Sat, 7 Aug 1999 20:07:35 +0200
From: "Robert de Vries" <>
Subject: Re: [NEW PATCH] timers, sysctl, signal (only to get POSIX timers and clocks)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/8/8/68

>+       KERN_CLK_TCK=41,        /* int: Ticks per second (clock_t) */
>
>There are several HZ values that currently happen to be the same.
>We have the HZ as seen in /proc, the HZ as seen in the clocks system
>call, and the HZ as actually used in the kernel for jiffies.
What's the difference?
> Linus
>has in the past objected to exposing the real HZ because the real HZ
>may differ from that seen in /proc. I think you can satisfy that
>objection by making a distinction.
Ok.
>
>+       KERN_LINUX_COUNTER_HZ=77 /* int: Frequency of free running counter
*/
>
>This is a CPU hardware counter? I never would have guessed.
>CPU_COUNTER_HZ and CPU_TSC_HZ are more descriptive.
The philosophy is that most processors have some form of counter. Not all of
them are in the CPU and they are not always called TSC. I wanted something
generic.
>
>+int good_timespec(const struct timespec *ts)
>+{
>+       if (ts == NULL) return 0;
>+       if (ts->tv_sec < 0) return 0;
>+       if ((ts->tv_nsec < 0) || (ts->tv_nsec >= NSEC_PER_SEC)) return 0;
>+       return 1;
>+}
>
>You wouldn't have to do so much IN THE KERNEL (hint, hint) if you
>used nice simple 64-bit values. Ask yourself "Why am I doing this?".
>The kernel API is something we are stuck with long-term.
>
>+       /* check whether the time lies in the past */
>+       if ((val->tv_sec < ts.tv_sec) ||
>+           ((val->tv_sec == ts.tv_sec) &&
>+            (val->tv_nsec <= ts.tv_nsec))) {
>+               /* expire immediately */
>+               val->tv_sec = 0;
>+               val->tv_nsec = 0;
>+       }
>+       else {
>+               val->tv_sec -= ts.tv_sec;
>+               val->tv_nsec -= ts.tv_nsec;
>+               if (val->tv_nsec < 0) {
>+                       val->tv_nsec += NSEC_PER_SEC;
>+                       val->tv_sec--;
>+               }
>+       }
>
>
>Hmmm...
>
>if(val<=ts) val=0;
>else val -= ts;
>
>The structs become a permanent part of the kernel API, even on 64-bit
>hardware that would be able to directly work with larger values.
Point taken, are you sure that all platforms can do 64 bit calculations?
(or does the compiler support it?)
        Robert
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/