Date: Wed, 10 Mar 1999 20:32:19 +0100 (CET)
From: Andrzej Krzysztofowicz <>
Subject: xconfig 2.2.[23] patch ...
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/3/10/144

Hi,
   I enclose my newest xconfig patch against 2.2.[23]. It fixes many 
of known bugs and introduces submenus. Xconfig users: please test it
and mail me your positive/negative opinions.
   Mail me also if you find any new xconfig problems which can be fixed in
next release.
   Sorry for sending the patch to the list, but I'm afraid that my ftp
site
(
ftp://rudy.mif.pg.gda.pl/pub/People/ankry/linux-patches/2.2/xconfig/
)
may be poorly accessible for most subscribers.
Regards
   Andrzej
--
=======================================================================
  Andrzej M. Krzysztofowicz               ankry@mif.pg.gda.pl
  phone (48)(58) 347 14 61
Faculty of Applied Phys. & Math.,   Technical University of Gdansk
diff -u --recursive linux-2.2.2-ac1/scripts/header.tk linux/scripts/header.tk
--- linux-2.2.2-ac1/scripts/header.tk	Tue Feb 23 23:22:36 1999
+++ linux/scripts/header.tk	Tue Feb 23 23:33:38 1999
@@ -67,9 +67,11 @@
 
 proc menu_option { w menu_num text } {
 	global menus_per_column
-	if { $menu_num <= $menus_per_column } then {
+	global processed_top_level
+	set processed_top_level [expr $processed_top_level + 1]
+	if { $processed_top_level <= $menus_per_column } then {
 	    set myframe left
-	} elseif { $menu_num <= [expr 2 * $menus_per_column] } then {
+	} elseif { $processed_top_level <= [expr 2 * $menus_per_column] } then {
 	    set myframe middle
 	} else {
 	    set myframe right
@@ -211,7 +213,7 @@
 	}
 	close $file1
 	update_choices
-	update_mainmenu .rdupd
+	update_mainmenu
 }
 proc write_comment { file1 file2 text } {
     	puts $file1 ""
@@ -282,11 +284,11 @@
 proc toggle_switch2 {w mnum line text variable} {
 	frame $w.x$line -relief sunken
 	radiobutton $w.x$line.y -text "y" -variable $variable -value 1 \
-		-relief groove -width 2 -command "update_menu$mnum .menu$mnum"
+		-relief groove -width 2 -command "update_active .menu$mnum"
 	radiobutton $w.x$line.m -text "-"  -variable $variable -value 2 \
-		-relief groove -width 2 -command "update_menu$mnum .menu$mnum"
+		-relief groove -width 2 -command "update_active .menu$mnum"
 	radiobutton $w.x$line.n -text "n"  -variable $variable -value 0 \
-		-relief groove -width 2 -command "update_menu$mnum .menu$mnum"
+		-relief groove -width 2 -command "update_active .menu$mnum"
 		
 	option_name $w $mnum $line $text $variable
 		
@@ -296,11 +298,11 @@
 proc toggle_switch3 {w mnum line text variable} {
 	frame $w.x$line -relief sunken
 	radiobutton $w.x$line.y -text "y" -variable $variable -value 1 \
-		-relief groove -width 2 -command "update_menu$mnum .menu$mnum"
+		-relief groove -width 2 -command "update_active .menu$mnum"
 	radiobutton $w.x$line.m -text "m"  -variable $variable -value 2 \
-		-relief groove -width 2 -command "update_menu$mnum .menu$mnum"
+		-relief groove -width 2 -command "update_active .menu$mnum"
 	radiobutton $w.x$line.n -text "n"  -variable $variable -value 0 \
-		-relief groove -width 2 -command "update_menu$mnum .menu$mnum"
+		-relief groove -width 2 -command "update_active .menu$mnum"
 		
 	option_name $w $mnum $line $text $variable
 		
@@ -358,6 +360,18 @@
 	pack $w.x$line -anchor w -fill both -expand on
 }
 
+proc submenu { w mnum line text subnum } {
+	frame $w.x$line
+	button $w.x$line.l -text "" -width 15 -relief groove
+	$w.x$line.l configure -activefore [cget $w.x$line.l -fg] \
+		-activeback [cget $w.x$line.l -bg] -state disabled
+	button $w.x$line.m -text "$text" -relief raised -anchor w \
+		-command "destroy .menu$subnum; menu$subnum .menu$subnum \"$text\""
+	pack $w.x$line.l -side left -fill both
+	pack $w.x$line.m -anchor w -side right -fill both -expand on
+	pack $w.x$line -anchor w -fill both -expand on
+}
+
 proc comment {w line text } {
 #nothing done for comments now.
 }
@@ -417,7 +431,7 @@
 	#
 	frame $w.f2
 	button $w.f2.ok -text "OK" \
-		-width 10 -command "destroy $w; focus $oldFocus"
+		-width 10 -command "destroy $w; catch {focus $oldFocus}"
 	pack $w.f2.ok -side bottom -pady 6 -anchor n
 	pack $w.f2 -side bottom -padx 10 -anchor s
 
@@ -458,6 +472,28 @@
 
 }
 
+proc unregister_active {w} {
+	global active_menus
+	set index [lsearch -exact $active_menus $w]
+	if {$index != -1} then {set active_menus [lreplace $active_menus $index $index]}
+}
+
+proc update_active {w} {
+	global active_menus
+	foreach i $active_menus {
+		set error_code [catch update_$i]
+		if {$error_code != 0} then {unregister_active $i}
+	}
+}
+
+proc validate_int {name val} {
+	if {([exec echo $val | sed s/^-//g | tr -d \[:digit:\] ] != "")} then {global $name; set $name 0}
+}
+
+proc validate_hex {name val} {
+	if {([exec echo $val | tr -d \[:xdigit:\] ] != "")} then {global $name; set $name 0}
+}
+
 #
 # Next set up the particulars for the top level menu, and define a few
 # buttons which we will stick down at the bottom.
@@ -468,3 +504,5 @@
 frame .f0.middle
 frame .f0.right
 
+set active_menus [list]
+set processed_top_level 0
diff -u --recursive linux-2.2.2-ac1/scripts/tail.tk linux/scripts/tail.tk
--- linux-2.2.2-ac1/scripts/tail.tk	Fri Jan 15 23:36:20 1999
+++ linux/scripts/tail.tk	Tue Feb 23 23:33:38 1999
@@ -29,7 +29,7 @@
 	read_config $defaults
 }
 
-update_mainmenu .f0
+update_mainmenu
 
 button .f0.right.save -anchor w -text "Save and Exit" \
     -command { writeconfig .config include/linux/autoconf.h; wrapup .wrap }
diff -u --recursive linux-2.2.2-ac1/scripts/tkcond.c linux/scripts/tkcond.c
--- linux-2.2.2-ac1/scripts/tkcond.c	Wed Jan 20 19:05:49 1999
+++ linux/scripts/tkcond.c	Tue Feb 23 23:36:53 1999
@@ -108,14 +108,42 @@
 {
     struct condition * cond_list;
     struct condition * cond_last;
-    int i;
+    int i, is_first = 1;
 
     cond_list = cond_last = NULL;
     for ( i = 0; i < depth; i++ )
     {
+	if ( conditions[i]->op == op_false )
+	{
+	    struct condition * cnew;
+
+	    /* It is always false condition */
+	    cnew = malloc( sizeof(*cnew) );
+	    memset( cnew, 0, sizeof(*cnew) );
+	    cnew->op = op_false;
+	    cond_list = cond_last = cnew;
+	    goto join_done;
+	}
+    }
+    for ( i = 0; i < depth; i++ )
+    {
 	struct condition * cond;
 	struct condition * cnew;
 
+	/* omit always true conditions */
+	if ( conditions[i]->op == op_true )
+	    continue;
+
+	/* if i have another condition, add an '&&' operator */
+	if ( !is_first )
+	{
+	    cnew = malloc( sizeof(*cnew) );
+	    memset( cnew, 0, sizeof(*cnew) );
+	    cnew->op = op_and;
+	    cond_last->next = cnew;
+	    cond_last = cnew;
+	}
+
 	/* add a '(' */
 	cnew = malloc( sizeof(*cnew) );
 	memset( cnew, 0, sizeof(*cnew) );
@@ -143,16 +171,7 @@
 	cnew->op = op_rparen;
 	cond_last->next = cnew;
 	cond_last = cnew;
-
-	/* if i have another condition, add an '&&' operator */
-	if ( i < depth - 1 )
-	{
-	    cnew = malloc( sizeof(*cnew) );
-	    memset( cnew, 0, sizeof(*cnew) );
-	    cnew->op = op_and;
-	    cond_last->next = cnew;
-	    cond_last = cnew;
-	}
+	is_first = 0;
     }
 
     /*
@@ -219,10 +238,125 @@
 	}
     }
 
+join_done:
     return cond_list;
 }
 
+static char * current_arch = NULL;
+
+void free_cond( struct condition *cond )
+{
+    struct condition *tmp, *tmp1;
+    for ( tmp = cond; tmp; tmp = tmp1 )
+    {
+	tmp1 = tmp->next;
+	if ( tmp->str )
+	    free( (void*)tmp->str );
+	free( (void*)tmp );
+    }
+}
+
+/*
+ * Eliminating conditions with ARCH=<not current>.
+ */
+struct condition *eliminate_other_arch( struct condition *list )
+{
+    struct condition *cond1a = list, *cond1b = NULL, *cond1c = NULL, *cond1d = NULL;
+
+    if ( current_arch == NULL )
+	current_arch = getenv( "ARCH" );
+    if ( cond1a->op == op_variable && ! strcmp( cond1a->str, "ARCH" ) )
+    {
+	cond1b = cond1a->next; if ( cond1b == NULL ) goto done;
+	cond1c = cond1b->next; if ( cond1c == NULL ) goto done;
+	cond1d = cond1c->next;
+
+	if ( cond1d == NULL )
+	{
+	    if ( (cond1b->op == op_eq && strcmp( cond1c->str, current_arch ))
+	    || (cond1b->op == op_neq && ! strcmp( cond1c->str, current_arch )) )
+	    {
+		/* This is for another architecture */ 
+		cond1a->op = op_false;
+		free( (void*)cond1a->str );
+		cond1a->str = NULL;
+		free_cond( cond1b );
+		return cond1a;
+	    }
+	    else if ( (cond1b->op == op_neq && strcmp( cond1c->str, current_arch ))
+		 || (cond1b->op == op_eq && ! strcmp( cond1c->str, current_arch )) )
+	    {
+		/* This is for current architecture */
+		cond1a->op = op_true;
+		free( (void*)cond1a->str );
+		cond1a->str = NULL;
+		free_cond( cond1b );
+		return cond1a;
+	    }
+	}
+	else if ( cond1d->op == op_or )
+	{
+	    if ( (cond1b->op == op_eq && strcmp( cond1c->str, current_arch ))
+	    || (cond1b->op == op_neq && ! strcmp( cond1c->str, current_arch )) )
+	    {
+		/* This is for another architecture */ 
+		cond1b = cond1d->next;
+		cond1d->next = NULL;
+		free_cond( cond1a );
+		return eliminate_other_arch( cond1b );
+	    }
+	    else if ( (cond1b->op == op_neq && strcmp( cond1c->str, current_arch ))
+		 || (cond1b->op == op_eq && ! strcmp( cond1c->str, current_arch )) )
+	    {
+		/* This is for current architecture */
+		cond1a->op = op_true;
+		cond1a->next = NULL;
+		free( (void*)cond1a->str );
+		cond1a->str = NULL;
+		free_cond( cond1b );
+		return cond1a;
+	    }
+	}
+    }
+done:
+    return list;
+}
+
+/*
+ * Eliminating kvariables pointing to removed options.
+ */
+static void fix_kvariable( struct kconfig * cfg, struct kconfig * scfg )
+{
+    struct kconfig *cfg1, *cfg2;
+    struct condition * cond;
+    int found = 0;
+
+    for ( cfg2 = scfg; cfg2 != NULL; cfg2 = cfg2->next )
+	if ( ( cfg2->token == token_bool
+	||   cfg2->token == token_choice_item
+	||   cfg2->token == token_dep_tristate
+	||   cfg2->token == token_hex
+	||   cfg2->token == token_int
+	||   cfg2->token == token_string
+	||   cfg2->token == token_tristate )
+	&&   ! strcmp( cfg2->optionname, cfg->optionname ) )
+		break;
 
+    for ( cfg1 = scfg; cfg1 != NULL; cfg1 = cfg1->next )
+	for ( cond = cfg1->cond; cond != NULL; cond = cond->next )
+	    if ( cond->op == op_kvariable )
+		if ( cond->cfg == cfg )
+		{
+		    if ( cfg2 )
+			cond->cfg = cfg2;
+		    else
+		    {
+			cond->cfg = NULL;
+			cond->str = strdup( cfg->optionname );
+			cond->op  = op_variable;
+		    }
+		}
+}
 
 /*
  * This is the main transformation function.
@@ -290,9 +424,12 @@
     {
 	struct condition * cond_stack [32];
 	int depth = 0;
+	struct kconfig * prev = NULL;
 
 	for ( cfg = scfg; cfg != NULL; cfg = cfg->next )
 	{
+	    int good = 1;
+
 	    switch ( cfg->token )
 	    {
 	    default:
@@ -325,6 +462,8 @@
 			case op_or:  cond->op = op_and1; break;
 			case op_neq: cond->op = op_eq;   break;
 			case op_eq:  cond->op = op_neq;  break;
+			case op_true: cond->op = op_false;break;
+			case op_false:cond->op = op_true; break;
 			}
 		    }
 		}
@@ -336,6 +475,7 @@
 
 	    case token_bool:
 	    case token_choice_item:
+	    case token_choice_header:
 	    case token_comment:
 	    case token_define_bool:
 	    case token_hex:
@@ -344,6 +484,15 @@
 	    case token_string:
 	    case token_tristate:
 		cfg->cond = join_condition_stack( cond_stack, depth );
+		if ( cfg->cond && cfg->cond->op == op_false )
+		{
+		    good = 0;
+		    if ( prev )
+			prev->next = cfg->next;
+		    else
+			scfg = cfg->next;
+		    fix_kvariable( cfg, scfg );
+		}
 		break;
 
 	    case token_dep_tristate:
@@ -353,8 +502,19 @@
 		 */
 		cond_stack [depth] = cfg->cond;
 		cfg->cond = join_condition_stack( cond_stack, depth+1 );
+		if ( cfg->cond && cfg->cond->op == op_false )
+		{
+		    good = 0;
+		    if ( prev )
+			prev->next = cfg->next;
+		    else
+			scfg = cfg->next;
+		    fix_kvariable( cfg, scfg );
+		}
 		break;
 	    }
+	    if ( good )
+		prev = cfg;
 	}
     }
 }
diff -u --recursive linux-2.2.2-ac1/scripts/tkgen.c linux/scripts/tkgen.c
--- linux-2.2.2-ac1/scripts/tkgen.c	Tue Feb 23 23:22:36 1999
+++ linux/scripts/tkgen.c	Tue Feb 23 23:36:07 1999
@@ -92,9 +92,24 @@
  *
  * 23 January 1999, Michael Elizabeth Chastain <mec@shout.net>
  * - Remove bug-compatible code.
+ *
+ * 30 January 1999, Andrzej M. Krzysztofowicz <ankry@mif.pg.gda.pl>
+ * Some bugfixes, including
+ * - disabling "m" options when CONFIG_MODULES is set to "n" as well as "y"
+ *   option in dep_tristate when dependency is set to "m",
+ * - deactivating choices which should not be available,
+ * - validation for int and hex introduced by resetting value to 0 if the 
+ *   entered one is not valid,
+ * - updates of all opened menus instead of the active only. I was afraid
+ *   that it would slow down updates, but I don't even see any speed difference
+ *   on my machine. If it slows you can still work with only a single menu
+ *   opened,
+ * - fixed error when focussing non-existent window (especially Help windows),
+ * Higher level submenus implemented.
  */
 
 #include <stdio.h>
+#include <stdlib.h>
 #include <unistd.h>
 #include "tkparse.h"
 
@@ -105,20 +120,34 @@
  */
 static int tot_menu_num = 0;
 
-
+/*
+ * Pointers to mainmenu_option and endmenu of each menu.
+ */
+struct kconfig * menu_first [256];
+struct kconfig * menu_last  [256];
 
 /*
  * Generate portion of wish script for the beginning of a submenu.
  * The guts get filled in with the various options.
  */
-static void start_proc( char * label, int menu_num, int flag )
+static void start_proc( char * label, int menu_num, int toplevel )
 {
-    if ( flag )
+    if ( toplevel )
 	printf( "menu_option menu%d %d \"%s\"\n", menu_num, menu_num, label );
     printf( "proc menu%d {w title} {\n", menu_num );
-    printf( "\tcatch {destroy $w}\n" );
+    printf( "\tset oldFocus [focus]\n" );
+    if ( menu_first[menu_num]->menu_number != 0 )
+    {
+	printf( "\tif {[catch {focus .menu%d}] != 0} then ",
+		menu_first[menu_num]->menu_number );
+	printf( "{menu%d .menu%d \"%s\"}\n",
+		menu_first[menu_num]->menu_number, menu_first[menu_num]->menu_number, menu_first[menu_num]->label );
+    }
+    printf( "\tcatch {destroy $w; unregister_active menu%d}\n", menu_num );
     printf( "\ttoplevel $w -class Dialog\n" );
     printf( "\twm withdraw $w\n" );
+    printf( "\tglobal active_menus\n" );
+    printf( "\tset active_menus [linsert $active_menus end menu%d]\n", menu_num );
     printf( "\tmessage $w.m -width 400 -aspect 300 -text \\\n" );
     printf( "\t\t\"%s\"  -relief raised\n", label );
     printf( "\tpack $w.m -pady 10 -side top -padx 10\n" );
@@ -127,16 +156,45 @@
     /*
      * Attach the "Prev", "Next" and "OK" buttons at the end of the window.
      */
-    printf( "\tset oldFocus [focus]\n" );
     printf( "\tframe $w.f\n" );
-    printf( "\tbutton $w.f.back -text \"Main Menu\" \\\n" );
-    printf( "\t\t-width 15 -command \"destroy $w; focus $oldFocus; update_mainmenu $w\"\n" );
+    if ( toplevel )
+	printf( "\tbutton $w.f.back -text \"Main Menu\" \\\n" );
+    else
+	printf( "\tbutton $w.f.back -text \"OK\" \\\n" );
+    printf( "\t\t-width 15 -command \"catch {focus $oldFocus}; destroy $w; unregister_active menu%d; ",
+	menu_num );
+    if ( menu_first[menu_num]->menu_number != 0 )
+	printf( "update_active $w\"\n" );
+    else
+	printf( "update_mainmenu\"\n" );
     printf( "\tbutton $w.f.next -text \"Next\" \\\n" );
-    printf( "\t\t-width 15 -command \" destroy $w; focus $oldFocus;  menu%d .menu%d \\\"$title\\\"\"\n", menu_num+1, menu_num+1 );
+    printf( "\t\t-width 15 -command \"catch {focus $oldFocus}; " );
+    /* 
+     * We are checking which windows should be destroyed and which are 
+     * common parrents with the next one. Remember that menu_num field
+     * in mainmenu_option record reports number of its *parent* menu.
+     */
+    if ( menu_num < tot_menu_num
+    && menu_first[menu_num + 1]->menu_number != menu_num )
+    {
+	int to_destr;
+
+	printf( "destroy $w; unregister_active menu%d; ", menu_num );
+	to_destr = menu_first[menu_num]->menu_number;
+	while ( to_destr > 0 && menu_first[menu_num + 1]->menu_number != to_destr )
+	{
+	    printf( "destroy .menu%d; unregister_active menu%d; ",
+		to_destr, to_destr );
+	    to_destr = menu_first[to_destr]->menu_number;
+	}
+    }
+    printf( "menu%d .menu%d \\\"$title\\\"\"\n",
+	menu_num+1, menu_num+1 );
     if ( menu_num == tot_menu_num )
 	printf( "\t$w.f.next configure -state disabled\n" );
     printf( "\tbutton $w.f.prev -text \"Prev\" \\\n" );
-    printf( "\t\t-width 15 -command \" destroy $w; focus $oldFocus; menu%d .menu%d \\\"$title\\\"\"\n", menu_num-1, menu_num-1 );
+    printf( "\t\t-width 15 -command \"catch {focus $oldFocus}; destroy $w; unregister_active menu%d; menu%d .menu%d \\\"$title\\\"\"\n",
+	menu_num, menu_num-1, menu_num-1 );
     if ( menu_num == 1 )
 	printf( "\t$w.f.prev configure -state disabled\n" );
     printf( "\tpack $w.f.back $w.f.next $w.f.prev -side left -expand on\n" );
@@ -311,9 +369,16 @@
 	break;
 
     case token_choice_header:
-	fprintf( stderr, "Internal error on token_choice_header\n" );
-	exit( 1 );
-
+	printf( ".menu%d.config.f.x%d.x configure -state normal;",
+	    menu_num, line_num );
+	printf( ".menu%d.config.f.x%d.l configure -state normal;",
+	    menu_num, line_num );
+	printf( "} else { " );
+	printf( ".menu%d.config.f.x%d.x configure -state disabled;",
+	    menu_num, line_num );
+	printf( ".menu%d.config.f.x%d.l configure -state disabled;}\n",
+	    menu_num, line_num );
+	break;
     case token_choice_item:
 	fprintf( stderr, "Internal error on token_choice_item\n" );
 	exit( 1 );
@@ -324,20 +389,24 @@
 	break;
 
     case token_dep_tristate:
+	printf( "\n" );
+	global( cfg->depend );
+	printf( "\tif {($%s != 1) && ($%s != 0) && ($%s == 1)} then {set %s 2};",
+	    cfg->depend, cfg->depend, cfg->optionname, cfg->optionname );
+	printf( "if { $%s != 1 && $%s != 0 } then {",
+	    cfg->depend, cfg->depend );
+	printf( ".menu%d.config.f.x%d.y configure -state disabled;",
+	    menu_num, line_num );
+	printf( "} else {" );
+	printf( ".menu%d.config.f.x%d.y configure -state normal;",
+	    menu_num, line_num );
+	printf( "}; " );
     case token_tristate:
-	if ( cfg->token == token_dep_tristate )
-	{
-	    global( cfg->depend );
-	    printf( "if { $%s != 1 && $%s != 0 } then {",
-		cfg->depend, cfg->depend );
-	    printf( ".menu%d.config.f.x%d.y configure -state disabled;",
-		menu_num, line_num );
-	    printf( "} else {" );
-	    printf( ".menu%d.config.f.x%d.y configure -state normal;",
-		menu_num, line_num);
-	    printf( "}; " );
-	}
-	else
+	printf( "\n\tif {($CONFIG_MODULES == 0) && ($%s == 2)} then {",
+	    cfg->optionname );
+	printf( "if {[cget .menu%d.config.f.x%d.y -state] == \"normal\"} then {set %s 1} else {set %s 0};};",
+	    menu_num, line_num, cfg->optionname, cfg->optionname );
+	if ( cfg->token == token_tristate )
 	{
 	    printf( ".menu%d.config.f.x%d.y configure -state normal;",
 		menu_num, line_num );
@@ -345,7 +414,9 @@
 
 	printf( ".menu%d.config.f.x%d.n configure -state normal;",
 	    menu_num, line_num );
-	printf( "global CONFIG_MODULES; if {($CONFIG_MODULES == 1)} then { .menu%d.config.f.x%d.m configure -state normal };",
+	printf( "if {($CONFIG_MODULES == 1)} then { .menu%d.config.f.x%d.m configure -state normal } else {",
+	    menu_num, line_num );
+	printf( ".menu%d.config.f.x%d.m configure -state disabled };",
 	    menu_num, line_num );
 	printf( ".menu%d.config.f.x%d.l configure -state normal;",
 	    menu_num, line_num );
@@ -374,7 +445,12 @@
 	break;
 
     case token_hex:
+	printf( "validate_hex %s \"$%s\"; ",
+	    cfg->optionname, cfg->optionname );
     case token_int:
+	if ( cfg->token == token_int )
+	    printf( "validate_int %s \"$%s\"; ",
+		cfg->optionname, cfg->optionname );
     case token_string:
 	printf( ".menu%d.config.f.x%d.x configure -state normal -foreground [ cget .ref -foreground ]; ",
 	    menu_num, line_num);
@@ -388,8 +464,17 @@
 	break;
 
     case token_mainmenu_option:
-	printf( ".f0.x%d configure -state normal } else { .f0.x%d configure -state disabled }\n",
-	    menu_num, menu_num );
+	if ( line_num >= 0 )
+	{
+	    printf( ".menu%d.config.f.x%d.m configure -state normal",
+		menu_num, line_num );
+	    printf( "} else {" );
+	    printf( ".menu%d.config.f.x%d.m configure -state disabled}\n",
+		menu_num, line_num );
+	}
+	else
+	    printf( ".f0.x%d configure -state normal } else { .f0.x%d configure -state disabled }\n",
+		menu_num, menu_num );
 	break;
     }
 }
@@ -442,7 +527,6 @@
     /*
      * Generate indentation.
      */
-    if ( cfg->token != token_choice_header )
 	printf( "\t" );
 
     /*
@@ -520,12 +604,15 @@
 		  cfg1 != NULL && cfg1->token == token_choice_item;
 		  cfg1  = cfg1->next )
 	    {
-		printf("\tif { $%s == \"%s\" } then { write_tristate $cfg $autocfg %s 1 $notmod } else { write_tristate $cfg $autocfg %s 0 $notmod }\n",
+		printf("\n\tif { $%s == \"%s\" } then { write_tristate $cfg $autocfg %s 1 $notmod } else { write_tristate $cfg $autocfg %s 0 $notmod }",
 		    cfg->optionname, cfg1->label,
 		    cfg1->optionname,
 		    cfg1->optionname );
 	    }
 	}
+	if ( cfg->cond != NULL )
+	    printf( "}" );
+	printf( "\n" );
 	break;
 
     case token_choice_item:
@@ -606,10 +693,13 @@
 
     printf( "\n\n\n" );
     printf( "\tfocus $w\n" );
-    printf( "\tupdate_menu%d $w.config.f\n",
-	menu_num );
+    printf( "\tupdate_active $w\n" );
     printf( "\tglobal winx; global winy\n" );
-    printf( "\tset winx [expr [winfo x .]+30]; set winy [expr [winfo y .]+30]\n" );
+    if ( menu_first[menu_num]->menu_number != 0 )
+	printf( "\tset winx [expr [winfo x .menu%d]+30]; set winy [expr [winfo y .menu%d]+30]\n",
+		menu_first[menu_num]->menu_number, menu_first[menu_num]->menu_number );
+    else
+	printf( "\tset winx [expr [winfo x .]+30]; set winy [expr [winfo y .]+30]\n" );
     printf( "\twm geometry $w +$winx+$winy\n" );
 
     /*
@@ -660,8 +750,9 @@
      * widgets, and will be called first when the window is mapped,
      * and each time one of the buttons in the window are clicked.
      */
-    printf( "proc update_menu%d {w}  {\n", menu_num );
+    printf( "proc update_menu%d {}  {\n", menu_num );
     printf( "\tupdate_define\n" );
+    printf("\tglobal CONFIG_MODULES\n");
 
     /*
      * Clear all of the booleans that are defined in this menu.
@@ -691,19 +782,41 @@
 		generate_if( cfg, cfg->cond, cfg->menu_number, cfg->menu_line );
 	    else
 	    {
+#if 0
 		/*
 		 * Treat tristate like conditional here.
 		 */
+/*
+ * This is dead code at the moment, as each token_dep_tristate has fake_if
+ * (cfg->depend == 1 || cfg->depend == 2)
+ */
 		if ( cfg->token == token_dep_tristate )
 		{
 		    global( cfg->depend );
+		    printf("\tif {($%s != 1) && ($%s != 0) && ($%s == 1)} then {set %s 2};",
+			cfg->depend, cfg->depend, cfg->optionname, cfg->optionname);
 		    printf( "\tif {$%s != 1 && $%s != 0 } then { .menu%d.config.f.x%d.y configure -state disabled } else { .menu%d.config.f.x%d.y configure -state normal}\n",
 			cfg->depend, cfg->depend,
 			menu_num, cfg->menu_line,
 			menu_num, cfg->menu_line );
 		}
+#endif
+		if ( cfg->token == token_tristate )
+		{
+		    if ( ! cfg->global_written )
+			printf( "\tglobal %s\n", cfg->optionname );
+		    printf("\n\tif {($CONFIG_MODULES == 0) && ($%s == 2)} then {set %s 1};",
+			cfg->optionname, cfg->optionname);
+		    printf( "if {($CONFIG_MODULES == 1)} then { .menu%d.config.f.x%d.m configure -state normal } else {	.menu%d.config.f.x%d.m configure -state disabled}\n",
+			menu_num, cfg->menu_line,
+			menu_num, cfg->menu_line );
+		}
 	    }
 	}
+	else if ( cfg->token == token_mainmenu_option
+		&& cfg->menu_number == menu_num
+		&& cfg->cond != NULL )
+	    generate_if( cfg, cfg->cond, menu_num, cfg->menu_line );
     }
 
     printf("}\n\n\n");
@@ -718,18 +831,20 @@
 {
     int menu_depth;
     int menu_num [64];
-    struct kconfig * menu_first [256];
-    struct kconfig * menu_last  [256];
     int imenu;
+    int top_level_num = 0;
     struct kconfig * cfg;
     struct kconfig * cfg1 = NULL;
     const char * name = "No Name";
 
     /*
-    * Thread the menu pointers so I can walk each menu separately.
-    */
+     * Mark begin and end of each menu so I can omit submenus when walking
+     * over a parent menu.
+     */
     tot_menu_num = 0;
     menu_depth   = 0;
+    menu_num [0] = 0;
+
     for ( cfg = scfg; cfg != NULL; cfg = cfg->next )
     {
 	switch ( cfg->token )
@@ -749,9 +864,17 @@
 	    menu_num   [menu_depth]   = tot_menu_num;
 	    menu_first [tot_menu_num] = cfg;
 	    menu_last  [tot_menu_num] = cfg;
+	    /*
+	     * Note, that menu_number is set to the number of parent 
+	     * (upper level) menu.
+	     */
+	    cfg->menu_number = menu_num[menu_depth - 1];
+	    if ( menu_depth == 1 )
+		++top_level_num;
 	    break;
 
 	case token_endmenu:
+	    menu_last [menu_num [menu_depth]] = cfg;
 	    /* flatten menus with proper scoping */
 	    if ( --menu_depth < 0 )
 		{ fprintf( stderr, "unmatched endmenu\n" ); exit( 1 ); }
@@ -765,11 +888,9 @@
 	case token_int:
 	case token_string:
 	case token_tristate:
+	    cfg->menu_number = menu_num[menu_depth];
 	    if ( menu_depth == 0 )
 		{ fprintf( stderr, "statement not in menu\n" ); exit( 1 ); }
-	    menu_last [menu_num [menu_depth]]->menu_next = cfg;
-	    menu_last [menu_num [menu_depth]]            = cfg;
-	    cfg->menu_next                               = NULL;
 	    break;
 
 	case token_define_bool:
@@ -784,7 +905,7 @@
      *   one blank button
      *   add two to round up for division
      */
-    printf( "set menus_per_column %d\n\n", (tot_menu_num + 4 + 1 + 2) / 3 );
+    printf( "set menus_per_column %d\n\n", (top_level_num + 4 + 1 + 2) / 3 );
 
     /*
      * Generate the menus.
@@ -793,19 +914,28 @@
     for ( imenu = 1; imenu <= tot_menu_num; ++imenu )
     {
 	int menu_line = 0;
+	int nr_submenu = imenu;
 
 	clear_globalflags( scfg );
-	start_proc( menu_first[imenu]->label, imenu, 1 );
+	start_proc( menu_first[imenu]->label, imenu, 
+		!menu_first[imenu]->menu_number );
 
-	for ( cfg = menu_first[imenu]; cfg != NULL; cfg = cfg->menu_next )
+	for ( cfg = menu_first[imenu]->next; cfg != NULL && cfg != menu_last[imenu]; cfg = cfg->next )
 	{
-	    cfg->menu_number = imenu;
-
 	    switch ( cfg->token )
 	    {
 	    default:
 		break;
 
+	    case token_mainmenu_option:
+		while ( menu_first[++nr_submenu]->menu_number > imenu )
+		    ;
+		cfg->menu_line = menu_line++;
+		printf( "\tsubmenu $w.config.f %d %d \"%s\" %d\n",
+		    cfg->menu_number, cfg->menu_line, cfg->label, nr_submenu );
+		cfg = menu_last[nr_submenu];
+		break;
+
 	    case token_bool:
 		cfg->menu_line = menu_line++;
 		printf( "\tbool $w.config.f %d %d \"%s\" %s\n",
@@ -829,9 +959,9 @@
 
 	    case token_choice_item:
 		/* note: no menu line; uses choice header menu line */
-		printf( "\t$w.config.f.x%d.x.menu add radiobutton -label \"%s\" -variable %s -value \"%s\" -command \"update_menu%d .menu%d.config.f\"\n",
+		printf( "\t$w.config.f.x%d.x.menu add radiobutton -label \"%s\" -variable %s -value \"%s\" -command \"update_active $w\"\n",
 		    cfg1->menu_line, cfg->label, cfg1->optionname,
-		    cfg->label, cfg1->menu_number, cfg1->menu_number );
+		    cfg->label );
 		break;
 
 	    case token_dep_tristate:
@@ -881,11 +1011,11 @@
      * correct.
      */
     clear_globalflags( scfg );
-    printf( "proc update_mainmenu {w}  {\n" );
-    for ( cfg = scfg; cfg != NULL; cfg = cfg->next )
+    printf( "proc update_mainmenu {}  {\n" );
+    for ( imenu = 1; imenu <= tot_menu_num; imenu++ )
     {
-	if ( cfg->token == token_mainmenu_option && cfg->cond != NULL )
-	    generate_if( cfg, cfg->cond, cfg->menu_number, cfg->menu_line );
+	if ( menu_first[imenu]->cond != NULL && menu_first[imenu]->menu_number == 0 )
+	    generate_if( menu_first[imenu], menu_first[imenu]->cond, imenu, -1 );
     }
     printf( "}\n\n\n" );
 
@@ -903,7 +1033,7 @@
 		printf( "\twrite_define %s %s\n", cfg->optionname, cfg->value );
 	}
     }
-    #endif
+#endif
 
     /*
      * Generate code to load the default settings into the variables.
@@ -1005,6 +1135,7 @@
 	if ( cfg->token == token_choice_header )
 	{
 	    printf( "\tglobal %s\n", cfg->optionname );
+	    printf("\tset %s \"%s\"\n", cfg->optionname, cfg->value);
 	    for ( cfg1  = cfg->next; 
 		  cfg1 != NULL && cfg1->token == token_choice_item;
 		  cfg1  = cfg1->next )
diff -u --recursive linux-2.2.2-ac1/scripts/tkparse.c linux/scripts/tkparse.c
--- linux-2.2.2-ac1/scripts/tkparse.c	Tue Feb 23 23:22:36 1999
+++ linux/scripts/tkparse.c	Tue Feb 23 23:36:53 1999
@@ -164,7 +164,7 @@
 	if ( *pnt == '\0' )
 	    syntax_error( "unterminated 'if' condition" );
 	if ( *pnt == ']' )
-	    return list;
+	    return eliminate_other_arch( list );
 
 	/* allocate a new token */
 	cond = malloc( sizeof(*cond) );
diff -u --recursive linux-2.2.2-ac1/scripts/tkparse.h linux/scripts/tkparse.h
--- linux-2.2.2-ac1/scripts/tkparse.h	Tue Feb 23 23:22:36 1999
+++ linux/scripts/tkparse.h	Tue Feb 23 23:36:53 1999
@@ -47,6 +47,8 @@
     op_constant,
     op_variable,
     op_kvariable,
+    op_true,
+    op_false,
     op_nuked
 };
 
@@ -100,5 +102,6 @@
  * Prototypes
  */
 
+extern struct condition * eliminate_other_arch ( struct condition * scfg ); /* tkcond.c */
 extern void fix_conditionals ( struct kconfig * scfg );		/* tkcond.c */
 extern void dump_tk_script   ( struct kconfig * scfg );		/* tkgen.c  */