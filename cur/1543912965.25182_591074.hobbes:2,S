Date: Sun,  2 Sep 2007 22:20:37 -0400
From: "Josef 'Jeff' Sipek" <>
Subject: [PATCH 14/32] Unionfs: file_revalidate updates
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/9/2/267

From: Erez Zadok <ezk@cs.sunysb.edu>
Correctly revalidate a file and account for lower mnts, even when branches
are updated or inserted.  Better info upon file copyup.
Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
---
 fs/unionfs/commonfops.c |   25 +++++++++++++++++++++----
 1 files changed, 21 insertions(+), 4 deletions(-)
diff --git a/fs/unionfs/commonfops.c b/fs/unionfs/commonfops.c
index 64bd0bd..612207a 100644
--- a/fs/unionfs/commonfops.c
+++ b/fs/unionfs/commonfops.c
@@ -333,6 +333,9 @@ int unionfs_file_revalidate(struct file *file, int willwrite)
 	 */
 	if (!d_deleted(dentry) &&
 	    (sbgen > fgen || dbstart(dentry) != fbstart(file))) {
+		/* save orig branch ID */
+		int orig_brid =	UNIONFS_F(file)->saved_branch_ids[fbstart(file)];
+
 		/* First we throw out the existing files. */
 		cleanup_file(file);
 
@@ -359,22 +362,36 @@ int unionfs_file_revalidate(struct file *file, int willwrite)
 			if (err)
 				goto out;
 		} else {
+			int new_brid;
 			/* We only open the highest priority branch. */
 			err = open_highest_file(file, willwrite);
 			if (err)
 				goto out;
+			new_brid = UNIONFS_F(file)->
+			  saved_branch_ids[fbstart(file)];
+			if (new_brid != orig_brid && sbgen > fgen) {
+				/*
+				 * If we re-opened the file on a different
+				 * branch than the original one, and this
+				 * was due to a new branch inserted, then
+				 * update the mnt counts of the old and new
+				 * branches accordingly.
+				 */
+				unionfs_mntget(dentry, bstart);
+				unionfs_mntput(sb->s_root,
+					       branch_id_to_idx(sb, orig_brid));
+			}
 		}
 		atomic_set(&UNIONFS_F(file)->generation,
-			   atomic_read(&UNIONFS_I(dentry->d_inode)->
-				       generation));
+			   atomic_read(&UNIONFS_I(dentry->d_inode)->generation));
 	}
 
 	/* Copyup on the first write to a file on a readonly branch. */
 	if (willwrite && IS_WRITE_FLAG(file->f_flags) &&
 	    !IS_WRITE_FLAG(unionfs_lower_file(file)->f_flags) &&
 	    is_robranch(dentry)) {
-		printk(KERN_DEBUG "unionfs: Doing delayed copyup of a "
-		       "read-write file on a read-only branch.\n");
+		printk(KERN_DEBUG "unionfs: do delay copyup of \"%s\"\n",
+		       dentry->d_name.name);
 		err = do_delayed_copyup(file);
 	}
 
-- 
1.5.2.2.238.g7cbf2f2
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/