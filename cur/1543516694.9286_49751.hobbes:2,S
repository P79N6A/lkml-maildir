Date: Sun, 21 Nov 1999 18:40:27 +0000
From: Oliver Mueschke <>
Subject: Re: PROBLEM: Directory inconsistencies on Joliet-mounted CDROMs
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/11/21/55

Volker Springer wrote:
> 
> Procedure:
> Mount CD-Recordable (mount /dev/cdrom <mountpoint>),
> diff -r <mountpoint> <network dir>
> => exactly 34 files are not seen on the CD (output of diff: Only in <network dir>/<file>)
> An unmount and re-mount again produces 34 missing files, but not necessarily
> the same as before.
this is old, but still in 2.3.x. and it's not joliet related. 
the bug is in fs/isofs/dir.c. try the patch below. it works like
2.0.x: _first_ check for (offset < bufsize) and then use *(buf+offset)
to decide if the directory has more entries. all versions from
2.1.x (x=60 or even earlier) on do it the other way around. and this
leads to cut off directory entries if (*(buf+bufsize) == 0).
oliver 
--- linux/fs/isofs/dir.c.orig   Sun Nov 21 19:11:52 1999
+++ linux/fs/isofs/dir.c    Sun Nov 21 19:35:58 1999
@@ -157,6 +157,22 @@
               block, offset, filp->f_pos);
            printk("inode->i_size = %x\n",inode->i_size);
 #endif
+                /* Next directory_record on next CDROM sector */
+                if (offset >= bufsize) {
+#ifdef DEBUG
+                        printk("offset >= bufsize\n");
+#endif
+                        brelse(bh);
+                        offset = 0;
+                        block = isofs_bmap(inode, (filp->f_pos) >> bufbits);
+                        if (!block)
+                                return 0;
+                        bh = breada(inode->i_dev, block, bufsize, filp->f_pos, inode->i_size);
+                        if (!bh)
+                                return 0;
+                        continue;
+                }
+
        de = (struct iso_directory_record *) (bh->b_data + offset);
        if(first_de) inode_number = (block << bufbits) + (offset & (bufsize - 1));
@@ -170,17 +186,12 @@
           CDROM sector.  If we are at the end of the directory, we
           kick out of the while loop. */
-       if ((de_len == 0) || (offset >= bufsize) ) {
+       if (de_len == 0) {
            brelse(bh);
-           if (de_len == 0) {
-               filp->f_pos = ((filp->f_pos & ~(ISOFS_BLOCK_SIZE - 1))
-                          + ISOFS_BLOCK_SIZE);
-               offset = 0;
-           } else {
-               offset -= bufsize;
-               filp->f_pos += offset;
-           }
+                       filp->f_pos = ((filp->f_pos & ~(ISOFS_BLOCK_SIZE - 1))
+                                      + ISOFS_BLOCK_SIZE);
+                       offset = 0;
            if (filp->f_pos >= inode->i_size)
                return 0;
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/