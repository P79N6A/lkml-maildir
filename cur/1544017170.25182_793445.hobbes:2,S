Date: Fri, 16 Jan 2009 09:47:33 -0500
From: Steven Rostedt <>
Subject: Re: [patch 1/5] x86, ftrace, hw-branch-tracer: support hotplug cpus
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2009/1/16/251

On Fri, 2009-01-16 at 11:50 +0100, Markus Metzger wrote:
>  static void bts_trace_print_header(struct seq_file *m)
>  {
>  	seq_puts(m,
> @@ -107,18 +173,34 @@
>  {
>  	struct ring_buffer_event *event;
>  	struct hw_branch_entry *entry;
> -	unsigned long irq;
> +	unsigned long irq1, irq2;
> +	int cpu;
> +
> +	if (unlikely(!tr))
> +		return;
> +
> +	if (unlikely(!trace_hw_branches_enabled))
> +		return;
> +
> +	local_irq_save(irq1);
> +	cpu = raw_smp_processor_id();
> +	if (atomic_inc_return(&tr->data[cpu]->disabled) != 1)
> +		goto out;
> 
> -	event = ring_buffer_lock_reserve(tr->buffer, sizeof(*entry), &irq);
> +	event = ring_buffer_lock_reserve(tr->buffer, sizeof(*entry), &irq2);
>  	if (!event)
>  		return;
You need a goto out here, otherwise you leave with interrupts disabled.
Doing 'echo 0 > /debug/tracing/tracing_on' will guarantee that you hit
this return.
-- Steve
>  	entry	= ring_buffer_event_data(event);
>  	tracing_generic_entry_update(&entry->ent, 0, from);
>  	entry->ent.type = TRACE_HW_BRANCHES;
> -	entry->ent.cpu = smp_processor_id();
> +	entry->ent.cpu = cpu;
>  	entry->from = from;
>  	entry->to   = to;
> -	ring_buffer_unlock_commit(tr->buffer, event, irq);
> +	ring_buffer_unlock_commit(tr->buffer, event, irq2);
> +
> + out:
> +	atomic_dec(&tr->data[cpu]->disabled);
> +	local_irq_restore(irq1);
>  }
>  
>  static void trace_bts_at(struct trace_array *tr,
> @@ -142,6 +224,11 @@
>  	}
>  }
>  
> +