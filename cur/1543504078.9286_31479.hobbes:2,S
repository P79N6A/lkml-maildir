Date: Tue, 27 Jul 1999 17:15:01 +0200
From: Jakub Jelinek <>
Subject: Re: PATCH: POSIX 1003.1b timer minor fixes
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/7/27/67

On Tue, Jul 27, 1999 at 02:38:02PM +0200, Robert H. de Vries wrote:
> Included you will find a patch correcting all comments from Ulrich Drepper
> and Andreas Jaeger.
> 
> It fixes:
> 
> * two typos (one in my code, and one in other code).
> * Rename MAX_ITIMERS to TIMER_MAX
> * Add DELAYTIMER_MAX
> 
> This patch is relative to prepatch 2.3.12-pre6, but should work without a
> problem to the latest prepatch.
Below are fixes against some 2.3.12-pre6 for SPARC. Basically you cannot add
syscalls above 255 on SPARC, this number is deeply hidden in assembly all
around. There are quite some syscall numbers unused though.
This patch also adds 32<->64bit wrappers for 32bit userland on sparc64.
On the other side I wonder why are sys_clock_* in the kernel unless higher
than microsecond resolution is implemented. It seems to me like they really
don't do any job which could not be done in glibc, and do
not give even any performance advantages over it.
--- ./arch/sparc/kernel/systbls.S.jji	Tue Jul 27 15:16:41 1999
+++ ./arch/sparc/kernel/systbls.S	Tue Jul 27 15:32:40 1999
@@ -37,8 +37,8 @@ sys_call_table:
 /*90*/	.long sys_dup2, sys_nis_syscall, sys_fcntl, sys_select, sys_nis_syscall
 /*95*/	.long sys_fsync, sys_setpriority, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
 /*100*/	.long sys_getpriority, sys_rt_sigreturn, sys_rt_sigaction, sys_rt_sigprocmask, sys_rt_sigpending
-/*105*/	.long sys_rt_sigtimedwait, sys_rt_sigqueueinfo, sys_rt_sigsuspend, sys_nis_syscall, sys_nis_syscall
-/*110*/	.long sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
+/*105*/	.long sys_rt_sigtimedwait, sys_rt_sigqueueinfo, sys_rt_sigsuspend, sys_timer_create, sys_timer_settime
+/*110*/	.long sys_timer_gettime, sys_timer_getoverrun, sys_timer_delete, sys_nis_syscall, sys_nis_syscall
 /*115*/	.long sys_nis_syscall, sys_gettimeofday, sys_getrusage, sys_nis_syscall, sys_getcwd
 /*120*/	.long sys_readv, sys_writev, sys_settimeofday, sys_fchown, sys_fchmod
 /*125*/	.long sys_nis_syscall, sys_setreuid, sys_setregid, sys_rename, sys_truncate
@@ -53,7 +53,7 @@ sys_call_table:
 /*170*/	.long sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_getdents
 /*175*/	.long sys_setsid, sys_fchdir, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
 /*180*/	.long sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_sigpending, sys_query_module
-/*185*/	.long sys_setpgid, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_newuname
+/*185*/	.long sys_setpgid, sys_clock_gettime, sys_clock_settime, sys_clock_getres, sys_newuname
 /*190*/	.long sys_init_module, sys_personality, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
 /*195*/	.long sys_nis_syscall, sys_nis_syscall, sys_getppid, sparc_sigaction, sys_sgetmask
 /*200*/	.long sys_ssetmask, sys_sigsuspend, sys_newlstat, sys_uselib, old_readdir
@@ -68,8 +68,7 @@ sys_call_table:
 /*240*/	.long sys_munlockall, sys_sched_setparam, sys_sched_getparam, sys_sched_setscheduler, sys_sched_getscheduler
 /*245*/	.long sys_sched_yield, sys_sched_get_priority_max, sys_sched_get_priority_min, sys_sched_rr_get_interval, sys_nanosleep
 /*250*/	.long sys_mremap, sys_sysctl, sys_getsid, sys_fdatasync, sys_nfsservctl
-/*255*/	.long sys_aplib, sys_timer_create, sys_timer_settime, sys_timer_gettime, sys_timer_getoverrun
-/*260*/ .long sys_timer_delete, sys_clock_gettime, sys_clock_settime, sys_clock_getres
+/*255*/	.long sys_aplib, sys_nis_syscall
 
 	/* Now the SunOS syscall table. */
 
--- ./arch/sparc64/kernel/systbls.S.jji	Tue Jul 27 15:16:41 1999
+++ ./arch/sparc64/kernel/systbls.S	Tue Jul 27 17:00:19 1999
@@ -38,8 +38,8 @@ sys_call_table32:
 /*90*/	.word sys_dup2, sys_nis_syscall, sys32_fcntl, sys32_select, sys_nis_syscall
 	.word sys_fsync, sys_setpriority, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
 /*100*/ .word sys_getpriority, sys32_rt_sigreturn, sys32_rt_sigaction, sys32_rt_sigprocmask, sys32_rt_sigpending
-	.word sys32_rt_sigtimedwait, sys32_rt_sigqueueinfo, sys32_rt_sigsuspend, sys_nis_syscall, sys_nis_syscall
-/*110*/	.word sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
+	.word sys32_rt_sigtimedwait, sys32_rt_sigqueueinfo, sys32_rt_sigsuspend, sys32_timer_create, sys32_timer_settime
+/*110*/ .word sys32_timer_gettime, sys_timer_getoverrun, sys_timer_delete, sys_nis_syscall, sys_nis_syscall
 	.word sys_nis_syscall, sys32_gettimeofday, sys32_getrusage, sys_nis_syscall, sys_getcwd
 /*120*/	.word sys32_readv, sys32_writev, sys32_settimeofday, sys_fchown, sys_fchmod
 	.word sys_nis_syscall, sys32_setreuid, sys32_setregid, sys_rename, sys_truncate
@@ -54,7 +54,7 @@ sys_call_table32:
 /*170*/	.word sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys32_getdents
 	.word sys_setsid, sys_fchdir, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
 /*180*/	.word sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys32_sigpending, sys32_query_module
-	.word sys_setpgid, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys32_newuname
+	.word sys_setpgid, sys32_clock_gettime, sys32_clock_settime, sys32_clock_getres, sys32_newuname
 /*190*/	.word sys32_init_module, sys32_personality, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
 	.word sys_nis_syscall, sys_nis_syscall, sys_getppid, sys32_sigaction, sys_sgetmask
 /*200*/	.word sys_ssetmask, sys_sigsuspend, sys32_newlstat, sys_uselib, old32_readdir
@@ -68,8 +68,7 @@ sys_call_table32:
 /*240*/	.word sys_munlockall, sys_sched_setparam, sys_sched_getparam, sys_sched_setscheduler, sys_sched_getscheduler
 	.word sys_sched_yield, sys_sched_get_priority_max, sys_sched_get_priority_min, sys32_sched_rr_get_interval, sys32_nanosleep
 /*250*/	.word sys_mremap, sys_sysctl, sys_getsid, sys_fdatasync, sys32_nfsservctl
-/*255*/	.word sys_aplib, sys_timer_create, sys_timer_settime, sys_timer_gettime, sys_timer_getoverrun
-/*260*/ .word sys_timer_delete, sys_clock_gettime, sys_clock_settime, sys_clock_getres
+	.word sys_aplib
 
 	/* Now the 64-bit native Linux syscall table. */
 
@@ -98,8 +97,8 @@ sys_call_table:
 /*90*/	.word sys_dup2, sys_nis_syscall, sys_fcntl, sys_select, sys_nis_syscall
 	.word sys_fsync, sys_setpriority, sys_socket, sys_connect, sys_accept
 /*100*/	.word sys_getpriority, sys_rt_sigreturn, sys_rt_sigaction, sys_rt_sigprocmask, sys_rt_sigpending
-	.word sys_rt_sigtimedwait, sys_rt_sigqueueinfo, sys_rt_sigsuspend, sys_nis_syscall, sys_nis_syscall
-/*110*/	.word sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_recvmsg, sys_sendmsg
+	.word sys_rt_sigtimedwait, sys_rt_sigqueueinfo, sys_rt_sigsuspend, sys_timer_create, sys_timer_settime
+/*110*/ .word sys_timer_gettime, sys_timer_getoverrun, sys_timer_delete, sys_recvmsg, sys_sendmsg
 	.word sys_nis_syscall, sys_gettimeofday, sys_getrusage, sys_getsockopt, sys_getcwd
 /*120*/	.word sys_readv, sys_writev, sys_settimeofday, sys_fchown, sys_fchmod
 	.word sys_recvfrom, sys_setreuid, sys_setregid, sys_rename, sys_truncate
@@ -114,7 +113,7 @@ sys_call_table:
 /*170*/	.word sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_getdents
 	.word sys_setsid, sys_fchdir, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
 /*180*/	.word sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_sigpending, sys_query_module
-	.word sys_setpgid, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_newuname
+	.word sys_setpgid, sys_clock_gettime, sys_clock_settime, sys_clock_getres, sys_newuname
 /*190*/	.word sys_init_module, sys_personality, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
 	.word sys_nis_syscall, sys_nis_syscall, sys_getppid, sys_nis_syscall, sys_sgetmask
 /*200*/	.word sys_ssetmask, sys_sigsuspend, sys_newlstat, sys_uselib, sys_nis_syscall
@@ -128,8 +127,7 @@ sys_call_table:
 /*240*/	.word sys_munlockall, sys_sched_setparam, sys_sched_getparam, sys_sched_setscheduler, sys_sched_getscheduler
 	.word sys_sched_yield, sys_sched_get_priority_max, sys_sched_get_priority_min, sys_sched_rr_get_interval, sys_nanosleep
 /*250*/	.word sys_mremap, sys_sysctl, sys_getsid, sys_fdatasync, sys_nfsservctl
-/*255*/	.word sys_aplib, sys_timer_create, sys_timer_settime, sys_timer_gettime, sys_timer_getoverrun
-/*260*/ .word sys_timer_delete, sys_clock_gettime, sys_clock_settime, sys_clock_getres
+	.word sys_aplib
 
 	/* Now the 32-bit SunOS syscall table. */
 
--- ./arch/sparc64/kernel/sys_sparc32.c.jji	Tue Jul 27 15:38:19 1999
+++ ./arch/sparc64/kernel/sys_sparc32.c	Tue Jul 27 16:59:55 1999
@@ -3894,3 +3894,161 @@ asmlinkage int sys32_adjtimex(struct tim
 
 	return ret;
 }
+
+struct itimerspec32 {
+	struct  timespec32 it_interval;
+        struct  timespec32 it_value;
+};
+
+int good_timespec(const struct timespec *ts);
+extern struct k_itimer* lock_timer(struct task_struct *tsk, timer_t timer_id);
+static inline void unlock_timer(struct k_itimer *timr)
+{
+	spin_unlock(&timr->it_lock);
+}
+extern void do_timer_gettime(struct k_itimer *timr, struct itimerspec *cur_setting);
+extern void do_timer_settime(struct k_itimer *timr, int flags, struct itimerspec *new_setting, struct itimerspec *old_setting);
+extern int sys_timer_create(clockid_t which_clock, sigevent_t *timer_event_spec, timer_t *created_timer_id);
+
+asmlinkage int sys32_timer_create(clockid_t which_clock, sigevent_t32 *timer_event_spec, timer_t *created_timer_id);
+{
+	mm_segment_t old_fs;
+	sigevent_t tes;
+	int ret, new_timer_id;
+	
+	if (timer_event_spec) {
+		memset (&tes, 0, sizeof(tes));
+		if (get_user (tes.sigev_value.sival_int, &timer_event_spec->sigev_value.sival_int) ||
+		    __get_user (tes.sigev_signo, &timer_event_spec->sigev_signo) ||
+		    __get_user (tes.sigev_notify, &timer_event_spec->sigev_notify) ||
+		    __get_user (tes._sigev_un._sigev_thread._attribute, &timer_event_spec->_sigev_un._sigev_thread._attribute))
+			return -EFAULT;
+		/* As sigev_value is a union of 32bit int and 64bit void *, put the int twice into the ptr, so that when
+		   actually sending the signal both sival_int and sival_ptr will result in correct operation. */
+		tes.sigev_value.sival_ptr = (void *)((long)tes.sigev_value.sival_int<<32 | tes.sigev_value.sival_int);
+		old_fs = get_fs ();
+		set_fs (KERNEL_DS);
+		ret = sys_timer_create (which_clock, &tes, &new_timer_id);
+		set_fs (old_fs);
+		if (!ret) {
+			if (put_user (new_timer_id, created_timer_id))
+				return -EFAULT;
+		}
+		return ret;
+	} else
+		return sys_timer_create (which_clock, NULL, created_timer_id);
+}
+
+asmlinkage int sys32_timer_gettime(timer_t timer_id, struct itimerspec32 *setting)
+{
+	struct k_itimer *timr;
+	struct itimerspec cur_setting;
+
+	timr = lock_timer(current, timer_id);
+	if (!timr) return -EINVAL;
+
+	do_timer_gettime(timr, &cur_setting);
+
+	unlock_timer(timr);
+	
+	if (put_user (cur_setting.it_interval.tv_sec, &setting->it_interval.tv_sec) ||
+	    __put_user (cur_setting.it_interval.tv_nsec, &setting->it_interval.tv_nsec) ||
+	    __put_user (cur_setting.it_value.tv_sec, &setting->it_value.tv_sec) ||
+	    __put_user (cur_setting.it_value.tv_nsec, &setting->it_value.tv_nsec))
+		return -EFAULT;		    
+
+	return 0;
+}
+
+asmlinkage int sys32_timer_settime(timer_t timer_id, int flags, struct itimerspec32 *new_setting,
+				   struct itimerspec32 *old_setting)
+{
+	struct k_itimer *timr;
+	struct itimerspec new_spec, old_spec;
+	int error = 0;
+
+	timr = lock_timer(current, timer_id);
+	if (!timr) return -EINVAL;
+
+	if (new_setting == NULL) {
+		error = -EINVAL;
+		goto out;
+	}
+
+	if (get_user (new_spec.it_interval.tv_sec, &new_setting->it_interval.tv_sec) ||
+	    __get_user (new_spec.it_interval.tv_nsec, &new_setting->it_interval.tv_nsec) ||
+	    __get_user (new_spec.it_value.tv_sec, &new_setting->it_value.tv_sec) ||
+	    __get_user (new_spec.it_value.tv_nsec, &new_setting->it_value.tv_nsec)) {
+		error = -EFAULT;
+		goto out;
+	}
+
+	if ((!good_timespec(&new_spec.it_interval)) ||
+	    (!good_timespec(&new_spec.it_value))) {
+		error = -EINVAL;
+		goto out;
+	}
+
+	do_timer_settime(timr, flags, &new_spec,
+			 old_setting ? &old_spec : NULL);
+
+	if (old_setting) {
+		if (put_user (old_spec.it_interval.tv_sec, &old_setting->it_interval.tv_sec) ||
+		    __put_user (old_spec.it_interval.tv_nsec, &old_setting->it_interval.tv_nsec) ||
+		    __put_user (old_spec.it_value.tv_sec, &old_setting->it_value.tv_sec) ||
+		    __put_user (old_spec.it_value.tv_nsec, &old_setting->it_value.tv_nsec))
+			error = -EFAULT;
+	}
+
+out:
+	unlock_timer(timr);
+	return error;
+}
+
+extern int sys_clock_gettime(clockid_t clock_id, struct timespec *ts);
+
+asmlinkage int sys32_clock_gettime(clockid_t clock_id, struct timespec32 *ts)
+{
+	struct timespec t;
+	int ret;
+	mm_segment_t old_fs = get_fs ();
+	
+	set_fs (KERNEL_DS);
+	ret = sys_clock_gettime(clock_id, &t);
+	set_fs (old_fs);
+	if (!ret && ts && (put_user (t.tv_sec, &ts->tv_sec) || __put_user (t.tv_nsec, &ts->tv_nsec)))
+		return -EFAULT;
+	return ret;
+}
+
+extern int sys_clock_settime(clockid_t clock_id, struct timespec *ts);
+
+asmlinkage int sys32_clock_settime(clockid_t clock_id, struct timespec32 *ts)
+{
+	struct timespec t;
+	int ret;
+	mm_segment_t old_fs = get_fs ();
+	
+	if (ts && (get_user (t.tv_sec, &ts->tv_sec) || __get_user (t.tv_nsec, &ts->tv_nsec)))
+		return -EFAULT;
+	set_fs (KERNEL_DS);
+	ret = sys_clock_settime(clock_id, &t);
+	set_fs (old_fs);
+	return ret;
+}
+
+extern int sys_clock_getres(clockid_t clock_id, struct timespec *ts);
+
+asmlinkage int sys32_clock_getres(clockid_t clock_id, struct timespec32 *ts)
+{
+	struct timespec t;
+	int ret;
+	mm_segment_t old_fs = get_fs ();
+	
+	set_fs (KERNEL_DS);
+	ret = sys_clock_getres(clock_id, &t);
+	set_fs (old_fs);
+	if (!ret && ts && (put_user (t.tv_sec, &ts->tv_sec) || __put_user (t.tv_nsec, &ts->tv_nsec)))
+		return -EFAULT;
+	return ret;
+}
--- ./include/asm-sparc/unistd.h.jji	Tue Jul 27 15:16:41 1999
+++ ./include/asm-sparc/unistd.h	Tue Jul 27 15:23:03 1999
@@ -123,11 +123,11 @@
 #define __NR_rt_sigtimedwait    105 /* Linux Specific                              */
 #define __NR_rt_sigqueueinfo    106 /* Linux Specific                              */
 #define __NR_rt_sigsuspend      107 /* Linux Specific                              */
-/* #define __NR_sigvec          108    SunOS Specific                              */
-/* #define __NR_sigblock        109    SunOS Specific                              */
-/* #define __NR_sigsetmask      110    SunOS Specific                              */
-/* #define __NR_sigpause        111    SunOS Specific                              */
-/* #define __NR_sigstack        112    SunOS Specific                              */
+#define __NR_timer_create	108 /* Linux Specific                              */
+#define __NR_timer_settime	109 /* Linux Specific                              */
+#define __NR_timer_gettime	110 /* Linux Specific                              */
+#define __NR_timer_getoverrun	111 /* Linux Specific                              */
+#define __NR_timer_delete	112 /* Linux Specific                              */
 #define __NR_recvmsg            113 /* Common                                      */
 #define __NR_sendmsg            114 /* Common                                      */
 /* #define __NR_vtrace          115    SunOS Specific                              */
@@ -201,9 +201,9 @@
 #define __NR_sigpending         183 /* Common                                      */
 #define __NR_query_module	184 /* Linux Specific				   */
 #define __NR_setpgid            185 /* Common                                      */
-/* #define __NR_pathconf        186    SunOS Specific                              */
-/* #define __NR_fpathconf       187    SunOS Specific                              */
-/* #define __NR_sysconf         188    SunOS Specific                              */
+#define __NR_clock_gettime	186 /* Linux Specific				   */
+#define __NR_clock_settime	187 /* Linux Specific				   */
+#define __NR_clock_getres	188 /* Linux Specific				   */
 #define __NR_uname              189 /* Linux Specific                              */
 #define __NR_init_module        190 /* Linux Specific                              */
 #define __NR_personality        191 /* Linux Specific                              */
@@ -271,14 +271,8 @@
 #define __NR_fdatasync          253
 #define __NR_nfsservctl         254
 #define __NR_aplib              255
-#define __NR_timer_create	256
-#define __NR_timer_settime	257
-#define __NR_timer_gettime	258
-#define __NR_timer_getoverrun	259
-#define __NR_timer_delete	260
-#define __NR_clock_gettime	261
-#define __NR_clock_settime	262
-#define __NR_clock_getres	263
+/* Please don't add syscalls above 255.
+   Contact jj@ultra.linux.cz or davem@redhat.com for number assignment.  */
 
 #define _syscall0(type,name) \
 type name(void) \
--- ./include/asm-sparc64/unistd.h.jji	Tue Jul 27 15:16:41 1999
+++ ./include/asm-sparc64/unistd.h	Tue Jul 27 15:20:38 1999
@@ -123,11 +123,11 @@
 #define __NR_rt_sigtimedwait    105 /* Linux Specific                              */
 #define __NR_rt_sigqueueinfo    106 /* Linux Specific                              */
 #define __NR_rt_sigsuspend      107 /* Linux Specific                              */
-/* #define __NR_sigvec          108    SunOS Specific                              */
-/* #define __NR_sigblock        109    SunOS Specific                              */
-/* #define __NR_sigsetmask      110    SunOS Specific                              */
-/* #define __NR_sigpause        111    SunOS Specific                              */
-/* #define __NR_sigstack        112    SunOS Specific                              */
+#define __NR_timer_create	108 /* Linux Specific                              */
+#define __NR_timer_settime	109 /* Linux Specific                              */
+#define __NR_timer_gettime	110 /* Linux Specific                              */
+#define __NR_timer_getoverrun	111 /* Linux Specific                              */
+#define __NR_timer_delete	112 /* Linux Specific                              */
 #define __NR_recvmsg            113 /* Common                                      */
 #define __NR_sendmsg            114 /* Common                                      */
 /* #define __NR_vtrace          115    SunOS Specific                              */
@@ -201,9 +201,9 @@
 #define __NR_sigpending         183 /* Common                                      */
 #define __NR_query_module	184 /* Linux Specific				   */
 #define __NR_setpgid            185 /* Common                                      */
-/* #define __NR_pathconf        186    SunOS Specific                              */
-/* #define __NR_fpathconf       187    SunOS Specific                              */
-/* #define __NR_sysconf         188    SunOS Specific                              */
+#define __NR_clock_gettime	186 /* Linux Specific				   */
+#define __NR_clock_settime	187 /* Linux Specific				   */
+#define __NR_clock_getres	188 /* Linux Specific				   */
 #define __NR_uname              189 /* Linux Specific                              */
 #define __NR_init_module        190 /* Linux Specific                              */
 #define __NR_personality        191 /* Linux Specific                              */
@@ -271,14 +271,8 @@
 #define __NR_fdatasync          253
 #define __NR_nfsservctl         254
 #define __NR_aplib              255
-#define __NR_timer_create	256
-#define __NR_timer_settime	257
-#define __NR_timer_gettime	258
-#define __NR_timer_getoverrun	259
-#define __NR_timer_delete	260
-#define __NR_clock_gettime	261
-#define __NR_clock_settime	262
-#define __NR_clock_getres	263
+/* Please don't add syscalls above 255.
+   Contact jj@ultra.linux.cz or davem@redhat.com for number assignment.  */
 
 #define _syscall0(type,name) \
 type name(void) \
--- ./include/asm-sparc64/siginfo.h.jji	Wed May 12 16:47:36 1999
+++ ./include/asm-sparc64/siginfo.h	Tue Jul 27 15:57:57 1999
@@ -258,7 +258,7 @@ typedef struct sigevent {
 #ifdef __KERNEL__
 
 typedef struct sigevent32 {
-	sigval_t sigev_value;
+	sigval_t32 sigev_value;
 	int sigev_signo;
 	int sigev_notify;
 	union {
--- ./kernel/itimer.c.jji	Tue Jul 27 16:31:53 1999
+++ ./kernel/itimer.c	Tue Jul 27 16:43:37 1999
@@ -347,7 +347,7 @@ out:
  * function returns 0. Otherwise it returns 1.
  */
 
-static int good_timespec(const struct timespec *ts)
+int good_timespec(const struct timespec *ts)
 {
 	if (ts == NULL) return 0;
 	if (ts->tv_sec < 0) return 0;
@@ -355,7 +355,7 @@ static int good_timespec(const struct ti
 	return 1;
 }
 
-static inline struct k_itimer* lock_timer(struct task_struct *tsk, timer_t timer_id)
+inline struct k_itimer* lock_timer(struct task_struct *tsk, timer_t timer_id)
 {
 	struct k_itimer *timr;
 
@@ -373,8 +373,8 @@ static inline void unlock_timer(struct k
 }
 
 /* Get the time remaining on a POSIX.1b interval timer. */
-static void do_timer_gettime(struct k_itimer *timr,
-			     struct itimerspec *cur_setting)
+void do_timer_gettime(struct k_itimer *timr,
+		      struct itimerspec *cur_setting)
 {
 	unsigned long expires = timr->it_timer.expires;
 
@@ -446,9 +446,9 @@ static void timer_value_abs_to_rel(struc
 }
 
 /* Set a POSIX.1b interval timer. */
-static void do_timer_settime(struct k_itimer *timr, int flags,
-			     struct itimerspec *new_setting,
-			     struct itimerspec *old_setting)
+void do_timer_settime(struct k_itimer *timr, int flags,
+		      struct itimerspec *new_setting,
+		      struct itimerspec *old_setting)
 {
 	/* disable the timer */
 	start_bh_atomic();
Cheers,
    Jakub
___________________________________________________________________
Jakub Jelinek | jj@sunsite.mff.cuni.cz | 
http://sunsite.mff.cuni.cz
Administrator of SunSITE Czech Republic, MFF, Charles University
___________________________________________________________________
UltraLinux  |  
http://ultra.linux.cz/
  |  
http://ultra.penguin.cz/
Linux version 2.3.11 on a sparc64 machine (1343.49 BogoMips)
___________________________________________________________________
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/