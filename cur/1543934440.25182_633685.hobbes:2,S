Date: Thu,  3 Jan 2008 01:50:08 +0100 (CET)
From: Andi Kleen <>
Subject: [PATCH] [13/20] x86: Use a deferrable timer for the correctable machine check poller
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/1/2/361

They are not time critical and delaying them a little for
the next regular wakeup is no problem.
Also when a CPU is idle then it is unlikely to generate
errors anyways, so it is ok to check only when the CPU
is actually doing something.
Signed-off-by: Andi Kleen <ak@suse.de>
---
 arch/x86/kernel/cpu/mcheck/mce_64.c |    8 +++-----
 1 file changed, 3 insertions(+), 5 deletions(-)
Index: linux/arch/x86/kernel/cpu/mcheck/mce_64.c
===================================================================
--- linux.orig/arch/x86/kernel/cpu/mcheck/mce_64.c
+++ linux/arch/x86/kernel/cpu/mcheck/mce_64.c
@@ -379,8 +379,7 @@ static void mcheck_timer(struct work_str
 	if (mce_notify_user()) {
 		next_interval = max(next_interval/2, HZ/100);
 	} else {
-		next_interval = min(next_interval * 2,
-				(int)round_jiffies_relative(check_interval*HZ));
+		next_interval = min(next_interval * 2, check_interval*HZ);
 	}
 
 	cpu = smp_processor_id();
@@ -442,8 +441,7 @@ static void mce_timers(int restart)
 		struct delayed_work *w = &per_cpu(mcheck_work, i);
 		cancel_delayed_work_sync(w);
 		if (restart)
-			schedule_delayed_work_on(i, w,
-					round_jiffies_relative(next_interval));
+				schedule_delayed_work_on(i, w, next_interval);
 	}
 }
 
@@ -553,7 +551,7 @@ void __cpuinit mcheck_init(struct cpuinf
 	int cpu = smp_processor_id();
 	static cpumask_t mce_cpus = CPU_MASK_NONE;
 
-	INIT_DELAYED_WORK(&per_cpu(mcheck_work, cpu), mcheck_timer);
+	INIT_DELAYED_WORK_DEFERRABLE(&per_cpu(mcheck_work, cpu), mcheck_timer);
 
 	mce_cpu_quirks(c);
 