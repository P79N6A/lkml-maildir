Date: Tue, 18 May 1999 13:39:25 +0200 (CEST)
From: Wolfram Kleff <>
Subject: [Patch] bugfix for Atari partition format, ISO fs
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/5/21/75

The following patch for Kernel 2.2.9 fixes these bugs:
- Atari partition format is now available for all architectures (endian
  problems)
- Atari partition format is now verified
- privacy fixes for the ISO fs: like the vfat fs, the user who mounted the CD
  owns all files, umask is supported (different behavior for superuser)
- ISO fs support for /proc/mounts
- "make modules_install" creates the module dependencies for modprobe
- misc minor fixes
I hope you like them, (and include it in 2.2.10 ;-)
Wolfram Kleff
diff -Nru linux-2.2.9/Makefile linux/Makefile
--- linux-2.2.9/Makefile	Tue May 18 12:18:22 1999
+++ linux/Makefile	Tue May 18 12:51:17 1999
@@ -328,6 +328,7 @@
 	echo $$MODULES | tr ' ' '\n' | sort | comm -23 $$MODLIB/.allmods - > $$MODLIB/.misc; \
 	if [ -s $$MODLIB/.misc ]; then inst_mod $$MODLIB/.misc misc; fi; \
 	rm -f $$MODLIB/.misc $$MODLIB/.allmods; \
+	depmod -a $(KERNELRELEASE); \
 	)
 
 # modules disabled....
diff -Nru linux-2.2.9/drivers/block/genhd.c linux/drivers/block/genhd.c
--- linux-2.2.9/drivers/block/genhd.c	Tue May 11 17:57:26 1999
+++ linux/drivers/block/genhd.c	Mon May  3 17:32:54 1999
@@ -223,7 +223,7 @@
 	   */
 		bh->b_state = 0;
 
-		if ((*(unsigned short *) (bh->b_data+510)) != cpu_to_le16(MSDOS_LABEL_MAGIC))
+		if ((*(__u16 *) (bh->b_data+510)) != cpu_to_le16(MSDOS_LABEL_MAGIC))
 			goto done;
 
 		p = (struct partition *) (0x1BE + bh->b_data);
@@ -1081,7 +1081,7 @@
 #endif /* CONFIG_MAC_PARTITION */
 
 #ifdef CONFIG_ATARI_PARTITION
-#include <asm/atari_rootsec.h>
+#include <linux/atari_rootsec.h>
 
 /* ++guenther: this should be settable by the user ("make config")?.
  */
@@ -1095,16 +1095,27 @@
   struct rootsector *rs;
   struct partition_info *pi;
   ulong extensect;
+  unsigned int psum;
+  int i;
 #ifdef ICD_PARTS
   int part_fmt = 0; /* 0:unknown, 1:AHDI, 2:ICD/Supra */
 #endif
 
   bh = bread (dev, 0, get_ptable_blocksize(dev));
-  if (!bh)
-    {
-      printk (" unable to read block 0\n");
+  if (!bh) {
+      printk (" unable to read block 0 (partition table)\n");
       return -1;
-    }
+  }
+
+  /* Verify this is an Atari rootsector: */
+  psum=0;
+  for (i=0;i<256;i++) {
+    psum+=ntohs(((__u16 *) (bh->b_data))[i]);
+  }
+  if ((psum & 0xFFFF) != 0x1234) {
+    brelse(bh);
+    return 0;
+  }
 
   rs = (struct rootsector *) bh->b_data;
   pi = &rs->part[0];
@@ -1125,7 +1136,7 @@
 	      part_fmt = 1;
 #endif
 	      printk(" XGM<");
-	      partsect = extensect = pi->st;
+	      partsect = extensect = ntohl(pi->st);
 	      while (1)
 		{
 		  xbh = bread (dev, partsect / 2, get_ptable_blocksize(dev));
@@ -1146,8 +1157,8 @@
 		    break;
 		  }
 
-		  add_partition(hd, minor, partsect + xrs->part[0].st,
-				xrs->part[0].siz);
+		  add_partition(hd, minor, partsect + ntohl(xrs->part[0].st),
+				ntohl(xrs->part[0].siz));
 
 		  if (!(xrs->part[1].flg & 1)) {
 		    /* end of linked partition list */
@@ -1160,7 +1171,7 @@
 		    break;
 		  }
 
-		  partsect = xrs->part[1].st + extensect;
+		  partsect = ntohl(xrs->part[1].st) + extensect;
 		  brelse (xbh);
 		  minor++;
 		  if (minor >= m_lim) {
@@ -1173,7 +1184,7 @@
 	  else
 	    {
 	      /* we don't care about other id's */
-	      add_partition (hd, minor, pi->st, pi->siz);
+	      add_partition (hd, minor, ntohl(pi->st), ntohl(pi->siz));
 	    }
 	}
     }
@@ -1200,7 +1211,7 @@
              memcmp (pi->id, "RAW", 3) == 0) )
         {
           part_fmt = 2;
-	  add_partition (hd, minor, pi->st, pi->siz);
+	  add_partition (hd, minor, ntohl(pi->st), ntohl(pi->siz));
         }
       }
       printk(" >");
@@ -1222,7 +1233,7 @@
 	char buf[8];
 
 	if (first_time)
-		printk("Partition check:\n");
+		printk(KERN_INFO "Partition check:\n");
 	first_time = 0;
 	first_sector = hd->part[MINOR(dev)].start_sect;
 
@@ -1235,7 +1246,7 @@
 		return;
 	}
 
-	printk(" %s:", disk_name(hd, MINOR(dev), buf));
+	printk(KERN_INFO " %s:", disk_name(hd, MINOR(dev), buf));
 #ifdef CONFIG_MSDOS_PARTITION
 	if (msdos_partition(hd, dev, first_sector))
 		return;
diff -Nru linux-2.2.9/fs/Config.in linux/fs/Config.in
--- linux-2.2.9/fs/Config.in	Tue May 11 17:56:08 1999
+++ linux/fs/Config.in	Sun May  2 15:58:57 1999
@@ -110,6 +110,7 @@
 if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
   bool 'Unixware slices support (EXPERIMENTAL)' CONFIG_UNIXWARE_DISKLABEL
 fi
+bool 'Atari partition map support' CONFIG_ATARI_PARTITION
 endmenu
 
 if [ "$CONFIG_AFFS_FS" != "n" ]; then
diff -Nru linux-2.2.9/fs/isofs/inode.c linux/fs/isofs/inode.c
--- linux-2.2.9/fs/isofs/inode.c	Tue Dec 29 20:40:35 1998
+++ linux/fs/isofs/inode.c	Tue May 18 12:30:57 1999
@@ -122,6 +122,7 @@
 	unsigned char check;
 	unsigned int blocksize;
 	mode_t mode;
+	mode_t umask;
 	gid_t gid;
 	uid_t uid;
 	char *iocharset;
@@ -286,12 +287,18 @@
 	popt->unhide = 'n';
 	popt->check = 'u';		/* unset */
 	popt->blocksize = 1024;
-	popt->mode = S_IRUGO | S_IXUGO; /* r-x for all.  The disc could
+	if (current->uid != 0) {
+	  popt->mode = (S_IRUGO | S_IXUGO) & ~(current->fs->umask);
+	  popt->umask = current->fs->umask;
+	} else {
+	  popt->mode = S_IRUGO | S_IXUGO; /* r-x for all.  The disc could
 					   be shared with DOS machines so
 					   virtually anything could be
 					   a valid executable. */
-	popt->gid = 0;
-	popt->uid = 0;
+	  popt->umask = 0;
+	}
+	popt->uid = current->uid;
+	popt->gid = current->gid;
 	popt->iocharset = NULL;
 	popt->utf8 = 0;
 	if (!options) return 1;
@@ -358,6 +365,7 @@
 		else if (value &&
 			 (!strcmp(this_char,"block") ||
 			  !strcmp(this_char,"mode") ||
+			  !strcmp(this_char,"umask") ||
 			  !strcmp(this_char,"uid") ||
 			  !strcmp(this_char,"gid"))) {
 		  char * vpnt = value;
@@ -371,13 +379,20 @@
 		    popt->blocksize = ivalue;
 		    break;
 		  case 'u':
-		    popt->uid = ivalue;
+		    if (this_char[1]=='i') {
+		      popt->uid = ivalue;
+		    } else {
+		      if (ivalue > 07777) return 0;
+		      popt->umask = ivalue;
+		      popt->mode &= ~(popt->umask);
+		    }
 		    break;
 		  case 'g':
 		    popt->gid = ivalue;
 		    break;
 		  case 'm':
-		    popt->mode = ivalue;
+		    if (ivalue > 0777) return 0;
+		    popt->mode = ivalue & ~(popt->umask);
 		    break;
 		  }
 		}
@@ -753,6 +768,7 @@
 	s->u.isofs_sb.s_unhide = opt.unhide;
 	s->u.isofs_sb.s_uid = opt.uid;
 	s->u.isofs_sb.s_gid = opt.gid;
+	s->u.isofs_sb.s_umask = opt.umask;
 	s->u.isofs_sb.s_utf8 = opt.utf8;
 	/*
 	 * It would be incredibly stupid to allow people to mark every file on the disk
@@ -1079,7 +1095,7 @@
 	raw_inode = ((struct iso_directory_record *) pnt);
 
 	if (raw_inode->flags[-high_sierra] & 2) {
-		inode->i_mode = S_IRUGO | S_IXUGO | S_IFDIR;
+		inode->i_mode = (S_IRUGO | S_IXUGO | S_IFDIR) & ~(inode->i_sb->u.isofs_sb.s_umask);
 		inode->i_nlink = 1; /* Set to 1.  We know there are 2, but
 				       the find utility tries to optimize
 				       if it is 2, and it screws up.  It is
@@ -1097,7 +1113,7 @@
 			if(raw_inode->name[i]=='.' || raw_inode->name[i]==';')
 				break;
 		if(i == raw_inode->name_len[0] || raw_inode->name[i] == ';')
-			inode->i_mode |= S_IXUGO; /* execute permission */
+			inode->i_mode |= S_IXUGO & ~(inode->i_sb->u.isofs_sb.s_umask); /* execute permission */
 	}
 	inode->i_uid = inode->i_sb->u.isofs_sb.s_uid;
 	inode->i_gid = inode->i_sb->u.isofs_sb.s_gid;
diff -Nru linux-2.2.9/fs/isofs/rock.c linux/fs/isofs/rock.c
--- linux-2.2.9/fs/isofs/rock.c	Sat Sep 26 01:27:13 1998
+++ linux/fs/isofs/rock.c	Tue May 11 16:40:00 1999
@@ -270,7 +270,7 @@
 	  printk("\n");
 	break;
       case SIG('P','X'):
-	inode->i_mode  = isonum_733(rr->u.PX.mode);
+	inode->i_mode  = isonum_733(rr->u.PX.mode) & ~(inode->i_sb->u.isofs_sb.s_umask);
 	inode->i_nlink = isonum_733(rr->u.PX.n_links);
 	inode->i_uid   = isonum_733(rr->u.PX.uid);
 	inode->i_gid   = isonum_733(rr->u.PX.gid);
@@ -363,7 +363,7 @@
 	reloc = iget(inode->i_sb, inode->u.isofs_i.i_first_extent);
 	if (!reloc)
 		goto out;
-	inode->i_mode = reloc->i_mode;
+	inode->i_mode = reloc->i_mode & ~(inode->i_sb->u.isofs_sb.s_umask);
 	inode->i_nlink = reloc->i_nlink;
 	inode->i_uid = reloc->i_uid;
 	inode->i_gid = reloc->i_gid;
diff -Nru linux-2.2.9/fs/super.c linux/fs/super.c
--- linux-2.2.9/fs/super.c	Wed May 12 01:04:58 1999
+++ linux/fs/super.c	Wed May 12 01:04:20 1999
@@ -32,6 +32,8 @@
 #include <linux/nfs_fs_sb.h>
 #include <linux/nfs_mount.h>
 
+#include <linux/iso_fs_sb.h>
+
 #ifdef CONFIG_KMOD
 #include <linux/kmod.h>
 #endif
@@ -103,6 +105,7 @@
 	lptr->mnt_sb = sb;
 	lptr->mnt_dev = sb->s_dev;
 	lptr->mnt_flags = sb->s_flags;
+	lptr->uid = current->uid;
 
 	sema_init(&lptr->mnt_dquot.semaphore, 1);
 	lptr->mnt_dquot.flags = 0;
@@ -313,6 +316,7 @@
 	struct proc_fs_info *fs_infop;
 	struct proc_nfs_info *nfs_infop;
 	struct nfs_server *nfss;
+	struct isofs_sb_info *iso9660;
 	int len = 0;
 
 	while ( tmp && len < PAGE_SIZE - 160)
@@ -371,7 +375,32 @@
 			len += sprintf(buf+len, ",addr=%s",
 				       nfss->hostname);
 		}
-		len += sprintf( buf + len, " 0 0\n" );
+		if (!strcmp("iso9660", tmp->mnt_sb->s_type->name)) {
+		  iso9660 = &tmp->mnt_sb->u.isofs_sb;
+
+		  if (! iso9660->s_rock) {
+		    len += sprintf(buf + len, ",norock");
+		  }
+		  if (iso9660->s_unhide == 'y') {
+		    len += sprintf(buf + len, ",unhide");
+		  }
+		  if (iso9660->s_cruft == 'y') {
+		    len += sprintf(buf + len, ",cruft");
+		  }
+		  if (iso9660->s_umask != 0) {
+		    len += sprintf(buf + len, ",umask=0%o", iso9660->s_umask);
+		  }
+		  if (iso9660->s_mode != (S_IRUGO | S_IXUGO)) {
+		    len += sprintf(buf + len, ",mode=0%o", iso9660->s_mode);
+		  }
+		  if (iso9660->s_uid != 0) {
+		    len += sprintf(buf + len, ",uid=%u", iso9660->s_uid);
+		  }
+		  if (iso9660->s_gid != 0) {
+		    len += sprintf(buf + len, ",gid=%u", iso9660->s_gid);
+		  }
+		}
+		len += sprintf( buf + len, " 0 0 %u\n", tmp->uid);
 		tmp = tmp->mnt_next;
 	}
 
@@ -1206,7 +1235,7 @@
 			sb->s_flags = root_mountflags;
 			current->fs->root = dget(sb->s_root);
 			current->fs->pwd = dget(sb->s_root);
-			printk ("VFS: Mounted root (%s filesystem)%s.\n",
+			printk(KERN_INFO "VFS: Mounted root (%s filesystem)%s.\n",
 				fs_type->name,
 				(sb->s_flags & MS_RDONLY) ? " readonly" : "");
 			vfsmnt = add_vfsmnt(sb, "/dev/root", "/");
diff -Nru linux-2.2.9/include/linux/iso_fs_sb.h linux/include/linux/iso_fs_sb.h
--- linux-2.2.9/include/linux/iso_fs_sb.h	Wed Aug 26 18:54:41 1998
+++ linux/include/linux/iso_fs_sb.h	Tue May 11 16:52:24 1999
@@ -23,6 +23,7 @@
 	unsigned char s_nosuid;
 	unsigned char s_nodev;
 	mode_t s_mode;
+	mode_t s_umask;
 	gid_t s_gid;
 	uid_t s_uid;
 	struct nls_table *s_nls_iocharset; /* Native language support table */
diff -Nru linux-2.2.9/include/linux/mount.h linux/include/linux/mount.h
--- linux-2.2.9/include/linux/mount.h	Sun Aug  9 21:25:12 1998
+++ linux/include/linux/mount.h	Tue May 11 16:54:51 1999
@@ -33,6 +33,7 @@
   struct super_block *mnt_sb;		/* pointer to superblock */
   struct quota_mount_options mnt_dquot;	/* Diskquota specific mount options */
   struct vfsmount *mnt_next;		/* pointer to next in linkedlist */
+  uid_t uid;				/* uid of the user who mounted the fs */
 };
 
 struct vfsmount *lookup_vfsmnt(kdev_t dev);