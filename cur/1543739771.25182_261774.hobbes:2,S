Date: Tue, 19 Oct 2004 13:14:57 +0200
From: Thomas Gleixner <>
Subject: Re: [patch] Real-Time Preemption, -RT-2.6.9-rc4-mm1-U5
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2004/10/19/97

On Tue, 2004-10-19 at 13:07, Ingo Molnar wrote:
> * Thomas Gleixner <tglx@linutronix.de> wrote:
> 
> > +        * Wait for the lockd process to start, but since we're holding
> > +        * the lockd semaphore, we can't wait around forever ...
> > +        */
> > +       if (wait_event_interruptible_timeout(lockd_start,
> > +                                            nlmsvc_pid != 0, HZ)) {
> > +               printk(KERN_WARNING
> > +                       "lockd_down: lockd failed to start\n");
> 
> yeah, this is much cleaner. 
Cleaner, but not perfect. The return value is > 0, if the timeout is not
reached. Grmbl.
> I'd suggest to remove the init_sem() hack
> from lib/rwsem-generic.c, it seems it is a nice facility to find
> semaphore abuses.
True. Will do so.
tglx
--- 2.6.9-rc4-mm1-RT-U5/fs/lockd/svc.c.orig	2004-10-19 10:02:17.000000000 +0200
+++ 2.6.9-rc4-mm1-VP-U5/fs/lockd/svc.c	2004-10-19 12:59:41.000000000 +0200
@@ -46,7 +46,7 @@
 int				nlmsvc_grace_period;
 unsigned long			nlmsvc_timeout;
 
-static DECLARE_MUTEX(lockd_start);
+static DECLARE_WAIT_QUEUE_HEAD(lockd_start);
 static DECLARE_WAIT_QUEUE_HEAD(lockd_exit);
 
 /*
@@ -109,7 +109,7 @@
 	 * Let our maker know we're running.
 	 */
 	nlmsvc_pid = current->pid;
-	up(&lockd_start);
+	wake_up(&lockd_start);
 
 	daemonize("lockd");
 
@@ -230,6 +230,7 @@
 		printk(KERN_WARNING
 			"lockd_up: no pid, %d users??\n", nlmsvc_users);
 
+
 	error = -ENOMEM;
 	serv = svc_create(&nlmsvc_program, LOCKD_BUFSIZE);
 	if (!serv) {
@@ -258,8 +259,15 @@
 			"lockd_up: create thread failed, error=%d\n", error);
 		goto destroy_and_out;
 	}
-	down(&lockd_start);
-
+	/*
+	 * Wait for the lockd process to start, but since we're holding
+	 * the lockd semaphore, we can't wait around forever ...
+	 */
+	if (wait_event_interruptible_timeout(lockd_start, 
+					     nlmsvc_pid != 0, HZ) <= 0) {
+		printk(KERN_WARNING 
+			"lockd_down: lockd failed to start\n");
+	}
 	/*
 	 * Note: svc_serv structures have an initial use count of 1,
 	 * so we exit through here on both success and failure.
@@ -298,16 +306,12 @@
 	 * Wait for the lockd process to exit, but since we're holding
 	 * the lockd semaphore, we can't wait around forever ...
 	 */
-	clear_thread_flag(TIF_SIGPENDING);
-	interruptible_sleep_on_timeout(&lockd_exit, HZ);
-	if (nlmsvc_pid) {
+	if (!wait_event_interruptible_timeout(lockd_exit, 
+					     nlmsvc_pid == 0, HZ) <= 0) {
 		printk(KERN_WARNING 
 			"lockd_down: lockd failed to exit, clearing pid\n");
 		nlmsvc_pid = 0;
 	}
-	spin_lock_irq(&current->sighand->siglock);
-	recalc_sigpending();
-	spin_unlock_irq(&current->sighand->siglock);
 out:
 	up(&nlmsvc_sema);
 }
@@ -423,7 +427,6 @@
 
 static int __init init_nlm(void)
 {
-	init_MUTEX_LOCKED(&lockd_start);
 	nlm_sysctl_table = register_sysctl_table(nlm_sysctl_root, 0);
 	return nlm_sysctl_table ? 0 : -ENOMEM;
 }