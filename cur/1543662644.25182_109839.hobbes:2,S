Date: Sat, 15 Feb 2003 01:01:53 +0000
From: Jamie Lokier <>
Subject: Re: Synchronous signal delivery..
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2003/2/14/340

Davide Libenzi wrote:
> > And when that's done you have some nice bonuses:
> >
> > 	- All event types are reported equally fast, and in a single
> > 	  system call (read()).
> >
> > 	- The order in which events occurred is preserved.
> > 	  (This is lost when you have to scan multiple queues).
> >
> > 	- Hierarchies of event sets of any kind are possible.
> > 	  (epoll has solved the logical problems of this already).
> >
> > 	- Less code duplicated.
> >
> > 	- Adding new kinds of kernel events becomes _very_ simple.
> 
> Hmm ... using read() you'll lose the timeout capability, that IMHO is
> pretty nice.
Very good point.
Timeouts could be events too - probably a good idea as they can then
be absolute, relative, attached to different system clocks (monotonic
vs. timeofday).  I think the POSIX timer work is like that.
It seems like a good idea to be able to attach one timeout event in
the same system call as the event_read call itself - because it is
_so_ common to vary the expiry time every time.
Then again, it is also extremely common to write this:
	gettimeofday(...)
	// calculate time until next application timer expires.
	// Note also race condition here, if we're preempted.
	read_events(..., next_app_time - timeofday)
	// we need to know the current time.
	gettimeofday(...)
So perhaps the current select/poll/epoll timeout method is not
particularly optimal as it is?
-- Jamie
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/