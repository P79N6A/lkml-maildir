Date: Mon, 14 Jun 2004 23:16:20 +0400
From: Stas Sergeev <>
Subject: Bug: debugging with GDB is broken under 2.6.6
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2004/6/14/132

Hello.
It seems some bug in 2.6.6 (and up to
2.6.7-rc3-mm2) makes gdb useless - it
is no longer possible to produce even
a simple stack trace for any program.
Attached it the test-case to demonstrate
the bug. Its output under any 2.6.6 kernels
is:
---
(gdb) #0  0xffffe410 in ?? ()
#1  0xbffffa88 in ?? ()
#2  0x00000000 in ?? ()
---
Absolutely broken backtrace.
And under 2.6.5 (the one that comes with
RedHat FC2 at least) and under 2.4 kernels:
---
(gdb) #0  0x00558402 in ?? ()
#1  0x0041ce83 in __waitpid_nocancel () from /lib/tls/libc.so.6
#2  0x08048645 in main (argc=1, argv=0xfef20f84) at gdb_tst.c:26
---
Perfect backtrace.
Any ideas what have caused this? As I am
using gdb very frequently, this bug gives
me some headache.
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main(int argc, char *argv[]) {
  char buf[255];
  int s;
  FILE *f;
  pid_t pid;
  switch((pid = fork())) {
    case 0:
      sprintf(buf, "gdb %s %i", argv[0], getppid());
      f = popen(buf, "w");
      fprintf(f, "bt\n");
      fprintf(f, "quit\n");
      fflush(f);
      wait(&s);
      pclose(f);
      break;
    case -1:
      return 1;
    default:
      waitpid(pid, &s, 0);
  }
  return 0;
}
Scanned by evaluation version of Dr.Web antivirus Daemon 
http://drweb.ru/unix/