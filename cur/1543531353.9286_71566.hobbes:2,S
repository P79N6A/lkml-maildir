Date: Wed, 22 Mar 2000 22:02:40 +0100
From: "Manfred Spraul" <>
Subject: Re: new IRQ scalability changes in 2.3.48
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/3/22/213

From: "Dimitris Michailidis" <dimitris@cthulhu.engr.sgi.com>
> Speaking of this sleep_on+unlock race that is still present in a few
drivers,
usb?
> how about adding sleep_on_unlock(wait_q, lock) that would unlock the
supplied
> lock at the right time, after adding the process to the wait queue?  This
> race used to be present in the scsi code and has been fixed with the
folowing
> (comments removed):
Ingo added wait_event() for drivers that don't need a spinlock.
I'm not sure that another "wait_event_spinlock()" is really required: we are
talking about 5 lines of code, and dozends of possible variations. [with
signals, without signals, acquire the spinlock if a signal arrives, return
without the spinlock on signal delivery, spin_lock or spin_lock_irq, with
timeout or without timeout]
                        add_wait_queue(&device->scpnt_wait, &wait);
                        if( interruptable ) {
                                set_current_state(TASK_INTERRUPTIBLE);
                        } else {
                                set_current_state(TASK_UNINTERRUPTIBLE);
                        }
                        spin_unlock_irqrestore(&device_request_lock, flags);
                        schedule();
It would be possible to optimize this one: __set_current_state() instead of
set_current_state(): the memory barrier is superfluous due to the spinlock.
--
    Manfred
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/