Date: Mon, 26 Feb 2007 09:28:55 -0800
From: Stephane Eranian <>
Subject: Re: bug in kernel 2.6.21-rc1-git1: conventional floppy drive cannot be mounted without hanging up the whole system
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/2/26/173

Hi,
On Mon, Feb 26, 2007 at 07:51:19AM -0800, Linus Torvalds wrote:
> 
> 
> On Mon, 26 Feb 2007, Jiri Slaby wrote:
> > 
> > Ok, this commit is the culprit:
> > Commit: 2ff2d3d74705d34ab71b21f54634fcf50d57bdd5
> > Author: Stephane Eranian <eranian@hpl.hp.com> Tue, 13 Feb 2007 13:26:22 +0100
> > 
> >     [PATCH] i386: add idle notifier
> 
> Interesting. It doesn't touch floppy at all, but it *does* seem to play 
> around with irq state. 
> 
> In particular, the floppy uses IRQF_DISABLED (which means that it doesn't 
> want interrupts enabled when in the irq handler), and I get the feeling 
> that the poll_idle() stuff made that not work.
> 
> That said, the only thing that *really* seems to change (as far as a 
> floopy driver could notice) is the added "exit_idle()" in the do_IRQ() 
> sequence, and I'm not seeing that one enabling interrupts. 
> 
> But the idle sequence definitely does (ie now we disable/enable interrupts 
> in cpu_idle(). I'm not seeing why that should matter, though.
> 
> Stephane, any ideas?
> 
I think this may be related to the issue fixed by Venkatesh here:
	
http://www.ussg.iu.edu/hypermail/linux/kernel/0611.3/1264.html
The same code was used for i386 but I think for both architectures, the patch
is missing default_idle(). I believe deault idle should look as follows:
void default_idle(void)
{
        if (!hlt_counter && boot_cpu_data.hlt_works_ok) {
                current_thread_info()->status &= ~TS_POLLING;
                /*
                 * TS_POLLING-cleared state must be visible before we
                 * test NEED_RESCHED:
                 */
                smp_mb();
                local_irq_disable();
                if (!need_resched())
                        safe_halt();    /* enables interrupts racelessly */
                else
                        local_irq_enable();
                current_thread_info()->status |= TS_POLLING;
        } else {
                /* loop is done by the caller */
---->		local_irq_enable();
                cpu_relax();
        }
}
I do not have any machine with floppy drives. Could you try this?
Thanks.
-- 
-Stephane
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/