Date: Wed, 25 Aug 1999 22:24:54 +0200
From: Peter Enderborg <>
Subject: Re: Device deadlock.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/8/25/91

"Richard B. Johnson" wrote:
> On Tue, 24 Aug 1999, Peter Enderborg wrote:
>
> > I have a program that sends midi events to the /dev/midi0 device.
> >
> > It open the device with open() for read/write. Sometimes it sends a lot of events
> >
> > and the device stops send. (Nonblocking) Then the device is dead. I stop the process and
> >
> > trying open the device and it is stil busy. The hardware is SB16 or SB128 PCI.
> >
> > Im thinking of sending some IOCTL to give it a reset signal, but I cant send IOCTL
> >
> > the device is busy. Ugly deadlock...
> >
>     include <fcntl.h>
>
>     fd = open("/dev/midi0", O_RWDR|O_NONBLOCK);
>
> Doesn't this work?
>
> Cheers,
> Dick Johnson
>                    **** FILE SYSTEM WAS MODIFIED ****
> Penguin : Linux version 2.3.13 on an i686 machine (400.59 BogoMips).
> Warning : It's hard to remain at the trailing edge of technology.
You can try play with this:
#include <stdio.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
int main()
{
  int fd1;
  int result;
  fd1 = open("/dev/midi00",O_RDWR|O_NONBLOCK);
  if (fd1 == -1)
    {
      printf("Error open %s [%d]\n",strerror(errno),errno);
      exit(1);
    }
  printf("Device ready. Lock it!\n");
  do
    {
      result = write(fd1,"ABC",3);
    }
  while (result == 3);
  printf("Result:%d\n",result);
  result = write(fd1,"ABC",3);
  if (result == -1)
    {
      printf("Error open %s [%d]\n",strerror(errno),errno);
    }
  return 0;
}
--
foo!
begin:vcard 
n:Enderborg;Peter
x-mozilla-html:FALSE
org:;
adr:;;;;;;
version:2.1
email;internet:pme@ufh.se
x-mozilla-cpt:;0
fn:Peter Enderborg
end:vcard
[unhandled content-type:application/x-pkcs7-signature]