Date: Thu, 12 Apr 2007 07:52:20 +0530
From: Srivatsa Vaddagiri <>
Subject: Re: [PATCH 7/8] Clean up workqueue.c with respect to the freezer based cpu-hotplug
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/4/11/415

On Tue, Apr 03, 2007 at 10:48:20PM +0530, Srivatsa Vaddagiri wrote:
> > Actually, we should do this before destroy_workqueue() calls flush_workqueue().
> > Otherwise flush_cpu_workqueue() can hang forever in a similar manner.
> 
> Yep. I guess these are a class of freezer deadlocks very similar to vfork
> parent waiting on child case. I get a feeling these should become common
> outside of kthread too (A waits on B for something, B gets frozen, which
> means A won't freeze causing freezer to fail). Can freezer detect this
> dependency somehow and thaw B automatically? Probably not that easy ..
I wonder if there is some value in "enforcing" an order in which
processes get frozen i.e freeze A first before B. That may solve the
deadlocks we have been discussing wrt kthread_stop and flush_workqueue
as well.
The idea is similar to how deadlock wrt multiple locks are solved -
where a ordering is enforced. Take Lock A first before Lock B. 
If process A waits on B (like in kthread_stop or flush_workqueue), then if we:
	1. Insert A and B in a list (freeze_me_first_list)
	2. Have freezer scan freeze_me_first_list before the master
	   task-list, so that it:
		2a. "freezes A and waits for A to get frozen" first
		2b. "freezes B and waits for B to get frozen" next
then we would avoid the nastiness of "B getting frozen first and A doesnt
freeze because of that" with lesser code changes?
-- 
Regards,
vatsa
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/