Date: Sat, 10 Feb 2007 09:40:49 +0800
From: Fengguang Wu <>
Subject: [PATCH -mm] readahead: partial sendfile fix
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/2/9/423

Enable readahead to handle partially done read requests, e.g.
        sendfile(188, 1921, [1478592], 19553028) = 37440
        sendfile(188, 1921, [1516032], 19515588) = 28800
        sendfile(188, 1921, [1544832], 19486788) = 37440
        sendfile(188, 1921, [1582272], 19449348) = 14400
        sendfile(188, 1921, [1596672], 19434948) = 37440
        sendfile(188, 1921, [1634112], 19397508) = 37440
In the above strace log,
        - some lighttpd is doing _sequential_ reading
        - every sendfile() returns with only _partial_ work done
page_cache_readahead() expects that if it returns @next_index, it will be
called exactly at @next_index next time. That's not true here. So the pattern
will be falsely recognized as a random read trace.
Also documented in "Linux AIO Performance and Robustness for Enterprise
Workloads" section 3.5:
	  sendfile(fd, 0, 2GB, fd2) = 8192,
	    tells readahead about up to 128KB of the read
	  sendfile(fd, 8192, 2GB - 8192, fd2) = 8192,
	    tells readahead about 8KB - 132KB of the read
	  sendfile(fd, 16384, 2GB - 16384, fd2) = 8192,
	    tells readahead about 16KB-140KB of the read
	       ...
	This confuses the readahead logic about the I/O pattern which appears
	to be 0-128K, 8K-132K, 16K-140K instead of clear sequentiality from
	0-2GB that is really appropriate.
Retry based AIO shares the same read pattern and readahead problem.
In this case, simply disabling readahead on restarted aio is not a good option:
we still need to call into readahead in the rare case of (req_size > ra_max).
Signed-off-by: Fengguang Wu <wfg@mail.ustc.edu.cn>
---
 mm/filemap.c   |    3 ---
 mm/readahead.c |    9 +++++++++
 2 files changed, 9 insertions(+), 3 deletions(-)
--- linux-2.6.20-rc6-mm3.orig/mm/readahead.c
+++ linux-2.6.20-rc6-mm3/mm/readahead.c
@@ -581,6 +581,15 @@ page_cache_readahead(struct address_spac
 	int sequential;
 
 	/*
+	 * A previous read request is partially completed,
+	 * causing the retried/continued read calls into us prematurely.
+	 */
+	if (ra->start < offset &&
+			offset < ra->prev_page &&
+				 ra->prev_page < ra->ahead_start + ra->ahead_size)
+		goto out;
+
+	/*
 	 * We avoid doing extra work and bogusly perturbing the readahead
 	 * window expansion logic.
 	 */
--- linux-2.6.20-rc6-mm3.orig/mm/filemap.c
+++ linux-2.6.20-rc6-mm3/mm/filemap.c
@@ -915,9 +915,6 @@ void do_generic_mapping_read(struct addr
 	if (!isize)
 		goto out;
 
-	if (unlikely(aio_restarted()))
-		next_index = last_index; /* Avoid repeat readahead */
-
 	end_index = (isize - 1) >> PAGE_CACHE_SHIFT;
 	for (;;) {
 		struct page *page;
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/