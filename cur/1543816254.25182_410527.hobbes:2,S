Date: Fri, 24 Mar 2006 19:13:16 +0300
From: Oleg Nesterov <>
Subject: [PATCH 2.6.16-mm1 1/3] simplify do_signal_stop()
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/3/24/188

depends on
	do_signal_stop-dont-take-tasklist_lock.patch
do_signal_stop() considers 'thread_group_empty()' as a special case.
This was needed to avoid taking tasklist_lock. Since this lock is
unneeded any longer, we can remove this special case and simplify
the code even more.
Also, before this patch, finish_stop() was called with stop_count == -1
for 'thread_group_empty()' case. This is not strictly wrong, but confusing
and unneeded.
Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>
--- MM/kernel/signal.c~2_DOSS	2006-03-23 22:48:10.000000000 +0300
+++ MM/kernel/signal.c	2006-03-24 20:01:46.000000000 +0300
@@ -1685,8 +1685,7 @@ out:
 static int do_signal_stop(int signr)
 {
 	struct signal_struct *sig = current->signal;
-	struct sighand_struct *sighand = current->sighand;
-	int stop_count = -1;
+	int stop_count;
 
 	if (!likely(sig->flags & SIGNAL_STOP_DEQUEUED))
 		return 0;
@@ -1696,30 +1695,14 @@ static int do_signal_stop(int signr)
 		 * There is a group stop in progress.  We don't need to
 		 * start another one.
 		 */
-		signr = sig->group_exit_code;
 		stop_count = --sig->group_stop_count;
-		current->exit_code = signr;
-		set_current_state(TASK_STOPPED);
-		if (stop_count == 0)
-			sig->flags = SIGNAL_STOP_STOPPED;
-	}
-	else if (thread_group_empty(current)) {
-		/*
-		 * Lock must be held through transition to stopped state.
-		 */
-		current->exit_code = current->signal->group_exit_code = signr;
-		set_current_state(TASK_STOPPED);
-		sig->flags = SIGNAL_STOP_STOPPED;
-	}
-	else {
+	} else {
 		/*
-		 * (sig->group_stop_count == 0)
 		 * There is no group stop already in progress.
 		 * We must initiate one now.
 		 */
 		struct task_struct *t;
 
-		current->exit_code = signr;
 		sig->group_exit_code = signr;
 
 		stop_count = 0;
@@ -1735,13 +1718,14 @@ static int do_signal_stop(int signr)
 				signal_wake_up(t, 0);
 			}
 		sig->group_stop_count = stop_count;
-
-		set_current_state(TASK_STOPPED);
-		if (stop_count == 0)
-			sig->flags = SIGNAL_STOP_STOPPED;
 	}
 
-	spin_unlock_irq(&sighand->siglock);
+	if (stop_count == 0)
+		sig->flags = SIGNAL_STOP_STOPPED;
+	current->exit_code = sig->group_exit_code;
+	__set_current_state(TASK_STOPPED);
+
+	spin_unlock_irq(&current->sighand->siglock);
 	finish_stop(stop_count);
 	return 1;
 }
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/