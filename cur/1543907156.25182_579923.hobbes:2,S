Date: Mon, 06 Aug 2007 10:12:40 -0400
From: Chris Snook <>
Subject: Re: why are some atomic_t's not volatile, while most are?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/8/6/305

Jerry Jiang wrote:
> Is there some feedback on this point ?
> 
> Thank you
> ./Jerry
> 
> On Sun, 1 Jul 2007 08:49:37 -0400 (EDT)
> "Robert P. J. Day" <rpjday@mindspring.com> wrote:
> 
>>   prompted by the earlier post on "volatile"s, is there a reason that
>> most atomic_t typedefs use volatile int's, while the rest don't?
>>
>> $ grep "typedef.*struct"  $(find . -name atomic.h)
>> ./include/asm-v850/atomic.h:typedef struct { int counter; } atomic_t;
>> ./include/asm-mips/atomic.h:typedef struct { volatile int counter; } atomic_t;
>> ./include/asm-mips/atomic.h:typedef struct { volatile long counter; } atomic64_t;
>> ...
>>
>>   etc, etc.  just curious.
If your architecture doesn't support SMP, the volatile keyword doesn't do 
anything except add a useless memory fetch.  Also, some SMP architectures (i386, 
x86_64, s390) provide sufficiently strong guarantees about memory access 
ordering that it's not necessary as long as you're using the appropriate 
locked/atomic instructions in the atomic operations.
	-- Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/