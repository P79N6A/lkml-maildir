Date: Wed, 12 May 1999 23:07:46 +0100 (GMT)
From: Tim Waugh <>
Subject: 2.3.1-pre2: lp and parport compilation fixes
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/5/13/86

Here are the modifications I needed to be able to print with 2.3.1-pre2
modules.
As an added bonus: the __init changes I mentioned a couple of days ago, by
popular demand. :-)
Tim.
*/
diff -durN linux-2.3.1-pre2/drivers/char/lp.c linux/drivers/char/lp.c
--- linux-2.3.1-pre2/drivers/char/lp.c	Wed May 12 09:14:29 1999
+++ linux/drivers/char/lp.c	Wed May 12 22:55:22 1999
@@ -194,7 +194,7 @@
 #ifdef LP_STATS
 			   0, 0, {0},
 #endif
-			   NULL, 0, 0, 0}
+			   0, 0, 0, }
 };
 
 /* Test if printer is ready */
@@ -731,6 +731,7 @@
 			return -EIO;
 		}
 	}
+	init_waitqueue_head (&lp_table[minor].wait_q);
 	lp_table[minor].lp_buffer = (char *) kmalloc(LP_BUFFER_SIZE, GFP_KERNEL);
 	if (!lp_table[minor].lp_buffer) {
 		MOD_DEC_USE_COUNT;
diff -durN linux-2.3.1-pre2/drivers/misc/parport_pc.c linux/drivers/misc/parport_pc.c
--- linux-2.3.1-pre2/drivers/misc/parport_pc.c	Wed May 12 09:14:37 1999
+++ linux/drivers/misc/parport_pc.c	Wed May 12 22:58:51 1999
@@ -43,6 +43,7 @@
 #include <linux/ioport.h>
 #include <linux/kernel.h>
 #include <linux/malloc.h>
+#include <linux/init.h>
 
 #include <asm/io.h>
 
@@ -53,7 +54,7 @@
    than PARPORT_MAX (in <linux/parport.h>).  */
 #define PARPORT_PC_MAX_PORTS  8
 
-static int user_specified = 0;
+static int user_specified __initdata = 0;
 
 static void parport_pc_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
@@ -350,7 +351,7 @@
 /*
  * Checks for port existence, all ports support SPP MODE
  */
-static int parport_SPP_supported(struct parport *pb)
+static int __init parport_SPP_supported(struct parport *pb)
 {
 	unsigned char r, w;
 
@@ -425,7 +426,7 @@
  * We will write 0x2c to ECR and 0xcc to CTR since both of these
  * values are "safe" on the CTR since bits 6-7 of CTR are unused.
  */
-static int parport_ECR_present(struct parport *pb)
+static int __init parport_ECR_present(struct parport *pb)
 {
 	unsigned char r;
 
@@ -458,7 +459,7 @@
 	return 0;
 }
 
-static int parport_ECP_supported(struct parport *pb)
+static int __init parport_ECP_supported(struct parport *pb)
 {
 	int i;
 	unsigned char oecr;
@@ -493,7 +494,7 @@
  *	or writing a 1 to the bit (SMC, UMC, WinBond), others ???
  *	This bit is always high in non EPP modes.
  */
-static int parport_EPP_supported(struct parport *pb)
+static int __init parport_EPP_supported(struct parport *pb)
 {
 	/* If EPP timeout bit clear then EPP available */
 	if (!parport_pc_epp_clear_timeout(pb))
@@ -514,7 +515,7 @@
 	return 0;
 }
 
-static int parport_ECPEPP_supported(struct parport *pb)
+static int __init parport_ECPEPP_supported(struct parport *pb)
 {
 	int mode;
 	unsigned char oecr;
@@ -550,7 +551,7 @@
  * be misdetected here is rather academic. 
  */
 
-static int parport_PS2_supported(struct parport *pb)
+static int __init parport_PS2_supported(struct parport *pb)
 {
 	int ok = 0;
 	unsigned char octr = parport_pc_read_control(pb);
@@ -570,7 +571,7 @@
 	return ok?PARPORT_MODE_PCPS2:0;
 }
 
-static int parport_ECPPS2_supported(struct parport *pb)
+static int __init parport_ECPPS2_supported(struct parport *pb)
 {
 	int mode;
 	unsigned char oecr;
@@ -590,7 +591,7 @@
 /* --- IRQ detection -------------------------------------- */
 
 /* Only if supports ECP mode */
-static int programmable_irq_support(struct parport *pb)
+static int __init programmable_irq_support(struct parport *pb)
 {
 	int irq, intrLine;
 	unsigned char oecr = parport_pc_read_econtrol(pb);
@@ -607,7 +608,7 @@
 	return irq;
 }
 
-static int irq_probe_ECP(struct parport *pb)
+static int __init irq_probe_ECP(struct parport *pb)
 {
 	int irqs, i;
 
@@ -634,7 +635,7 @@
  * This detection seems that only works in National Semiconductors
  * This doesn't work in SMC, LGS, and Winbond 
  */
-static int irq_probe_EPP(struct parport *pb)
+static int __init irq_probe_EPP(struct parport *pb)
 {
 	int irqs;
 	unsigned char octr = parport_pc_read_control(pb);
@@ -675,7 +676,7 @@
 	return pb->irq;
 }
 
-static int irq_probe_SPP(struct parport *pb)
+static int __init irq_probe_SPP(struct parport *pb)
 {
 	int irqs;
 	unsigned char octr = parport_pc_read_control(pb);
@@ -723,7 +724,7 @@
  * When ECP is available we can autoprobe for IRQs.
  * NOTE: If we can autoprobe it, we can register the IRQ.
  */
-static int parport_irq_probe(struct parport *pb)
+static int __init parport_irq_probe(struct parport *pb)
 {
 	if (pb->modes & PARPORT_MODE_PCECR) {
 		pb->irq = programmable_irq_support(pb);
@@ -754,7 +755,7 @@
 
 /* --- Initialisation code -------------------------------- */
 
-static int probe_one_port(unsigned long int base, int irq, int dma)
+static int __init probe_one_port(unsigned long int base, int irq, int dma)
 {
 	struct parport *p;
 	int probedirq = PARPORT_IRQ_NONE;
@@ -841,7 +842,7 @@
 	return 1;
 }
 
-int parport_pc_init(int *io, int *irq, int *dma)
+int __init parport_pc_init(int *io, int *irq, int *dma)
 {
 	int count = 0, i = 0;
 	if (io && *io) {
diff -durN linux-2.3.1-pre2/include/linux/lp.h linux/include/linux/lp.h
--- linux-2.3.1-pre2/include/linux/lp.h	Wed May 12 22:33:19 1999
+++ linux/include/linux/lp.h	Wed May 12 22:51:35 1999
@@ -123,10 +123,10 @@
 	unsigned int runchars;
 	struct lp_stats stats;
 #endif
-	wait_queue_head_t wait_q;
 	unsigned int last_error;
 	volatile unsigned int irq_detected:1;
 	volatile unsigned int irq_missed:1;
+	wait_queue_head_t wait_q;
 };
 
 /*
diff -durN linux-2.3.1-pre2/include/linux/parport.h linux/include/linux/parport.h
--- linux-2.3.1-pre2/include/linux/parport.h	Tue Jan 26 00:05:21 1999
+++ linux/include/linux/parport.h	Wed May 12 22:58:05 1999
@@ -163,7 +163,7 @@
 	struct pardevice *next;
 	struct pardevice *prev;
 	struct parport_state *state;     /* saved status over preemption */
-	struct wait_queue *wait_q;
+	wait_queue_head_t wait_q;
 	unsigned long int time;
 	unsigned long int timeslice;
 	unsigned int waiting;
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/