Date: Wed, 08 Dec 1999 11:14:13 +0100
From: Eric PAIRE <>
Subject: SIGCONT misbehaviour in Linux
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/12/8/40

Hi Linux gurus,
Michael Snyder is currently integrating my linuxthreads debugging support
inside the source tree of GDB at Cygnus, and he notified what I think is a
generic kernel bug in the signal handling:
When a process blocked in the kernel receives a stopping signal (POSIX says
SIGSTOP, SIGTSTP, SIGTTIN and SIGTTOU), then the process stops, and this is
correctly implemented by Linux. *BUT*, when such a process receives a SIGCONT,
then it must continue, whatever signal handling is configured in the process.
The specific problem here is that, if the process is blocked in
sys_nanosleep(), then receiving a SIGSTOP will make it exit from
sys_nanosleep() and enter into TASK_STOPPED state in do_signal(). 
When it will be awaken via a SIGCONT, then it will exit immediately
from the kernel, whatever time it remains to sleep, even if no signal
handler is attached to SIGCONT, which is not the correct POSIX semantics
(It should only return if there is a signal handler attached to SIGCONT).
Notice also that the remaining time does not take into account the time
during which the process has been stopped.
The general problem here is that the kernel seems to *ALWAYS* return EINTR
when signals have been sent during system calls, *EVEN* when there is no
signal handler attached to the signal, which seems to be in contradiction
with the generic POSIX semantics of EINTR. I have added the glibc-bug
mailing list because I don't know whether the POSIX behaviour should be
handled correctly in the libc or in the kernel.
BTW, a funny user test to show this misbehaviour is to type the following
commands in bash:
sleep 1000
^Z
fg
and the process running sleep 1000 immediatly returns on Linux. I tested it
on other systems and it works correctly (the sleep continue).
Best regards,
-Eric
P.S. The original problem of Michael was with PTRACE_ATTACH, which side effect
	is to make a process executing nanosleep() ot immediatly exit from
	nanosleep() wheen attached by GDB, which make gdb intrusive in the
	process behaviour....
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ Eric PAIRE
Web  : 
http://www.ri.silicomp.com/~paire
  | Group SILICOMP - Research Institute
Email: eric.paire@ri.silicomp.com         | 2, avenue de Vignate
Phone: +33 (0) 476 63 48 71               | F-38610 Gieres
Fax  : +33 (0) 476 51 05 32               | FRANCE
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/