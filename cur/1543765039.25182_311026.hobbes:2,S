Date: Tue, 12 Apr 2005 21:26:43 +1000
From: Nick Piggin <>
Subject: Re: Processes stuck on D state on Dual Opteron
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/4/12/141

Nick Piggin wrote:
> Chen, Kenneth W wrote:
>> I like the patch a lot and already did bench it on our db setup.  
>> However,
>> I'm seeing a negative regression compare to a very very crappy patch (see
>> attached, you can laugh at me for doing things like that :-).
>>
> 
> OK - if we go that way, perhaps the following patch may be the
> way to do it.
> 
Here.
-- 
SUSE Labs, Novell Inc.
Index: linux-2.6/drivers/block/ll_rw_blk.c
===================================================================
--- linux-2.6.orig/drivers/block/ll_rw_blk.c	2005-04-12 21:03:01.000000000 +1000
+++ linux-2.6/drivers/block/ll_rw_blk.c	2005-04-12 21:03:45.000000000 +1000
@@ -1956,10 +1956,11 @@ out:
  */
 static struct request *get_request_wait(request_queue_t *q, int rw)
 {
-	DEFINE_WAIT(wait);
 	struct request *rq;
 
-	do {
+	rq = get_request(q, rw, GFP_NOIO);
+	while (!rq) {
+		DEFINE_WAIT(wait);
 		struct request_list *rl = &q->rq;
 
 		prepare_to_wait_exclusive(&rl->wait[rw], &wait,
@@ -1987,7 +1988,7 @@ static struct request *get_request_wait(
 			spin_lock_irq(q->queue_lock);
 		}
 		finish_wait(&rl->wait[rw], &wait);
-	} while (!rq);
+	}
 
 	return rq;
 }