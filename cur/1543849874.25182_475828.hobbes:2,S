Date: Mon, 23 Oct 2006 15:32:07 +0400
From: Andrey Panin <>
Subject: Re: 2.6.19-rc2: known unfixed regressions (v3)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/10/23/118

On 295, 10 22, 2006 at 02:23:55PM +0200, Adrian Bunk wrote:
> This email lists some known unfixed regressions in 2.6.19-rc2 compared 
> to 2.6.18 that are not yet fixed Linus' tree.
> 
> If you find your name in the Cc header, you are either submitter of one
> of the bugs, maintainer of an affectected subsystem or driver, a patch
> of you caused a breakage or I'm considering you in any other way possibly
> involved with one or more of these issues.
> 
> Due to the huge amount of recipients, please trim the Cc when answering.
> 
>
> Subject    : CONFIG_X86_VISWS=y, CONFIG_SMP=n compile error
> References : 
http://lkml.org/lkml/2006/10/7/51
> Submitter  : Jesper Juhl <jesper.juhl@gmail.com>
> Caused-By  : David Howells <dhowells@redhat.com>
>              commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
> Status     : unknown
Attached patch fixes this problem.
-- 
Andrey Panin		| Linux and UNIX system administrator
pazke@donpac.ru		| PGP key: wwwkeys.pgp.net
Signed-off-by: Andrey Panin <pazke@donpac.ru>
 arch/i386/mach-visws/visws_apic.c       |    7 +---
 include/asm-i386/mach-visws/do_timer.h  |   53 --------------------------------
 include/asm-i386/mach-visws/mach_apic.h |    5 +++
 3 files changed, 8 insertions(+), 57 deletions(-)
diff -urdpNX /usr/share/dontdiff linux-2.6.19-rc2.vanilla/arch/i386/mach-visws/visws_apic.c linux-2.6.19-rc2/arch/i386/mach-visws/visws_apic.c
--- linux-2.6.19-rc2.vanilla/arch/i386/mach-visws/visws_apic.c	2006-10-22 14:32:13.000000000 +0400
+++ linux-2.6.19-rc2/arch/i386/mach-visws/visws_apic.c	2006-10-22 14:37:30.000000000 +0400
@@ -122,7 +122,7 @@ static void end_cobalt_irq(unsigned int 
 	spin_unlock_irqrestore(&cobalt_lock, flags);
 }
 
-static struct hw_interrupt_type cobalt_irq_type = {
+static struct irq_chip cobalt_irq_type = {
 	.typename =	"Cobalt-APIC",
 	.startup =	startup_cobalt_irq,
 	.shutdown =	disable_cobalt_irq,
@@ -159,7 +159,7 @@ static void end_piix4_master_irq(unsigne
 	spin_unlock_irqrestore(&cobalt_lock, flags);
 }
 
-static struct hw_interrupt_type piix4_master_irq_type = {
+static struct irq_chip piix4_master_irq_type = {
 	.typename =	"PIIX4-master",
 	.startup =	startup_piix4_master_irq,
 	.ack =		ack_cobalt_irq,
@@ -167,9 +167,8 @@ static struct hw_interrupt_type piix4_ma
 };
 
 
-static struct hw_interrupt_type piix4_virtual_irq_type = {
+static struct irq_chip piix4_virtual_irq_type = {
 	.typename =	"PIIX4-virtual",
-	.startup =	startup_8259A_irq,
 	.shutdown =	disable_8259A_irq,
 	.enable =	enable_8259A_irq,
 	.disable =	disable_8259A_irq,
diff -urdpNX /usr/share/dontdiff linux-2.6.19-rc2.vanilla/include/asm-i386/mach-visws/do_timer.h linux-2.6.19-rc2/include/asm-i386/mach-visws/do_timer.h
--- linux-2.6.19-rc2.vanilla/include/asm-i386/mach-visws/do_timer.h	2006-10-22 14:33:24.000000000 +0400
+++ linux-2.6.19-rc2/include/asm-i386/mach-visws/do_timer.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,53 +0,0 @@
-/* defines for inline arch setup functions */
-
-#include <asm/fixmap.h>
-#include <asm/i8259.h>
-#include "cobalt.h"
-
-static inline void do_timer_interrupt_hook(void)
-{
-	/* Clear the interrupt */
-	co_cpu_write(CO_CPU_STAT,co_cpu_read(CO_CPU_STAT) & ~CO_STAT_TIMEINTR);
-
-	do_timer(1);
-#ifndef CONFIG_SMP
-	update_process_times(user_mode_vm(irq_regs));
-#endif
-/*
- * In the SMP case we use the local APIC timer interrupt to do the
- * profiling, except when we simulate SMP mode on a uniprocessor
- * system, in that case we have to call the local interrupt handler.
- */
-#ifndef CONFIG_X86_LOCAL_APIC
-	profile_tick(CPU_PROFILING);
-#else
-	if (!using_apic_timer)
-		smp_local_timer_interrupt();
-#endif
-}
-
-static inline int do_timer_overflow(int count)
-{
-	int i;
-
-	spin_lock(&i8259A_lock);
-	/*
-	 * This is tricky when I/O APICs are used;
-	 * see do_timer_interrupt().
-	 */
-	i = inb(0x20);
-	spin_unlock(&i8259A_lock);
-	
-	/* assumption about timer being IRQ0 */
-	if (i & 0x01) {
-		/*
-		 * We cannot detect lost timer interrupts ... 
-		 * well, that's why we call them lost, don't we? :)
-		 * [hmm, on the Pentium and Alpha we can ... sort of]
-		 */
-		count -= LATCH;
-	} else {
-		printk("do_slow_gettimeoffset(): hardware timer problem?\n");
-	}
-	return count;
-}
diff -urdpNX /usr/share/dontdiff linux-2.6.19-rc2.vanilla/include/asm-i386/mach-visws/mach_apic.h linux-2.6.19-rc2/include/asm-i386/mach-visws/mach_apic.h
--- linux-2.6.19-rc2.vanilla/include/asm-i386/mach-visws/mach_apic.h	2006-01-03 06:21:10.000000000 +0300
+++ linux-2.6.19-rc2/include/asm-i386/mach-visws/mach_apic.h	2006-10-22 14:16:53.000000000 +0400
@@ -51,6 +51,11 @@ static inline void clustered_apic_check(
 {
 }
 
+static inline int apicid_to_node(int logical_apicid)
+{
+	return 0;
+}
+
 /* Mapping from cpu number to logical apicid */
 static inline int cpu_to_logical_apicid(int cpu)
 {[unhandled content-type:application/pgp-signature]