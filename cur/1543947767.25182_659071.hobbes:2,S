Date: Sun, 24 Feb 2008 14:03:02 -0500 (EST)
From: Alan Stern <>
Subject: Re: [Bug 10030] Suspend doesn't work when SD card is inserted
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/2/24/176

On Sun, 24 Feb 2008, Pavel Machek wrote:
> Hi!
> 
> > Index: usb-2.6/drivers/base/power/main.c
> > ===================================================================
> > --- usb-2.6.orig/drivers/base/power/main.c
> > +++ usb-2.6/drivers/base/power/main.c
> > @@ -25,6 +25,7 @@
> >  #include <linux/pm.h>
> >  #include <linux/resume-trace.h>
> >  #include <linux/rwsem.h>
> > +#include <linux/sched.h>
> > 
> >  #include "../base.h"
> >  #include "power.h"
> > @@ -59,6 +60,13 @@ static DECLARE_RWSEM(pm_sleep_rwsem);
> > 
> >  int (*platform_enable_wakeup)(struct device *dev, int is_on);
> > 
> > +static struct task_struct *suspending_task;
> 
> What locking protects this variable? What happens when suspending_task
> exits? (Hmm, that would probably be bug, anyway?)
It's protected by whatever existing locking scheme allows only one
task to start a system sleep at a time.  For example, the suspending 
task has to get a write lock on pm_sleep_rwsem.
Yes, if the suspending task exits before the system has woken up, 
you're in trouble regardless.
> Or are we running UP when this is accessed? This at least needs a big
> fat comment.
> 
> > +bool in_suspend_context(void)
> > +{
> > +	return (suspending_task == current);
> > +}
We aren't necessarily UP.  But since all that matters is whether or not 
suspend_task is equal to the current task, no extra locking is needed.  
I'll add a comment explaining all this.
Alan Stern