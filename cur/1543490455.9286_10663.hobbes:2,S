Date: Sat, 20 Mar 1999 09:58:48 -0800
From: "G. Allen Morris III" <>
Subject: [patch] expire nfsd caches correctly.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/3/20/57

This patch fixes two problems:  diskspace was not being release when 
at file was deleted, and rmdir did not work on vfat filesystems.
This patch removes cache entries that are being unlink'd or rmdir'd,
and makes sure that all cache entries are flushed periodically.
--------------------------------------------------------------------
diff -u -X exclude linux-2.2.3/fs/nfsd/nfsfh.c linux/fs/nfsd/nfsfh.c
--- linux-2.2.3/fs/nfsd/nfsfh.c	Sat Jan 16 17:05:13 1999
+++ linux/fs/nfsd/nfsfh.c	Sat Mar 20 09:31:39 1999
@@ -235,7 +235,7 @@
 /*
  * Search for a path entry for the specified (dev, inode).
  */
-struct nfsd_path *get_path_entry(kdev_t dev, ino_t ino)
+static struct nfsd_path *get_path_entry(kdev_t dev, ino_t ino)
 {
 	struct nfsd_path *pe;
 	struct list_head *tmp;
@@ -713,7 +713,6 @@
 		dentry = dget(fhe->dentry);
 		goto out;
 	}
-
 	/*
 	 * Search the path cache ...
 	 */
@@ -859,6 +858,34 @@
 	return NULL;
 }
 
+void
+expire_all(void)
+{
+ 	if (time_after_eq(jiffies, nfsd_next_expire)) {
+ 		expire_old(NFSD_FILE_CACHE,  5*HZ);
+ 		expire_old(NFSD_DIR_CACHE , 60*HZ);
+ 		nfsd_next_expire = jiffies + 5*HZ;
+ 	}
+}
+
+/* 
+ * Free cache after unlink/rmdir.
+ */
+void
+expire_by_dentry(struct dentry *dentry)
+{
+	struct fh_entry *fhe;
+
+	fhe = find_fhe(dentry, NFSD_FILE_CACHE, NULL);
+	if (fhe) {
+		expire_fhe(fhe, NFSD_FILE_CACHE);
+	}
+	fhe = find_fhe(dentry, NFSD_DIR_CACHE, NULL);
+	if (fhe) {
+		expire_fhe(fhe, NFSD_DIR_CACHE);
+	}
+}
+
 /*
  * The is the basic lookup mechanism for turning an NFS file handle 
  * into a dentry. There are several levels to the search:
@@ -997,15 +1024,8 @@
 		add_to_lookup_cache(dentry, fh);
 	}
 
-	/*
-	 * Perform any needed housekeeping ...
-	 * N.B. move this into one of the daemons ...
-	 */
-	if (time_after_eq(jiffies, nfsd_next_expire)) {
-		expire_old(NFSD_FILE_CACHE,  5*HZ);
-		expire_old(NFSD_DIR_CACHE , 60*HZ);
-		nfsd_next_expire = jiffies + 5*HZ;
-	}
+	expire_all();
+
 	return dentry;
 }
 
@@ -1133,7 +1153,7 @@
 #ifdef NFSD_PARANOIA
 if (error)
 printk("fh_verify: %s/%s permission failure, acc=%x, error=%d\n",
-dentry->d_parent->d_name.name, dentry->d_name.name, access, error);
+dentry->d_parent->d_name.name, dentry->d_name.name, access, (error >> 24));
 #endif
 out:
 	return error;
diff -u -X exclude linux-2.2.3/fs/nfsd/nfssvc.c linux/fs/nfsd/nfssvc.c
--- linux-2.2.3/fs/nfsd/nfssvc.c	Tue Dec 29 15:17:13 1998
+++ linux/fs/nfsd/nfssvc.c	Sat Mar 20 09:15:42 1999
@@ -101,7 +101,7 @@
 nfsd(struct svc_rqst *rqstp)
 {
 	struct svc_serv	*serv = rqstp->rq_server;
-	int		oldumask, err;
+	int		oldumask, err, first = 0;
 
 	/* Lock module and set up kernel thread */
 	MOD_INC_USE_COUNT;
@@ -115,8 +115,10 @@
 
 	oldumask = current->fs->umask;		/* Set umask to 0.  */
 	current->fs->umask = 0;
-	if (!nfsd_active++)
+	if (!nfsd_active++) {
 		nfssvc_boot = xtime;		/* record boot time */
+		first = 1;
+	}
 	lockd_up();				/* start lockd */
 
 	/*
@@ -133,8 +135,14 @@
 		 * Find a socket with data available and call its
 		 * recvfrom routine.
 		 */
-		while ((err = svc_recv(serv, rqstp, MAX_SCHEDULE_TIMEOUT)) == -EAGAIN)
-			;
+		while ((err = svc_recv(serv, rqstp,
+		        first?5*HZ:MAX_SCHEDULE_TIMEOUT)) == -EAGAIN) {
+			if (first && 1) {
+				exp_readlock();
+				expire_all();
+				exp_unlock();
+			}
+		}
 		if (err < 0)
 			break;
 
diff -u -X exclude linux-2.2.3/fs/nfsd/vfs.c linux/fs/nfsd/vfs.c
--- linux-2.2.3/fs/nfsd/vfs.c	Mon Feb 15 16:34:59 1999
+++ linux/fs/nfsd/vfs.c	Sat Mar 20 09:35:27 1999
@@ -11,7 +11,7 @@
  * So if you notice code paths that apparently fail to dput() the
  * dentry, don't worry--they have been taken care of.
  *
- * Copyright (C) 1995, 1996, 1997 Olaf Kirch <okir@monad.swb.de>
+ * Copyright (C) 1995-1999 Olaf Kirch <okir@monad.swb.de>
  */
 
 #include <linux/config.h>
@@ -1139,8 +1139,11 @@
 		goto out;
 	}
 
+	expire_by_dentry(rdentry);
+
 	if (type != S_IFDIR) {
 		/* It's UNLINK */
+
 		err = fh_lock_parent(fhp, rdentry);
 		if (err)
 			goto out;
@@ -1155,6 +1158,7 @@
 	} else {
 		/* It's RMDIR */
 		/* See comments in fs/namei.c:do_rmdir */
+
 		rdentry->d_count++;
 		nfsd_double_down(&dirp->i_sem, &rdentry->d_inode->i_sem);
 		if (!fhp->fh_pre_mtime)
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/