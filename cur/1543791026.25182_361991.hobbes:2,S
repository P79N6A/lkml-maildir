Date: Mon, 31 Oct 2005 14:02:32 -0800
From: Badari Pulavarty <>
Subject: [PATCH] SHM_NORESERVE flags for shmget()
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/10/31/289

Hi Andrew,
Here is the patch to add SHM_NORESERVE functionality
similar to MAP_NORESERVE for shared memory segments.
This mainly to avoid abuse of OVERCOMMIT_ALWAYS and
this flag is ignored for OVERCOMMIT_NEVER. 
Hugh reviewed the patch earlier and had no objections 
to it. Could you include this ?
Thanks,
Badari
Signed-off-by: Badari Pulavarty <pbadari@us.ibm.com>
diff -Naurp -X dontdiff linux-2.6.14/include/linux/shm.h linux-2.6.14.new/include/linux/shm.h
--- linux-2.6.14/include/linux/shm.h	2005-09-30 14:17:35.000000000 -0700
+++ linux-2.6.14.new/include/linux/shm.h	2005-10-18 08:46:03.000000000 -0700
@@ -92,6 +92,7 @@ struct shmid_kernel /* private to the ke
 #define	SHM_DEST	01000	/* segment will be destroyed on last detach */
 #define SHM_LOCKED      02000   /* segment will not be swapped */
 #define SHM_HUGETLB     04000   /* segment will use huge TLB pages */
+#define SHM_NORESERVE   010000  /* don't check for reservations */
 
 #ifdef CONFIG_SYSVIPC
 long do_shmat(int shmid, char __user *shmaddr, int shmflg, unsigned long *addr);
diff -Naurp -X dontdiff linux-2.6.14/ipc/shm.c linux-2.6.14.new/ipc/shm.c
--- linux-2.6.14/ipc/shm.c	2005-09-30 14:17:35.000000000 -0700
+++ linux-2.6.14.new/ipc/shm.c	2005-10-20 14:14:40.000000000 -0700
@@ -212,8 +212,16 @@ static int newseg (key_t key, int shmflg
 		file = hugetlb_zero_setup(size);
 		shp->mlock_user = current->user;
 	} else {
+		int acctflag = VM_ACCOUNT;
+		/*
+		 * Do not allow no accounting for OVERCOMMIT_NEVER, even
+	 	 * if it's asked for.
+		 */
+		if  ((shmflg & SHM_NORESERVE) && 
+			sysctl_overcommit_memory != OVERCOMMIT_NEVER)
+			acctflag = 0;
 		sprintf (name, "SYSV%08x", key);
-		file = shmem_file_setup(name, size, VM_ACCOUNT);
+		file = shmem_file_setup(name, size, acctflag);
 	}
 	error = PTR_ERR(file);
 	if (IS_ERR(file))