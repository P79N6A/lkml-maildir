Date: Mon, 14 May 2007 12:07:21 +0200
From: "Rafael J. Wysocki" <>
Subject: Re: [RFD] Freezing of kernel threads
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/5/14/89

On Monday, 14 May 2007 09:26, Gautham R Shenoy wrote:
> On Mon, May 14, 2007 at 11:48:46AM +0530, Srivatsa Vaddagiri wrote:
> > 
> > The other complication get/put_hotcpu() had was dealing with
> > write-followed-by-read lock attempt by the *same* thread (whilst doing
> > cpu_down/up).  IIRC this was triggered by some callback processing in CPU_DEAD 
> > or CPU_DOWN_PREPARE.
> > 
> > 
> > cpu_down()
> >  |- take write lock 
> >  |- CPU_DOWN_PREPARE
> >  |        |- foo() wants a read_lock 
> > 
> > Stupid as it sounds, it was really found to be happening!  Gautham, do you 
> > recall who that foo() was? Somebody in cpufreq I guess ..
> 
> IIRC, it was a problem with ondemand. while handling CPU_DEAD, ondemand code
> would call destroy_workqueue, which tried flushing the workqueue, which
> once upon a time did lock_cpu_hotplug, before Oleg and Andrew cleaned 
> that up. 
> 
> Ofcourse, cpufreq works fine now after Venki's patches which
> just nullifies the reference to the policy structure of the cpu to be
> removed during the CPU_DOWN_PREPARE by calling __cpufreq_remove_dev
> instead of handling it in CPU_DEAD.
> 
> However, as we have discovered, without freezing all the threads, it
> is inadvisable to call flush_workqueue from a cpu-hotplug callback 
> path. 
Please see my recent patch at 
http://lkml.org/lkml/2007/5/14/7
 .
It's not exactly the same thing, but I think the trick in there might be
useful.
Greetings,
Rafael
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/