Date: Tue, 07 Aug 2007 15:38:22 -0600
From: "Chris Friesen" <>
Subject: Re: why are some atomic_t's not volatile, while most are?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/8/7/466

Chris Snook wrote:
> That's why we define atomic_read like so:
> 
> #define atomic_read(v)          ((v)->counter)
> 
> This avoids the aliasing problem, because the compiler must de-reference 
> the pointer every time, which requires a memory fetch.
Can you guarantee that the pointer dereference cannot be optimised away 
on any architecture?  Without other restrictions, a suficiently 
intelligent optimiser could notice that the address of v doesn't change 
in the loop and the destination is never written within the loop, so the 
read could be hoisted out of the loop.
Even now, powerpc (as an example) defines atomic_t as:
typedef struct { volatile int counter; } atomic_t
That volatile is there precisely to force the compiler to dereference it 
every single time.
Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/