Date: Thu, 13 Mar 2008 18:04:05 -0700
From: "Yinghai Lu" <>
Subject: Re: [PATCH] mm: make reserve_bootmem can crossed the nodes
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/3/13/466

On Thu, Mar 13, 2008 at 5:13 PM, Johannes Weiner <hannes@saeurebad.de> wrote:
> Hi,
>
>  "Yinghai Lu" <yhlu.kernel@gmail.com> writes:
>
>  >  static void __init free_bootmem_core(bootmem_data_t *bdata, unsigned long addr,
>  > @@ -407,6 +432,11 @@ unsigned long __init init_bootmem_node(p
>  >  void __init reserve_bootmem_node(pg_data_t *pgdat, unsigned long physaddr,
>  >                                unsigned long size, int flags)
>  >  {
>  > +     int ret;
>  > +
>  > +     ret = can_reserve_bootmem_core(pgdat->bdata, physaddr, size, flags);
>  > +     if (ret < 0)
>  > +             return;
>  >       reserve_bootmem_core(pgdat->bdata, physaddr, size, flags);
>
>  I don't get it.  Sorry.  What is the purpose of
>  can_reserve_bootmem_core()?  It does exactly what reserve_bootmem_core
>  does besides actually setting the bits.  All the pre-checking you wanted
>  to have out of the way is repeated again in reserve_bootmem_core()
>  (well, almost all).
can_reserve_bootmem_core is check if there is some pages is reserved
already with
>  > +                     if (flags & BOOTMEM_EXCLUSIVE)
>  > +                             return -EBUSY;
so it will avoid the restoring later.
YH