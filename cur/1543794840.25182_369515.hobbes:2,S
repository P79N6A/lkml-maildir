Date: Tue, 22 Nov 2005 08:34:53 -0800
From: Badari Pulavarty <>
Subject: mmap64() behaviour on 64-bit machines ?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/11/22/142

Hi,
I am confused on the behaviour of mmap64() on 64-bit machines.
When I run following simple program, I get SIGSEGV in memset().
But if I replace mmap64() with mmap() - it works fine.
I verified this on ppc64, em64t, amd64.
Whats happening here ? Any clues ?
Thanks,
Badari
[root@localhost ~]# ./tst junk
Segmentation fault
strace output: 
...
open("junk", O_RDWR|O_CREAT, 0644)      = 3
write(3, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"...,
4096) = 4096
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, 3, 0) =
0x2aaaaaaac000
--- SIGSEGV (Segmentation fault) @ 0 (0) ---
+++ killed by SIGSEGV +++
Process 26736 detached
#include <fcntl.h>
#include <stdio.h>
#include <sys/mman.h>
char buf[4096];
int main(int argc, char* argv[])
{
  int fd;
  char *start;
  if (argc < 2) {
	printf("Usage: %s <filename>\n", argv[0]);
	exit(1);
  }
  fd = open(argv[1], O_RDWR | O_CREAT , 0644);
  if (fd < 0) {
	perror("open");
	exit(1);
  }
  if (write(fd, buf, 4096) < 0) {
	perror("write");
	exit(2);
  } 
  start = (char *)mmap64(0, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
  if (!start) {
	perror("mmap64");
	exit(2);
  }
  memset(start, 0, 4096);
  exit(0);	
}