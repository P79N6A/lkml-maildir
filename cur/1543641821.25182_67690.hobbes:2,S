Date: Sun, 1 Sep 2002 15:57:49 -0600
From: Bruce Guenter <>
Subject: Re: [PATCH] warnkill trivia 2/2
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2002/9/1/139

On Sun, Sep 01, 2002 at 02:39:03PM +0200, Tomas Szepe wrote:
> I've been playing a bit with how gcc handles the const qualifiers
> and made an interesting discovery:
> 
> Trying to compile
> 
> typedef int *p_int;
> void a(const p_int t) { *t = 0; }
> void b(const p_int t) { t = (int *) 0; }
> void c(const int *t) { *t = 0; }
> void d(const int *t) { t = (int *) 0; }
> void e(int const *t) { *t = 0; }
> void f(int const *t) { t = (int *) 0; }
> 
> will give 'assignment of read-only location' warnings for
> b(), c() and e(), i.e. it's impossible to have a constant
> pointer to a non-constant value w/o using a qualified
> typedef.
If you want a constant *pointer*, use:
	void f(int* const t)
	(read "f is a function, taking parameter constant pointer to
	int, returning void)
> W/o a typedef, gcc seems unable to tell the difference
> between 'const int *' and 'int const *' altogether.
That's because there is no difference ("pointer to integer constant" vs
"pointer to constant integer").
See 
http://untroubled.org/articles/cdecls.txt
 for one of the best
references I've ever seen to understanding C type declarations.
-- 
Bruce Guenter <bruceg@em.ca> 
http://em.ca/~bruceg/
 
http://untroubled.org/
OpenPGP key: 699980E8 / D0B7 C8DD 365D A395 29DA  2E2A E96F B2DC 6999 80E8
[unhandled content-type:application/pgp-signature]