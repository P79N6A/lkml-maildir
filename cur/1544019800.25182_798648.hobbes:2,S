Date: Thu, 29 Jan 2009 13:08:27 -0500 (EST)
From: Steven Rostedt <>
Subject: Re: [PATCH -v2] use per cpu data for single cpu ipi calls
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2009/1/29/283

On Thu, 29 Jan 2009, Peter Zijlstra wrote:
> > 
> > 
> > > +                       else {
> > > +                               data = &per_cpu(csd_data, cpu);
> > > +                               spin_lock(&per_cpu(csd_data_lock, cpu));
> > > +                               while (data->flags & CSD_FLAG_LOCK)
> > > +                                       cpu_relax();
> > > +                               data->flags = CSD_FLAG_LOCK;
> > > +                               spin_unlock(&per_cpu(csd_data_lock, cpu));
> > > +                       }
> > 
> > I think your argument would hold if he did:
> > 
> >   data = &__get_cpu_var(csd_data);
> > 
> > But now he's actually grabbing the remote cpu's csd, and thus needs
> > atomicy around that remote csd -- which two cpus could contend for.
> 
> So the below should do
> 
> ---
>  kernel/smp.c |    6 +-----
>  1 files changed, 1 insertions(+), 5 deletions(-)
> 
> diff --git a/kernel/smp.c b/kernel/smp.c
> index 9bce851..9eead6c 100644
> --- a/kernel/smp.c
> +++ b/kernel/smp.c
> @@ -201,8 +201,6 @@ void generic_smp_call_function_single_interrupt(void)
>  }
> 
>  static DEFINE_PER_CPU(struct call_single_data, csd_data);
> -static DEFINE_PER_CPU(spinlock_t, csd_data_lock) =
> -	__SPIN_LOCK_UNLOCKED(csd_lock);
> 
>  /*
>   * smp_call_function_single - Run a function on a specific CPU
> @@ -259,12 +257,10 @@ int smp_call_function_single(int cpu, void (*func) (void *info), void *info,
>  			if (data)
>  				data->flags = CSD_FLAG_ALLOC;
>  			else {
> -				data = &per_cpu(csd_data, cpu);
> -				spin_lock(&per_cpu(csd_data_lock, cpu));
> +				data = &per_cpu(csd_data, me);
>  				while (data->flags & CSD_FLAG_LOCK)
>  					cpu_relax();
>  				data->flags = CSD_FLAG_LOCK;
> -				spin_unlock(&per_cpu(csd_data_lock, cpu));
>  			}
>  		} else {
>  			data = &d;
Ah, OK.
So if we just use our own CPU data, we can through away the spinlocks and 
just do the test ourselves.
That's even better.
Ingo, can you apply Peter's patch on top of mine.
-- Steve