Date: Sat, 10 Jul 2004 08:31:34 +0200
From: Arjan van de Ven <>
Subject: Re: GCC 3.4 and broken inlining.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2004/7/10/22

On Sat, Jul 10, 2004 at 03:21:17AM +0200, Adrian Bunk wrote:
> > one thing to note is that you also need to monitor stack usage then :)
> > inlining somewhat blows up stack usage so do monitor it...
> 
> How could inlining increase stack usage?
void foo1(void)
{
	char array[200];
	do_something(array);
}
void foo2(void)
{
	char other_array[200];
	do_somethingelse(other_array);
}
void function_to_which_they_inline(void)
{
	foo1();
	foo2();
}
(assume the do_* functions get inlined into foo or are defines or whatever)
without inlining it's clear that the max stack usage is 200, the lifetimes
of the 2 arrays are 100% exclusive.
With inlining, gcc reorders instructions in it's optimisation passes, and as
a result the lifetimes of the 2 arrays no longer are exclusive and as a
result gcc has no choice to have both separately on the stack.
[unhandled content-type:application/pgp-signature]