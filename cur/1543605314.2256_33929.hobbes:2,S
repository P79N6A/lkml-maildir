Date: Thu, 18 Oct 2001 12:49:01 -0700 (PDT)
From: Patrick Mochel <>
Subject: Re: [RFC] New Driver Model for 2.5
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2001/10/18/147

> The "state of all the devices in the system". Presumably, while you 
> walk the tree the first time (to save state) interrupts are enabled, 
> and devices are active. Operations (including interrupts) on the 
> device can, presumably, change the state of the device after its 
> state has been saved.
Ya, I'm an idiot sometimes. I relized this just as I was leaving for
lunch. I almost turned around to come back and answer..
This is what I had in mind; If someone could give me a thumbs-up or
thumbs-down on whether or not this would work:
When the driver gets a save_state request, that is its notification that
it is going to sleep. It should then stop/finish all I/O requests. It
should then prevent itself from taking any more - by setting a flag or
whatever. Then, device save state. 
>From that point in, it should know not to take any requests, theoretically
preserving state. 
When it gets the restore_state() call, it should first restore device
state. Once it does that, it knows that it can take I/O requests again. 
That should work, right?
The only thing that that won't work for is the device to which we're
saving state, like the disk. At some point, though we have to accept that
the state that we saved was some checkpoint in the past, and it won't
reflect the state that changed in the process of writing the system state.
	-pat
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/