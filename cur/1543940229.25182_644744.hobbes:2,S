Date: Tue, 29 Jan 2008 00:13:55 +0100
From: "Oliver Pinter (Pintér Olivér)"  <>
Subject: [2.6.22.y] {11/17} - via-velocity-dont-oops-on-mtu-change-2 - series for stable kernel
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/1/28/510

-- 
Thanks,
Oliver
commit d8a71a5e6e4d10d146f860b516c08d5e8fc1cde4
Author: Stephen Hemminger <shemminger@linux-foundation.org>
Date:   Wed Nov 28 22:20:16 2007 -0800
    Subject: via-velocity: don't oops on MTU change (resend)
    Patch-mainline: v2.6.24-rc4
    References: 341537
    via-velocity: don't oops on MTU change (resend)
    The VIA veloicty driver needs the following to allow changing MTU when down.
    The buffer size needs to be computed when device is brought up, not when
    device is initialized.  This also fixes a bug where the buffer size was
    computed differently on change_mtu versus initial setting.
    Signed-off-by: Stephen Hemminger <shemminger@linux-foundation.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>
    Acked-by: Jeff Mahoney <jeffm@suse.com>
diff --git a/drivers/net/via-velocity.c b/drivers/net/via-velocity.c
index 63a2f81..431269e 100644
--- a/drivers/net/via-velocity.c
+++ b/drivers/net/via-velocity.c
@@ -1075,6 +1075,9 @@ static int velocity_init_rd_ring(struct velocity_info *vptr)
 	int ret = -ENOMEM;
 	unsigned int rsize = sizeof(struct velocity_rd_info) *
 					vptr->options.numrx;
+	int mtu = vptr->dev->mtu;
+
+	vptr->rx_buf_sz = (mtu <= ETH_DATA_LEN) ? PKT_BUF_SZ : mtu + 32;
 
 	vptr->rd_info = kmalloc(rsize, GFP_KERNEL);
 	if(vptr->rd_info == NULL)
@@ -1733,8 +1736,6 @@ static int velocity_open(struct net_device *dev)
 	struct velocity_info *vptr = netdev_priv(dev);
 	int ret;
 
-	vptr->rx_buf_sz = (dev->mtu <= 1504 ? PKT_BUF_SZ : dev->mtu + 32);
-
 	ret = velocity_init_rings(vptr);
 	if (ret < 0)
 		goto out;
@@ -1813,12 +1814,6 @@ static int velocity_change_mtu(struct net_device *dev, int new_mtu)
 		velocity_free_rd_ring(vptr);
 
 		dev->mtu = new_mtu;
-		if (new_mtu > 8192)
-			vptr->rx_buf_sz = 9 * 1024;
-		else if (new_mtu > 4096)
-			vptr->rx_buf_sz = 8192;
-		else
-			vptr->rx_buf_sz = 4 * 1024;
 
 		ret = velocity_init_rd_ring(vptr);
 		if (ret < 0)