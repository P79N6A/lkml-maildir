Date: Sat, 14 Jul 2007 16:39:24 -0400
From: Mathieu Desnoyers <>
Subject: Re: [PATCH -rt 2/5] Thread Migration Preemption - v2
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/7/14/168

* Peter Zijlstra (a.p.zijlstra@chello.nl) wrote:
> How about somethign like this?
> 
Interesting approach.. then the process in its migrate disable critical
section will wake us up when it ends, but we are still available for
other migrations.
I'll try to merge this with what I have.
> ---
> 
> Avoid busy looping on unmigratable tasks by pushing the migration requests
> onto a delayed_migration_queue, which we try on each wakeup.
> 
> Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
> ---
>  kernel/sched.c |   10 ++++++++--
>  1 file changed, 8 insertions(+), 2 deletions(-)
> 
> Index: linux-2.6/kernel/sched.c
> ===================================================================
> --- linux-2.6.orig/kernel/sched.c
> +++ linux-2.6/kernel/sched.c
> @@ -288,6 +288,7 @@ struct rq {
> 
>  	struct task_struct *migration_thread;
>  	struct list_head migration_queue;
> +	struct list_head delayed_migration_queue;
>  #endif
> 
>  #ifdef CONFIG_SCHEDSTATS
> @@ -5623,6 +5624,11 @@ static int migration_thread(void *data)
>  		head = &rq->migration_queue;
> 
>  		if (list_empty(head)) {
> +			/*
> +			 * we got a wakeup, give the delayed list another shot.
> +			 */
> +			if (current->state != TASK_INTERRUPTIBLE)
> +				list_splice(&rq->delayed_migration_queue, head);
>  			spin_unlock_irq(&rq->lock);
>  			schedule();
>  			set_current_state(TASK_INTERRUPTIBLE);
> @@ -5641,8 +5647,7 @@ static int migration_thread(void *data)
>  			 * wake us up.
>  			 */
>  			spin_lock_irq(&rq->lock);
> -			head = &rq->migration_queue;
> -			list_add(&req->list, head);
> +			list_add(&req->list, &rq->delayed_migration_queue);
>  			set_tsk_thread_flag(req->task, TIF_NEED_MIGRATE);
>  			spin_unlock_irq(&rq->lock);
>  			wake_up_process(req->task);
> @@ -7006,6 +7011,7 @@ void __init sched_init(void)
>  		rq->cpu = i;
>  		rq->migration_thread = NULL;
>  		INIT_LIST_HEAD(&rq->migration_queue);
> +		INIT_LIST_HEAD(&rq->delayed_migration_queue);
>  #endif
>  		atomic_set(&rq->nr_iowait, 0);
> 
> 
> 
-- 
Mathieu Desnoyers
Computer Engineering Ph.D. Student, Ecole Polytechnique de Montreal
OpenPGP key fingerprint: 8CD5 52C3 8E3C 4140 715F  BA06 3F25 A8FE 3BAE 9A68
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/