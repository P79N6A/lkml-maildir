Date: Tue, 15 Jan 2008 16:14:54 +0100
From: Peter Zijlstra <>
Subject: Re: [RFC/PATCH 4/8] revoke: core code V7
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/1/15/182

On Fri, 2007-12-14 at 17:16 +0200, Pekka J Enberg wrote:
> +static int revoke_files(struct inode *inode)
> +{
> +	struct super_block *sb;
> +	struct file *file;
> +	int err = 0;
> +
> +	sb = inode->i_sb;
> +	if (!sb)
> +		return -EINVAL;
> +
> +restart:
> +	file_list_lock();
> +	list_for_each_entry(file, &sb->s_files, f_u.fu_list) {
> +		struct dentry *dentry = file->f_path.dentry;
> +
> +		if (dentry->d_inode != inode)
> +			continue;
> +
> +		if (file->f_op != inode->i_fop)
> +			continue;
> +
> +		get_file(file);
> +
> +		/*
> +		 * inode->i_mutex cannot be acquired under files_lock
> +		 */
> +		file_list_unlock();
> +
> +		err = file->f_op->revoke(file);
> +		make_revoked_file(inode, file);
> +		fput(file);
> +
> +		if (err)
> +			goto out;
> +
> +		if (signal_pending(current)) {
> +			err = -EINTR;
> +			goto out;
> +		}
> +		cond_resched();
> +		goto restart;
> +	}
> +	file_list_unlock();
> +out:
> +	return err;
> +}
Humm, we were trying to get rid of file_list_lock(), this puts up
another user of the sb file list.
Also, that loop looks horribly expensive: n*(1+m); where n is the list
size, and m the number of matching fds.
Granted, I see no other options either.