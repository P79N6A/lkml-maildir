Date: Fri, 18 Jan 2008 09:38:51 -0600
From: "Chris Friesen" <>
Subject: Re: Why is the kfree() argument const?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/1/18/272

David Schwartz wrote:
> 2) The 'kfree' operation changes the logical state of the object pointed to,
> as the object goes from existent to non-existent.
I don't think that kfree() itself changes the state of the object.  It 
doesn't call a destructor or anything like that, so the object itself 
must be "inert" before the call to kfree().  That is, at the time of the 
kfree() call the system must have ensured that the object will no longer 
be used by anything.
The call to kfree() is simply bookkeeping--allowing that memory to be 
reused by other parts of the kernel.
> 3) It is most useful for 'kfree' to be non-const because destroying an
> object through a const pointer can easily be done in error. One of the
> reasons you provide a const pointer is because you need the function you
> pass the pointer to not to modify the object. Since this is an unusual
> operation that could be an error, it is logical to force the person doing it
> to clearly indicate that he knows the pointer is const and that he knows it
> is right anyway.
I have a certain amount of sympathy for this view...it's a fairly 
painless way to reduce the likelihood of errors.  At the same time, I 
don't think I've ever run into this problem myself--is it really all 
that common?
Chris