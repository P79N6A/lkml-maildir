Date: Mon, 03 Dec 2007 14:33:06 -0500
From: Jeff Moyer <>
Subject: Re: [2.6.24 BUG] 100% iowait on host while UML is running
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/12/3/192

Zach Brown <zach.brown@oracle.com> writes:
>> We could check ctx->reqs_active before scheduling to determine whether
>> or not we are waiting for I/O, but this would require taking the
>> context lock in order to be accurate.  Given that the test would be
>> only for the sake of book keeping, it might be okay to do it outside
>> of the lock.
>> 
>> Zach, what are your thoughts on this?
>
> I agree that it'd be OK to test it outside the lock, though we'll want
> some commentary:
>
> 	/* Try to only show up in io wait if there are ops in flight */
> 	if (ctx->reqs_active)
> 		io_schedule();
> 	else
> 		schedule();
>
> It's cheap, safe, and accurate the overwhelming majority of the time :).
>
> We only need it in read_events().  The other two io_schedule() calls are
> only reached to wait on pending reqs specifically.
>
> It still won't make sense for iocbs which aren't performing IO, but I
> guess that's one more bridge to cross when we come to it.
>
> Do you want to throw this tiny patch together and submit it?
Sure.  I tested this on a system that I used to reproduce the problem,
and it shows I/O Wait back at normal levels on an idle system with 1
uml guest running.
Andrew, do you need a separate email with a [patch] heading or will
this do?
Cheers,
Jeff
Only account I/O wait time in read_events if there are active
requests.
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
diff --git a/fs/aio.c b/fs/aio.c
index f12db41..9dec7d2 100644
--- a/fs/aio.c
+++ b/fs/aio.c
@@ -1161,7 +1161,12 @@ retry:
 			ret = 0;
 			if (to.timed_out)	/* Only check after read evt */
 				break;
-			io_schedule();
+			/* Try to only show up in io wait if there are ops
+			 *  in flight */
+			if (ctx->reqs_active)
+				io_schedule();
+			else
+				schedule();
 			if (signal_pending(tsk)) {
 				ret = -EINTR;
 				break;