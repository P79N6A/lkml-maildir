Date: Fri, 24 Mar 2000 12:09:02 -0800
From: Dragan Stancevic <>
Subject: [PATCH] eepro100.c
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/3/24/114

This patch is against linux-2.2.15-pre15.
It prevent's the eepro100 card from locking up the system when the card
triggers FCP, Currently it just disables it, I am working on FC and ER
support right now so FCP will be handled properly....
-- 
                                                -Dragan
--- linux-2.2.15-pre15/drivers/net/eepro100.orig.c	Thu Mar 23 20:06:58 2000
+++ linux-2.2.15-pre15/drivers/net/eepro100.c	Fri Mar 24 12:04:31 2000
@@ -24,6 +24,9 @@
 	The driver also contains updates by different kernel developers.
 	This driver clone is maintained by Andrey V. Savochkin <saw@saw.sw.com.sg>.
 	Please use this email address and linux-kernel mailing list for bug reports.
+	
+	Disabled FC and ER, to avoid lockups when when we get FCP interrupts.
+	Dragan Stancevic <visitor@valinux.com> March 24th, 2000.
 */
 
 static const char *version =
@@ -506,7 +509,7 @@ const char i82557_config_cmd[22] = {
 const char i82558_config_cmd[22] = {
 	22, 0x08, 0, 1,  0, 0, 0x22, 0x03,  1, /* 1=Use MII  0=Use AUI */
 	0, 0x2E, 0,  0x60, 0x08, 0x88,
-	0x68, 0, 0x40, 0xf2, 0xBD, 		/* 0xBD->0xFD=Force full-duplex */
+	0x68, 0, 0x40, 0xf2, 0x84, 		/* Disable FC*/
 	0x31, 0x05, };
 
 /* PHY media interface chips. */
@@ -1090,7 +1093,11 @@ static void speedo_resume(struct net_dev
 	wait_for_cmd_done(ioaddr + SCBCmd);
 	outl(virt_to_bus(&sp->tx_ring[sp->dirty_tx % TX_RING_SIZE]),
 		 ioaddr + SCBPointer);
-	outw(CUStart, ioaddr + SCBCmd);
+
+	/*We are not ACK-ing FCP and ER in the interrupt handler yet so they should
+	 remain masked --Dragan*/
+	outw(CUStart | SCBMaskEarlyRx | SCBMaskFlowCtl, ioaddr + SCBCmd);
+
 }
 
 /* Media monitoring and control. */
@@ -1107,10 +1114,15 @@ static void speedo_timer(unsigned long d
 		if (partner != sp->partner) {
 			int flow_ctrl = sp->advertising & partner & 0x0400 ? 1 : 0;
 			if (speedo_debug > 2)
-				printk(KERN_DEBUG "%s: Link status change.\n", dev->name);
+				/*sp->partner always 0? --Dragan*/
+				printk(KERN_DEBUG "%s: TIMER Link stat chng, CARD[0x%4.4x],"
+						" P_OLD[0x%4.4x], P_NEW[0x%4.4x].\n", dev->name,
+					   	sp->advertising, sp->partner, partner);
 			sp->partner = partner;
 			if (flow_ctrl != sp->flow_ctrl) {
 				sp->flow_ctrl = flow_ctrl;
+				printk(KERN_DEBUG "%s: TIMER Flow control CHANGED [0x%x].\n",
+					   	dev->name, sp->flow_ctrl);
 				sp->rx_mode = -1;	/* Trigger a reload. */
 			}
 			/* Clear sticky bit. */
@@ -1487,6 +1499,8 @@ static void speedo_interrupt(int irq, vo
 	do {
 		status = inw(ioaddr + SCBStatus);
 		/* Acknowledge all of the current interrupt sources ASAP. */
+		/*Will change from 0xfc00 to 0xff00 when we start handling
+		 FCP and ER interrupts --Dragan*/
 		outw(status & 0xfc00, ioaddr + SCBStatus);
 
 		if (speedo_debug > 4)
@@ -1586,6 +1600,8 @@ static void speedo_interrupt(int irq, vo
 			printk(KERN_ERR "%s: Too much work at interrupt, status=0x%4.4x.\n",
 				   dev->name, status);
 			/* Clear all interrupt sources. */
+			/*Will change from 0xfc00 to 0xff00 when we start handling
+			 FCP and ER interrupts --Dragan*/
 			outl(0xfc00, ioaddr + SCBStatus);
 			break;
 		}
@@ -1987,7 +2003,14 @@ static void set_rx_mode(struct net_devic
 		config_cmd_data[4] = rxdmacount;
 		config_cmd_data[5] = txdmacount + 0x80;
 		config_cmd_data[15] |= (new_rx_mode & 2) ? 1 : 0;
-		config_cmd_data[19] = sp->flow_ctrl ? 0xBD : 0x80;
+		/*
+		config_cmd_data[19] = sp->flow_ctrl ? 0xBD : 0x84;
+		0x80 doesn't disable FC 0x84 does.
+		Disable Flow control since we are not ACK-ing any FC interrupts
+	   	for now. --Dragan */
+		config_cmd_data[19] = 0x84;
+		/*printk("<1>" "Setting card flow control REG_19 [0x%x].\n",
+		  config_cmd_data[19] );*/
 		config_cmd_data[19] |= sp->full_duplex ? 0x40 : 0;
 		config_cmd_data[21] = (new_rx_mode & 1) ? 0x0D : 0x05;
 		if (sp->phy[0] & 0x8000) {			/* Use the AUI port instead. */