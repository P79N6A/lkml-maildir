Date: Fri, 19 Nov 2004 11:08:30 -0600
From: "K.R. Foley" <>
Subject: Re: [patch] Real-Time Preemption, -RT-2.6.10-rc2-mm2-V0.7.29-0
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2004/11/19/147

Steven Rostedt wrote:
> I'm getting a bug print (really a warning) from enable_irq spawned from
> the e100 driver. The reason is that enable_irq is being called because
> the irq depth is zero.
> 
> Looking into this, it is because the e100 uses a shared interrupt.  On
> setup (see drivers/net/e100.c: e100_up) it disables the irq that it will
> use, and then calls request_irq which calls setup_irq which zeros out
> the depth of the irq if it is not shared.  So if the e100 is the first
> to be loaded, then you get this message. 
> 
> I know that for now this doesn't hurt anything, but besides annoying me
> in my print outs (I can't stop panicking when I see it ;-),  is this
> really a bug and thus a design flaw of the e100? How else can a shared
> irq initialize without turning off the irq before setting itself up?
> 
> Should it enable the irq before it requests it, and thus open the race
> of a spurious interrupt, or just disable all interrupts?
> 
> Thanks,
> 
Actually I think it shouldn't call either enable or disable because it 
is shared (or allowed to be shared). After creating a patch myself to 
fix this I realized that it had already been fixed in the newest version 
of the driver on sourceforge. Anyway if you are interested in this fix 
temporarily, here it is.
kr
--- linux-2.6.10-rc1-mm3.cln/drivers/net/e100.c.orig	2004-11-15 21:09:24.846227425 -0600
+++ linux-2.6.10-rc1-mm3.cln/drivers/net/e100.c	2004-11-15 21:10:10.870474989 -0600
@@ -1680,8 +1680,6 @@
 	if((err = e100_rx_alloc_list(nic)))
 		return err;
 
-	disable_irq(nic->pdev->irq);
-
 	if((err = e100_alloc_cbs(nic)))
 		goto err_rx_clean_list;
 	if((err = e100_hw_init(nic)))
@@ -1693,7 +1691,6 @@
 		nic->netdev->name, nic->netdev)))
 		goto err_no_irq;
 	e100_enable_irq(nic);
-	enable_irq(nic->pdev->irq);
 	netif_wake_queue(nic->netdev);
 	return 0;
 
@@ -1704,7 +1701,6 @@
 err_rx_clean_list:
 	e100_rx_clean_list(nic);
 
-	enable_irq(nic->pdev->irq);
 	return err;
 }
 