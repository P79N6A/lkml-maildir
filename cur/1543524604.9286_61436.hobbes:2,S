Date: Fri, 04 Feb 2000 15:39:14 +0100
From: Manfred Spraul <>
Subject: Re: 2.2.15pre5: still very unstable
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/2/4/49

Andrea Arcangeli wrote:
> 
> On Fri, 4 Feb 2000, Manfred Spraul wrote:
> 
> >* callers that assume that TASK_{,UN}INTERRUPTIBLE remains effective
> >across these calls. We must fix them, and as far as I understood
> >Andrea's post, he agrees:
> 
> I definitly agree ;).
> 
> >* __pollwait(). IMHO a real bug.
> 
> At first sight I couldn't see any problem there. Please elaborate.
> 
I tried to elaborate, but then I noticed that do_poll() won't hang, it
will just poll all files again although no new data has arrived. We
_could_ ignore that [because the current code is slightly faster than my
patch if one of the first 100 files has new data], but IMO we should
change __pollwait().
sys_poll():
* allocates one page for the poll table, that's enough for ~ 120 files
[2.3, wait queue debugging enabled].
* allocates memory for all file numbers, and copies them to kernel space
* calls do_poll()
do_poll():
* set_current_state(TASK_INTERRUPTIBLE)
* calls "f_ops->poll()" for all files
* returns if at least one file has new data.
* schedule().
* and repeat.
f_ops->poll():
* registers a wake-up wait queue by calling poll_wait().
poll_wait() calls __pollwait() if the wake-up is required [it's
superflous if poll() won't sleep]
__pollwait() allocates more memory if the first page of the poll table
is full.
--> __pollwait() can reset ->state to TASK_RUNNING.
--> schedule() in do_poll() will return immediately
--> do_poll() will check all files again although no new data is
available.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/