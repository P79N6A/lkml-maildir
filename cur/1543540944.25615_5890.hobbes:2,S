Date: Mon, 7 Aug 2000 14:22:54 +0100 (BST)
From: Mark Hemment <>
Subject: [PATCH] signal_struct slab cache
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/8/7/45

Linus, all,
  The per-task signal handling structure (signal_struct) is a "bad" size
for the general sized slab caches; on IA32, it is 1312bytes which means it
comes from the 2048 byte cache - giving only 2 structures from each 
page.  It is probably a bad size for many other architectures.
  By creating a specific slab cache for the signal_struct gives 3
structures per page, saving memory.  Also, by using a specific cache,
allocation and release of the structures is slightly fast.
  Please find a patch (against 2.4.0-test5) attached.
Mark
diff -ur -X ignore --new-file linux-2.4.0-test5/kernel/exit.c mem-2.4.0-test5/kernel/exit.c
--- linux-2.4.0-test5/kernel/exit.c	Fri Jul 28 00:47:16 2000
+++ mem-2.4.0-test5/kernel/exit.c	Mon Aug  7 14:06:27 2000
@@ -20,6 +20,8 @@
 extern void sem_exit (void);
 extern struct task_struct *child_reaper;
 
+extern kmem_cache_t	*sigact_cachep;
+
 int getrusage(struct task_struct *, int, struct rusage *);
 
 static void release(struct task_struct * p)
@@ -260,7 +262,7 @@
 		tsk->sig = NULL;
 		spin_unlock_irq(&tsk->sigmask_lock);
 		if (atomic_dec_and_test(&sig->count))
-			kfree(sig);
+			kmem_cache_free(sigact_cachep, sig);
 	}
 
 	flush_signals(tsk);
diff -ur -X ignore --new-file linux-2.4.0-test5/kernel/fork.c mem-2.4.0-test5/kernel/fork.c
--- linux-2.4.0-test5/kernel/fork.c	Fri Jul 28 00:47:16 2000
+++ mem-2.4.0-test5/kernel/fork.c	Mon Aug  7 14:05:19 2000
@@ -35,6 +35,9 @@
 /* SLAB cache for mm_struct's. */
 kmem_cache_t *mm_cachep;
 
+/* SLAB cache for signal_structs. */
+kmem_cache_t	*sigact_cachep;
+
 struct task_struct *pidhash[PIDHASH_SZ];
 
 /* UID task count cache, to prevent walking entire process list every
@@ -193,6 +196,12 @@
 	if(!uid_cachep)
 		panic("Cannot create uid taskcount SLAB cache\n");
 
+	sigact_cachep = kmem_cache_create("signal_act",
+					  sizeof(struct signal_struct),
+					  0, SLAB_HWCACHE_ALIGN, NULL, NULL);
+	if (!sigact_cachep)
+		panic("Cannot create signal action SLAB cache\n");
+
 	for(i = 0; i < UIDHASH_SZ; i++)
 		uidhash[i] = 0;
 
@@ -614,7 +623,7 @@
 		atomic_inc(&current->sig->count);
 		return 0;
 	}
-	tsk->sig = kmalloc(sizeof(*tsk->sig), GFP_KERNEL);
+	tsk->sig = kmem_cache_alloc(sigact_cachep, GFP_KERNEL);
 	if (!tsk->sig)
 		return -1;
 	spin_lock_init(&tsk->sig->siglock);