Date: Tue, 13 May 2003 15:21:26 +0400
From: Ivan Kokshaysky <>
Subject: Re: Message Signalled Interrupt support?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2003/5/13/82

On Mon, May 12, 2003 at 11:48:51AM -0700, Matt Porter wrote:
> request_msi() needs an additional parameter to specify which MSI
> it is hooking.  A device can implement many messages in order to
> clarify which one of many events on a device has occurred.  It
> may be desired to hook a separate handler for each of those to
> avoid another read of a status register.
Assuming that platform specific PCI setup does reasonable real to virtual
IRQ mapping, request_msi() is not needed. We can use pdev->irq
as "base" vector and MSI message number as offset. Alpha works this
way, BTW.
I think of something like this:
/**
 * pci_using_msi - is this PCI device configured to use MSI?
 * @dev: PCI device structure of device being queried
 *
 * Tells whether or not a PCI device is configured to use Message Signaled
 * Interrupts. Returns number of allocated MSI messages, else 0.
 */
int
pci_using_msi(struct pci_dev *dev)
{
	int msi = pci_find_capability(dev, PCI_CAP_ID_MSI);
	u8 msgctl;
	if (!msi || !dev->irq)
		return 0;
	pci_read_config_byte(dev, msi + PCI_MSI_FLAGS, &msgctl);
	if (!(msgctl & PCI_MSI_FLAGS_ENABLE))
		return 0;
	
	return 1 << ((msgctl >> 4) & 7); /* # of messages allocated */
}
So that MSI-aware driver can do
	nummsgs = pci_using_msi(dev);
	if (!nummsgs)
		goto no_msi;
	for (msg = 0; msg < nummsgs; msg++) {
		...
		request_irq(dev->irq + msg, ...);
	}
Ivan.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/