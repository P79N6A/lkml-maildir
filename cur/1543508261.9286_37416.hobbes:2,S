Date: Sun, 5 Sep 1999 02:36:48 -0700 (PDT)
From: Robert Dinse <>
Subject: Sparc SRMMU code question:
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/9/5/17

     I have a question about the following code segment in the file:
	arch/sparc/mm/srmmu.c
     The code segment in question:
static inline pte_t *srmmu_get_pte_slow(void)
{
        pte_t *ret;
        struct page *page;
        
        ret = (pte_t *)get_free_page(GFP_KERNEL);
        if (ret) {
                page = mem_map + MAP_NR(ret);
                flush_chunk((unsigned long)ret);
                (unsigned int)page->pprev_hash = 0xfffe;
                spin_lock(&pte_spinlock);
                (unsigned long *)page->next_hash = pte_quicklist;
                pte_quicklist = (unsigned long *)page;
                pgtable_cache_size += 15;
        }
        return ret;
}
     In the conditional code after "if (ret)", there is a spin_lock.  This
spin_lock() would only be executed if (ret) is true.  I don't see any
corrosponding spin_unlock().
     If (ret) is true, wouldn't it leave this locked forever?
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/