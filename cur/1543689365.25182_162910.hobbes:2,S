Date: 03 Sep 2003 21:29:59 -0700
From: john stultz <>
Subject: [PATCH] linux-2.6.0-test4_cyclone-hpet-fix_A0
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2003/9/4/7

Andrew, All,
	I probably should have been more active in reviewing the HPET code
before it went in, but I've been somewhat occupied with other bugs
recently. I'm excited to see someone else using my time-source
interface, however the HPET patch definitely pushes the interface beyond
its design (not a bad thing, just makes for some short term uglies).
Having multiple interrupt sources as well as time sources will generate
some work for 2.7 to clean it all up.
Anyway, the HPET changes made calibrate_tsc() static, which it probably
should be, but it broke the timer_cyclone code. This patch fixes it back
up by re-implementing calibrate_tsc() locally as it was done in
timer_hpet.c 
Please apply.
thanks
-john
Also, while apparently unrelated, but touching code from the HPET patch,
I'm seeing some form of memory corruption on the 16way x440 which is
overwriting the wait_timer_tick pointer in apic.c I added some
initialized corruption pad variables around the pointer and they're
definitely being trampled. I'll have to look into it further tomorrow.
diff -Nru a/arch/i386/kernel/timers/timer_cyclone.c b/arch/i386/kernel/timers/timer_cyclone.c
--- a/arch/i386/kernel/timers/timer_cyclone.c	Wed Sep  3 21:07:47 2003
+++ b/arch/i386/kernel/timers/timer_cyclone.c	Wed Sep  3 21:07:47 2003
@@ -18,8 +18,9 @@
 #include <asm/pgtable.h>
 #include <asm/fixmap.h>
 
+#include "mach_timer.h"
+
 extern spinlock_t i8253_lock;
-extern unsigned long calibrate_tsc(void);
 
 /* Number of usecs that the last interrupt was delayed */
 static int delay_at_last_interrupt;
@@ -132,6 +133,66 @@
 	/* convert to nanoseconds */
 	ret = base + ((this_offset - last_offset)&CYCLONE_TIMER_MASK);
 	return ret * (1000000000 / CYCLONE_TIMER_FREQ);
+}
+
+/* ------ Calibrate the TSC ------- 
+ * Return 2^32 * (1 / (TSC clocks per usec)) for do_fast_gettimeoffset().
+ * Too much 64-bit arithmetic here to do this cleanly in C, and for
+ * accuracy's sake we want to keep the overhead on the CTC speaker (channel 2)
+ * output busy loop as low as possible. We avoid reading the CTC registers
+ * directly because of the awkward 8-bit access mechanism of the 82C54
+ * device.
+ */
+
+#define CALIBRATE_TIME	(5 * 1000020/HZ)
+
+static unsigned long __init calibrate_tsc(void)
+{
+	mach_prepare_counter();
+
+	{
+		unsigned long startlow, starthigh;
+		unsigned long endlow, endhigh;
+		unsigned long count;
+
+		rdtsc(startlow,starthigh);
+		mach_countup(&count);
+		rdtsc(endlow,endhigh);
+
+
+		/* Error: ECTCNEVERSET */
+		if (count <= 1)
+			goto bad_ctc;
+
+		/* 64-bit subtract - gcc just messes up with long longs */
+		__asm__("subl %2,%0\n\t"
+			"sbbl %3,%1"
+			:"=a" (endlow), "=d" (endhigh)
+			:"g" (startlow), "g" (starthigh),
+			 "0" (endlow), "1" (endhigh));
+
+		/* Error: ECPUTOOFAST */
+		if (endhigh)
+			goto bad_ctc;
+
+		/* Error: ECPUTOOSLOW */
+		if (endlow <= CALIBRATE_TIME)
+			goto bad_ctc;
+
+		__asm__("divl %2"
+			:"=a" (endlow), "=d" (endhigh)
+			:"r" (endlow), "0" (0), "1" (CALIBRATE_TIME));
+
+		return endlow;
+	}
+
+	/*
+	 * The CTC wasn't reliable: we got a hit on the very first read,
+	 * or the CPU was so fast/slow that the quotient wouldn't fit in
+	 * 32 bits..
+	 */
+bad_ctc:
+	return 0;
 }
 
 static int __init init_cyclone(char* override)
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/