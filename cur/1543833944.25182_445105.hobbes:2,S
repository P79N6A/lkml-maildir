Date: Tue, 18 Jul 2006 11:09:56 +0200
From: Arjan van de Ven <>
Subject: Re: How to explain to lock validator: locking inodes in inode order
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/7/18/12

Hi,
> Yes. It never takes a lock on any higher inode without holding the lock on a
> lower inode first. I have a full proof across the VFS+FS [see below].
ok just checking. The reason this is important is that once you tell
lockdep this is a special situation, it better be that, since you're
losing any checking for the "but what if not" case. 
> 
> >
> > all places in the kernel that take this mutex in that order only do it
> > in i_ino order, including all directory operations like cross directory
> > rename?
> 
> I had to disable the kernel's locking of multiple objects in namei.c using a
> new FS_ flag because it would actually deadlock for this filesystem.
ok fun ;) It might be interesting to talk to Al Viro about this at some
point, maybe there is something interesting in your locking that could
improve the linux VFS locking scheme
To annotate for lockdep,  you probably can use the same constants as we
used for inodes (after all you're sort of doing the same anyway); so
your code can be made to look roughly like this: 
if ( < ) {
   mutex_lock_nested( ..... , I_MUTEX_PARENT);
   mutex_lock_nested( ..... , I_MUTEX_CHILD);
} else {
   mutex_lock_nested( ..... , I_MUTEX_PARENT);
   mutex_lock_nested( ..... , I_MUTEX_CHILD);
}
this means that you tell that the first mutex taken is the parent in a
parent-child relationship which is hierarchical for "external" reasons
(in this case your sorting).
Greetings,
    Arjan van de Ven
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/