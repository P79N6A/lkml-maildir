Date: Fri, 13 Jul 2007 16:21:30 +0300
From: "Pekka Enberg" <>
Subject: Re: [PATCH] replace kmem_cache_alloc with kmem_cache_zalloc to remove some following zero initializations.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/7/13/194

Hi Kirill,
On 7/13/07, Kirill Korotaev <dev@sw.ru> wrote:
> Look, until you have any numbers in hands it's impossible to say
> which one is faster.
Well, it's not too hard to guess: struct dentry is 124 bytes on i386
so kmem_cache_zalloc over it is bound to be slower tha
kmem_cache_alloc as most members are initialized to non-NULL. And if
you're into micro-benchmarks, here's one:
d_alloc takes 182.75ns
d_alloc_zalloc takes 315.89ns
So definitely NAK for Denis' patch.
                                               Pekka
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <string.h>
#include <time.h>
struct dentry {
	void *a;
	void *b;
	void *c;
	void *d;
	void *e;
	void *f;
	void *g;
	void *h;
	unsigned char d_iname[36];
};
#define NR_ITERS 1000000
#define MAX_DENTRIES (NR_ITERS*2)
static unsigned long offset;
static struct dentry dentries[MAX_DENTRIES];
static inline void *__kmalloc(void)
{
	void *p = &dentries[offset++];
	if (offset == MAX_DENTRIES)
		offset = 0;
	return p;
}
void *kmalloc(size_t sz)
{
	return __kmalloc();
}
struct dentry *d_alloc(const char *name)
{
	struct dentry *ret = kmalloc(sizeof *ret);
	if (ret) {
		ret->a = NULL;
		ret->b = NULL;
		ret->c = NULL;
		ret->d = NULL;
		ret->e = (void *) 0xdeadbeef;
		ret->f = (void *) 0xdeadbeef;
		ret->g = (void *) 0xdeadbeef;
		ret->h = (void *) 0xdeadbeef;
		strcpy(ret->d_iname, name);
	}
	return ret;
}
static inline void * __memset_generic(void * s, char c,size_t count)
{
	int d0, d1;
	__asm__ __volatile__(
	        "rep\n\t"
	        "stosb"
	        : "=&c" (d0), "=&D" (d1)
	        :"a" (c),"1" (s),"0" (count)
	        :"memory");
	return s;
}
void *kzalloc(size_t sz)
{
	void *p = __kmalloc();
	if (p)
		__memset_generic(p, 0, sz);
	return p;
}
struct dentry *d_alloc_zalloc(const char *name)
{
	struct dentry *ret = kzalloc(sizeof *ret);
	if (ret) {
		ret->e = (void *) 0xdeadbeef;
		ret->f = (void *) 0xdeadbeef;
		ret->g = (void *) 0xdeadbeef;
		ret->h = (void *) 0xdeadbeef;
		strcpy(ret->d_iname, name);
	}
	return ret;
}
int main(int argc, char *argv[])
{
	struct timeval start, end;
	unsigned long long usec;
	int i;
	gettimeofday(&start, NULL);
	for (i = 0; i < NR_ITERS; i++) {
		struct dentry *dentry = d_alloc("root");
		if (!dentry || dentry->a != NULL)
			abort();
	}
	gettimeofday(&end, NULL);
	usec = end.tv_usec + 1000000*(end.tv_sec - start.tv_sec) - start.tv_usec;
	printf("d_alloc takes %0.2lfns\n", (double)usec * 1000 / NR_ITERS);
	gettimeofday(&start, NULL);
	for (i = 0; i < NR_ITERS; i++) {
		struct dentry *dentry = d_alloc_zalloc("root");
		if (!dentry || dentry->a != NULL)
			abort();
	}
	gettimeofday(&end, NULL);
	usec = end.tv_usec + 1000000*(end.tv_sec - start.tv_sec) - start.tv_usec;
	printf("d_alloc_zalloc takes %0.2lfns\n", (double)usec * 1000 / NR_ITERS);
	return 0;
}
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/