Date: Wed, 08 Mar 2006 20:16:11 +0000
From: David Howells <>
Subject: Re: [PATCH] Document Linux's memory barriers
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/3/8/231

Pavel Machek <pavel@ucw.cz> wrote:
> > + (*) set_mb(var, value)
> > + (*) set_wmb(var, value)
> > +
> > +     These assign the value to the variable and then insert at least a write
> > +     barrier after it, depending on the function.
> > +
> 
> I... don't understand what these do. Better explanation would
> help.. .what is function?
I can only guess, and hope someone corrects me if I'm wrong.
> Does it try to say that set_mb(var, value) is equivalent to var =
> value; mb();
Yes.
> but here mb() affects that one variable, only?
No. set_*mb() is simply a canned sequence of assignment, memory barrier.
The type of barrier inserted depends on which function you choose. set_mb()
inserts an mb() and set_wmb() inserts a wmb().
> "LOCK access"?
The LOCK and UNLOCK functions presumably make at least one memory write apiece
to manipulate the target lock (on SMP at least).
> Does it try to say that ...will be completed after any access inside lock
> region is completed?
No. What you get in effect is something like:
	LOCK { *lock = q; }
	*A = a;
	*B = b;
	UNLOCK { *lock = u; }
Except that the accesses to the lock memory are made using special procedures
(LOCK prefixed instructions, XCHG, CAS/CMPXCHG, LL/SC, etc).
> This makes it sound like pentium-III+ is incompatible with previous
> CPUs. Is it really the case?
Yes - hence the alternative instruction stuff.
David
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/