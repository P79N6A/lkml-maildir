Date: Wed, 2 Jun 2004 11:55:47 +0300 (EEST)
From:  dahood@post ...
Subject: Locking pages in memory
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2004/6/2/33

Hi,
I'm trying to lock some pages from a mmaped user memory (say user_addr). (mmap on a file)
For this I did the following (in a kernel module):
1. with get_user I fault every page into the memory, then I get the physical address of each page.
2. I put PG_reserved and do a get_page on each page.
3. After I finish using the memory, I truncate the file used for mmap to 0, and close the file descriptor(this is done in user space).
4. In kernel space, I do set_page_count to 1, for every page, clear PG_reserved, and do put_page.
My problem is that in kernel 2.4, this works perfectly, while in 2.6, when I do put_page, I get an bad state on page, because page_mapped is not 0 (page->pte.direct != 0), which means that the page in take into account into rmap. But because the page is PG_reserved, I think it shoudn't be.
Is there is something more that I should do in kernel 2.6 if I'm using reserved pages, more than in 2.4?  
In kernel 2.4, I know that is my responsability to set the page count to 1, when I'm sure that there is no one else using the pages, and put_page to kernel. 
I tried a workaround in 2.6, by setting page->pte.direct=0, before doing the final put_page. In this way, the put_page function is happy, but when I try do large allocation in user space program, I keep getting segmentation fault, so I think that the pte.direct hack is not ok.
Thank you,
Dan
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/