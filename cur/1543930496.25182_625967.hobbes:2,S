Date: Sun, 9 Dec 2007 18:16:52 +0100
From: "Dmitry Adamushko" <>
Subject: RT Load balance changes in sched-devel
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/12/9/94

[ cc'ed lkml ]
I guess, one possible load-balancing point is out of consideration --
sched_setscheduler()
(also rt_mutex_setprio()).
(1)  NORMAL --> RT, when p->se.on_rq == 1 && ! task_running(rq, p)
(2) RT --> NORMAL, when task_running(rq, p) == 1
e.g. for (2) we may even get a completely idle rq (schedule() -->
schedule_balance_rt() will not help due to schedule_balance_rt()
having a rt_task(prev) check in place... and 'prev' is of NORMAL type
when it's scheduled out).
btw., both cases would be addressed by placing load-balance points
into sched_class_rt->{enqueue,dequeue}_task_rt()... push_rt_tasks()
and pull_rt_tasks() respectively. As a side effect (I think,
technically, it would be possible), 3 out of 4 *_balance_rt() calls
(the exception: schedule_tail_balance_rt()) in schedule() would become
unnecessary.
_BUT_
the enqueue/dequeue() interface would become less straightforward,
logically-wise.
Something like:
rq = activate_task(rq, ...) ; /* may unlock rq and lock/return another one */
would complicate the existing use cases.
-- 
Best regards,
Dmitry Adamushko