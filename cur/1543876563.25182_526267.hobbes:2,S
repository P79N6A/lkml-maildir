Date: Mon, 2 Apr 2007 16:33:54 +0200
From: Eric Dumazet <>
Subject: Re: CPU ordering with respect to krefs
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/4/2/199

On Mon, 2 Apr 2007 14:47:59 +0200
Oliver Neukum <oneukum@suse.de> wrote:
> Hi,
> 
> some atomic operations are only atomic, not ordered. Thus a CPU is allowed
> to reorder memory references to an object to before the reference is
> obtained. This fixes it.
> 
> 	Regards
> 		Oliver
> Signed-off-by: Oliver Neukum <oneukum@suse.de>
> ------
> 
> --- a/lib/kref.c	2007-04-02 14:40:40.000000000 +0200
> +++ b/lib/kref.c	2007-04-02 14:40:50.000000000 +0200
> @@ -21,6 +21,7 @@
>  void kref_init(struct kref *kref)
>  {
>  	atomic_set(&kref->refcount,1);
> +	smp_mb();
>  }
I dont understand why smp_mb() is needed here, and not in spinlock_init() for example.
If you have ordering issues, then the caller of kref_init() should take care of it, not kref_init() itself.
Random example taken in drivers/usb/gadget/file_storage.c :
static int __init fsg_alloc(void)
{
...
kref_init(&fsg->ref);
init_completion(&fsg->thread_notifier);
the_fsg = fsg;
}
In this example, "the_fsg = fsg" memory write might be visible before the memory writes done in init_completion().
Doing a smp_mb() in kref_init() wont help.
AFAIK kref implementation doesnt need this extra smp_mb().
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/