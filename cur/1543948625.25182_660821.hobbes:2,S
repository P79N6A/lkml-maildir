Date: Wed, 27 Feb 2008 18:43:39 -0800 (PST)
From: Christoph Lameter <>
Subject: Re: Linux 2.6.25-rc2
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/2/27/527

On Wed, 27 Feb 2008, Andrew Morton wrote:
> Doing ++ on a u32 _is_ atomic wrt interrupts on x86 and probably lots of
> other architectures, so we're OK using unsigned there.  But on some other
> architectures ++ on u32 is not atomic wrt interrutps, so they should use
> atomic_t or some other arch-specific mechanism.
> 
> And guess what?  It's already all been done: local_t.
local_t requires the disabling of preempt to work right.
The real solution here is cpu_alloc / cpu_ops. Per cpu operations work on 
an offset relative to the start of the per process cpu data area in some 
register. An increment can then be atomic vs. interrupt because it does 
the calculation of the address and the inc in one instruction. F.e.
gs: inc [percpu_offset]
Processor may change before and after without ill effects. So no preempt 
since the instruction will always reference the %%gs register that points 
to the percpu area of the currently executing processor.