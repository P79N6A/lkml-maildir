Date: Thu, 11 Dec 2008 09:25:31 +0900
From: KAMEZAWA Hiroyuki <>
Subject: Re: [RFC][PATCH 1/6] memcg: fix pre_destory handler
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/12/10/393

On Wed, 10 Dec 2008 10:35:34 -0800
Paul Menage <menage@google.com> wrote:
> On Wed, Dec 10, 2008 at 3:29 AM, KAMEZAWA Hiroyuki
> <kamezawa.hiroyu@jp.fujitsu.com> wrote:
> >
> > (BTW, I don't like hierarchy-walk-by-small-locks approarch now because
> >  I'd like to implement scan-and-stop-continue routine.
> >  See how readdir() aginst /proc scans PID. It's very roboust against
> >  very temporal PIDs.)
> 
> So you mean that you want to be able to sleep, and then contine
> approximately where you left off, without keeping any kind of
> reference count on the last cgroup that you touched? OK, so in that
> case I agree that you would need some kind of hierarch
> 
> > I tried similar patch and made it to use only one shared refcnt.
> > (my previous patch...)
> 
> A crucial difference is that your css_tryget() fails if the cgroups
> framework is trying to remove the cgroup but might abort due to
> another subsystem holding a reference, whereas mine spins and if the
> rmdir is aborted it will return a refcount.
> 
sure.
> >
> > We need rolling update of refcnts and rollback. Such code tends to make
> > a hole (This was what my first patch did...).
> 
> Can you clarify what you mean by "rolling update of refcnts"?
> 
 for(..i++)
	atomic_dec/inc( refcnt[i)
But my first version of this patch did above. I can write it again easily.
Thanks,
-Kame