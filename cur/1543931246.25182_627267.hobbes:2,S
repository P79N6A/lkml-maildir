Date: Wed, 12 Dec 2007 14:36:27 -0800 (PST)
From: Roland McGrath <>
Subject: Re: [PATCH] arch_ptrace_stop
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/12/12/424

> Mutter.  These would be better as static inlines.  A macro just invites
> variable-unused warnings on non-ia64 and outright compilation errors on
> ia64.  Speaking from experience...
> 
> static inline void arch_ptrace_stop(int exit_code, siginfo_t *info)
> {
> }
> #define arch_ptrace_stop arch_ptrace_stop
> 
> should work?
That's fine with me.  I just followed the example of e.g. arch_ptrace_attach.
> >  /*
> > + * Return nonzero if there is a SIGKILL that should be waking us up.
> > + * Called with the siglock held.
> > + */
> > +static int sigkill_pending(struct task_struct *tsk)
> > +{
> > +	return ((sigismember(&tsk->pending.signal, SIGKILL) ||
> > +		 sigismember(&tsk->signal->shared_pending.signal, SIGKILL)) &&
> > +		!unlikely(sigismember(&tsk->blocked, SIGKILL)));
> > +}
> 
> Could you please take a peek at the infrastructure added by
> 
ftp://ftp.kernel.org/pub/linux/kernel/people/akpm/patches/2.6/2.6.24-rc4/2.6.24-rc4-mm1/broken-out/add-lock_page_killable.patch
> and see if there is exploitable commonality?
I haven't reviewed that whole set in detail yet.  So I'd rather leave this
for a later cleanup.  (This ptrace change alone, along with its ia64
pieces, can probably go in much earlier without disrupting anything else.)
The fatal_signal_pending function in that patch is not exactly the same as
this check, though it might turn out that it's actually equivalent due to
higher-level constraints.  
Thanks,
Roland