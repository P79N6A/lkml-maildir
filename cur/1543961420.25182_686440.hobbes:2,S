Date: Tue, 29 Apr 2008 18:28:32 +0530
From: Gautham R Shenoy <>
Subject: [PATCH 2/8] lockdep: reader-in-writer recursion
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/4/29/213

Subject: lockdep: reader-in-writer recursion
From: Peter Zijlstra <a.p.zijlstra@chello.nl>
Create a read mode that allows for reader-in-writer recursion
Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
Signed-off-by: Gautham R Shenoy <ego@in.ibm.com>
---
 include/linux/lockdep.h |    1 +
 kernel/lockdep.c        |    9 ++++++++-
 2 files changed, 9 insertions(+), 1 deletions(-)
diff --git a/include/linux/lockdep.h b/include/linux/lockdep.h
index 4c4d236..36e254f 100644
--- a/include/linux/lockdep.h
+++ b/include/linux/lockdep.h
@@ -291,6 +291,7 @@ extern void lockdep_init_map(struct lockdep_map *lock, const char *name,
  *   0: exclusive (write) acquire
  *   1: read-acquire (no recursion allowed)
  *   2: read-acquire with same-instance recursion allowed
+ *   3: 2 + reader in writer recursion
  *
  * Values for check:
  *
diff --git a/kernel/lockdep.c b/kernel/lockdep.c
index 94b0f4f..3859259 100644
--- a/kernel/lockdep.c
+++ b/kernel/lockdep.c
@@ -1280,6 +1280,13 @@ check_deadlock(struct task_struct *curr, struct held_lock *next,
 		 */
 		if ((read == 2) && prev->read)
 			return 2;
+		/*
+		 * Allow read-after-write recursion of the same
+		 * lock class (i.e. write_lock(lock)+read_lock(lock)):
+		 */
+		if (read == 3)
+			return 2;
+
 		return print_deadlock_bug(curr, prev, next);
 	}
 	return 1;
@@ -1559,7 +1566,7 @@ static int validate_chain(struct task_struct *curr, struct lockdep_map *lock,
 		 * If we are the first recursive read, don't jump over our
 		 * dependency.
 		 */
-		if (hlock->read == 2 && ret != 2)
+		if (hlock->read >= 2 && ret != 2)
 			hlock->read = 1;
 		/*
 		 * Add dependency only if this lock is not the head
-- 
Thanks and Regards
gautham