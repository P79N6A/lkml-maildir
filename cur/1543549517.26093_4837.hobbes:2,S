Date: Fri, 22 Sep 2000 03:11:22 -0500
From: Peter Samuelson <>
Subject: [PATCH] old+new RAID for 2.2.17+
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/9/22/145

Alan, would you consider the following for 2.2.19?  (It compiles but I
can't test functionality as I don't run md.)
Inspired by Matthew Kirkwood's patch to move RAID to drivers/md/, I've
merged this with RAID 0.90 and 2.2.17.  The idea here is not to disturb
the old RAID, so the two can coexist like tulip and oldtulip (except
here you can't build both at once since md.o isn't modular).
For brevity, I'm not including the RAID 0.90 files themselves:
  drivers/md/{md,linear,raid[015],xor}.c
  include/linux/raid/*.h
Get those from Ingo's patch, or get my full patch from
  
http://peter.cadcamlab.org/linux/raid90-2.2.17-a.diff.bz2
Ingo, Alan, everyone, how does it look?
Peter
diff -urNx*~ 2.2.17/Documentation/Configure.help 2.2.17+raid90/Documentation/Configure.help
--- 2.2.17/Documentation/Configure.help	Wed Sep 20 01:45:01 2000
+++ 2.2.17+raid90/Documentation/Configure.help	Wed Sep 20 06:35:53 2000
@@ -961,6 +961,25 @@
 
   If unsure, say N.
 
+New-style RAID support
+CONFIG_MD_RAID90
+  New-style RAID (also known as "RAID 0.90") is a rewrite of software
+  RAID for Linux.  Many bugs have been fixed and new features
+  implemented.  Unfortunately, it is not a drop-in replacement; the
+  on-disk structures have changed and so have the user-space tools.
+  You will need raidtools version 0.90 or above (Debian calls this
+  `raidtools2').
+
+  If you have existing old-style RAID partitions and do not wish to
+  migrate them to new-style, say N; otherwise say Y.
+
+Autodetect RAID partitions
+CONFIG_AUTODETECT_RAID
+  This feature lets the kernel detect RAID partitions on bootup.
+  An autodetect RAID partition is a normal partition with partition
+  type 0xfd. Use this if you want to boot RAID devices, or want to
+  run them automatically.
+
 Linear (append) mode
 CONFIG_MD_LINEAR
   If you say Y here, then your multiple devices driver will be able to
diff -urNx*~ 2.2.17/Makefile 2.2.17+raid90/Makefile
--- 2.2.17/Makefile	Wed Sep 20 01:45:02 2000
+++ 2.2.17+raid90/Makefile	Fri Sep 22 02:25:08 2000
@@ -206,6 +206,10 @@
 DRIVERS := $(DRIVERS) drivers/i2o/i2o.a
 endif
 
+ifeq ($(CONFIG_MD_RAID90),y)
+DRIVERS += drivers/md/mddev.o
+endif
+
 ifeq ($(CONFIG_PHONE),y)
 DRIVERS := $(DRIVERS) drivers/telephony/telephony.a
 endif
@@ -336,6 +340,7 @@
 	}; \
 	\
 	if [ -f BLOCK_MODULES ]; then inst_mod BLOCK_MODULES block; fi; \
+	if [ -f MD_MODULES    ]; then inst_mod MD_MODULES    block; fi; \
 	if [ -f NET_MODULES   ]; then inst_mod NET_MODULES   net;   fi; \
 	if [ -f IPV4_MODULES  ]; then inst_mod IPV4_MODULES  ipv4;  fi; \
 	if [ -f IPV6_MODULES  ]; then inst_mod IPV6_MODULES  ipv6;  fi; \
diff -urNx*~ 2.2.17/arch/sparc/config.in 2.2.17+raid90/arch/sparc/config.in
--- 2.2.17/arch/sparc/config.in	Wed Sep 20 01:44:17 2000
+++ 2.2.17+raid90/arch/sparc/config.in	Fri Sep 22 01:33:39 2000
@@ -85,10 +85,15 @@
 
 bool 'Multiple devices driver support' CONFIG_BLK_DEV_MD
 if [ "$CONFIG_BLK_DEV_MD" = "y" ]; then
+  bool '   New-style RAID support' CONFIG_MD_RAID90
+  dep_bool '   Autodetect RAID partitions' CONFIG_AUTODETECT_RAID $CONFIG_MD_RAID90
   tristate '   Linear (append) mode' CONFIG_MD_LINEAR
   tristate '   RAID-0 (striping) mode' CONFIG_MD_STRIPED
   tristate '   RAID-1 (mirroring) mode' CONFIG_MD_MIRRORING
   tristate '   RAID-4/RAID-5 mode' CONFIG_MD_RAID5
+fi
+if [ "$CONFIG_MD_LINEAR" = "y" -o "$CONFIG_MD_STRIPED" = "y" ]; then
+  dep_bool '      Boot support (linear, striped)' CONFIG_MD_BOOT $CONFIG_MD_RAID90
 fi
 
 tristate 'RAM disk support' CONFIG_BLK_DEV_RAM
diff -urNx*~ 2.2.17/arch/sparc64/config.in 2.2.17+raid90/arch/sparc64/config.in
--- 2.2.17/arch/sparc64/config.in	Wed Sep 20 01:45:05 2000
+++ 2.2.17+raid90/arch/sparc64/config.in	Fri Sep 22 01:33:53 2000
@@ -98,10 +98,15 @@
 
 bool 'Multiple devices driver support' CONFIG_BLK_DEV_MD
 if [ "$CONFIG_BLK_DEV_MD" = "y" ]; then
+  bool '   New-style RAID support' CONFIG_MD_RAID90
+  dep_bool '   Autodetect RAID partitions' CONFIG_AUTODETECT_RAID $CONFIG_MD_RAID90
   tristate '   Linear (append) mode' CONFIG_MD_LINEAR
   tristate '   RAID-0 (striping) mode' CONFIG_MD_STRIPED
   tristate '   RAID-1 (mirroring) mode' CONFIG_MD_MIRRORING
   tristate '   RAID-4/RAID-5 mode' CONFIG_MD_RAID5
+fi
+if [ "$CONFIG_MD_LINEAR" = "y" -o "$CONFIG_MD_STRIPED" = "y" ]; then
+  dep_bool '      Boot support (linear, striped)' CONFIG_MD_BOOT $CONFIG_MD_RAID90
 fi
 
 tristate 'RAM disk support' CONFIG_BLK_DEV_RAM
diff -urNx*~ 2.2.17/drivers/Makefile 2.2.17+raid90/drivers/Makefile
--- 2.2.17/drivers/Makefile	Wed Sep 20 01:43:20 2000
+++ 2.2.17+raid90/drivers/Makefile	Wed Sep 20 09:14:25 2000
@@ -10,7 +10,7 @@
 SUB_DIRS     := block char net misc sound
 MOD_SUB_DIRS := $(SUB_DIRS)
 ALL_SUB_DIRS := $(SUB_DIRS) pci sgi scsi sbus cdrom isdn pnp \
-				macintosh video dio zorro fc4 usb telephony i2o
+		macintosh video dio zorro fc4 usb telephony i2o md
 
 ifdef CONFIG_DIO
 SUB_DIRS += dio
@@ -71,6 +71,11 @@
   ifeq ($(CONFIG_SCSI),m)
   MOD_SUB_DIRS += scsi
   endif
+endif
+
+ifeq ($(CONFIG_MD_RAID90),y)
+SUB_DIRS += md
+MOD_SUB_DIRS += md
 endif
 
 ifeq ($(CONFIG_PNP),y)
diff -urNx*~ 2.2.17/drivers/block/Config.in 2.2.17+raid90/drivers/block/Config.in
--- 2.2.17/drivers/block/Config.in	Wed Sep 20 01:44:17 2000
+++ 2.2.17+raid90/drivers/block/Config.in	Wed Sep 20 06:54:24 2000
@@ -102,6 +102,8 @@
 fi
 bool 'Multiple devices driver support' CONFIG_BLK_DEV_MD
 if [ "$CONFIG_BLK_DEV_MD" = "y" ]; then
+  bool '   New-style RAID support' CONFIG_MD_RAID90
+  dep_bool '   Autodetect RAID partitions' CONFIG_AUTODETECT_RAID $CONFIG_MD_RAID90
   tristate '   Linear (append) mode' CONFIG_MD_LINEAR
   tristate '   RAID-0 (striping) mode' CONFIG_MD_STRIPED
   tristate '   RAID-1 (mirroring) mode' CONFIG_MD_MIRRORING
diff -urNx*~ 2.2.17/drivers/block/Makefile 2.2.17+raid90/drivers/block/Makefile
--- 2.2.17/drivers/block/Makefile	Wed Sep 20 01:43:20 2000
+++ 2.2.17+raid90/drivers/block/Makefile	Wed Sep 20 09:39:32 2000
@@ -255,6 +255,7 @@
 endif
 
 ifeq ($(CONFIG_BLK_DEV_MD),y)
+ifneq ($(CONFIG_MD_RAID90),y)
 LX_OBJS += md.o
 
 ifeq ($(CONFIG_MD_LINEAR),y)
@@ -289,6 +290,7 @@
   endif
 endif
 
+endif
 endif
 
 ifeq ($(CONFIG_BLK_DEV_NBD),y)
diff -urNx*~ 2.2.17/drivers/block/genhd.c 2.2.17+raid90/drivers/block/genhd.c
--- 2.2.17/drivers/block/genhd.c	Wed Sep 20 01:45:07 2000
+++ 2.2.17+raid90/drivers/block/genhd.c	Wed Sep 20 06:56:36 2000
@@ -28,6 +28,7 @@
 #include <linux/string.h>
 #include <linux/blk.h>
 #include <linux/init.h>
+#include <linux/raid/md.h>
 
 #include <asm/system.h>
 #include <asm/byteorder.h>
@@ -1671,6 +1672,9 @@
 	else
 #endif
 	rd_load();
+#endif
+#ifdef CONFIG_AUTODETECT_RAID
+	autodetect_raid();
 #endif
 #ifdef CONFIG_MD_BOOT
         md_setup_drive();
diff -urNx*~ 2.2.17/drivers/block/ll_rw_blk.c 2.2.17+raid90/drivers/block/ll_rw_blk.c
--- 2.2.17/drivers/block/ll_rw_blk.c	Wed Sep 20 01:44:18 2000
+++ 2.2.17+raid90/drivers/block/ll_rw_blk.c	Wed Sep 20 09:59:04 2000
@@ -23,6 +23,7 @@
 #include <asm/io.h>
 #include <asm/uaccess.h>
 #include <linux/blk.h>
+#include <linux/raid/md.h>
 
 #include <linux/module.h>
 
@@ -53,6 +54,11 @@
 spinlock_t io_request_lock = SPIN_LOCK_UNLOCKED;
 
 /*
+ * per-major idle-IO detection
+ */
+unsigned long io_events[MAX_BLKDEV];
+
+/*
  * used to wait on when there are no free requests
  */
 struct wait_queue * wait_for_request;
@@ -641,6 +647,8 @@
 		return;
 	/* Maybe the above fixes it, and maybe it doesn't boot. Life is interesting */
 	lock_buffer(bh);
+	if (!buffer_lowprio(bh))
+		io_events[major]++;
 
 	if (blk_size[major]) {
 		unsigned long maxsector = (blk_size[major][MINOR(bh->b_rdev)] << 1) + 1;
@@ -892,7 +900,7 @@
 		bh[i]->b_rsector=bh[i]->b_blocknr*(bh[i]->b_size >> 9);
 #ifdef CONFIG_BLK_DEV_MD
 		if (major==MD_MAJOR &&
-		    md_map (MINOR(bh[i]->b_dev), &bh[i]->b_rdev,
+			md_map (bh[i]->b_dev, &bh[i]->b_rdev,
 			    &bh[i]->b_rsector, bh[i]->b_size >> 9)) {
 		        printk (KERN_ERR
 				"Bad md_map in ll_rw_block\n");
@@ -912,7 +920,7 @@
 			set_bit(BH_Req, &bh[i]->b_state);
 #ifdef CONFIG_BLK_DEV_MD
 			if (MAJOR(bh[i]->b_dev) == MD_MAJOR) {
-				md_make_request(MINOR (bh[i]->b_dev), rw, bh[i]);
+				md_make_request(bh[i], rw);
 				continue;
 			}
 #endif
diff -urNx*~ 2.2.17/drivers/block/md.c 2.2.17+raid90/drivers/block/md.c
--- 2.2.17/drivers/block/md.c	Sat Oct 31 12:37:14 1998
+++ 2.2.17+raid90/drivers/block/md.c	Wed Sep 20 09:58:33 2000
@@ -758,8 +758,10 @@
   block_fsync
 };
 
-int md_map (int minor, kdev_t *rdev, unsigned long *rsector, unsigned long size)
+int md_map (kdev_t dev, kdev_t *rdev, unsigned long *rsector, unsigned long size)
 {
+  int minor = MINOR (dev);
+
   if ((unsigned int) minor >= MAX_MD_DEV)
   {
     printk ("Bad md device %d\n", minor);
@@ -775,8 +777,9 @@
   return (md_dev[minor].pers->map(md_dev+minor, rdev, rsector, size));
 }
   
-int md_make_request (int minor, int rw, struct buffer_head * bh)
+int md_make_request (struct buffer_head * bh, int rw)
 {
+	int minor = MINOR (bh->b_dev);
 	if (md_dev [minor].pers->make_request) {
 		if (buffer_locked(bh))
 			return 0;
diff -urNx*~ 2.2.17/drivers/md/Makefile 2.2.17+raid90/drivers/md/Makefile
--- 2.2.17/drivers/md/Makefile	Wed Dec 31 18:00:00 1969
+++ 2.2.17+raid90/drivers/md/Makefile	Fri Sep 22 02:23:12 2000
@@ -0,0 +1,28 @@
+#
+# Makefile for the kernel software RAID drivers
+# Matthew Kirkwood, Peter Samuelson
+#
+
+O_TARGET	:= mddev.o
+SUB_DIRS	:=
+MOD_SUB_DIRS	:=
+ALL_SUB_DIRS	:=
+MOD_LIST_NAME	:= MD_MODULES
+
+export-objs	:= md.o xor.o
+
+obj-y		:= md.o
+obj-m		:=
+
+obj-$(CONFIG_MD_LINEAR)		+= linear.o
+obj-$(CONFIG_MD_STRIPED)	+= raid0.o
+obj-$(CONFIG_MD_MIRRORING)	+= raid1.o
+obj-$(CONFIG_MD_RAID5)		+= raid5.o xor.o
+
+# Translate to Rules.make lists
+O_OBJS		:= $(filter-out $(export-objs), $(obj-y))
+OX_OBJS		:= $(filter     $(export-objs), $(obj-y))
+M_OBJS		:= $(sort $(filter-out $(export-objs), $(obj-m)))
+MX_OBJS		:= $(sort $(filter     $(export-objs), $(obj-m)))
+
+include $(TOPDIR)/Rules.make
diff -urNx*~ 2.2.17/include/linux/blkdev.h 2.2.17+raid90/include/linux/blkdev.h
--- 2.2.17/include/linux/blkdev.h	Wed Sep 20 01:45:31 2000
+++ 2.2.17+raid90/include/linux/blkdev.h	Fri Sep 22 02:12:10 2000
@@ -93,8 +93,9 @@
 extern void make_request(int major,int rw, struct buffer_head * bh);
 
 /* md needs this function to remap requests */
-extern int md_map (int minor, kdev_t *rdev, unsigned long *rsector, unsigned long size);
-extern int md_make_request (int minor, int rw, struct buffer_head * bh);
+extern int md_map (kdev_t dev, kdev_t *rdev,
+		   unsigned long *rsector, unsigned long size);
+extern int md_make_request (struct buffer_head * bh, int rw);
 extern int md_error (kdev_t mddev, kdev_t rdev);
 
 extern int * blk_size[MAX_BLKDEV];
diff -urNx*~ 2.2.17/include/linux/fs.h 2.2.17+raid90/include/linux/fs.h
--- 2.2.17/include/linux/fs.h	Wed Sep 20 01:45:31 2000
+++ 2.2.17+raid90/include/linux/fs.h	Fri Sep 22 02:12:10 2000
@@ -185,6 +185,7 @@
 #define BH_Lock		2	/* 1 if the buffer is locked */
 #define BH_Req		3	/* 0 if the buffer has been invalidated */
 #define BH_Protected	6	/* 1 if the buffer is protected */
+#define BH_LowPrio	7	/* 1 if the buffer is lowprio */
 
 /*
  * Try to keep the most commonly used fields in single cache lines (16
@@ -755,6 +756,7 @@
 extern void refile_buffer(struct buffer_head * buf);
 extern void set_writetime(struct buffer_head * buf, int flag);
 extern int try_to_free_buffers(struct page *, int wait);
+extern void cache_drop_behind(struct buffer_head *bh);
 
 extern int nr_buffers;
 extern long buffermem;
@@ -775,6 +777,25 @@
 	}
 }
 
+extern inline void mark_buffer_highprio(struct buffer_head * bh)
+{
+	clear_bit(BH_LowPrio, &bh->b_state);
+}
+
+extern inline void mark_buffer_lowprio(struct buffer_head * bh)
+{
+	/*
+	 * dirty buffers cannot be marked lowprio.
+	 */
+	if (!buffer_dirty(bh))
+		set_bit(BH_LowPrio, &bh->b_state);
+}
+
+static inline int buffer_lowprio(struct buffer_head * bh)
+{
+	return test_bit(BH_LowPrio, &bh->b_state);
+}
+
 extern inline void mark_buffer_dirty(struct buffer_head * bh, int flag)
 {
 	if (!test_and_set_bit(BH_Dirty, &bh->b_state)) {
@@ -782,6 +803,23 @@
 		if (bh->b_list != BUF_DIRTY)
 			refile_buffer(bh);
 	}
+	/*
+	 * if a buffer gets marked dirty then it has to lose
+	 * it's lowprio state.
+	 */
+	mark_buffer_highprio(bh);
+}
+
+extern inline void mark_buffer_dirty_lowprio(struct buffer_head * bh)
+{
+	if (!test_and_set_bit(BH_Dirty, &bh->b_state)) {
+		if (bh->b_list != BUF_DIRTY)
+			refile_buffer(bh);
+		/*
+		 * Mark it lowprio only if it was not dirty before!
+		 */
+		set_bit(BH_LowPrio, &bh->b_state);
+	}
 }
 
 extern int check_disk_change(kdev_t dev);
@@ -855,6 +893,7 @@
 extern struct buffer_head * find_buffer(kdev_t dev, int block, int size);
 extern void ll_rw_block(int, int, struct buffer_head * bh[]);
 extern int is_read_only(kdev_t);
+extern int is_device_idle(kdev_t);
 extern void __brelse(struct buffer_head *);
 extern inline void brelse(struct buffer_head *buf)
 {
@@ -870,8 +909,12 @@
 extern void set_blocksize(kdev_t dev, int size);
 extern unsigned int get_hardblocksize(kdev_t dev);
 extern struct buffer_head * bread(kdev_t dev, int block, int size);
+extern struct buffer_head * buffer_ready (kdev_t dev, int block, int size);
+extern void bread_ahead (kdev_t dev, int block, int size);
 extern struct buffer_head * breada(kdev_t dev,int block, int size, 
 				   unsigned int pos, unsigned int filesize);
+extern struct buffer_head * breada_blocks(kdev_t dev,int block,
+						int size, int blocks);
 
 extern int brw_page(int, struct page *, kdev_t, int [], int, int);
 
diff -urNx*~ 2.2.17/include/linux/sysctl.h 2.2.17+raid90/include/linux/sysctl.h
--- 2.2.17/include/linux/sysctl.h	Wed Sep 20 01:44:40 2000
+++ 2.2.17+raid90/include/linux/sysctl.h	Wed Sep 20 05:52:45 2000
@@ -430,7 +430,8 @@
 /* CTL_DEV names: */
 enum {
 	DEV_CDROM=1,
-	DEV_HWMON=2
+	DEV_HWMON=2,
+	DEV_MD=3
 };
 
 /* /proc/sys/dev/cdrom */
@@ -441,6 +442,11 @@
 	DEV_CDROM_DEBUG=4,
 	DEV_CDROM_LOCK=5,
 	DEV_CDROM_CHECK_MEDIA=6
+};
+
+/* /proc/sys/dev/md */
+enum {
+	DEV_MD_SPEED_LIMIT=1
 };
 
 #ifdef __KERNEL__
diff -urNx*~ 2.2.17/init/main.c 2.2.17+raid90/init/main.c
--- 2.2.17/init/main.c	Wed Sep 20 01:45:31 2000
+++ 2.2.17+raid90/init/main.c	Wed Sep 20 08:46:48 2000
@@ -19,6 +19,7 @@
 #include <linux/utsname.h>
 #include <linux/ioport.h>
 #include <linux/init.h>
+#include <linux/raid/md.h>
 #include <linux/smp_lock.h>
 #include <linux/blk.h>
 #include <linux/hdreg.h>
@@ -539,7 +540,7 @@
 #ifdef CONFIG_BLK_DEV_FD
 	{ "fd",      0x0200 },
 #endif
-#ifdef CONFIG_MD_BOOT
+#if CONFIG_MD_BOOT || CONFIG_AUTODETECT_RAID
 	{ "md",      0x0900 },	     
 #endif     
 #ifdef CONFIG_BLK_DEV_XD
@@ -1041,6 +1042,9 @@
 #ifdef CONFIG_MD_BOOT
 	{ "md=", md_setup},
 #endif
+#if CONFIG_MD_RAID90
+	{ "raid=", raid_setup},
+#endif
 #ifdef CONFIG_ADBMOUSE
 	{ "adb_buttons=", adb_mouse_setup },
 #endif
@@ -1577,6 +1581,9 @@
 			while (pid != wait(&i));
 		if (MAJOR(real_root_dev) != RAMDISK_MAJOR
 		     || MINOR(real_root_dev) != 0) {
+#ifdef CONFIG_AUTODETECT_RAID
+			autodetect_raid();
+#endif
 			error = change_root(real_root_dev,"/initrd");
 			if (error)
 				printk(KERN_ERR "Change root to /initrd: "
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
Please read the FAQ at 
http://www.tux.org/lkml/