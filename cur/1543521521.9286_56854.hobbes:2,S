Date: Mon, 10 Jan 2000 15:51:05 +0100
From: Manfred Spraul <>
Subject: kbacktrace
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/1/10/81

Andi,
I thought once more about obtaining an accurate multi-cpu backtrace, and
I don't like the IPI based solutions:
* non-NMI based solutions cannot obtain the backtrace if the other cpu
spins with disabled interrupts. Especially if you call
smp_call_function() from an hardware interrupt or with disabled local
interrupts, you could lock-up again.
* I don't want to rely on the NMI interrupt unless there is no other
option.
What about the following idea [only possible on 2.3]:
* The TSS address is always fixed, ie we can access the TSS of the
secondary CPU's and find the kernel stack pages.
* We dump the _complete_ backtrace [ie all function pointers in the 7 kB
stack area of the current thread].
This means:
* we always get the complete back trace
* it will be more difficult to read the back trace, but it should be
possible.
* We'll _always_ get the back trace, the only exception is during stack
switching. But AFAICS, this code cannot block.
What do you think?
--
	Manfred
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/