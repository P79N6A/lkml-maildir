Date: Thu, 1 Feb 2007 12:46:44 +0100
From: Ingo Molnar <>
Subject: [-mm patch] x86_64 GTOD: offer scalable vgettimeofday
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/2/1/108

* jbohac@suse.cz <jbohac@suse.cz> wrote:
> Inter-CPU monotonicity can not, however, be guaranteed in a vsyscall, 
> so vsyscall is not used by default. [...]
note that this is not actually the case. My patch below, ontop of -mm, 
implements a fully monotonic gettimeofday as an optional vsyscall 
feature.
The 'price' paid for it is lower resolution - but it's still good for 
those benchmarking TPC-C runs - and /alot/ simpler. It's also quite a 
bit faster than any TSC based vgettimeofday, because it doesnt have to 
do an RDTSC (or RDTSCP) instruction nor any approximation of the time.
	Ingo
---------------------------->
Subject: [patch] x86_64 GTOD: offer scalable vgettimeofday
From: Ingo Molnar <mingo@elte.hu>
offer scalable vgettimeofday independently of whether the TSC is 
synchronous or not. Off by default. Results in low resolution 
gettimefday().
this patch also fixes an SMP bug in sys_vtime(): we should read 
__vsyscall_gtod_data.wall_time_tv.tv_sec only once.
Signed-off-by: Ingo Molnar <mingo@elte.hu>
---
 arch/x86_64/kernel/vsyscall.c |   30 +++++++++++++++++++++++++++---
 1 file changed, 27 insertions(+), 3 deletions(-)
Index: linux/arch/x86_64/kernel/vsyscall.c
===================================================================
--- linux.orig/arch/x86_64/kernel/vsyscall.c
+++ linux/arch/x86_64/kernel/vsyscall.c
@@ -107,6 +107,22 @@ static __always_inline void do_vgettimeo
 	cycle_t now, base, mask, cycle_delta;
 	unsigned long seq, mult, shift, nsec_delta;
 	cycle_t (*vread)(void);
+
+	if (likely(__vsyscall_gtod_data.sysctl_enabled == 2)) {
+		struct timeval tmp;
+
+		do {
+			barrier();
+			*tv = __vsyscall_gtod_data.wall_time_tv;
+			barrier();
+			tmp = __vsyscall_gtod_data.wall_time_tv;
+
+		} while (tmp.tv_usec != tv->tv_usec ||
+					tmp.tv_sec != tv->tv_sec);
+
+		return;
+	}
+
 	do {
 		seq = read_seqbegin(&__vsyscall_gtod_data.lock);
 
@@ -151,11 +167,19 @@ int __vsyscall(0) vgettimeofday(struct t
  * unlikely */
 time_t __vsyscall(1) vtime(time_t *t)
 {
+	time_t secs;
+
 	if (!__vsyscall_gtod_data.sysctl_enabled)
 		return time_syscall(t);
-	else if (t)
-		*t = __vsyscall_gtod_data.wall_time_tv.tv_sec;
-	return __vsyscall_gtod_data.wall_time_tv.tv_sec;
+
+	/*
+	 * Make sure that what we return is the same number we
+	 * write:
+	 */
+	secs = __vsyscall_gtod_data.wall_time_tv.tv_sec;
+	if (t)
+		*t = secs;
+	return secs;
 }
 
 /* Fast way to get current CPU and node.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/