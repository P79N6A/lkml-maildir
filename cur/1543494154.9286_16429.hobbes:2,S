Date: Thu, 29 Apr 1999 10:37:43 -0400
From: Eric Lowe <>
Subject: RE: Process VM Addr to Kernel VM Addr at Interrupt Time.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/4/29/62

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="MS Exchange Server version 5.5.2448.0">
<TITLE>RE: Process VM Addr to Kernel VM Addr at Interrupt Time.</TITLE>
</HEAD>
<BODY>
<P><FONT SIZE=2>&gt; &gt; process, etc.</FONT>
<BR><FONT SIZE=2>&gt; &gt; Without a mechanism to allow the driver to be notified the </FONT>
<BR><FONT SIZE=2>&gt; process has died</FONT>
<BR><FONT SIZE=2>&gt; &gt; to stop the DMA disk buffers could be destroyed, processes </FONT>
<BR><FONT SIZE=2>&gt; overwritten, etc.</FONT>
<BR><FONT SIZE=2>&gt; &gt; This is a BAD THING.</FONT>
<BR><FONT SIZE=2>&gt; </FONT>
<BR><FONT SIZE=2>&gt;&nbsp;&nbsp;&nbsp;&nbsp; When a kernel mapping is created for a given user-page. </FONT>
<BR><FONT SIZE=2>&gt; Doesn't the reference</FONT>
<BR><FONT SIZE=2>&gt;&nbsp;&nbsp;&nbsp;&nbsp; count for the page be &quot;2&quot;, one for the user and one for </FONT>
<BR><FONT SIZE=2>&gt; the kernel. Doesn't </FONT>
<BR><FONT SIZE=2>&gt;&nbsp;&nbsp;&nbsp;&nbsp; the page structure maintain a reference count ?</FONT>
<BR><FONT SIZE=2>&gt;&nbsp;&nbsp;&nbsp;&nbsp; Also when a kernel mapping is created, shouldn't the page </FONT>
<BR><FONT SIZE=2>&gt; accquire a property</FONT>
<BR><FONT SIZE=2>&gt;&nbsp;&nbsp;&nbsp;&nbsp; of staying around, even if the user mapping goes off ? </FONT>
<BR><FONT SIZE=2>&gt; Because when the user</FONT>
<BR><FONT SIZE=2>&gt;&nbsp;&nbsp;&nbsp;&nbsp; process goes off the page * should * not go back to the </FONT>
<BR><FONT SIZE=2>&gt; free pool, but stay </FONT>
<BR><FONT SIZE=2>&gt;&nbsp;&nbsp;&nbsp;&nbsp; around as the &quot;ref cnt&quot; is now &quot;1&quot;. Also it should always </FONT>
<BR><FONT SIZE=2>&gt; stay in memory, because</FONT>
<BR><FONT SIZE=2>&gt;&nbsp;&nbsp;&nbsp;&nbsp; the page is still locked. If a process was the only user </FONT>
<BR><FONT SIZE=2>&gt; for the page when</FONT>
<BR><FONT SIZE=2>&gt;&nbsp;&nbsp;&nbsp;&nbsp; the memory cleanup occurs as part of exit(), the page </FONT>
<BR><FONT SIZE=2>&gt; will go back to the free pool</FONT>
<BR><FONT SIZE=2>&gt;&nbsp;&nbsp;&nbsp;&nbsp; and lose its property of being locked. </FONT>
</P>
<P><FONT SIZE=2>Yes.&nbsp; Someone please correct me if I'm wrong -- but since I'm using the PG_locked bit, when the reference count falls to 1 the kernel knows that it has the other reference, and frees the memory anyway.&nbsp; I have tested repeated allocations, locks, and killed the process with the buffer locked -- and the memory usage of the system doesn't go up, which seems to verify this is the case.&nbsp; Of course, I could get around this by setting PG_reserved, but that would make the memory unusable until reboot -- which would be evil.&nbsp; This is precisely the wrong kind of hack that makes Linus' hair stand up on end, as it should. :-)</FONT></P>
<P><FONT SIZE=2>&gt;&nbsp;&nbsp;&nbsp;&nbsp; But i do accept one likely problem in such DMA's. In case </FONT>
<BR><FONT SIZE=2>&gt; the driver is waiting</FONT>
<BR><FONT SIZE=2>&gt;&nbsp;&nbsp;&nbsp;&nbsp; for the DMA to happen/complete and an un-advertised </FONT>
<BR><FONT SIZE=2>&gt; exit() happens:</FONT>
</P>
<P><FONT SIZE=2>That's why a callback mechanism is necessary; or, alternatively, a way to access a process's page tables from a kernel thread that will still live after the process dies (but that also requires that the memory not be freed until after it's unlocked...)</FONT></P>
<P><FONT SIZE=2>&gt;&nbsp;&nbsp;&nbsp;&nbsp; This will more likely cause kernel memory VM and the </FONT>
<BR><FONT SIZE=2>&gt; pages behind them to be eaten </FONT>
<BR><FONT SIZE=2>&gt;&nbsp;&nbsp;&nbsp;&nbsp; up, as there is no one to free them if the process goes </FONT>
<BR><FONT SIZE=2>&gt; off un-advertised. This </FONT>
<BR><FONT SIZE=2>&gt;&nbsp;&nbsp;&nbsp;&nbsp; is assuming that the process had called exit() in the </FONT>
<BR><FONT SIZE=2>&gt; interruptible blocking call </FONT>
<BR><FONT SIZE=2>&gt;&nbsp;&nbsp;&nbsp;&nbsp; itself on receipt of say a SIGSEGV ( for a multi-threaded </FONT>
<BR><FONT SIZE=2>&gt; case ), or some other</FONT>
<BR><FONT SIZE=2>&gt;&nbsp;&nbsp;&nbsp;&nbsp; fatal exit criteria.</FONT>
<BR><FONT SIZE=2>&gt; </FONT>
<BR><FONT SIZE=2>&gt;&nbsp;&nbsp;&nbsp;&nbsp; I have another question:</FONT>
<BR><FONT SIZE=2>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Doesn't the above happen for the case for allocation of </FONT>
<BR><FONT SIZE=2>&gt; kernel buffers and mmap</FONT>
<BR><FONT SIZE=2>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to the user ? I mean who will free the kernel buffers in </FONT>
<BR><FONT SIZE=2>&gt; this case ?</FONT>
</P>
<P><FONT SIZE=2>The kernel.&nbsp; The real problem is this-- I need to be able to set a timer to go off regardless of whether or not the process that locked the pages is still around.&nbsp; I can't do that from the process context, since it is removed from the timer queue when the process goes away.&nbsp; A possible solution would be to do the work from a kernel thread that sleeps and wakes up when a timer goes off every so often and checks for buffers that have been locked but have a reference count of '1'.&nbsp; This adds overhead though, so I would think it would be more efficient to give this job to the swapper since it's already around...</FONT></P>
<P><FONT SIZE=2>--</FONT>
<BR><FONT SIZE=2>Eric Lowe</FONT>
<BR><FONT SIZE=2>elowe@systran.com</FONT>
<BR><FONT SIZE=2>Software Engineer Co-op, Systran Corporation</FONT>
<BR><FONT SIZE=2>937-252-5601 x330</FONT>
</P>
<BR>
<BR>
</BODY>
</HTML>