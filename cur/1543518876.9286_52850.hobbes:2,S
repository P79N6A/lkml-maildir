Date: Sun, 12 Dec 1999 00:11:38 +0100
From: Manfred Spraul <>
Subject: Re: 2.3.31 - shm broken on Alpha ?
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/12/11/91

I found the problem: someone broke the binary compatibility with user
space: 
linux/include/linux/shm.h:
struct shmid_ds {
	struct ipc_perm shm_perm;
-	int	shm_segsz;
+	size_t  shm_segsz;
[...]
};
Could you please apply the attached patch and check the new kernel?
[Untested, but it should fix your problem]
--
	Manfred// $Header$
// Kernel Version:
//  VERSION = 2
//  PATCHLEVEL = 3
//  SUBLEVEL = 31
//  EXTRAVERSION =
--- 2.3/ipc/shm.c	Wed Dec  8 23:17:05 1999
+++ build-2.3/ipc/shm.c	Sun Dec 12 00:08:36 1999
@@ -32,6 +32,7 @@
 struct shmid_kernel /* extend struct shmis_ds with private fields */
 {	
 	struct shmid_ds		u;
+	size_t			real_segsz;
 	unsigned long		shm_npages; /* size of segment (pages) */
 	pte_t			**shm_dir;  /* ptr to array of ptrs to frames -> SHMMAX */ 
 	struct vm_area_struct	*attaches;  /* descriptors for attaches */
@@ -89,7 +90,6 @@
 /* some statistics */
 static ulong swap_attempts = 0;
 static ulong swap_successes = 0;
-static ulong used_segs = 0;
 
 void __init shm_init (void)
 {
@@ -204,7 +204,11 @@
 	}
 	shp->u.shm_perm.key = key;
 	shp->u.shm_perm.mode = (shmflg & S_IRWXUGO);
-	shp->u.shm_segsz = size;
+	shp->real_segsz = size;
+	if(size < INT_MAX)
+		shp->u.shm_segsz = size;
+	 else
+	 	shp->u.shm_segsz = INT_MAX;
 	shp->u.shm_cpid = current->pid;
 	shp->attaches = NULL;
 	shp->u.shm_lpid = shp->u.shm_nattch = 0;
@@ -337,7 +341,7 @@
 
 		memset(&shm_info,0,sizeof(shm_info));
 		shm_lockall();
-		shm_info.used_ids = used_segs;
+		shm_info.used_ids = shm_ids.in_use;
 		shm_info.shm_rss = shm_rss;
 		shm_info.shm_tot = shm_tot;
 		shm_info.shm_swp = shm_swp;
@@ -566,7 +570,7 @@
 		err = -ENOMEM;
 		addr = 0;
 	again:
-		if (!(addr = get_unmapped_area(addr, (unsigned long)shp->u.shm_segsz)))
+		if (!(addr = get_unmapped_area(addr, (unsigned long)shp->real_segsz)))
 			goto out_unlock_up;
 		if(addr & (SHMLBA - 1)) {
 			addr = (addr + (SHMLBA - 1)) & ~(SHMLBA - 1);
@@ -593,7 +597,7 @@
 	if (addr < current->mm->start_stack &&
 	    addr > current->mm->start_stack - PAGE_SIZE*(shp->shm_npages + 4))
 		goto out_unlock_up;
-	if (!(shmflg & SHM_REMAP) && find_vma_intersection(current->mm, addr, addr + (unsigned long)shp->u.shm_segsz))
+	if (!(shmflg & SHM_REMAP) && find_vma_intersection(current->mm, addr, addr + (unsigned long)shp->real_segsz))
 		goto out_unlock_up;
 
 	shm_unlock(shmid);
@@ -957,7 +961,7 @@
 				shp->u.shm_perm.key,
 				shm_buildid(i, shp->u.shm_perm.seq),
 				shp->u.shm_perm.mode,
-				shp->u.shm_segsz,
+				shp->real_segsz,
 				shp->u.shm_cpid,
 				shp->u.shm_lpid,
 				shp->u.shm_nattch,
--- 2.3/include/linux/shm.h	Sun Nov  7 10:20:50 1999
+++ build-2.3/include/linux/shm.h	Sun Dec 12 00:06:08 1999
@@ -18,7 +18,7 @@
 
 struct shmid_ds {
 	struct ipc_perm		shm_perm;	/* operation perms */
-	size_t			shm_segsz;	/* size of segment (bytes) */
+	int			shm_segsz;	/* size of segment (bytes) */
 	__kernel_time_t		shm_atime;	/* last attach time */
 	__kernel_time_t		shm_dtime;	/* last detach time */
 	__kernel_time_t		shm_ctime;	/* last change time */