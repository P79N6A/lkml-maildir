Date: Fri, 16 Jul 1999 16:50:12 -0600
From: Larry McVoy <>
Subject: Re: kernel thread support - LWP's
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/7/16/137

: > Sure, I'm happy with a new kind of process group. In the docs we can
: > say "this is for threads". Couple that with a new kill() syscall which
: > does "kill one of a group" and we can support POSIX semantics.
: 
: How about extending process groups so that a process can belong to any (sane)
: number of groups?
: 
: addpgid(pid, pgid);
: rempgid(pid, pgid);
This is the right idea.  Chris and I came to the same understanding on
the phone earlier.  Here's some more on the same theme.  If Chris wants
to pick these up, I'll sign up for writing the man pages.  Since I did
all POSIX ctty stuff in SunOS, I'll also sign up to make sure these
don't break POSIX ctty behaviour.
	/*
	 * Allocate a process group and set the permissions.
	 * Permissions are user/group/all like file permissions
	 * and constrain who can join the process group.
	 * The returned process group value is an unused (and now
	 * unusable) process id.
	 * Note: if the process group is never used, then the pgid is
	 * returned to the pid space when the caller (and the callers
	 * children) exit.
	 *
	 * Return: ! -1 is the pgid, otherwise:
	 *	EAGAIN for no available process ids.
	 *	ENOSPC for no space in calling process' supplemental pgrp list.
	 */
	pgid = newpgid(mode_t perms);
	/*
	 * Return supplemental process groups to which the specified pid
	 * belongs.  The list does not include the traditional process
	 * group used by the controlling terminal, use getpgid() for that.
	 *
	 * Returns: >= 0 is the # of pgids found.
	 */
	error = getpgids(int size, pid_t pgids[]);
	
	/*
	 * Join a process group.  The process group must be a supplemental
	 * process group created by newpgid().
	 *
	 * Returns: 0 is OK, else:
	 *	EPERM permissions do not allow caller to join this group, or
	 *	if pid != 0, the permissions do not allow the specified process
	 *	to join this process group.
	 *	EPERM pid != 0, pid is not the same uid as the caller, and 
	 *	the caller is not root.
	 *	ENOSPC for no space in calling process' supplemental pgrp list.
	 *	EINVAL if the specified pgid is a traditional process group,
	 *	i.e., a process group associated with a controlling tty.
	 */
	error = joinpgid(pid_t pid, pid_t pgid);
	/*
	 * Leave a process group.
	 *	Errors are like joinpgid().
	 */
	error = leavepgid(pid_t pid, pid_t pgid);
	/*
	 * Set signal semantics for a process group.  For all non controlling
	 * terminal signals (i.e., not SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU),
	 * this also works on traditional process groups.
	 */
#define	SIG_DEFAULT	0
#define	SIG_WAKEUP1	0x0001	/* signal only one of the members of the
				 * process group.
				 */
	error = sigsemantics(pid_t pgid, int flags);
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/