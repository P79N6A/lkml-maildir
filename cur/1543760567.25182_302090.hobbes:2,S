Date: Fri, 11 Mar 2005 19:14:13 +0000
From: Alan Cox <>
Subject: Re: User mode drivers: part 1, interrupt handling (patch for 2.6.11)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/3/11/188

On Gwe, 2005-03-11 at 03:36, Peter Chubb wrote:
> +static irqreturn_t irq_proc_irq_handler(int irq, void *vidp, struct pt_regs *regs)
> +{
> + 	struct irq_proc *idp = (struct irq_proc *)vidp;
> + 
> + 	BUG_ON(idp->irq != irq);
> + 	disable_irq_nosync(irq);
> + 	atomic_inc(&idp->count);
> + 	wake_up(&idp->q);
> + 	return IRQ_HANDLED;
You just deadlocked the machine in many configurations. You can't use
disable_irq for this trick you have to tell the kernel how to handle it.
I posted a proposal for this sometime ago because X has some uses for
it. The idea being you'd pass a struct that describes
1.	What tells you an IRQ occurred on this device
2.	How to clear it
3.	How to enable/disable it.
Something like
	struct {
		u8 type;		/* 8, 16, 32  I/O or MMIO */
		u8 bar;			/* PCI bar to use */
		u32 offset;		/* Into bar */
		u32 mask;		/* Bits to touch/compare */
		u32 value;		/* Value to check against/set */
	}
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/