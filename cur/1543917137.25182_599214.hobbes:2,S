Date: Wed, 26 Sep 2007 10:48:18 -0700
From: "Chris David" <>
Subject: Proposed 2.6 Patch for AMD MIPS Alchemy au1550 I2C interface I2C  interface
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2007/9/26/285

Hello, 
Please CC me on replies. 
I have made a trivial patch to fix a problem on the AMD MIPS Alchemy au1550
I2C interface.  The PSC (programmable serial controller) seem to 'hang' when 
I sent only an 'address' byte on the I2C bus.  The patch essentially uses  
the PSC_SMBSTAT register's TE (transmit FIFO empty) bit to check when the 
transmit FIFO is empty, instead of using the PSC_SMBEVNT register's TU  
(transmit underflow) bit.  Using the TE bit fixed the hang problem. 
I tested this on kernel 2.6.16, and confirmed the patch updates the 2.6.22
kernel correctly.  If someone else can test this, that would be great. 
Dan Malek is the author of the file in question.  I would be more than happy 
to provide any additional information about this patch to Dan or anyone 
else.  Please email me privately. 
I am a newbie, but I did read part of the FAQ, and used my best judgement.  
Kindly let me know if my communication could be improved.  And please CC me 
on replies. 
Thank you, 
 -Chris David 
diff -Naur linux-2.6.16-orig/drivers/i2c/busses/i2c-au1550.c linux-2.6.16/drivers/i2c/busses/i2c-au1550.c
--- linux-2.6.16-orig/drivers/i2c/busses/i2c-au1550.c	2007-09-26 08:38:45.000000000 -0700
+++ linux-2.6.16/drivers/i2c/busses/i2c-au1550.c	2007-09-26 08:43:43.000000000 -0700
@@ -61,17 +61,14 @@
 
 	sp = (volatile psc_smb_t *)(adap->psc_base);
 
-	/* Wait for Tx FIFO Underflow.
+	/* Wait for Tx Buffer Empty
 	*/
 	for (i = 0; i < adap->xfer_timeout; i++) {
-		stat = sp->psc_smbevnt;
+		stat = sp->psc_smbstat;
 		au_sync();
-		if ((stat & PSC_SMBEVNT_TU) != 0) {
-			/* Clear it.  */
-			sp->psc_smbevnt = PSC_SMBEVNT_TU;
-			au_sync();
+		if ((stat & PSC_SMBSTAT_TE) != 0)
 			return 0;
-		}
+
 		udelay(1);
 	}
 