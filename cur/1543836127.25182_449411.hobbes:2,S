Date: Wed, 02 Aug 2006 16:51:47 +0200
From: Haavard Skinnemoen <>
Subject: [PATCH 2/3] at91_serial: Fix break handling
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2006/8/2/120

The RXBRK field in the AT91/AT32 USART status register has the
following definition according to the AT32AP7000 data sheet:
    RXBRK: Break Received/End of Break
    0: No Break received or End of Break detected since the last RSTSTA.
    1: Break Received or End of Break detected since the last RSTSTA.
Thus, for each break, the USART sets the RXBRK bit twice. This patch
modifies the driver to report the break event to the serial core only
once by keeping track of whether a break condition is currently active.
With this patch, SysRq works as expected on the AT32STK1000 board
with an AT32AP7000 CPU.
Signed-off-by: Haavard Skinnemoen <hskinnemoen@atmel.com>
---
 drivers/serial/at91_serial.c |   11 +++++++++--
 1 files changed, 9 insertions(+), 2 deletions(-)
diff --git a/drivers/serial/at91_serial.c b/drivers/serial/at91_serial.c
index f2fecc6..c759e7c 100644
--- a/drivers/serial/at91_serial.c
+++ b/drivers/serial/at91_serial.c
@@ -112,6 +112,7 @@ struct at91_uart_port {
 	struct uart_port	uart;		/* uart */
 	struct clk		*clk;		/* uart clock */
 	unsigned short		suspended;	/* is port suspended? */
+	unsigned short		break_active;
 };
 
 static struct at91_uart_port at91_ports[AT91_NR_UART];
@@ -250,6 +251,7 @@ static void at91_break_ctl(struct uart_p
  */
 static void at91_rx_chars(struct uart_port *port, struct pt_regs *regs)
 {
+	struct at91_uart_port *at91_port = (struct at91_uart_port *) port;
 	struct tty_struct *tty = port->info->tty;
 	unsigned int status, ch, flg;
 
@@ -269,9 +271,14 @@ static void at91_rx_chars(struct uart_po
 			UART_PUT_CR(port, AT91_US_RSTSTA);	/* clear error */
 			if (status & AT91_US_RXBRK) {
 				status &= ~(AT91_US_PARE | AT91_US_FRAME);	/* ignore side-effect */
-				port->icount.brk++;
-				if (uart_handle_break(port))
+				if (at91_port->break_active) {
+					at91_port->break_active = 0;
+				} else {
+					at91_port->break_active = 1;
+					port->icount.brk++;
+					uart_handle_break(port);
 					goto ignore_char;
+				}
 			}
 			if (status & AT91_US_PARE)
 				port->icount.parity++;
-- 
1.4.0
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/