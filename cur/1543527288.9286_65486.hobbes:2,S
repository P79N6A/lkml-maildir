Date: Thu, 24 Feb 2000 17:26:03 +0100
From: Borislav Deianov <>
Subject: [patch] convert h8.c to use list.h
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2000/2/24/120

Linus,
The attached patch againt pre-2.3.48-1 does the following to the H8
driver:
- converts it to use list.h instead of lists.h
- a couple of minor fixes
It compiles but I don't have that device so I can't test it. I've
preserved the original behavior, although there are a couple of
suspicious places in the code that I've marked with XXX.
Please apply.
Regards,
Borislav
diff -Nur linux-2.3.48-1/drivers/char/h8.c linux-2.3.48-1-h8/drivers/char/h8.c
--- linux-2.3.48-1/drivers/char/h8.c	Thu Feb 24 16:13:55 2000
+++ linux-2.3.48-1-h8/drivers/char/h8.c	Thu Feb 24 17:08:07 2000
@@ -6,6 +6,8 @@
  *
  * Fixes:
  *	June 1999, AV	added releasing /proc/driver/h8
+ *	Feb  2000, Borislav Deianov
+ *			changed queues to use list.h instead of lists.h
  */
 
 #include <linux/config.h>
@@ -23,6 +25,7 @@
 #include <linux/stat.h>
 #include <linux/proc_fs.h>
 #include <linux/miscdevice.h>
+#include <linux/list.h>
 #include <linux/ioport.h>
 #include <linux/poll.h>
 #include <linux/init.h>
@@ -31,13 +34,6 @@
 #define __KERNEL_SYSCALLS__
 #include <asm/unistd.h>
 
-/*
- * This is the only driver still using the broken
- * lists.h stuff, let's not do that.. 
- */
-#error must be converted to new <linux/list.h>
-#include <linux/lists.h>
-
 #include "h8.h"
 
 #define DEBUG_H8
@@ -58,18 +54,13 @@
 /*
  * Forward declarations.
  */
-int          h8_init(void);
+static int   h8_init(void);
 int          h8_display_blank(void);
 int          h8_display_unblank(void);
 
 static void  h8_intr(int irq, void *dev_id, struct pt_regs *regs);
 
-#ifdef CONFIG_PROC_FS
 static int   h8_get_info(char *, char **, off_t, int);
-#else
-static int   h8_get_info(char *, char **, off_t, int) {}
-#error "Somebody needs to learn C. Badly."
-#endif
 
 /*
  * Support Routines.
@@ -147,7 +138,9 @@
 unsigned int h8_index = -1;
 unsigned int h8_enabled = 0;
 
-queue_head_t h8_actq, h8_cmdq, h8_freeq;
+LIST_HEAD(h8_actq);
+LIST_HEAD(h8_cmdq);
+LIST_HEAD(h8_freeq);
 
 /* 
  * Globals used in thermal control of Alphabook1.
@@ -176,7 +169,7 @@
 static void h8_intr(int irq, void *dev_id, struct pt_regs *regs)
 {
 	u_char	stat_reg, data_reg;
-	h8_cmd_q_t *qp = (h8_cmd_q_t *)QUEUE_FIRST(&h8_actq, link);
+	h8_cmd_q_t *qp = list_entry(h8_actq.next, h8_cmd_q_t, link);
 
 	stat_reg = H8_GET_STATUS;
 	data_reg = H8_READ_DATA;
@@ -266,7 +259,7 @@
 	        return;
 	    } else if (data_reg == H8_SYNC_BYTE) {
 	        h8_state = H8_IDLE;
-		if (!QUEUE_IS_EMPTY(&h8_actq, link))
+		if (!list_empty(&h8_actq))
 		    h8_send_next_cmd_byte();
 	    } else {
 	        Dprintk ("h8_intr: resync unknown data 0x%x \n", data_reg);
@@ -282,10 +275,10 @@
 		/* If command reception finished. */
 		if (qp->cnt == qp->nrsp) {
 		    h8_state = H8_IDLE;
-		    QUEUE_REMOVE(&h8_actq, qp, link);
+		    list_del(&qp->link);
 		    h8_cmd_done (qp);
 		    /* More commands to send over? */
-		    if (!QUEUE_IS_EMPTY(&h8_cmdq, link))
+		    if (!list_empty(&h8_cmdq))
 		        h8_start_new_cmd();
 		}
 		return;
@@ -323,9 +316,6 @@
         misc_register(&h8_device);
         request_region(h8_base, 8, "h8");
 
-	QUEUE_INIT(&h8_actq, link, h8_cmd_q_t *);
-	QUEUE_INIT(&h8_cmdq, link, h8_cmd_q_t *);
-	QUEUE_INIT(&h8_freeq, link, h8_cmd_q_t *);
 	h8_alloc_queues();
 
 	h8_hw_init();
@@ -370,9 +360,9 @@
 	return;
 }
 
-#ifdef CONFIG_PROC_FS
 static int h8_get_info(char *buf, char **start, off_t fpos, int length)
 {
+#ifdef CONFIG_PROC_FS
         char *p;
 
         if (!h8_enabled)
@@ -393,8 +383,10 @@
 		     );
 
         return p - buf;
-}
+#else
+	return 0;
 #endif
+}
 
 /* Called from console driver -- must make sure h8_enabled. */
 int h8_display_blank(void)
@@ -446,7 +438,7 @@
         save_flags(flags); cli();
         for (i = 0; i < H8_Q_ALLOC_AMOUNT; i++) {
                 /* place each at front of freeq */
-                QUEUE_ENTER(&h8_freeq, &qp[i], link, h8_cmd_q_t *);
+                list_add(&qp[i].link, &h8_freeq);
         }
         restore_flags(flags);
         return (1);
@@ -464,15 +456,15 @@
 
         /* get cmd buf */
 	save_flags(flags); cli();
-        while (QUEUE_IS_EMPTY(&h8_freeq, link)) {
+        while (list_empty(&h8_freeq)) {
                 Dprintk("H8: need to allocate more cmd buffers\n");
                 restore_flags(flags);
                 h8_alloc_queues();
                 save_flags(flags); cli();
         }
         /* get first element from queue */
-        qp = (h8_cmd_q_t *)QUEUE_FIRST(&h8_freeq, link);
-        QUEUE_REMOVE(&h8_freeq, qp, link);
+        qp = list_entry(h8_freeq.next, h8_cmd_q_t, link);
+        list_del(&qp->link);
 
         restore_flags(flags);
 
@@ -485,7 +477,8 @@
         /* queue it at the end of the cmd queue */
         save_flags(flags); cli();
 
-        QUEUE_ENTER(&h8_cmdq, qp, link, h8_cmd_q_t *);
+        /* XXX this actually puts it at the start of cmd queue, bug? */
+        list_add(&qp->link, &h8_cmdq);
 
         restore_flags(flags);
 
@@ -506,13 +499,13 @@
                 return;
         }
 
-        if (!QUEUE_IS_EMPTY(&h8_actq, link)) {
+        if (!list_empty(&h8_actq)) {
                 Dprintk("h8_start_new_cmd: inconsistency: IDLE with non-empty active queue!\n");
                 restore_flags(flags);
                 return;
         }
 
-        if (QUEUE_IS_EMPTY(&h8_cmdq, link)) {
+        if (list_empty(&h8_cmdq)) {
                 Dprintk("h8_start_new_cmd: no command to dequeue\n");
                 restore_flags(flags);
                 return;
@@ -521,9 +514,10 @@
          * Take first command off of the command queue and put
          * it on the active queue.
          */
-        qp = (h8_cmd_q_t *) QUEUE_FIRST(&h8_cmdq, link);
-        QUEUE_REMOVE(&h8_cmdq, qp, link);
-        QUEUE_ENTER(&h8_actq, qp, link, h8_cmd_q_t *);
+        qp = list_entry(h8_cmdq.next, h8_cmd_q_t, link);
+        list_del(&qp->link);
+        /* XXX should this go to the end of the active queue? */
+        list_add(&qp->link, &h8_actq);
         h8_state = H8_XMIT;
         if (h8_debug & 0x1)
                 Dprintk("h8_start_new_cmd: Starting a command\n");
@@ -538,7 +532,7 @@
 void
 h8_send_next_cmd_byte(void)
 {
-        h8_cmd_q_t      *qp = (h8_cmd_q_t *)QUEUE_FIRST(&h8_actq, link);
+        h8_cmd_q_t      *qp = list_entry(h8_actq.next, h8_cmd_q_t, link);
         int cnt;
 
         cnt = qp->cnt;
@@ -695,7 +689,7 @@
 	    if (h8_debug & 0x40000) 
 	        printk("H8: Sync command done - byte returned was 0x%x\n", 
 		       qp->rcvbuf[0]);
-	    QUEUE_ENTER(&h8_freeq, qp, link, h8_cmd_q_t *);
+	    list_add(&qp->link, &h8_freeq);
 	    break;
 
 	case H8_RD_SN:
@@ -703,7 +697,7 @@
 	    printk("H8: read Ethernet address: command done - address: %x - %x - %x - %x - %x - %x \n", 
 		   qp->rcvbuf[0], qp->rcvbuf[1], qp->rcvbuf[2],
 		   qp->rcvbuf[3], qp->rcvbuf[4], qp->rcvbuf[5]);
-	    QUEUE_ENTER(&h8_freeq, qp, link, h8_cmd_q_t *);
+	    list_add(&qp->link, &h8_freeq);
 	    break;
 
 	case H8_RD_HW_VER:
@@ -711,13 +705,13 @@
 	case H8_RD_MAX_TEMP:
 	    printk("H8: Max recorded CPU temp %d, Sys temp %d\n",
 		   qp->rcvbuf[0], qp->rcvbuf[1]);
-	    QUEUE_ENTER(&h8_freeq, qp, link, h8_cmd_q_t *);
+	    list_add(&qp->link, &h8_freeq);
 	    break;
 
 	case H8_RD_MIN_TEMP:
 	    printk("H8: Min recorded CPU temp %d, Sys temp %d\n",
 		   qp->rcvbuf[0], qp->rcvbuf[1]);
-	    QUEUE_ENTER(&h8_freeq, qp, link, h8_cmd_q_t *);
+	    list_add(&qp->link, &h8_freeq);
 	    break;
 
 	case H8_RD_CURR_TEMP:
@@ -725,7 +719,7 @@
 	    xx.byte[0] = qp->rcvbuf[0];
 	    xx.byte[1] = qp->rcvbuf[1];
 	    wake_up(&h8_sync_wait); 
-	    QUEUE_ENTER(&h8_freeq, qp, link, h8_cmd_q_t *); 
+	    list_add(&qp->link, &h8_freeq);
 	    break;
 
 	case H8_RD_SYS_VARIENT:
@@ -746,7 +740,7 @@
 	    xx.byte[0] = qp->rcvbuf[1];
 	    h8_sync_channel |= H8_GET_EXT_STATUS;
 	    wake_up(&h8_sync_wait); 
-	    QUEUE_ENTER(&h8_freeq, qp, link, h8_cmd_q_t *); 
+	    list_add(&qp->link, &h8_freeq);
 	    break;
 
 	case H8_RD_USER_CFG:
@@ -761,7 +755,7 @@
 	case H8_RD_INT_BATT_STATUS:
 	    printk("H8: Read int batt status cmd done - returned was %x %x %x\n",
 		   qp->rcvbuf[0], qp->rcvbuf[1], qp->rcvbuf[2]);
-	    QUEUE_ENTER(&h8_freeq, qp, link, h8_cmd_q_t *);
+	    list_add(&qp->link, &h8_freeq);
 	    break;
 
 	case H8_RD_EXT_BATT_STATUS:
@@ -773,7 +767,7 @@
 	        printk("H8: Device control cmd done - byte returned was 0x%x\n",
 		       qp->rcvbuf[0]);
 	    }
-	    QUEUE_ENTER(&h8_freeq, qp, link, h8_cmd_q_t *);
+	    list_add(&qp->link, &h8_freeq);
 	    break;
 
 	case H8_CTL_TFT_BRT_DC:
@@ -794,7 +788,7 @@
 	        XDprintk("H8: ctl upper thermal thresh cmd done - returned was %d\n",
 		       qp->rcvbuf[0]);
 	    }
-	    QUEUE_ENTER(&h8_freeq, qp, link, h8_cmd_q_t *);
+	    list_add(&qp->link, &h8_freeq);
 	    break;
 
 	case H8_CTL_LOWER_TEMP:
diff -Nur linux-2.3.48-1/drivers/char/h8.h linux-2.3.48-1-h8/drivers/char/h8.h
--- linux-2.3.48-1/drivers/char/h8.h	Wed Jun 24 23:30:09 1998
+++ linux-2.3.48-1-h8/drivers/char/h8.h	Thu Feb 24 14:58:58 2000
@@ -229,7 +229,7 @@
  * H8 command buffers
  */
 typedef struct h8_cmd_q {
-        DLNODE(struct h8_cmd_q) link; /* double linked list */
+        struct list_head link;          /* double linked list */
         int             ncmd;           /* number of bytes in command */
         int             nrsp;           /* number of bytes in response */
         int             cnt;            /* number of bytes sent/received */
@@ -237,10 +237,6 @@
         u_char          cmdbuf[H8_MAX_CMD_SIZE]; /* buffer to store command */
         u_char          rcvbuf[H8_MAX_CMD_SIZE]; /* buffer to store response */
 } h8_cmd_q_t;
-
-typedef struct __queue_head {
-	DLNODE(struct h8_cmd_q) link;
-} queue_head_t;
 
 union   intr_buf {
         u_char  byte[2];