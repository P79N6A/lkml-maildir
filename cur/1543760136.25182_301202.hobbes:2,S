Date: Wed, 9 Mar 2005 16:36:23 +0100
From: Jan Hudec <>
Subject: Re: Writing data > PAGESIZE into kernel with proc fs
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2005/3/9/138

On Wed, Mar 09, 2005 at 11:26:30 +0100, Weber Matthias wrote:
> On Tue, Mar 08, 2005 at 20:05:42 +0100, Weber Matthias wrote:
> >> is there any chance to signal an EOF when writing data to kernel via proc fs? >> Actually if the length of data is N*PAGE_SIZE it seems not to be detectable. 
> >> I followed up the "struct file" but haven't found anything that helped...
> 
> > End-of-file is signified by closing the file. As usual.
> 
> Having only this struct describing an proc entry, i have no idea on how to detect when the file is closed. For this i expect to register a callback function but where and how?
> 
> struct proc_dir_entry {
> 	unsigned int low_ino;
> 	unsigned short namelen;
> 	const char *name;
> 	mode_t mode;
> 	nlink_t nlink;
> 	uid_t uid;
> 	gid_t gid;
> 	unsigned long size;
> 	struct inode_operations * proc_iops;
> 	struct file_operations * proc_fops;
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
When it comes to that, you can always prepare your won file operations
instead of the default ones (that use read_proc and write_proc) below
and turn the proc entry into whatever you want.
> 	get_info_t *get_info;
> 	struct module *owner;
> 	struct proc_dir_entry *next, *parent, *subdir;
> 	void *data;
> 	read_proc_t *read_proc;
> 	write_proc_t *write_proc;
> 	atomic_t count;		/* use count */
> 	int deleted;		/* delete flag */
> };
The simple way of working with proc files is to have userland just fill
in the buffer and process that buffer when you need to, not when the
userland sends the data. So you just take the "data" buffer when you
need it.
When you need something more fancy, you simply create your own
proc_fops. That has read and write functions, where you need to take
care of the offset yourself, but you can treat each open separately
(open is called when userland process opens your proc entry and IIRC
fput or release or something like that when it closes it (you do NOT
want "close" -- that might be called more than once for one open)), turn
it into character-device-alike, implement ioctl, implement select/poll
on your entry and other fancy stuff.
Of course, you can copy the default proc_fops and only implement the
ones you actualy need different.
-------------------------------------------------------------------------------
						 Jan 'Bulb' Hudec <bulb@ucw.cz>
[unhandled content-type:application/pgp-signature]