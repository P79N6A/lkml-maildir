Date: Thu, 28 Jan 1999 01:02:39 -0600 (CST)
From: Shaun Wilson <>
Subject: plip.c and transmit timeout madness
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/1/28/10

Using the same setup (concearning plip) I've had since 2.1.117 I'm having
problems with 2.2.0 which i finally decided to install this morning. All's
well, disk access is smooth, et cetera.
but when i bring my plip interface up it only functions for a small time
before my console is flooded with "transmit timout(1,80)".
I have encountered this problem in past kernels (last september) and since
then I have been using my own patch to get rid of it, only with 2.2.0
there are two additional issues:
1) The drivers/net/plip.c source has been modified since I developed the
patch and no longer cleanly applies.
2) After re-implmenting most of teh patch (all except for the portion
which defaults net_debug to 0 instead of 1, thus removing the messages
altogether) in a more 'congruent with kernel net_debug' manner the message
snot only continue to appear, but worse, now the interface is dead, no
traffic in and no traffic out.
I've spent from 8am till now trying to figure out why and it eludes me.
attatched are two patches.  the first addresses irq handling (actually
redundancy in irq handling that i pointed out last spetember) and teh
second will patch plip.c with irq fix and it addresses the fact that
net_debug 2 was being ignored throughout the plip.c source.
It seems taht for whatever reason teh first patch extends teh time which
teh interface remains functional, oterh than that, I'm at a loss because I
can't see anything besides two macros and a new HS_TIMEOUT define that is
new to plip.c
I've emailed the maintainer before(gniibe@*.jp) and received no response,
so if anyone knows what the purpose behind HS_TIMEOUT is please fill me
in, afaik it's nothing more than a method of capturing a timeout specific
to the transmit operation, which would also be my problem.
--- plip.c-old-ely1	Wed Jan 27 23:17:24 1999
+++ plip.c	Wed Jan 27 23:20:30 1999
@@ -27,6 +27,8 @@
  *
  *		Ely Wilson
  *		  - Fixed all calls to synchronize_irq() as suggested Sept98
+ *		  - Some if () statements were ignoring proposed net_debug
+ *		    levels. 
  *
  *
  *		This program is free software; you can redistribute it and/or
@@ -122,7 +124,7 @@
 /* Maximum number of devices to support. */
 #define PLIP_MAX  8
 
-/* Use 0 for production, 1 for verification, >2 for debug */
+/* Use 0 for production, 1 for verification, >=2 for debug */
 #ifndef NET_DEBUG
 #define NET_DEBUG 1
 #endif
@@ -526,7 +528,7 @@
 		outb(PAR_INTR_OFF, PAR_CONTROL(dev));
 		dev->interrupt = 0;
 		outb(0x01, PAR_DATA(dev)); /* send ACK */
-		if (net_debug > 2)
+		if (net_debug > 1)
 			printk(KERN_DEBUG "%s: receive start\n", dev->name);
 		rcv->state = PLIP_PK_LENGTH_LSB;
 		rcv->nibble = PLIP_NB_BEGIN;
@@ -603,7 +605,7 @@
 		nl->enet_stats.rx_bytes += rcv->length.h;
 		nl->enet_stats.rx_packets++;
 		rcv->skb = NULL;
-		if (net_debug > 2)
+		if (net_debug > 1)
 			printk(KERN_DEBUG "%s: receive end\n", dev->name);
 
 		/* Close the connection. */
@@ -727,7 +729,7 @@
 					return OK;
 				}
 				outb(PAR_INTR_OFF, PAR_CONTROL(dev));
-				if (net_debug > 2)
+				if (net_debug > 1)
 					printk(KERN_DEBUG "%s: send start\n", dev->name);
 				snd->state = PLIP_PK_LENGTH_LSB;
 				snd->nibble = PLIP_NB_BEGIN;
@@ -780,7 +782,7 @@
 		/* Close the connection */
 		outb (0x00, data_addr);
 		snd->skb = NULL;
-		if (net_debug > 2)
+		if (net_debug > 1)
 			printk(KERN_DEBUG "%s: send end\n", dev->name);
 		nl->connection = PLIP_CN_CLOSING;
 		nl->is_deferred = 1;
@@ -819,7 +821,7 @@
 
 	status = inb(PAR_STATUS(dev));
 	if ((status & 0xf8) == 0x80) {
-		if (net_debug > 2)
+		if (net_debug > 1)
 			printk(KERN_DEBUG "%s: reset interface.\n", dev->name);
 		nl->connection = PLIP_CN_NONE;
 		nl->should_relinquish = 0;
@@ -863,7 +865,7 @@
 		return;
 	}
 	dev->interrupt = 1;
-	if (net_debug > 3)
+	if (net_debug > 2)
 		printk(KERN_DEBUG "%s: interrupt.\n", dev->name);
 
 	spin_lock_irq(&nl->lock);
@@ -938,7 +940,7 @@
 		return 0;
 	}
 
-	if (net_debug > 2)
+	if (net_debug > 1)
 		printk(KERN_DEBUG "%s: send request\n", dev->name);
 
 	spin_lock_irq(&nl->lock);--- plip.c.220	Wed Jan 27 08:36:35 1999
+++ plip.c	Wed Jan 27 23:05:39 1999
@@ -25,6 +25,10 @@
  *		  - Changed {enable,disable}_irq handling to make it work
  *		    with new ("stack") semantics.
  *
+ *		Ely Wilson
+ *		  - Fixed all calls to synchronize_irq() as suggested Sept98
+ *
+ *
  *		This program is free software; you can redistribute it and/or
  *		modify it under the terms of the GNU General Public License
  *		as published by the Free Software Foundation; either version
@@ -436,11 +440,11 @@
 		dev_kfree_skb(snd->skb);
 		snd->skb = NULL;
 	}
+
 	spin_unlock_irq(&nl->lock);
-	if (error == HS_TIMEOUT) {
+	if (error == HS_TIMEOUT)
 		DISABLE(dev->irq);
-		synchronize_irq();
-	}
+
 	outb(PAR_INTR_OFF, PAR_CONTROL(dev));
 	dev->tbusy = 1;
 	nl->connection = PLIP_CN_ERROR;
@@ -519,7 +523,6 @@
 	switch (rcv->state) {
 	case PLIP_PK_TRIGGER:
 		DISABLE(dev->irq);
-		/* Don't need to synchronize irq, as we can safely ignore it */
 		outb(PAR_INTR_OFF, PAR_CONTROL(dev));
 		dev->interrupt = 0;
 		outb(0x01, PAR_DATA(dev)); /* send ACK */
@@ -712,7 +715,6 @@
 			if (c0 & 0x08) {
 				spin_unlock_irq(&nl->lock);
 				DISABLE(dev->irq);
-				synchronize_irq();
 				if (nl->connection == PLIP_CN_RECEIVE) {
 					/* Interrupted.
 					   We don't need to enable irq,
@@ -1025,7 +1027,6 @@
 	dev->tbusy = 1;
 	dev->start = 0;
 	DISABLE(dev->irq);
-	synchronize_irq();
 
 #ifdef NOTDEF
 	outb(0x00, PAR_DATA(dev));