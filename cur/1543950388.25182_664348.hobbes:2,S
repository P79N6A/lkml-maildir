Date: Thu, 6 Mar 2008 11:51:34 +0100
From: Andre Noll <>
Subject: Re: [PATCH 001 of 9] md: Fix deadlock in md/raid1 and md/raid10 when handling a read error.
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/3/6/77

On 14:29, Neil Brown wrote:
> > Are you worried about another CPU setting conf->pending_bio_list.head
> > to != NULL after the if statement? If that's an issue I think also
> > the original patch is problematic because the same might happen after
> > the final spin_unlock_irq() but but before flush_pending_writes()
> > returns zero.
> 
> No.  I'm worried that another CPU might set
> conf->pending_bio_list.head *before* the if statement, but it isn't
> seen by this CPU because of the lack of memory barriers.  The spinlock
> ensures that the memory state is consistent.
But is that enough to avoid the deadlock? I think the following
scenario would be possible with the code in the original patch:
	// suppose conf->pending_bio_list.head==NULL ATM
	CPU0:
	int rv = 0;
	spin_lock_irq(&conf->device_lock);
	if (conf->pending_bio_list.head) // false
	spin_unlock_irq(&conf->device_lock);
	CPU1:
	conf->pending_bio_list.head = something;
	CPU0:
	return rv; // zero
Andre
-- 
The only person who always got his work done by Friday was Robinson Crusoe
[unhandled content-type:application/pgp-signature]