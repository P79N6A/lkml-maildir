Date: Sat, 06 Nov 2004 21:52:37 +1100
From: Con Kolivas <>
Subject: [PATCH] [sched experimental] implement cpubound policy
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2004/11/6/44

As discussed previously on lkml, implement cpubound policy.
This patch adds support for a scheduling policy based on SCHED_NORMAL without
interactive modification of it's dynamic priority. It has fixed priority
equal to what a dynamic priority fully cpubound task of the same nice level
would have.
It is suited to:
1. Tasks known to be cpubound in advance but are still desired to have
   similar cpu proportion as equal nice level SCHED_NORMAL tasks.
2. As a way of rigidly fixing the cpu distribution of multiple tasks of the
   same importance (such as multiple X sessions).
3. As a way of ensuring multiple threads dependant on each other are
   the same priority to prevent busy-on-wait scenarios where locking is
   difficult (eg multiple threaded java apps).
This scheduling policy can only have at best the same cpu distribution as a
SCHED_NORMAL task so it cannot be used for unfair advantage in multiuser
setups. The name "BOUND" was chosen to represent meaning "cpu bound" and
"priority bound".
Current userspace tools that support setting the policy can be used to set
it. However most have used this policy number for SCHED_BATCH implementations
which we do not yet support in mainline.
This will need some extensive testing mainly to ensure it is a useful policy,
although the code to implement it is trivial. If it does not prove useful
we should not pursue it.
Signed-off-by: Con Kolivas <kernel@kolivas.org>
Index: linux-2.6.10-rc1-mm3/include/linux/sched.h
===================================================================
--- linux-2.6.10-rc1-mm3.orig/include/linux/sched.h	2004-11-06 21:04:16.174979723 +1100
+++ linux-2.6.10-rc1-mm3/include/linux/sched.h	2004-11-06 21:11:19.997162978 +1100
@@ -129,6 +129,12 @@ extern unsigned long nr_iowait(void);
 #define SCHED_NORMAL		0
 #define SCHED_FIFO		1
 #define SCHED_RR		2
+#define SCHED_BOUND		3	/* Fixed priority SCHED_NORMAL */
+
+#define SCHED_MAX		3	/* Highest supported policy */
+
+#define RT_POLICY(policy)	(policy == SCHED_FIFO || policy == SCHED_RR)
+#define SUPPORTED_POLICY(policy)	(policy >= 0 && policy <= SCHED_MAX)
 
 struct sched_param {
 	int sched_priority;
Index: linux-2.6.10-rc1-mm3/kernel/sched.c
===================================================================
--- linux-2.6.10-rc1-mm3.orig/kernel/sched.c	2004-11-06 21:11:14.544009827 +1100
+++ linux-2.6.10-rc1-mm3/kernel/sched.c	2004-11-06 21:11:20.000162512 +1100
@@ -151,7 +151,8 @@
 	(SCALE(TASK_NICE(p), 40, MAX_BONUS) + INTERACTIVE_DELTA)
 
 #define TASK_INTERACTIVE(p) \
-	((p)->prio <= (p)->static_prio - DELTA(p))
+	((p)->policy != SCHED_BOUND && \
+		(p)->prio <= (p)->static_prio - DELTA(p))
 
 #define INTERACTIVE_SLEEP(p) \
 	(JIFFIES_TO_NS(MAX_SLEEP_AVG * \
@@ -628,7 +629,9 @@ static int effective_prio(task_t *p)
 	if (rt_task(p))
 		return p->prio;
 
-	bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
+	bonus = - MAX_BONUS / 2;
+	if (p->policy != SCHED_BOUND)
+		bonus += CURRENT_BONUS(p);
 
 	prio = p->static_prio - bonus;
 	if (prio < MAX_RT_PRIO)
@@ -3227,7 +3230,7 @@ static void __setscheduler(struct task_s
 	BUG_ON(p->array);
 	p->policy = policy;
 	p->rt_priority = prio;
-	if (policy != SCHED_NORMAL)
+	if (RT_POLICY(policy))
 		p->prio = MAX_USER_RT_PRIO-1 - p->rt_priority;
 	else
 		p->prio = p->static_prio;
@@ -3269,8 +3272,7 @@ recheck:
 		policy = oldpolicy = p->policy;
 	else {
 		retval = -EINVAL;
-		if (policy != SCHED_FIFO && policy != SCHED_RR &&
-				policy != SCHED_NORMAL)
+		if (!SUPPORTED_POLICY(policy))
 			goto out_unlock;
 	}
 	/*
@@ -3280,12 +3282,11 @@ recheck:
 	retval = -EINVAL;
 	if (lp.sched_priority < 0 || lp.sched_priority > MAX_USER_RT_PRIO-1)
 		goto out_unlock;
-	if ((policy == SCHED_NORMAL) != (lp.sched_priority == 0))
+	if ((!RT_POLICY(policy)) != (lp.sched_priority == 0))
 		goto out_unlock;
 
 	retval = -EPERM;
-	if ((policy == SCHED_FIFO || policy == SCHED_RR) &&
-	    !capable(CAP_SYS_NICE))
+	if (RT_POLICY(policy) && !capable(CAP_SYS_NICE))
 		goto out_unlock;
 	if ((current->euid != p->euid) && (current->euid != p->uid) &&
 	    !capable(CAP_SYS_NICE))
@@ -3732,6 +3733,7 @@ asmlinkage long sys_sched_get_priority_m
 		ret = MAX_USER_RT_PRIO-1;
 		break;
 	case SCHED_NORMAL:
+	case SCHED_BOUND:
 		ret = 0;
 		break;
 	}
@@ -3755,6 +3757,7 @@ asmlinkage long sys_sched_get_priority_m
 		ret = 1;
 		break;
 	case SCHED_NORMAL:
+	case SCHED_BOUND:
 		ret = 0;
 	}
 	return ret;
[unhandled content-type:application/pgp-signature]