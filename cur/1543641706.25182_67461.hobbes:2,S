Date: 31 Aug 2002 11:12:19 +0200
From: Luca Barbieri <>
Subject: logbuf_lock deadlock on NMI
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2002/8/31/46

I already mentioned this in an unrelated thread but I got no responses.
NMIs, by definition and documentation, are non maskable. This means that
we can get them anywhere, even when interrupts are disabled.
The problem is that in some paths of the NMI handler (mem_parity_error,
io_check_error, mca_handle_nmi), we call printk without busting
spinlocks first.
As a consequence, if I'm not missing something, if we get e.g. a memory
parity error while inside printk, we deadlock on logbuf_lock.
Apart from removing logbuf_lock and other locks that might be held in
printk, we could solve this by telling the APIC (I think that the same
can be done with the 8259 but I'm not sure) to send an interrupt to the
current CPU.
The interrupt, being maskable, will be triggered only outside
irq-protected spinlocks so we can safely do the NMI printk inside it.
Alternatively we may just reset the locks but since some errors are
non-fatal it probably isn't a good idea.
Any comments?
[unhandled content-type:application/pgp-signature]