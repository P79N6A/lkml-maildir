Date: Fri, 16 Jan 2009 11:08:24 +0100
From: "Frédéric Weisbecker" <>
Subject: Re: [PATCH 2/2] ftrace: add stack trace to function tracer
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2009/1/16/117

Hi Steven,
2009/1/16 Steven Rostedt <rostedt@goodmis.org>:
> +static struct tracer_flags func_flags = {
> +       .val = 0, /* By default: all flags disabled */
> +       .opts = func_opts
> +};
> +
> +static int func_set_flag(u32 old_flags, u32 bit, int set)
> +{
> +       if (bit == TRACE_FUNC_OPT_STACK) {
> +               /* do nothing if already set */
> +               if (!!set == !!(func_flags.val & TRACE_FUNC_OPT_STACK))
> +                       return 0;
This is just a small thing but set will always be 1 or 0. And if you want
the current val of your options, you can take old_flags :-)
Would you prefer I send a patch to not call the set_flag callback
when the option set/unset by the user is already set/unset ?
> +               if (set)
> +                       register_ftrace_function(&trace_stack_ops);
> +               else
> +                       unregister_ftrace_function(&trace_stack_ops);
> +
> +               return 0;
> +       }
> +
> +       return -EINVAL;
> +}
> +
>  static struct tracer function_trace __read_mostly =
>  {
>        .name        = "function",
>        .init        = function_trace_init,
>        .reset       = function_trace_reset,
>        .start       = function_trace_start,
> +       .flags          = &func_flags,
> +       .set_flag       = func_set_flag,
>  #ifdef CONFIG_FTRACE_SELFTEST
>        .selftest    = trace_selftest_startup_function,
>  #endif
> --
> 1.5.6.5
>
> --
>