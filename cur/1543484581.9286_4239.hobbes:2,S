Date: Sat, 6 Feb 1999 00:30:25 +1100 (EST)
From: CaT <>
Subject: [patch] mode option to fat/vfat fs
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/2/5/83

Well, hope noone tries to lynch me or anything. :)
This is my first kernel patch and hopefully I've done it right and not
introduced any nasties. I've tested it on my own HD till it looked like
I got it right and it looks like I did. At least *I'll* be using it from
now on. :)
Anyways, what this patch does is allow fat/vfat filesystems to take on
a mode option which permits the user to set the mode bits for the fs.
At the moment, as near as I can gather from the code, the way to do this
is to fiddle with the current umask, mount the system, put it back to
what you want and then continue. I thought this to be a tad messy so I
wrote this as I couldn't find another way to do it.
In case people liked the old behaviour, if you do not use the option
the old behaviour is retained.
Please send comments and stuff. Thanks and enjoy. :)
Also, there was no spacific fat fs maintainer in the MAINTAINERS file
so I sent it to the VFAT maintainer. Hope this is cool.
--- /root/fat_inode.c.original	Fri Feb  5 21:49:44 1999
+++ linux/fs/fat/inode.c	Sat Feb  6 00:00:15 1999
@@ -3,6 +3,11 @@
  *
  *  Written 1992,1993 by Werner Almesberger
  *  VFAT extensions by Gordon Chaffee, merged with msdos fs by Henrik Storner
+ *
+ *  1999/02/05: mode option added by CaT (cat@zip.com.au) to choose between
+ *              getting file modes from the umask or a user supplied value.
+ *              If no mode option given, old behaviour is preserved (ie
+ *              the umask value is used).
  */
 
 #include <linux/version.h>
@@ -117,6 +122,8 @@
 	opts->fs_uid = current->uid;
 	opts->fs_gid = current->gid;
 	opts->fs_umask = current->fs->umask;
+	opts->fs_mode = 0000; /* Make it nothing. I know I don't need 4 0's :) */
+	opts->useumask = 1; /* Do we use the umask or the user specified mode? */
 	opts->quiet = opts->sys_immutable = opts->dotsOK = opts->showexec = 0;
 	opts->codepage = 0;
 	opts->utf8 = 0;
@@ -170,6 +177,14 @@
 			else if (!strcmp(value,"no")) opts->dotsOK = 0;
 			else ret = 0;
 		}
+		else if (!strcmp(this_char,"mode")) {
+			if (!value || !*value) {
+				ret = 0;
+			} else {
+				opts->fs_mode = simple_strtoul(value,&value,8);
+				opts->useumask = 0; /* ignore the umask */
+			}
+		}
 		else if (!strcmp(this_char,"uid")) {
 			if (!value || !*value) ret = 0;
 			else {
@@ -593,8 +608,10 @@
 	inode->i_gid = MSDOS_SB(sb)->options.fs_gid;
 	inode->i_version = ++event;
 	if (inode->i_ino == MSDOS_ROOT_INO) {
-		inode->i_mode = (S_IRWXUGO & ~MSDOS_SB(sb)->options.fs_umask) |
-		    S_IFDIR;
+		inode->i_mode = (S_IRWXUGO &
+				 (MSDOS_SB(sb)->options.useumask ?
+				  ~MSDOS_SB(sb)->options.fs_umask :
+				  MSDOS_SB(sb)->options.fs_mode)) | S_IFDIR;
 		inode->i_op = fs_dir_inode_ops;
 		if (MSDOS_SB(sb)->fat_bits == 32) {
 			MSDOS_I(inode)->i_start = MSDOS_SB(sb)->root_cluster;
@@ -635,8 +652,10 @@
 	raw_entry = &((struct msdos_dir_entry *) (bh->b_data))
 	    [inode->i_ino & (MSDOS_DPB-1)];
 	if ((raw_entry->attr & ATTR_DIR) && !IS_FREE(raw_entry->name)) {
-		inode->i_mode = MSDOS_MKMODE(raw_entry->attr,S_IRWXUGO &
-		    ~MSDOS_SB(sb)->options.fs_umask) | S_IFDIR;
+		inode->i_mode = MSDOS_MKMODE(raw_entry->attr,
+		     S_IRWXUGO & (MSDOS_SB(sb)->options.useumask ?
+		      ~MSDOS_SB(sb)->options.fs_umask :
+		      MSDOS_SB(sb)->options.fs_mode)) | S_IFDIR;
 		inode->i_op = fs_dir_inode_ops;
 
 		MSDOS_I(inode)->i_start = CF_LE_W(raw_entry->start);
@@ -670,7 +689,9 @@
 		      (MSDOS_SB(sb)->options.showexec &&
 		       !is_exec(raw_entry->ext)))
 		    	? S_IRUGO|S_IWUGO : S_IRWXUGO)
-		    & ~MSDOS_SB(sb)->options.fs_umask) | S_IFREG;
+		    & (MSDOS_SB(sb)->options.useumask ?
+		       ~MSDOS_SB(sb)->options.fs_umask :
+		       MSDOS_SB(sb)->options.fs_mode)) | S_IFREG;
 		if (MSDOS_SB(sb)->cvf_format)
 			inode->i_op = (MSDOS_SB(sb)->cvf_format->flags & CVF_USE_READPAGE)
 				? &fat_file_inode_operations_readpage
@@ -779,8 +800,12 @@
 		inode->i_mode |= S_IXUGO;
 
 	inode->i_mode = ((inode->i_mode & S_IFMT) | ((((inode->i_mode & S_IRWXU
-	    & ~MSDOS_SB(sb)->options.fs_umask) | S_IRUSR) >> 6)*S_IXUGO)) &
-	    ~MSDOS_SB(sb)->options.fs_umask;
+	    & (MSDOS_SB(sb)->options.useumask ?
+	       ~MSDOS_SB(sb)->options.fs_umask :
+	       MSDOS_SB(sb)->options.fs_mode)) | S_IRUSR) >> 6)*S_IXUGO)) &
+	    (MSDOS_SB(sb)->options.useumask ?
+	     ~MSDOS_SB(sb)->options.fs_umask :
+	     MSDOS_SB(sb)->options.fs_mode);
 	return 0;
 }
 
--- /root/linux_msdos_fs_sb.h.original	Sat Feb  6 00:03:09 1999
+++ linux/include/linux/msdos_fs_sb.h	Sat Feb  6 00:04:59 1999
@@ -9,6 +9,7 @@
 struct fat_mount_options {
 	uid_t fs_uid;
 	gid_t fs_gid;
+	unsigned short fs_mode;   /* file/dir mode when useumask == 0 */
 	unsigned short fs_umask;
 	unsigned short codepage;  /* Codepage for shortname conversions */
 	char *iocharset;          /* Charset used for filename input/display */
@@ -24,7 +25,8 @@
 		 posixfs:1,       /* Allow names like makefile and Makefile to coexist */
 		 numtail:1,       /* Does first alias have a numeric '~1' type tail? */
 		 atari:1,         /* Use Atari GEMDOS variation of MS-DOS fs */
-		 fat32:1;	  /* Is this a FAT32 partition? */
+		 fat32:1,	  /* Is this a FAT32 partition? */
+		 useumask:1;	  /* Do we derive the fs mode from the umask? */
 };
 
 struct vfat_unicode {
-- 
CaT (cat@zip.net.au)                       URL: 
http://www.zip.com.au/dev/null
    There was farting in the air that night,
        It lit so bright,
            Fernando...
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/