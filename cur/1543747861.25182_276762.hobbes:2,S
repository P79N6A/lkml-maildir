Date: Sun, 05 Dec 2004 14:32:43 +0700
From: Rudolf Usselmann <>
Subject: Re: 2.6.9, 64bit, 4GB memory => panics ...
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2004/12/5/20

On Sun, 2004-12-05 at 14:20, Adam Heath wrote:
> On Sun, 5 Dec 2004, Rudolf Usselmann wrote:
> 
> > int mem[10000];
> > int i, n;
> >
> > for(i=0;i<2000;i++) {
> > 	printf("Doing alloc %0d ...\n",i);
> > 	mem[i] = (int)malloc(1024*1024*1024);
> 
> allocate a 1 gig block, but store it in an int array?  That's wrong.
> 
> > 	if(mem[i] == NULL)
> > 		printf("Malloc failed ...\n");
> > 	else
> > 		for(n=0;n<(1024*1024*1024);n=n+640)	mem[i] = n;
> 
> You alter n, but then always only set mem[i], without varying i.
> 
> Your program is buggy, and memleaks.
> 
> Plus, the kernel uses overcommit by default, and since you aren't actually
> touching the memory you are allocating, you are only limited by the address
> space size allowed per process(depends on how you configured the kernel).
Thanks for pointing that out Adam ! Will this work better:
#include "stdio.h"
#include "stdlib.h"
int main() {
char *mem[10000];
int i, n;
for(i=0;i<2000;i++) {
	printf("Doing alloc %0d ...\n",i);
	mem[i] = (char *)malloc(1024*1024*1024);
	if(mem[i] == NULL)
		printf("Malloc failed ...\n");
	else
		for(n=0;n<(1024*1024*1024);n=n+640)	mem[i][n] = n;
   }
while(1);
return(0);
}
Thanks !
rudi
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/