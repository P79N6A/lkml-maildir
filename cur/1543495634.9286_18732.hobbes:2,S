Date: Thu, 13 May 1999 13:03:42 +0200
From: Andi Kleen <>
Subject: [PATCH] Make isdn4linux compile again in 2.3.1pre4
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/1999/5/14/26

This makes isdn4linux compile and work (at least on my machine for sync ppp
and simple X.75 logins) again.
Boy, isdn_common.c is really ugly. 
-Andi
Index: linux/include/linux/isdn.h
===================================================================
RCS file: /vger/u4/cvs/linux/include/linux/isdn.h,v
retrieving revision 1.21
diff -u -u -r1.21 isdn.h
--- isdn.h	1999/01/21 13:36:24	1.21
+++ isdn.h	1999/05/13 10:14:56
@@ -626,8 +626,7 @@
   atemu                 emu;             /* AT-emulator data               */
   struct termios	normal_termios;  /* For saving termios structs     */
   struct termios	callout_termios;
-  struct wait_queue	*open_wait;
-  struct wait_queue	*close_wait;
+  wait_queue_head_t 	open_wait, close_wait;
 } modem_info;
 
 #define ISDN_MODEM_WINSIZE 8
@@ -683,8 +682,8 @@
   struct ippp_buf_queue rq[NUM_RCV_BUFFS]; /* packet queue for isdn_ppp_read() */
   struct ippp_buf_queue *first;  /* pointer to (current) first packet */
   struct ippp_buf_queue *last;   /* pointer to (current) last used packet in queue */
-  struct wait_queue *wq;
-  struct wait_queue *wq1;
+  wait_queue_head_t wq;
+  wait_queue_head_t wql;
   struct task_struct *tk;
   unsigned int mpppcfg;
   unsigned int pppcfg;
@@ -748,7 +747,7 @@
   ulong               flags;            /* Flags                            */
   int                 channels;         /* Number of channels               */
   int                 reject_bus;       /* Flag: Reject rejected call on bus*/
-  struct wait_queue  *st_waitq;         /* Wait-Queue for status-read's     */
+  wait_queue_head_t   st_waitq;         /* Wait-Queue for status-read's     */
   int                 maxbufsize;       /* Maximum Buffersize supported     */
   unsigned long       pktcount;         /* Until now: unused                */
   int                 running;          /* Flag: Protocolcode running       */
@@ -761,8 +760,8 @@
   unsigned long      DLEflag;           /* Flags: Insert DLE at next read   */
 #endif
   struct sk_buff_head *rpqueue;         /* Pointers to start of Rcv-Queue   */
-  struct wait_queue  **rcv_waitq;       /* Wait-Queues for B-Channel-Reads  */
-  struct wait_queue  **snd_waitq;       /* Wait-Queue for B-Channel-Send's  */
+  wait_queue_head_t  *rcv_waitq;  /* array of Wait-Queues for B-Channel-Reads  */
+  wait_queue_head_t  *snd_waitq;  /* array of Wait-Queue for B-Channel-Sends  */
   char               msn2eaz[10][ISDN_MSNLEN];  /* Mapping-Table MSN->EAZ   */
 } driver;
 
@@ -778,7 +777,7 @@
 				               /*  see ISDN_TIMER_..defines  */
   int               global_flags;
   infostruct        *infochain;                /* List of open info-devs.    */
-  struct wait_queue *info_waitq;               /* Wait-Queue for isdninfo    */
+  wait_queue_head_t info_waitq;               /* Wait-Queue for isdninfo    */
   struct timer_list timer;		       /* Misc.-function Timer       */
   int               chanmap[ISDN_MAX_CHANNELS];/* Map minor->device-channel  */
   int               drvmap[ISDN_MAX_CHANNELS]; /* Map minor->driver-index    */
Index: linux/drivers/isdn/isdn_common.c
===================================================================
RCS file: /vger/u4/cvs/linux/drivers/isdn/isdn_common.c,v
retrieving revision 1.28
diff -u -u -r1.28 isdn_common.c
--- isdn_common.c	1999/01/21 13:33:24	1.28
+++ isdn_common.c	1999/05/13 10:15:01
@@ -741,7 +741,6 @@
 				isdn_free_queue(&dev->drv[di]->rpqueue[i]);
 			kfree(dev->drv[di]->rpqueue);
 			kfree(dev->drv[di]->rcv_waitq);
-			kfree(dev->drv[di]->snd_waitq);
 			kfree(dev->drv[di]);
 			dev->drv[di] = NULL;
 			dev->drvid[di][0] = '\0';
@@ -785,7 +784,7 @@
  * of the mapping (di,ch)<->minor, happen during the sleep? --he 
  */
 int
-isdn_readbchan(int di, int channel, u_char * buf, u_char * fp, int len, struct wait_queue **sleep)
+isdn_readbchan(int di, int channel, u_char * buf, u_char * fp, int len, wait_queue_head_t *sleep)
 {
 	int left;
 	int count;
@@ -2088,6 +2087,7 @@
 		return 0;
 	}
 	memset((char *) d, 0, sizeof(driver));
+	init_waitqueue_head(&d->st_waitq); 
 	if (!(d->rcverr = (int *) kmalloc(sizeof(int) * n, GFP_KERNEL))) {
 		printk(KERN_WARNING "register_isdn: Could not alloc rcverr\n");
 		kfree(d);
@@ -2112,8 +2112,9 @@
 	for (j = 0; j < n; j++) {
 		skb_queue_head_init(&d->rpqueue[j]);
 	}
-	if (!(d->rcv_waitq = (struct wait_queue **)
-	      kmalloc(sizeof(struct wait_queue *) * n, GFP_KERNEL))) {
+	d->rcv_waitq = (wait_queue_head_t *)
+		kmalloc(sizeof(wait_queue_head_t) * 2 * n, GFP_KERNEL);
+	if (!d->rcv_waitq) { 
 		printk(KERN_WARNING "register_isdn: Could not alloc rcv_waitq\n");
 		kfree(d->rpqueue);
 		kfree(d->rcvcount);
@@ -2121,18 +2122,11 @@
 		kfree(d);
 		return 0;
 	}
-	memset((char *) d->rcv_waitq, 0, sizeof(struct wait_queue *) * n);
-	if (!(d->snd_waitq = (struct wait_queue **)
-	      kmalloc(sizeof(struct wait_queue *) * n, GFP_KERNEL))) {
-		printk(KERN_WARNING "register_isdn: Could not alloc snd_waitq\n");
-		kfree(d->rcv_waitq);
-		kfree(d->rpqueue);
-		kfree(d->rcvcount);
-		kfree(d->rcverr);
-		kfree(d);
-		return 0;
+	d->snd_waitq = d->rcv_waitq + n; 		
+	for (j = 0; j < n; j++) { 
+		init_waitqueue_head(&d->rcv_waitq[n]); 
+		init_waitqueue_head(&d->snd_waitq[n]); 
 	}
-	memset((char *) d->snd_waitq, 0, sizeof(struct wait_queue *) * n);
 	d->channels = n;
 	d->loaded = 1;
 	d->maxbufsize = i->maxbufsize;
@@ -2215,12 +2209,15 @@
 	memset((char *) dev, 0, sizeof(isdn_dev));
 	init_timer(&dev->timer);
 	dev->timer.function = isdn_timer_funct;
-	dev->sem = MUTEX;
+	init_MUTEX(&dev->sem);
+	init_waitqueue_head(&dev->info_waitq); 
 	for (i = 0; i < ISDN_MAX_CHANNELS; i++) {
 		dev->drvmap[i] = -1;
 		dev->chanmap[i] = -1;
 		dev->m_idx[i] = -1;
 		strcpy(dev->num[i], "???");
+		init_waitqueue_head(&dev->mdm.info[i].open_wait);
+		init_waitqueue_head(&dev->mdm.info[i].close_wait);
 	}
 	if (register_chrdev(ISDN_MAJOR, "isdn", &isdn_fops)) {
 		printk(KERN_WARNING "isdn: Could not register control devices\n");
Index: linux/drivers/isdn/isdn_common.h
===================================================================
RCS file: /vger/u4/cvs/linux/drivers/isdn/isdn_common.h,v
retrieving revision 1.11
diff -u -u -r1.11 isdn_common.h
--- isdn_common.h	1999/01/21 13:33:26	1.11
+++ isdn_common.h	1999/05/13 10:15:01
@@ -90,7 +90,7 @@
 extern void isdn_timer_ctrl(int tf, int onoff);
 extern void isdn_unexclusive_channel(int di, int ch);
 extern int isdn_getnum(char **);
-extern int isdn_readbchan(int, int, u_char *, u_char *, int, struct wait_queue**);
+extern int isdn_readbchan(int, int, u_char *, u_char *, int, wait_queue_head_t *);
 extern int isdn_get_free_channel(int, int, int, int, int);
 extern int isdn_writebuf_skb_stub(int, int, int, struct sk_buff *);
 extern int register_isdn(isdn_if * i);
Index: linux/drivers/isdn/isdn_ppp.c
===================================================================
RCS file: /vger/u4/cvs/linux/drivers/isdn/isdn_ppp.c,v
retrieving revision 1.21
diff -u -u -r1.21 isdn_ppp.c
--- isdn_ppp.c	1999/01/21 13:33:33	1.21
+++ isdn_ppp.c	1999/05/13 10:15:03
@@ -359,8 +359,7 @@
 
 	ippp_table[lp->ppp_slot]->state = IPPP_OPEN | IPPP_CONNECT | IPPP_NOBLOCK;
 
-	if (ippp_table[lp->ppp_slot]->wq)
-		wake_up_interruptible(&ippp_table[lp->ppp_slot]->wq);
+	wake_up_interruptible(&ippp_table[lp->ppp_slot]->wq);
 }
 
 /*
@@ -377,7 +376,7 @@
 		return 0;
 	is = ippp_table[slot];
 
-	if (is->state && is->wq)
+	if (is->state)
 		wake_up_interruptible(&is->wq);
 
 	is->state = IPPP_CLOSEWAIT;
@@ -437,8 +436,9 @@
 	is->mru = 1524;         /* MRU, default 1524 */
 	is->maxcid = 16;        /* VJ: maxcid */
 	is->tk = current;
-	is->wq = NULL;          /* read() wait queue */
-	is->wq1 = NULL;         /* select() wait queue */
+	/* next two are redundant, but be paranoid */ 
+	init_waitqueue_head(&is->wq);  /* read() wait queue */
+	init_waitqueue_head(&is->wql);  /* select() wait queue */
 	is->first = is->rq + NUM_RCV_BUFFS - 1;	/* receive queue */
 	is->last = is->rq;
 	is->minor = min;
@@ -777,8 +777,7 @@
 	is->last = bl->next;
 	restore_flags(flags);
 
-	if (is->wq)
-		wake_up_interruptible(&is->wq);
+	wake_up_interruptible(&is->wq);
 
 	return len;
 }
@@ -911,6 +910,8 @@
 			return -1;
 		}
 		memset((char *) ippp_table[i], 0, sizeof(struct ippp_struct));
+		init_waitqueue_head(&ippp_table[i]->wq); 
+		init_waitqueue_head(&ippp_table[i]->wql); 
 		ippp_table[i]->state = 0;
 		ippp_table[i]->first = ippp_table[i]->rq + NUM_RCV_BUFFS - 1;
 		ippp_table[i]->last = ippp_table[i]->rq;
Index: linux/drivers/isdn/isdn_tty.c
===================================================================
RCS file: /vger/u4/cvs/linux/drivers/isdn/isdn_tty.c,v
retrieving revision 1.27
diff -u -u -r1.27 isdn_tty.c
--- isdn_tty.c	1998/11/08 11:14:50	1.27
+++ isdn_tty.c	1999/05/13 10:15:05
@@ -1567,8 +1567,7 @@
 static int
 isdn_tty_block_til_ready(struct tty_struct *tty, struct file *filp, modem_info * info)
 {
-	struct wait_queue wait =
-	{current, NULL};
+	DECLARE_WAITQUEUE(wait, current); 
 	int do_clocal = 0;
 	unsigned long flags;
 	int retval;
@@ -2004,8 +2003,8 @@
 		info->blocked_open = 0;
 		info->callout_termios = m->cua_modem.init_termios;
 		info->normal_termios = m->tty_modem.init_termios;
-		info->open_wait = 0;
-		info->close_wait = 0;
+		init_waitqueue_head(&info->open_wait);
+		init_waitqueue_head(&info->close_wait);
 		info->isdn_driver = -1;
 		info->isdn_channel = -1;
 		info->drv_index = -1;
-- 
This is like TV. I don't like TV.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.rutgers.edu
Please read the FAQ at 
http://www.tux.org/lkml/