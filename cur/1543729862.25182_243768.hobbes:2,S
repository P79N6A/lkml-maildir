Date: Fri, 20 Aug 2004 17:50:41 +0200 (DFT)
From: Simon Derr <>
Subject: [PATCH] CPU stuck in wake_up_forked_thread()
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2004/8/20/192

Hi,
It seems (as of 2.6.8-rc3) that there is an issue in
wake_up_forked_thread():
from kernel/sched.c:
        local_irq_save(flags);
lock_again:
        rq = cpu_rq(cpu);
        double_rq_lock(this_rq, rq);
        BUG_ON(p->state != TASK_RUNNING);
        /*
         * We did find_idlest_cpu() unlocked, so in theory
         * the mask could have changed - just dont migrate
         * in this case:
         */
        if (unlikely(!cpu_isset(cpu, p->cpus_allowed))) {
                cpu = this_cpu;
                double_rq_unlock(this_rq, rq);
                goto lock_again;
        }
But what if 'this_cpu' is not set in p->cpus_allowed ?
Then this CPU might loop here forever.
I someone is interested I have an ugly test program that does trigger
this.
One possible solution could be:
Signed-off-by: Simon Derr <Simon.Derr@bull.net>
Index: kdb_268/kernel/sched.c
===================================================================
--- kdb_268.orig/kernel/sched.c	2004-08-20 16:44:53.033231213 +0200
+++ kdb_268/kernel/sched.c	2004-08-20 17:20:35.439454969 +0200
@@ -1249,7 +1249,11 @@
 	 * in this case:
 	 */
 	if (unlikely(!cpu_isset(cpu, p->cpus_allowed))) {
-		cpu = this_cpu;
+		if (cpu_isset(this_cpu, p->cpus_allowed))
+			cpu = this_cpu;
+		else
+			cpu = first_cpu(p->cpus_allowed);
+
 		double_rq_unlock(this_rq, rq);
 		goto lock_again;
 	}
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  
http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  
http://www.tux.org/lkml/