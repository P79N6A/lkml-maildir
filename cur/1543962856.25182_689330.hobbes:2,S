Date: Mon, 5 May 2008 00:19:08 +0200
From: Segher Boessenkool <>
Subject: Re: undefined reference to __udivdi3 (gcc-4.3)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-Lkml-Link: https://lkml.org/lkml/2008/5/4/284

> I assume it's one or both of these loops in arch/x86/xen/time.c 
> do_stolen_accounting() that are being optimized into a divide which 
> generates a libgcc call:
>
> 	while (stolen >= NS_PER_TICK) {
> 		ticks++;
> 		stolen -= NS_PER_TICK;
> 	}
>
> or
>
> 	while (blocked >= NS_PER_TICK) {
> 		ticks++;
> 		blocked -= NS_PER_TICK;
> 	}
That looks plausible.
> I seem to recall in one previous case we added some dummy assembly 
> code to stop gcc from doing this.
I think you refer to 38332cb9, "time: prevent the loop in
timespec_add_ns() from being optimised away".
         while(unlikely(ns >= NSEC_PER_SEC)) {
+               /* The following asm() prevents the compiler from
+                * optimising this loop into a modulo operation.  */
+               asm("" : "+r"(ns));
+
                 ns -= NSEC_PER_SEC;
                 a->tv_sec++;
         }
> Not sure if that is a sustainable fix, though..
It should be.  The asm() arg tells GCC that the asm() could modify
"ns" in some way, so GCC cannot optimise away the loop, since it
doesn't have the required info about the induction variable to do
that.
Segher